/// <reference path="FxEnvironment.d.ts" />
/// <reference path="Html5.d.ts" />
/// <reference path="jquery.d.ts" />
/// <reference path="knockout.d.ts" />
/// <reference path="knockout.projections.d.ts" />
/// <reference path="Q.d.ts" />
/// <reference path="require.d.ts" />

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Assets\Assets.d.ts
declare module MsPortalFx.Assets {
    import FxBase = MsPortalFx.Base;
    import FxPromiseV = FxBase.PromiseV;
    import FxImage = FxBase.Image;
    import FxExtension = MsPortalFx.Extension;
    import FxComposition = FxImpl.Composition.Selectable;
    import FxCompositionCore = FxImpl.CompositionCore;
    import FxViewModels = MsPortalFx.ViewModels;
    import DynamicSelection = FxViewModels.DynamicSelection;
    import DynamicBladeSelection = FxViewModels.DynamicBladeSelection;
    /**
     * Represents a set of flags for the contracts supportde by the asset view model.
     */
    const enum AssetContracts {
        /**
         * No contracts supported by the asset type.
         */
        None = 0,
        /**
         * The asset type supports the asset info contract.
         */
        AssetInfo = 1,
        /**
         * The asset type supports the browse config contract.
         */
        BrowseConfig = 2,
        /**
         * The asset type supports the supplemental data contract.
         */
        SupplementalData = 4,
        /**
         * The asset type supports the resource menu config contract.
         */
        ResourceMenuConfig = 8,
        /**
         * The asset type supports the resource menu config contract but only for kinds marked as use resource menu.
         */
        KindResourceMenuConfig = 16,
        /**
         * The asset type supports static resource menu overview.
         */
        StaticResourceMenuOverview = 32,
    }
    /**
     * Represents a set of flags for the browse requirements for the asset view model.
     */
    const enum BrowseRequirements {
        /**
         * Indicates no permissions are required
         */
        None = 0,
        /**
         * Indicates that coadmin permissions are required.
         */
        CoAdmin = 1,
    }
    /**
     * The asset info contains information about a specific asset.
     */
    interface AssetInfo extends StringMap<any> {
        /**
         * The asset ID for the asset.
         */
        id: any;
        /**
         * The name for the asset.
         */
        name: string;
    }
    /**
     * The rejection reason for the getAssetInfo promise.
     */
    const enum AssetInfoRejection {
        /**
         * The asset was not found.
         */
        NotFound = 0,
    }
    /**
     * The contract for the asset type's asset info.
     */
    interface AssetInfoContract {
        /**
         * Gets the asset info for the given asset ID.
         *
         * @param id The asset ID.
         * @return A promise which will be resolved with the asset info on success or rejected with the reason.
         */
        getAssetInfo(id: any): MsPortalFx.Base.PromiseV<AssetInfo>;
    }
    /**
     * Determines if the given contracts flagset supports a given contract.
     *
     * @param contracts The contracts flagset which contains all the supported contracts.
     * @param contract The asset contract to check.
     * @return Boolean true if the contracts flagset supports the given contract, else false.
     */
    function supportsContract(contracts: number, contract: AssetContracts): boolean;
    /**
     * Determines if the given asset type information supports a given contract.
     *
     * @param assetTypeInformation The asset type information which contains all the supported contracts.
     * @param contract The asset contract to check.
     * @return Boolean true if there is an asset type information, a view model and the contracts supports the given contract, else false.
     */
    function assetTypeInformationSupportsContract(assetTypeInformation: AssetTypeInformation, contract: AssetContracts): boolean;
    /**
     * This represents an asset type display name in it's four forms.
     */
    interface CompositeDisplayName {
        /**
         * The singular, formal-cased display name.
         */
        singular: string;
        /**
         * The plural, formal-cased display name.
         */
        plural: string;
        /**
         * The singular, lower-cased display name.
         */
        lowerSingular: string;
        /**
         * The plural, lower-cased display name.
         */
        lowerPlural: string;
        /**
         * The service display name.
         */
        service?: string;
    }
    /**
     * The asset type interface which represents a fully qualified asset type (extension + asset type).
     */
    interface AssetType {
        /**
         * The extension name for the fully qualified asset type.
         */
        extensionName: string;
        /**
         * The asset type for the fully qualified asset type.
         */
        assetType: string;
    }
    /**
     * The asset type information interface which represents an asset type's info like icon and display name.
     */
    interface AssetTypeInformation extends AssetType {
        /**
         * The asset type's icon image if successful, null otherwise.
         */
        icon: FxImage;
        /**
         * The asset type's display name if successful, null otherwise.
         */
        compositeDisplayName: CompositeDisplayName;
        /**
         * The browse type for the asset type.
         */
        browseType: FxExtension.BrowseType;
        /**
         * The browse link URI for the asset type.
         */
        browseLinkUri?: string;
        /**
         * The name of the asset type view model associated with this asset type.
         */
        viewModel: string;
        /**
         * The contracts flag for which contracts the asset view model supports.
         */
        contracts: number;
        /**
         * The service name for the dynamic blade service associated with the asset.
         */
        dynamicBladeServiceViewModel?: string;
        /**
         * Optional flag to indicate the asset type is from a preview extension.
         * If this flag is not specified, the asset type is NOT from a preview.
         */
        isPreview?: boolean;
        /**
         * The marketplace item id associated with the asset.
         */
        marketplaceItemId?: string;
        /**
         * The marketplace menu item id associated with the asset.
         */
        marketplaceMenuItemId?: string;
        /**
         * Optional 'private' browse flag which indicates to exclude this asset from the browse UX.
         */
        privateBrowse?: boolean;
        /**
         * The list of keywords.
         */
        keywords?: string[];
    }
    /**
     * The asset type information interface which represents an asset type's info like icon and display name.
     */
    interface ResourceTypeAssetTypeInformation extends AssetTypeInformation {
        /**
         * The resource type.
         */
        resourceType: string;
        /**
         * The ARM API version to use for this resource type.
         * If this is not specified, the latest API version will be used from the ARM manifest file.
         */
        apiVersion?: string;
        /**
         * The flag to hide assets from the resource map.
         * THIS IS OBSOLETE AND WILL ALWAYS BE TRUE UNTIL THIS FLAG IS REMOVED.
         */
        hideOnResourceMap?: boolean;
        /**
         * The routing type for the resource type.
         * If this is not specified, the 'Default' routing type will be used.
         */
        routingType?: FxExtension.ResourceRoutingType;
        /**
         * The blade associated with the resource type.
         */
        bladeName?: string;
        /**
         * The blade extension associated with the resource type.
         */
        bladeExtensionName?: string;
        /**
         * The static overview menu item.
         */
        staticOverview?: FxExtension.StaticOverviewDefinition;
        /**
         * The optional array of kinds for this resource type.
         */
        kinds?: FxExtension.ResourceKindDefinition[];
    }
    /**
     * The asset triplet interface which represents a fully qualified asset ID.
     */
    interface AssetTriplet {
        /**
         * The extension name for the fully qualified asset ID.
         */
        extensionName: string;
        /**
         * The asset type for the fully qualified asset ID.
         */
        assetType: string;
        /**
         * The asset ID for the fully qualified asset ID.
         */
        assetId: any;
    }
    /**
     * The asset information interface which represents an asset ID and asset type information for a given resource ID.
     */
    interface AssetInformation extends AssetTypeInformation {
        /**
         * The asset ID if successful, null otherwise.
         */
        assetId: any;
        /**
         * The dynamic selection if successful, null otherwise.
         */
        dynamicSelection: DynamicSelection;
    }
    /**
     * The asset information interface which represents an asset ID and asset type information for a given resource ID.
     */
    interface ResourceAssetInformation extends AssetInformation {
        /**
         * The resource ID.
         */
        resourceId: string;
    }
    /**
     * The asset type information interface which represents the registered asset types and indicates if the set is complete or not.
     */
    interface RegisteredAssetTypesInformation {
        /**
         * Asset type information.
         */
        assetTypesInformation: ResourceTypeAssetTypeInformation[];
        /**
         * Indicates whether the Asset type data is complete i.e. from all the loaded extensions or is partial.
         */
        isPartialSet?: boolean;
    }
    /**
     * The asset blade reference provides the extension and blade name for a blade.
     */
    interface AssetBladeReference {
        /**
         * The name of the blade.
         */
        blade: string;
        /**
         * The name of the extension.
         */
        extension: string;
    }
    /**
     * The dynamic selection and icon interface provides a wrapper for dynamic selection and icon.
     */
    interface DynamicSelectionAndIcon {
        /**
         * The selection.
         */
        selection: DynamicSelection;
        /**
         * The icon.
         */
        icon: FxImage;
        /**
         * Optional flag to indicate the asset type is from a preview extension.
         * If this flag is not specified, the asset type is NOT from a preview.
         */
        isPreview?: boolean;
    }
    /**
     * The icon and kind interface provides a wrapper for an icon and the resource kind.
     */
    interface IconAndKind {
        /**
         * The icon.
         */
        icon: FxImage;
        /**
         * The kind.
         */
        kind: string;
        /**
         * Optional flag to indicate the asset type is from a preview extension.
         * If this flag is not specified, the asset type is NOT from a preview.
         */
        isPreview?: boolean;
    }
    /**
     * The resource blade inputs contract provides the inputs for all resource and asset blades.
     */
    interface ResourceBladeInputs {
        /**
         * The ID of the resource or asset for the blade.
         */
        id: any;
    }
    /**
     * Maps a dynamic blade selection to a blade reference.
     *
     * @param bladeSelection The dynamic blade selection.
     * @param onClosed The onClosed callback for the blade.
     * @return The promise that resolves to the blade reference.
     */
    function mapDynamicBladeSelectionToBladeReference(bladeSelection: DynamicBladeSelection, onClosed?: FxCompositionCore.BladeClosedWithDataHandler<any>): FxPromiseV<FxComposition.BladeReference<ResourceBladeInputs>>;
    /**
     * Maps an asset ID to a resource ID using the asset type system.
     * Note that this will reject if the asset type does not support mapping to resource ID.
     *
     * @param assetId The fully qualified asset ID.
     * @return A promise that resolves to the resource ID string for the fully qualified asset ID.
     */
    function mapAssetIdToResourceId(assetId: AssetTriplet): FxPromiseV<string>;
    /**
     * Maps a resource ID to an asset ID using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @return A promise that resolves to the fully qualified asset ID for the resource ID.
     */
    function mapResourceIdToAssetId(resourceId: string): FxPromiseV<AssetTriplet>;
    /**
     * Maps an asset triplet to a blade reference and an icon using the asset type system.
     * Note that this will reject if an asset type is not found.
     *
     * @param assetId The fully qualified asset ID.
     * @return A promise that resolves to the fully qualified blade reference and the icon for the asset ID.
     */
    function mapAssetIdToDynamicSelectionAndIcon(assetId: AssetTriplet, forceBladeSelection?: boolean): FxPromiseV<DynamicSelectionAndIcon>;
    /**
     * Maps an asset triplet to a dynamic selection using the asset type system.
     * Note that this will reject if an asset type is not found.
     *
     * @param assetId The fully qualified asset ID.
     * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
     * @return A promise that resolves to the fully qualified dynamic selection for the asset ID.
     */
    function mapAssetIdToDynamicSelection(assetId: AssetTriplet, forceBladeSelection?: boolean): FxPromiseV<DynamicSelection>;
    /**
     * Maps an asset triplet to blade reference using the asset type system.
     * Note that this will reject if an asset type is not found.
     *
     * @param assetId The fully qualified asset ID.
     * @return A promise that resolves to the fully qualified blade reference for the asset ID.
     */
    function mapAssetIdToBladeReference(assetId: AssetTriplet): FxPromiseV<FxComposition.BladeReference<ResourceBladeInputs>>;
    /**
     * Maps a resource ID to a dynamic selection and an icon using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
     * @return A promise that resolves to the fully qualified dynamic selection and the icon for the resource ID.
     */
    function mapResourceIdToDynamicSelectionAndIcon(resourceId: string, forceBladeSelection?: boolean): FxPromiseV<DynamicSelectionAndIcon>;
    /**
     * Maps a resource ID to a dynamic selection using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
     * @return A promise that resolves to the fully qualified dynamic selection for the resource ID.
     */
    function mapResourceIdToDynamicSelection(resourceId: string, forceBladeSelection?: boolean): FxPromiseV<DynamicSelection>;
    /**
     * Maps a resource ID to blade reference using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @param onClosed The onClosed callback for the blade.
     * @return A promise that resolves to the fully qualified blade reference for the resource ID.
     */
    function mapResourceIdToBladeReference(resourceId: string, onClosed?: FxCompositionCore.BladeClosedWithDataHandler<any>): FxPromiseV<FxComposition.BladeReference<ResourceBladeInputs>>;
    /**
     * Gets an asset type's information for a given asset type using the asset type system.
     * Note that this will reject if the asset type is not found.
     *
     * @param extensionName The name of the extension that owns the asset type.
     * @param assetType The name of the asset type.
     * @return A promise that resolves to the asset type information structure for the asset type.
     */
    function getAssetTypeInformation(extensionName: string, assetType: string): FxPromiseV<AssetTypeInformation>;
    /**
     * Gets an asset type information for an array of resource types using the asset type system.
     * Note that this will not reject if an asset type is not found for the resource type, but the
     * assetTypeInformation will be null for that resource type.
     *
     * @param resourceTypes The array of names of the resource types.
     * @return A promise that resolves to the asset type information structure for the resource type.
     */
    function getResourceTypeAssetTypeInformation(resourceTypes: string[]): FxPromiseV<ResourceTypeAssetTypeInformation[]>;
    /**
     * Gets the asset information for an array of resource IDs using the asset type system.
     * Note that this will not reject if an asset type is not found for the resource type, but the assetId and
     * assetTypeInformation will be null for that resource ID.
     *
     * @param resourceIds An array of resource IDs.
     * @return A promise that resolves to an array of asset information packets, one for each source resource ID.
     */
    function getResourceAssetInformation(resourceIds: string[]): FxPromiseV<ResourceAssetInformation[]>;
    /**
     * Signals that resources of the specified type have changed and cache for these resources should be updated.
     *
     * @param resourceIds An array of resource IDs.
     * @return The promise that resolves when the operation has completed.
     */
    function signalResourcesChanged(resourceIds: string[]): FxBase.Promise;
}
declare module FxImpl.Assets {
    import FxAssets = MsPortalFx.Assets;
    let runtimeForTesting: Extension.Runtime;
    /**
     * The asset triplet with cloud interface which represents a fully qualified asset ID.
     */
    interface AssetTripletWithCloud extends FxAssets.AssetTriplet {
        /**
         * The cloud name for the fully qualified asset ID.
         */
        cloudName: string;
    }
    /**
     * The asset type information interface which represents the registered asset types and indicates if the set is complete or not.
     */
    interface RegisteredAssetTypesInformation extends FxAssets.RegisteredAssetTypesInformation {
        /**
         * Asset type information.
         */
        assetTypesInformation: ResourceTypeAssetTypeInformation[];
    }
    /**
     * The asset type information interface which represents an asset type's info like icon and display name.
     */
    interface ResourceTypeAssetTypeInformation extends FxAssets.ResourceTypeAssetTypeInformation {
        /**
         * The cloud name.
         */
        cloudName: string;
    }
    /**
     * Gets the unique id of an asset type/resource type.
     *
     * @param extensionName the extension name
     * @param cloudName the cloud name
     * @param typeName the type name, could be asset type or resource type
     * @return The the unique id.
     */
    function getAssetTypeOrResourceTypeId(extensionName: string, cloudName: string, typeName: string): string;
    /**
     * Gets the unique id of an asset type/resource type.
     *
     * @param windowId The window id of the extension.
     * @param typeName the type name, could be asset type or resource type.
     * @return The unique id.
     */
    function getAssetTypeOrResourceTypeIdByWindowId(windowId: string, typeName: string): string;
    /**
     * Add cloud name to asset type id.
     *
     * @param assetTypeId The asset type id.
     * @param cloudName The cloud name.
     * @return The unique id.
     */
    function addCloudNameToAssetTypeId(assetTypeId: string, cloudName: string): string;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Assets\Assets.BrowseConfig.d.ts
declare module MsPortalFx.Assets {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import Grid = FxViewModels.Controls.Lists.Grid;
    /**
     * The column to describe a column in the browse grid.
     */
    interface Column {
        /**
         * The column ID.
         */
        id: string;
        /**
         * The column display name (shows up in UI).
         */
        name: KnockoutObservable<string>;
        /**
         * The column description (shows up in UI).
         */
        description?: KnockoutObservable<string>;
        /**
         * The the item key (source property) for the column.
         */
        itemKey: string;
        /**
         * The format for the column.
         */
        format?: Grid.Format;
        /**
         * The format options for the column.
         */
        formatOptions?: Grid.FormatOptions;
        /**
         * The width for the column.
         */
        width?: KnockoutObservable<string>;
        /**
         * The CSS class for the column.
         */
        cssClass?: string;
        /**
         * Hides the column.
         */
        isHidden?: KnockoutObservableBase<boolean>;
    }
    /**
     * The browse config contains the information for a non-default browse such as columns.
     */
    interface BrowseConfig {
        /**
         * The array of column config definitions.
         */
        columns: Column[];
        /**
         * The array of column IDs for the default columns for the browse grid.
         */
        defaultColumns: string[];
        /**
         * Any additional properties used in HTML templates which will be provided by supplemental data.
         */
        properties?: string[];
        /**
         * Optional command group reference for the item context menu.
         */
        contextMenu?: CommandGroupReference;
        /**
         * Optional info box to display custom text.
         */
        infoBox?: BrowseInfoBox;
    }
    /**
     * The command group reference interface which references a command group by name and optional extenion.
     */
    interface CommandGroupReference {
        /**
         * The command group name.
         */
        commandGroup: string;
        /**
         * The optional command group owner extension.  If not specified, the asset type extension is used.
         */
        commandGroupOwner?: string;
    }
    /**
     * The browse info box interface which extensions can provide to display cutom information on their browse blades.
     */
    interface BrowseInfoBox {
        /**
         * The image on the info box.
         */
        image: FxBase.Image;
        /**
         * The text.
         */
        text: string;
        /**
         * The link to launch from info box.
         */
        uri?: string;
        /**
         * The blade detail to open from info box.
         */
        blade?: FxViewModels.DynamicBladeSelection;
    }
    /**
     * The contract for the asset type's browse config.
     */
    interface BrowseConfigContract {
        /**
         * Gets the browse config.
         *
         * @return A promise which will be resolved with the browse config.
         */
        getBrowseConfig(): FxBase.PromiseV<BrowseConfig>;
    }
    /**
     * Pre-defined columns for resource types.
     *
     * NOTE: actual column configuration is in Hubs.
     */
    module ResourceColumns {
        /**
         * The name resource column.
         */
        const name: string;
        const nameColumnId: string;
        /**
         * The kind resource column.
         */
        const kind: string;
        /**
         * The resource group resource column.
         */
        const resourceGroup: string;
        const resourceGroupColumnId: string;
        /**
         * The location resource column.
         */
        const location: string;
        const locationColumnId: string;
        /**
         * The location ID resource column.
         */
        const locationId: string;
        /**
         * The resource ID resource column.
         */
        const resourceId: string;
        /**
         * The resource group ID resource column.
         */
        const resourceGroupId: string;
        /**
         * The resource type resource column.
         */
        const resourceType: string;
        /**
         * The subscription resource column.
         */
        const subscription: string;
        const subscriptionName: string;
        const subscriptionColumnId: string;
        /**
         * The subscription ID resource column.
         */
        const subscriptionId: string;
        /**
         * The asset type resource column.
         */
        const assetType: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Assets\Assets.ResourceMenuConfig.d.ts
declare module MsPortalFx.Assets {
    import FxHubsAzure = HubsExtension.Azure;
    import FxMenu = FxImpl.Controls.Menu;
    import FxSubscription = MsPortalFx.Azure.Subscription;
    /**
     * The group IDs for the build-in menu groups.
     */
    const ManagementGroupId: string;
    const SupportGroupId: string;
    const QuickAccessGroupId: string;
    const MonitoringGroupId: string;
    /**
     * The item IDs for the build-in menu items.
     */
    const EventLogsItemId: string;
    const ExportTemplateItemId: string;
    const MyAccessItemId: string;
    const ResourceProvidersItemId: string;
    const ResourceHealthItemId: string;
    const ResourceGroupsItemId: string;
    const ResourcesItemId: string;
    const SubscriptionCertsItemId: string;
    const SubscriptionQuotasItemId: string;
    const SupportHelpRequestItemId: string;
    const TagsItemId: string;
    const LocksItemId: string;
    const TroubleshootItemId: string;
    const UsersItemId: string;
    const PropertiesItemId: string;
    const AlertsItemId: string;
    const DiagnosticsItemId: string;
    const MetricsItemId: string;
    const AppInsightsItemId: string;
    const LogAnalyticsItemId: string;
    const LogSearchItemId: string;
    const ResourceAdvisorItemId: string;
    /**
     * Defines an item in a group of the menu.
     */
    interface MenuItem extends FxMenu.MenuItem {
    }
    /**
     * Defines a group in the menu.
     */
    interface MenuGroup extends FxMenu.MenuGroup {
        /**
         * Gets or sets if the menu group should be elevated in the menu blade.
         */
        elevated?: boolean;
    }
    /**
     * Defines a group extension in the menu.
     * This is used to extend the built-in groups with additional items.
     *
     * NOTE: The resourceId must be one of the constants for group IDs in this file.
     *       Using a different ID will result in a load rejection.
     */
    interface MenuGroupExtension {
        /**
         * Gets the ID for the built-in group.
         */
        referenceId: string;
        /**
         * The menu items in the group.
         */
        items: MenuItem[];
    }
    /**
     * The resource information for the resource menu.
     */
    interface ResourceInformation {
        /**
         * The resource ID.
         */
        resourceId: string;
        /**
         * The resource or resource group.
         */
        resource: FxSubscription | FxHubsAzure.ResourceGroup | FxHubsAzure.Resource;
        /**
         * The resource's subscription information (only valid for non-tenant resources).
         */
        subscription?: FxSubscription;
    }
    /**
     * The options of the resource menu config.
     */
    interface ResourceMenuOptions {
        /**
         * Enables the setting exporting a template from resources and resource groups.
         */
        enableExportTemplate?: boolean;
        /**
         * Enables the settings for roles and users.
         */
        enableRbac?: boolean;
        /**
         * Enables the settings for help request support.
         */
        enableSupportHelpRequest?: boolean;
        /**
         * Enables the settings for troubleshoot support.
         */
        enableSupportTroubleshoot?: boolean;
        /**
         * Enables the settings for troubleshoot support.
         */
        enableSupportTroubleshootV2?: boolean;
        /**
         * Enables the settings for resource health support.
         */
        enableSupportResourceHealth?: boolean;
        /**
         * Enables the settings for the event logs.
         */
        enableSupportEventLogs?: boolean;
        /**
         * Enables the setting for tags.
         */
        enableTags?: boolean;
        /**
         * Enables the setting for standard properties blade.
         */
        enableProperties?: boolean;
        /**
         * Enables the settings for alerts.
         */
        enableAlerts?: boolean;
        /**
         * Enables the settings for diagnostics.
         */
        enableDiagnostics?: boolean;
        /**
         * Enables the settings for metrics.
         */
        enableMetrics?: boolean;
        /**
         * Enables the settings for app insights.
         */
        enableAppInsights?: boolean;
        /**
         * Enables the settings to show app insights on top of the group.
         */
        showAppInsightsFirst?: boolean;
        /**
         * Enables the settings for log analytics.
         */
        enableLogAnalytics?: boolean;
        /**
         * Enables the settings for log search.
         */
        enableLogSearch?: boolean;
        /**
         * Enables the settings for locks.
         */
        enableLocks?: boolean;
        /**
         * Enables the settings for resource advisor support.
         */
        enableSupportResourceAdvisor?: boolean;
    }
    /**
     * The menu group instance type (either a menu group or a menu group extension).
     */
    type MenuGroupInstance = MenuGroup | MenuGroupExtension;
    /**
     * The resource menu configuration.
     */
    interface ResourceMenuConfig {
        /**
         * The resource menu item (overview item).
         */
        overview: MenuItem;
        /**
         * The menu item groups.
         */
        groups: MenuGroupInstance[];
        /**
         * The ID of the default menu item.
         * If this is not provided, the overview item will be the default item.
         */
        defaultItemId?: string;
        /**
         * Optional set of resource menu options.
         */
        options?: ResourceMenuOptions;
    }
    /**
     * The contract for the asset type's resource menu config.
     */
    interface ResourceMenuConfigContract {
        /**
         * Gets the resource menu configuration.
         *
         * @param resourceInfo The resource ID and resource|resource group for the menus.
         * @return A promise which will be resolved with the resource menu configuration.
         */
        getMenuConfig(resourceInfo: ResourceInformation): MsPortalFx.Base.PromiseV<ResourceMenuConfig>;
    }
}
declare module FxImpl.Assets {
    import FxBase = MsPortalFx.Base;
    import BladeReference = FxImpl.Composition.Selectable.BladeReference;
    import FxExtension = FxImpl.Extension;
    /**
     * Supplies the blade reference for the detail blade opened by a menu item on the resource menu blade.
     *
     * @param lifetime The lifetime of the menu item.
     * @param extensionDescriptor The descriptor of the extension that provided the menu item.
     * @param item The menu item.
     * @return A promise for the blade reference.
     */
    function supplyMenuDetailBladeReferenceAsync(lifetime: FxBase.LifetimeManager, extensionDescriptor: FxExtension.ExtensionDescriptor, item: Controls.Menu.MenuItem): Q.Promise<BladeReference<any>>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Assets\Assets.SupplementalData.d.ts
declare module MsPortalFx.Assets {
    import FxBase = MsPortalFx.Base;
    /**
     * The supplemental data provides the supplemental data for a single resource.
     */
    interface SupplementalData extends StringMap<any> {
        /**
         * The resource ID for the resource.
         */
        resourceId: string;
        /**
         * Optional command group reference override for the item context menu.
         */
        contextMenu?: CommandGroupReference;
    }
    /**
     * The contract for the asset type's supplemental data.
     */
    interface SupplementalDataContract {
        /**
         * The supplemental data stream observable array is used to stream supplemental data.
         */
        supplementalDataStream: KnockoutObservableArray<SupplementalData>;
        /**
         * Gets the supplemental data for the array of resource IDs.
         *
         * @param resourceIds The array of resource IDs for the supplemental data.
         * @param columns The array of columns for the supplemental data that is required.
         * @return A promise which will be resolved when data is ready to be streamed.
         */
        getSupplementalData(resourceIds: string[], columns: string[]): FxBase.Promise;
    }
    /**
     * Namespace for the supplemental data stream handling.
     */
    module SupplementalDataStreamHelper {
        /**
         * Connects a query view to a supplemental data stream.
         *
         * @param lifetimeManager The lifetime manager for this supplemental data stream.
         * @param view The quey view source for the connection.
         * @param destination The supplemental data stream for the connection.
         * @param isRequestedCallback The callback to determine if the item was requested.
         * @param buildDataCallback The callback to build the supplemental data for the item.
         */
        function ConnectView<TModel, TId>(lifetimeManager: FxBase.LifetimeManager, view: MsPortalFx.Data.QueryView<TModel, TId>, destination: KnockoutObservableArray<SupplementalData>, isRequestedCallback: (item: TModel) => boolean, buildDataCallback: (item: TModel) => SupplementalData): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ArmErrors.d.ts
declare module FxImpl.Azure {
    /**
     * A simplified version of the JQueryXHR error.
     */
    interface SimplifiedError extends Error {
        /**
         * The error ready state.
         */
        readyState: number;
        /**
         * The error status (HTTP code).
         */
        status: MsPortalFx.Base.Net2.HttpStatusCode;
        /**
         * The error status text (HTTP code text).
         */
        statusText: string;
        /**
         * The error message from the response JSON if it exists.
         */
        message: string;
        /**
         * The error code from the response JSON if it exists.
         */
        code: string;
        /**
         * The error stack.
         */
        stack: string;
    }
    /**
     * Error detail returned from ARM
     */
    interface ArmErrorDetails {
        /**
         * The error code.
         */
        code: string;
        /**
         * The error message.
         */
        message: string;
        /**
         * The target entity.
         */
        target: string;
        /**
         * The details.
         */
        details?: ArmErrorDetails[];
    }
    /**
     * The error info
     */
    interface ArmError extends ArmErrorDetails {
        /**
         * The error details.
         */
        details?: ArmErrorDetails[];
    }
    /**
     * Mapped error object with details.
     */
    interface MappedArmError {
        /**
         * The top level error with code.
         */
        error: string;
        /**
         * The nested errors with code if any.
         */
        details: (string | MappedArmError)[];
    }
    /**
     * Parses error object returned from ARM.
     * @param errorObj error object returned from ARM.
     * @return mapped error object.
     */
    function parseArmError(errorObj: ArmError, flatten?: boolean): MappedArmError;
    /**
     * Parses error object returned from ARM to a concatenated string.
     * @param errorObj error object returned from ARM.
     * @param message A base message to use at the beginning of the returned message.
     * @return string containing the concatenated errors returned from ARM.
     */
    function parseArmErrorToMessage(error: ArmError, message?: string): string;
    /**
     * Builds a simplified error object out of a JQueryXHR error. Useful if you're returning errors
     * over the PO-layer.
     *
     * @param jqxhr The JQueryXHR error object.
     * @return The simplified error object.
     */
    function buildSimplifiedError<T>(jqxhr: JQueryXHR<T>): SimplifiedError;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\BaseResourceDropDown.d.ts
declare module MsPortalFx.Azure {
    /**
     * Options for validating required permissions.
     */
    interface RequiredPermissions {
        /**
         * The list of required actions/permissions.
         */
        actions: string[];
        /**
         * The message to show in case validation fails.
         */
        message?: string;
    }
    interface CreatorAndDropdDownValue<T> {
        /**
         * Specifies if the value returned should be created
         */
        createNew: boolean;
        /**
         * The value returned from the dropdown
         */
        value: T;
    }
}
declare module FxImpl.Azure {
    import FxAzure = MsPortalFx.Azure;
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    import BaseControl = FxViewModels.Controls.Base.Contract;
    import Forms = FxViewModels.Forms;
    import FilterComboBox = Forms.FilterComboBox;
    /**
     * BaseResourceDropDown namespace.
     */
    module BaseResourceDropDown {
        /**
         * BaseResourceDropDown options.
         */
        interface Options<T> extends FilterComboBox.Options {
            /**
             * The form control that hosts the drop down `control`.
             */
            form: Forms.Form.ViewModel<any>;
            /**
             * The edit scope accessor associated with the drop down control.
             */
            accessor: Forms.EditScopeAccessors<T>;
        }
        /**
         * Return options from the FilterComboBoxCreateCallback
         */
        interface FilterComboBoxResult<T> {
            /**
             * The control to place on the form and expose to authors. Use this if it's
             * different from the dropdown.
             */
            control?: BaseControl;
            /**
             * The control for the internal representation of the dropdown
             */
            filterComboBox: FilterComboBox.ViewModel;
            /**
             * An extra valid observable to determine if the control is valid
             */
            valid?: KnockoutObservableBase<boolean>;
        }
        /**
         * BaseResourceDropDown configuration.
         */
        interface Config<T> {
            /**
             * Flag indicating whether creating new objects through the filter combo control is
             * allowed. Defaults to false.
             */
            allowCreateNew?: boolean;
            /**
             * An observable that blocks loading the items till set to true. Defaults to false.
             */
            blockLoadingItems?: KnockoutObservableBase<boolean>;
            /**
             * An observable updated with the name for the object that should be set as the initial
             * value for the control (and in the edit scope). Defaults to undefined (no initial selection).
             */
            nameForInitialValue?: KnockoutObservableBase<string>;
            /**
             * Returns a sorted list of items sorted in the order of selection preference. This will
             * not affect the presentation order, just the initial selection. If there is no value
             * defined in the edit scope or using the nameForInitialValue property, the dropdown will
             * pick the first valid item in this ordered list. If not supplied, then the original
             * list of values will be used (preserving original presentation order).
             */
            getSortedListForInitialSelection?: () => T[];
            /**
             * A callback that returns a promise resolved with the items for the drop down.
             */
            fetchItems: () => FxPromiseV<T[]>;
            /**
             * A callback that acts as a filter that checks whether the name identifies the supplied object.
             */
            filterObjectByName: (item: T, name: string) => boolean;
            /**
             * A callback that transforms the supplied item into a filter combo box option.
             */
            itemToHierarchicalFormOption: (item: T) => FilterComboBox.HierarchicalFormOption<string>;
            /**
             * The object value to return if no filter value is found
             */
            createNewOption?: KnockoutObservableBase<T>;
            /**
             * Callback to Instantiate FilterComboBox with Base Options
             * Ids could be ambiguous with names, and could lead to unexpected behavior if
             * ids and names are the same. Both will be passed into this function
             */
            filterComboBoxCreateCallback?: Func1<Options<T>, FilterComboBoxResult<T>>;
            /**
             * Filter function to remove items from the drop down. This is run in a computed so any
             * observables used in this function will trigger this filter
             */
            optionsFilter?: Func1<T[], T[]>;
            /**
             * The control to be exposed
             */
            control?: BaseControl;
            /**
             * The default value if none are selected
             */
            nullValue?: T;
        }
    }
    /**
     * The base class implementation for a resource drop down.
     * Extended by the Subscription, Resource Group, and Location Pickers.
     */
    class BaseResourceDropDown<T> {
        /**
         * The control placed on the form.
         */
        control: BaseControl;
        /**
         * An observable indicating whether the field is enabled.
         */
        enabled: KnockoutObservableBase<boolean>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent: KnockoutObservableBase<string>;
        /**
         * An observable indicating whether the field is valid.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * An observable that holds the currently selected value.
         */
        value: KnockoutObservableBase<T>;
        protected _items: T[];
        protected _filterCombo: FilterComboBox.ViewModel;
        protected _itemsObs: KnockoutObservableArray<T>;
        protected _loading: KnockoutObservable<boolean>;
        private _bConfig;
        private _bContainer;
        private _bOptions;
        private _firstLoad;
        private _loadingDeferred;
        private _setOptions;
        /**
         * Instantiates a new base drop down control.
         *
         * @param container The container into which the part containing this control is being placed.
         * @param options The set of options used to initialize the BaseResourceDropDown.
         * @param config The config used to configure the BaseResourceDropDown.
         */
        constructor(container: FxViewModels.ContainerContract, options: BaseResourceDropDown.Options<T>, config: BaseResourceDropDown.Config<T>);
        /**
         * Clears validation on the field.
         * @return A promise that is resolved when the validation has been cleared.
         */
        clearValidation(): FxPromise;
        /**
          * Triggers validation on the field.
          * @return A promise that is resolved when the validation has been triggered.
          */
        triggerValidation(): FxPromise;
        /**
         * Returns the corresponding object in the drop down list for the given name.
         * @param  name The name to match the object.
         * @return The corresponding object that matches the name.
         */
        getObjectByName(name: string): T;
        protected _loadItems(): void;
        protected _hasPermission(resourceId: string, requiredPermissions: KnockoutObservableBase<FxAzure.RequiredPermissions>, errorMessage: string): FxPromiseV<FxViewModels.ValidationResult>;
        private _setInitialValue();
        private _getFirstValidValue(items, index?);
        private _resetEditScopeValue(initialValue?);
        private _validate(val);
        private _validateBaseOptions(options);
        private _validateBaseConfig(config);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\Legal\Legal.d.ts
declare module MsPortalFx.Azure.Legal {
    /**
     * Input/configuration data used by the Legal Terms V2 blade.
     * NOTE: This model is deprecated. Any new code should use LegalTermsConfig instead.
     *
     * @deprecated Callers should use LegalTermsConfig instead.
     */
    interface DataModel {
        /**
         * If true, a 'pin to startboard' checkbox will be displayed on the action bar.
         */
        showPinToStartboardCheckbox?: boolean;
        /**
         * Subscription Id.
         */
        subscriptionId: string;
        /**
         * Used to switch the legal terms language.
         */
        legalTermsLanguage: LegalTermsLanguageEnum;
        /**
         * An array of gallery products.
         */
        products?: Product[];
        /**
         * An array of manually defined products. Used for products that don't exists on the gallery.
         */
        inlineProductDescriptions?: InlineProductDescription[];
        /**
         * The pricing tier selections made by the user.
         */
        pricingTierSelections?: PricingTierSelection[];
    }
    /**
     * Input/configuration data used by the Legal Terms V2 blade. In PCLegalTermsV2Blade, this is the type of the config
     * accepted by the parameter provider (via the supplyProviderConfig callback from the parameter collector).
     *
     * For solution
     */
    interface LegalTermsConfig {
        /**
         * Indicates what kind of marketplace item we are displaying legal terms language for.
         */
        legalTermsLanguage: LegalTermsLanguageEnum;
        /**
         * If true, a 'pin to startboard' checkbox will be displayed on the action bar.
         */
        showPinToStartboardCheckbox?: boolean;
        /**
         * The ID of the subscription which is being used to provision the marketplace item.
         */
        subscriptionId: string;
        /**
         * Details of the gallery item whose legal terms are being displayed. Obtain this value from
         * MsPortalFx.Azure.ResourceManager.ArmProvisioner<T>.armProvisioningConfig.galleryCreateOptions.galleryItem.
         * This value may be ommitted only if legalTermsLanguage == LegalTermsLanguageEnum.TemplateDeployment.
         */
        galleryItem?: any;
        /**
         * Describes the plan, promotion code, and other purchase details for each of the 3rd party products the user is buying.
         * For gallery items which do not have pricing or plans (such as solution templates), omit this value
         * and the legal terms blade will display the products extracted from galleryItem.
         */
        productPurchases?: ProductPurchase[];
    }
    /**
     * Describes the plan, promotion code, and other purchase details for each of the 3rd party products the user is buying.
     */
    interface ProductPurchase {
        /**
         * The publisherId (also called publisher namespace) for the product. This corresponds to
         * GalleryCreateOptions.galleryItem.products[i].offerDetails.publisherId.
         */
        publisherId: string;
        /**
         * The publisherId (also called publisher namespace) for the product. This corresponds to
         * GalleryCreateOptions.galleryItem.products[i].offerDetails.offerId.
         */
        offerId: string;
        /**
         * The ID of the plan (or VM SKU) which the user has chose for this product.
         */
        planId: string;
        /**
         * The promotion code which the user is using to purchase this 3rd party product. If no promotion code is being
         * applied then omit this value or set it to null.
         */
        promotionCode?: string;
        /**
         * The IDs of the third-party meters which apply to the plan that the user has purchased. If third party meters don't
         * apply to this type of product or no meters apply to the selected plan then omit this property or set it to an empty array.
         */
        meterIds?: string[];
        /**
         * For app services and data services, this should be set to the localized display name of the selected plan (corresponding to planId),
         * This value will be displayed alongside the offer name at the top of the legal terms blade. For other types of offers (virtual machines, etc)
         * this value should be ommitted.
         */
        servicePlanName?: string;
        /**
         * When the 3rd party product is a VM image this should be set to a FirstPartyVirtualMachinePurchase which describes the SKU / VM size chosen.
         * If the product is not a VM image this value should be omitted.
         */
        firstPartyVirtualMachine?: FirstPartyVirtualMachinePurchase;
    }
    /**
     * Describes the Azure VM SKU/size on which a VM image runs.
     */
    interface FirstPartyVirtualMachinePurchase {
        /**
         * The display name of this VM size/SKU, as it was presented to the user in the VM size picker control.
         */
        skuDisplayName: string;
        /**
         * The type of operating system on which the VM runs.
         */
        operatingSystem: FirstPartyOperatingSystem;
        /**
         * The parameters needed to get the per-unit (hourly) price of this VM SKU using the getSpecsCosts RPC exposed by the
         * billing extension.
         */
        hourlyCost: FirstPartyVirtualMachineCost;
    }
    /**
     * Describes the inputs needed to query the cost of a 1st party virtual machine SKU using the getSpecsCosts RPC
     * exposed by the billing extension.
     */
    interface FirstPartyVirtualMachineCost {
        /**
         * The resource ID of the resource corresponding to this VM in the billing system.
         * This value corresponds to HubsExtension.Azure.Pricing.FirstPartyResource.resourceId.
         */
        resourceId: string;
        /**
         * This is the quantity of the resource which should be used when estimating the resource's
         * cost using the getSpecsCosts RPC. This value corresponds to
         * HubsExtension.Azure.Pricing.FirstPartyResource.quantity.
         */
        quantity: number;
    }
    /**
     * Enumerates the operating systems on which an Azure VM may run.
     */
    enum FirstPartyOperatingSystem {
        Windows = 0,
        Linux = 1,
    }
    /**
     * The type of the result returned by the parameter provider in PCLegalTermsV2Blade.
     */
    interface LegalTermsAcceptanceResult {
        /**
         * True if the user consented to the legal terms displayed, and false if the user closed the legal terms
         * blade without consenting.
         */
        isAccepted: boolean;
    }
    /**
     * Pricing tier selection model.
     */
    interface PricingTierSelection {
        /**
         * The spec resource set.
         */
        specResourceSet: SpecResourceSet;
        /**
         * The specs allowed to have zero as a possible cost amount.
         */
        specsToAllowZeroCost: string[];
    }
    /**
     * Data contract for a resource quota set.
     */
    interface SpecResourceSet {
        /**
         * The spec id.
         */
        id: string;
        /**
         * The third party quotas.
         */
        thirdParty?: ThirdPartyResource[];
    }
    /**
     * Data contract for a third party resource.
     */
    interface ThirdPartyResource {
        /**
         * The round-tripped Id.
         */
        id?: string;
        /**
         * The resource publisher Id.
         */
        publisherId: string;
        /**
         * The resource offer Id.
         */
        offerId: string;
        /**
         * The resource offer display name.
         */
        offerDisplayName: string;
        /**
         * The resource plan Id.
         */
        planId: string;
        /**
         * The promotion code.
         */
        promotionCode: string;
        /**
         * The third party meters.
         */
        meters: ThirdPartyMeter[];
    }
    /**
     * Data contract for a third party meter.
     */
    interface ThirdPartyMeter {
        /**
         * The meter ID
         */
        meterId: string;
        /**
         * The meter Name
         */
        meterDisplayName: string;
        /**
         * The meter quantity
         */
        quantity: number;
    }
    /**
    * Used to retrieve the product (offer) information from the gallery.
    */
    interface Product {
        /**
         * Publisher id for the product.
         */
        publisherId: string;
        /**
         * Offer id for the product.
         */
        offerId: string;
        /**
         * Plan id for the product.
         */
        planId: string;
    }
    /**
     * Used in cases where a real gallery product doesn't exists
     * but still product information needs to be shown in the legal terms page.
     */
    interface InlineProductDescription {
        /**
         * Publisher display name.
         */
        publisherDisplayName: string;
        /**
         * Offer display name.
         */
        offerDisplayName: string;
        /**
         * Tells if the product has a free trial.
         */
        hasFreeTrial: boolean;
        /**
         * Tells if the product requires an external license.
         */
        requiresExternalLicense: boolean;
        /**
         * The legal terms HTML.
         */
        legalTerms: string;
        /**
         * The privacy policy HTML.
         */
        privacyPolicy: string;
        /**
         * The other pricing details URI.
         */
        pricingDetailsUri: string;
    }
    /**
     * Input data used by the LegalTermsSubscriptionProgrammaticAccessBlade blade.
     */
    interface SubscriptionProgrammaticAccessDataModel {
        /**
         * Subscription Id.
         */
        subscriptionId: string;
    }
    /**
     * Input data used by the LegalTermsSkuProgrammaticAccessBlade blade.
     */
    interface SkuProgrammaticAccessDataModel {
        /**
         * A gallery product.
         */
        product: Product;
    }
    /**
     * Used to switch the legal terms language in the LegalTermsV2 blade.
     */
    enum LegalTermsLanguageEnum {
        /**
         * Displays the default legal text which applies to single-VM products
         * and dev services.
         */
        Default = 0,
        /**
         * Displays the legal text which applies to solution templates (i.e. multi-VM offers) and
         * custom ARM templates (i.e. via the Template Deployment gallery item).
         */
        TemplateDeployment = 1,
        /**
         * Deprecated. Do not pass this value.
         */
        RequestPricingInformation = 2,
        /**
         * Displays the legal text which applies when enabling / disabling programmatic access to deploy a product.
         * Only the LegalTermsSkuProgrammaticAccessBlade should pass this value.
         */
        ProgrammaticAccess = 3,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\Locations.d.ts
declare module FxImpl.Azure {
    import FxAzure = MsPortalFx.Azure;
    import FxBase = MsPortalFx.Base;
    import FxRpc = FxBase.Rpc.Internal;
    import FxPromiseV = FxBase.PromiseV;
    /**
     * The inputs to the getLocationsForCreateEndPoint function definition.
     */
    interface GetLocationsForCreateEndPointArgs {
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The list of resource types.
         */
        resourceTypes?: string[];
        /**
         * Internal use only
         */
        cloudName?: string;
    }
    /**
     * Internal RPC endpoint to get the display names for locations.
     */
    const getLocationDisplayNamesEndPoint: FxRpc.FuncEndPointDefinition<void, StringMap<string>>;
    /**
     * Internal RPC endpoint to get locations for create.
     */
    const getLocationsForCreateEndPoint: FxRpc.FuncEndPointDefinition<GetLocationsForCreateEndPointArgs, FxAzure.Location[]>;
    /**
     * The user settings key to store the list of last used locations in deployments.
     */
    const lastUsedLocationsKey: string;
    /**
     * Returns the list of locations as a dictionary.
     *
     * @param rpcClient The RPC client.
     * @param args Inputs required by the RPC endpoint.
     * @return A promise that resolves with a list of locations.
     */
    function getLocationsForCreate(rpcClient: FxRpc.Client, args: GetLocationsForCreateEndPointArgs): FxPromiseV<FxAzure.Location[]>;
    /**
     * Returns the list of locations as a dictionary.
     *
     * @param rpcClient The RPC client.
     * @return A promise that resolves with a dictionary of location ids mapped to display names.
     */
    function getLocationDisplayNames(rpcClient: FxRpc.Client): FxPromiseV<StringMap<string>>;
    /**
     * Returns a sorted list of the most recently used locations in create.
     *
     * @param rpcClient The RPC client.
     * @return A promise that resolves with a sorted list of the most recently used locations in create.
     */
    function getLastUsedLocations(rpcClient: FxRpc.Client): FxPromiseV<string[]>;
    /**
     * Locations comparer for sorting (uses display name).
     * @param locA Location A.
     * @param locB Location B.
     * @return Comparison result.
     */
    function locationsComparer(locA: FxAzure.Location, locB: FxAzure.Location): number;
}
declare module MsPortalFx.Azure {
    import FxBase = MsPortalFx.Base;
    import FxPromiseV = FxBase.PromiseV;
    /**
     * Returns the list of locations as a dictionary.
     *
     * @return A promise that resolves to a dictionary of locations.
     */
    function getLocations(): FxPromiseV<StringMap<string>>;
    /**
     * Data contract for a single location.
     */
    interface Location {
        /**
         * The display name of the location.
         */
        displayName: string;
        /**
         * The normalized name of the location.
         */
        name: string;
        /**
         * The latitude of the location.
         */
        latitude?: number;
        /**
         * The longitude of the location.
         */
        longitude?: number;
    }
    /**
     * Locations namespace.
     */
    module Locations {
        import BaseDropDown = FxImpl.Azure.BaseResourceDropDown;
        import FxViewModels = MsPortalFx.ViewModels;
        /**
         * DropDown namespace.
         */
        module DropDown {
            /**
             * Locations drop down options.
             */
            interface Options extends BaseDropDown.Options<Location> {
                /**
                 * The observable that holds the subscription id used to filter locations.
                 */
                subscriptionIdObservable: KnockoutObservableBase<string>;
                /**
                 * Optional. The observable that holds the list of resource types used to filter locations.
                 */
                resourceTypesObservable?: KnockoutObservableBase<string[]>;
                filter?: LocationFilter | KnockoutObservableBase<LocationFilter>;
            }
            /**
             * The location filter.
             */
            interface LocationFilter {
                /**
                 * List of allowed locations.
                 * Either this or the disallowed locations can be specified.
                 */
                allowedLocations?: AllowedLocations;
                /**
                 * List of disallowed locations.
                 * Either this or the allowed locations can be specified.
                 */
                disallowedLocations?: DisallowedLocation[];
            }
            /**
             * The allowed locations.
             */
            interface AllowedLocations {
                /**
                 * The list of allowed location names.
                 */
                locationNames: string[];
                /**
                 * @deprecated Optional, disabled message to show for the disabled locations.
                 */
                disabledMessage?: string;
            }
            /**
             * The disallowed location.
             */
            interface DisallowedLocation {
                /**
                 * The location to disable.
                 */
                name: string;
                /**
                 * Optional, disabled message to show for the disabled location.
                 */
                disabledMessage?: string;
            }
        }
        /**
         * The location drop down. Commonly used in create blades.
         */
        class DropDown extends BaseDropDown<Location> {
            private _subId;
            private _resourceTypes;
            /**
             * Instantiates a new locations drop down control.
             *
             * @param container The container into which the part containing this control is being placed.
             * @param options The set of options to configure the locations drop down.
             */
            constructor(container: FxViewModels.ContainerContract, options: DropDown.Options);
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceFilter.d.ts
declare module MsPortalFx.Azure {
    import Fx = MsPortalFx;
    import FxAzure = Fx.Azure;
    import FxBase = Fx.Base;
    import FxViewModels = Fx.ViewModels;
    import FxControls = FxViewModels.Controls;
    import ListBase = FxImpl.ViewModels.Controls.Lists.Base;
    /**
     * The resource filter control.
     */
    module ResourceFilter {
        /**
         * The options to create resource filter control.
         */
        interface Options {
            /**
             * Value indicating whether to show the filter text box.
             */
            showTextFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the resource type drop down.
             */
            showTypeFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription drop down.
             */
            showSubscriptionFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription summary.
             */
            showSubscriptionSummary?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription summary as tenant-level.
             */
            showTenantLevelSubscriptionSummary?: KnockoutObservableBase<boolean>;
            /**
             * Optional value for selected subscription id.
             */
            selectedSubscriptionId?: KnockoutObservableBase<string>;
            /**
             * Optional value for text filter place holder.
             */
            textFilterPlaceholder?: KnockoutObservableBase<string>;
            /**
             * The viewmodel of a list/grid control that can be controlled by this resource filter.
             * The list will treat the textFilter textbox as a search text box by doing the following:
             *      enter keystrokes: Activate the first result
             *      down arrow keystrokes: Focus the first result
             *      focus and blur: highlight/remove highlight from the first result
             */
            actionHandler?: KnockoutObservableBase<ListBase.ActionHandler> | ListBase.ActionHandler;
        }
        /**
         * The view model for resource filter control.
         */
        class ViewModel extends FxControls.Base.ViewModel implements Options {
            /**
              * See interface.
              */
            showTextFilter: KnockoutObservableBase<boolean>;
            /**
             * See interface.
             */
            showTypeFilter: KnockoutObservableBase<boolean>;
            /**
             * See interface.
             */
            showSubscriptionFilter: KnockoutObservableBase<boolean>;
            /**
             * The value indicating whether subscriptions are filtered or not.
             */
            subscriptionsFiltered: KnockoutObservable<boolean>;
            /**
             * The See interface.
             */
            showSubscriptionSummary: KnockoutObservableBase<boolean>;
            /**
             * The See interface.
             */
            showTenantLevelSubscriptionSummary: KnockoutObservableBase<boolean>;
            /**
             * The list of selected resource types.
             */
            selectedTypes: KnockoutObservable<string[]>;
            /**
             * The list of selected subscriptions.
             */
            selectedSubscriptions: KnockoutObservable<FxAzure.Subscription[]>;
            /**
             * The text filter value.
             */
            filterText: KnockoutObservable<string>;
            /**
             * The cloud name.
             * Note: Internal use only.
             */
            cloudName: KnockoutObservable<string>;
            /**
             * Flag for whether cloud name is initialized.
             * Note: Internal use only.
             */
            isCloudNameInitialized: KnockoutObservable<boolean>;
            /**
             * See interface.
             */
            selectedSubscriptionId: KnockoutObservableBase<string>;
            /**
             * See interface.
             */
            textFilterPlaceholder: KnockoutObservableBase<string>;
            /**
             * The viewmodel of a list/grid control that can be controlled by this resource filter.
             * The list will treat the textFilter textbox as a search text box by doing the following:
             *      enter keystrokes: Activate the first result
             *      down arrow keystrokes: Focus the first result
             *      focus and blur: highlight/remove highlight from the first result
             */
            actionHandler: KnockoutObservableBase<ListBase.ActionHandler> | ListBase.ActionHandler;
            /**
             * A flag to determine whether or not the selected subscriptions are loaded and valid.
             * This is initially false, but will be set to true after all subscriptions in the cloud are retrieved and the selected subscriptions collection is set as a result.
             * It will be reset to false when the cloud changes in multicloud scenarios.
             */
            subscriptionsLoaded: KnockoutReadOnlyObservable<boolean>;
            /**
             * Constructs a resource filter view model.
             *
             * @param lifetimeManager Lifetime manager for this view model.
             * @param options The options for the resource filter view model.
             */
            constructor(container: FxBase.LifetimeManager, options?: Options);
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceGroups.d.ts
declare module FxImpl.Azure {
    import FxAzure = MsPortalFx.Azure;
    import FxBase = MsPortalFx.Base;
    import FxRpc = FxBase.Rpc.Internal;
    import ResourceGroup = FxAzure.ResourceGroup;
    /**
     * Internal RPC endpoint to get the resource groups under a list of subscriptions.
     */
    const getResourceGroupsFromSubscriptionEndPoint: FxRpc.FuncEndPointDefinition<string[], ResourceGroup[]>;
    /**
     * Returns the list of resource groups under a list of subscriptions.
     *
     * @param rpcClient The RPC client.
     * @param subscriptionIds The list of subscription ids.
     * @return A promise that resolves to the list of resource groups.
     */
    function getResourceGroupsFromSubscription(rpcClient: FxRpc.Client, subscriptionIds: string[]): FxBase.PromiseV<ResourceGroup[]>;
    /**
     * Checks if the resource id is locked as readonly.
     *
     * @param rpcClient The RPC client.
     * @param resourceId Inputs required by the RPC endpoint.
     * @return A promise that resolves with a list of locations.
     */
    function getIsReadOnly(rpcClient: FxRpc.Client, resourceId: string): FxBase.PromiseV<boolean>;
}
declare module MsPortalFx.Azure {
    /**
     * Data contract for a single resource group.
     */
    interface ResourceGroup {
        /**
         * Resource group location.
         */
        location: string;
        /**
         * Resource group name.
         */
        name: string;
        /**
         * Resource group provisioning state.
         */
        provisioningState?: string;
    }
    module ResourceGroups {
        import FxAzure = MsPortalFx.Azure;
        import FxBase = MsPortalFx.Base;
        import FxPromiseV = FxBase.PromiseV;
        import FxCreatorAndComboBox = FxImpl.ViewModels.Forms.CreatorAndComboBox;
        import FxViewModels = MsPortalFx.ViewModels;
        import InternalAzure = FxImpl.Azure;
        import BaseDropDown = InternalAzure.BaseResourceDropDown;
        export import AllowedMode = FxCreatorAndComboBox.AllowedMode;
        export import Mode = FxCreatorAndComboBox.Mode;
        /**
         * The max number of characters allowed for a resource group name.
         */
        const NameMaxLength: number;
        module Internal {
            /**
             * Validates a resource group name. If a subscription is provided, the function will check if
             * a resource group with that name exists for the given subscription.
             *
             * @param resourceGroupName The resource group name.
             * @param subscription The subscription
             * @param cloudName The cloud name.
             * @param existingResourceGroups An optional array of resource groups to do an existence check
             * @param existenceCheckCallback An optional async callback to get existing resource groups
             * @return The ValidationResult object.
             */
            function validateResourceGroupName(resourceGroupName: string, subscriptionId: string, cloudName: string, existingResourceGroups?: string[], existenceCheckCallback?: Func<FxPromiseV<FxViewModels.ValidationResult>>): FxPromiseV<FxViewModels.ValidationResult>;
        }
        /**
         * Validates a resource group name. If a subscription is provided, the function will check if
         * a resource group with that name exists for the given subscription.
         *
         * @param resourceGroupName The resource group name.
         * @param subscription The subscription
         * @param existingResourceGroups An optional array of resource groups to do an existence check
         * @param existenceCheckCallback An optional async callback to get existing resource groups
         * @return The ValidationResult object.
         */
        function validateResourceGroupName(resourceGroupName: string, subscriptionId: string, existingResourceGroups?: string[], existenceCheckCallback?: Func<FxPromiseV<FxViewModels.ValidationResult>>): FxPromiseV<FxViewModels.ValidationResult>;
        /**
         * The resource group drop down module.
         */
        module DropDown {
            interface Options extends BaseDropDown.Options<FxAzure.CreatorAndDropdDownValue<ResourceGroup>> {
                /**
                 * Subscription observable to fetch and validate resource groups against.
                 */
                subscriptionIdObservable: KnockoutObservableBase<string>;
                /**
                 * The default value for a new resource group name. If set, the +New text box will
                 * default to that value. If a resource group already exists with the same value, this
                 * string will be incremented ("val", "val_1", "val_2", etc.). If not set, the text
                 * box will be left blank (default).
                 */
                defaultNewValue?: string;
                /**
                 * The list of required permissions the subscription must have.
                 */
                requiredPermissions?: KnockoutObservableBase<RequiredPermissions>;
                /**
                 * The mode allowed for the resource group dropdown
                 */
                allowedMode?: KnockoutObservableBase<AllowedMode>;
            }
        }
        class DropDown extends BaseDropDown<FxAzure.CreatorAndDropdDownValue<ResourceGroup>> {
            /**
             * Specifies if you can create new or use existing resource groups, or both in this control
             */
            allowedMode: KnockoutObservableBase<AllowedMode>;
            private _createNewText;
            private _dropDown;
            private _optionsGroup;
            private _options;
            private _validated;
            /**
             * Constructs an instance of a BaseResourceDropDown form field integrated with EditScope.
             *
             * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
             * @param options Optional The set of options to configure the FilterComboField control.
             */
            constructor(container: FxViewModels.ContainerContract, options: DropDown.Options);
            /**
             * Switch the control between create new and use existing
             * @param createNew parameter to directly set the option selected instead of toggle.
             */
            toggleNewOrExisting(mode?: Mode): void;
            private static _fetchItems(options);
            private static _validate(dropDown, armResourceGroupObservable, value);
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceManager\Common.d.ts
declare module MsPortalFx.Azure.ResourceManager {
    import Gallery = Services.Gallery;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxPropertiesPart = FxViewModels.Parts.Properties;
    /**
     * The Gallery-create configuration options.
     */
    interface GalleryCreateOptions {
        /**
         * Gallery item information extracted from the gallery item and passed over to the extension.
         */
        galleryItem: GalleryItemExtract;
        /**
         * The context in which the gallery item was launched.
         */
        launchingContext: LaunchingContext;
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The subscription display name.
         */
        subscriptionDisplayName: string;
        /**
         * The resource group name.
         */
        resourceGroupName: string;
        /**
         * The location/region.
         */
        resourceGroupLocation: string;
        /**
         * The resource group location display name.
         */
        resourceGroupLocationDisplayName?: string;
        /**
         * The deployment name.
         */
        deploymentName: string;
        /**
         * The list of URIs for the CSM template files.
         */
        deploymentTemplateFileUris: StringMap<string>;
        /**
         * The list of URIs for the deployment fragments.
         */
        deploymentFragmentFileUris?: StringMap<string>;
    }
    /**
     * Gallery item information extracted from the gallery item and passed over to the extension.
     */
    interface GalleryItemExtract {
        /**
         * The identity of the gallery item.
         */
        id: string;
        /**
         * The item display name.
         */
        itemDisplayName: string;
        /**
         * Gets or sets Publisher display name.
         */
        publisherDisplayName: string;
        /**
         * The item version.
         */
        version: string;
        /**
         * The list of category IDs the gallery item belongs to.
         */
        categoryIds: string[];
        /**
         * Gallery item products.
         */
        products: GalleryItemProduct[];
        /**
         * Gallery item products with no pricing information.
         */
        productsWithNoPricing: GalleryItemProduct[];
        /**
         * The item additional artifacts.
         */
        specialArtifacts?: Gallery.Artifact[];
        /**
         * The dictionary of metadata properties to be used by the extension.
         */
        metadata?: StringMap<string>;
    }
    /**
     * Gallery product (offer) model.
     */
    interface GalleryItemProduct {
        /**
         * The product (offer) display name.
         */
        displayName: string;
        /**
         * The publisher display name.
         */
        publisherDisplayName: string;
        /**
         * The uri to the legal terms HTML.
         */
        legalTermsUri: string;
        /**
         * The uri to the privacy policy HTML.
         */
        privacyPolicyUri: string;
        /**
         * The other pricing details URI.
         */
        pricingDetailsUri: string;
        /**
         * The pricing details. Optional.
         * If the product doesn't contain pricing details, then we won't fetch pricing information
         * for it.
         */
        offerDetails?: GalleryItemOfferPricingDetails;
    }
    /**
     * Gallery offer pricing details model.
     * Used to retrieve the pricing information for a gallery offer.
     */
    interface GalleryItemOfferPricingDetails {
        /**
         * The offer id.
         */
        offerId: string;
        /**
         * The publisher id.
         */
        publisherId: string;
        /**
         * The offer plans provided by the publisher.
         */
        plans: GalleryItemOfferPlan[];
    }
    /**
     * Gallery offer plan.
     */
    interface GalleryItemOfferPlan {
        /**
         * The plan id.
         */
        planId: string;
        /**
         * The plan display name.
         */
        displayName: string;
        /**
         * The summary text for the plan.
         */
        summary: string;
        /**
         * The description HTML for the plan.
         */
        description: string;
    }
    /**
     * The context from which a gallery create is kicked off.
     */
    interface LaunchingContext extends StringMap<any> {
        /**
         * The gallery item id.
         */
        galleryItemId: string;
        /**
         * The source entity launching the create flow (blade name, control, etc.). Used for telemetry logging.
         */
        source: string[];
        /**
         * The gallery menu item id.
         */
        menuItemId?: string;
        /**
         * The gallery sub menu item id.
         */
        subMenuItemId?: string;
        /**
         * The gallery item index from the source grid.
         */
        itemIndex?: number;
        /**
         * Unique id for tracking a deployment.
         */
        telemetryId?: string;
        /**
         * Extension version.
         */
        extVersion?: string;
        /**
         * The name of the create blade.
         */
        createBlade?: string;
        /**
         * Indicates if this is a create flow that uses the PCv1/v2 API.
         */
        oldCreateApi?: boolean;
    }
    /**
     * Represents types of resource move operations supported in the system.
     */
    const enum MoveType {
        /**
         * Move resources across subscriptions and resource groups excluding current subscription.
         */
        Subscription = 0,
        /**
         * Move resources across resource groups only.
         */
        ResourceGroup = 1,
        /**
         * Move resources across subscriptions and resource groups including current subscription.
         */
        SubscriptionAndResourceGroup = 3,
        /**
         * Move resource is not supported.
         */
        None = 4,
    }
    /**
     * Returns the move resource blade for editing resource group/subscription properties.
     *
     * @param resourceId resource Id of the resource to be moved.
     * @param moveType supported move types by the resource RP.
     * @return An edit blade for the moving resources across subscriptions/resource groups.
     */
    function getMoveResourceBlade(resourceId: string, moveType: MoveType): FxPropertiesPart.OpenBlade;
    module Internal {
        /**
         * Indicates a gallery item create availability.
         */
        enum GalleryItemAccess {
            /**
            * If the access is not set it means the default rules should be followed.
            */
            NotSet = 0,
            /**
            * This means the item was curated to be allowed regardless of categories.
            * For example in the case of dream spark an item may be allowed if specified in the curation.
            */
            Allowed = 1,
            /**
            * This means the item was curated to not be allowed.
            */
            NotAllowed = 2,
        }
        /**
         * Galley item with extended options used by the create flow.
         */
        interface ExtendedGalleryItem extends Gallery.GalleryItem {
            /**
             * Represents a value indicating if an item is allowed or not by the subscription quota according to the curation.
             */
            galleryItemAccess?: GalleryItemAccess;
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceManager\Deployments.d.ts
declare module FxImpl.Azure.ResourceManager {
    import FxBase = MsPortalFx.Base;
    import ResourceManager = MsPortalFx.Azure.ResourceManager;
    import RpcCore = FxBase.Rpc.Internal;
    /**
     * The max number of items tracked in the list of last deployed gallery items in user settings.
     */
    var lastDeployedGalleryItemsMaxCount: number;
    /**
     * The max number of locations tracked in the list of last used locations in user settings.
     */
    var lastUsedLocationsMaxCount: number;
    /**
     * Internal RPC endpoint to read uset settings from HubsExtension.
     */
    const readUserSettingsEndPoint: RpcCore.FuncEndPointDefinition<string[], StringMap<any>>;
    /**
     * Internal ARM template deployment options.
     */
    interface TemplateDeploymentOptions extends ResourceManager.TemplateDeploymentOptions {
        /**
         * The cloud name. It is only used in deploy v1. Shell needs this to pass to Hubs
         */
        cloudName?: string;
    }
    /**
     * Deploys an ARM deployment template.
     *
     * @param rpcClient The RPC client.
     * @param options The template deployment options.
     * @return A promise resolved with the template deployment result, and possibly reports progress
     *      (based on the options).
     */
    function deployTemplate(rpcClient: RpcCore.Client, options: TemplateDeploymentOptions): FxBase.PromiseVN<ResourceManager.TemplateDeploymentResult, ResourceManager.TemplateDeploymentResult>;
    /**
     * Polls for an ARM deployment updates.
     *
     * @param rpcClient The RPC client.
     * @param options The template deployment polling options.
     * @return A promise resolved with the template deployment result, and possibly reports progress
     *      (based on the options).
     */
    function pollForDeployment(rpcClient: RpcCore.Client, options: ResourceManager.TemplateDeploymentPollingOptions): FxBase.PromiseVN<ResourceManager.TemplateDeploymentResult, ResourceManager.TemplateDeploymentResult>;
    /**
     * Validates an ARM template.
     *
     * @param options The template deployment options.
     * @returns A promise with the template validation result.
     */
    function validateTemplate(rpcClient: RpcCore.Client, options: TemplateDeploymentOptions): FxBase.PromiseVN<any, ResourceManager.TemplateValidationError>;
}
declare module MsPortalFx.Azure.ResourceManager {
    import FxBase = MsPortalFx.Base;
    /**
     * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
     */
    module DeploymentStates {
        /**
         * Deployment accepted.
         */
        const Accepted: string;
        /**
         * Deployment succeeded.
         */
        const Succeeded: string;
        /**
         * Deployment failed.
         */
        const Failed: string;
        /**
         * Deployment canceled.
         */
        const Canceled: string;
        /**
         * Deployment running.
         */
        const Running: string;
        /**
         * Deployment deploying.
         */
        const Deploying: string;
        /**
         * Deployment waiting.
         */
        const Waiting: string;
        /**
         * Deployment deleting.
         */
        const Deleting: string;
        /**
         * Deployment deleted.
         */
        const Deleted: string;
    }
    /**
     * ARM template deployment API arguments.
     */
    interface DeploymentApiArgs {
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The deployment name.
         */
        deploymentName: string;
        /**
         * The resource group name.
         */
        resourceGroupName: string;
        /**
         * The resource id. Supply this to link the notifications to the asset or if the deployment
         * results in a startboard part.
         */
        resourceId?: string;
        /**
         * The context from which a gallery create is kicked off. Used for telemetry logging.
         */
        launchingContext?: LaunchingContext;
        /**
          * Debug info.
          */
        debug?: string;
    }
    /**
     * ARM template deployment options.
     */
    interface TemplateDeploymentOptions extends DeploymentApiArgs {
        /**
         * The location/region.
         */
        resourceGroupLocation: string;
        /**
         * An array of the resource providers to be registered for the subscription.
         */
        resourceProviders: string[];
        /**
         * The template parameters.
         */
        parameters?: StringMap<string | number | boolean | Object>;
        /**
         * The uri for the ARM template. Specify this or the templateJson property, but not both.
         */
        templateLinkUri?: string;
        /**
         * The inline deployment template JSON. Specify this or the templateLinkUri property, but not both.
         */
        templateJson?: string;
        /**
         * Flag indicating whether to suppress default deployment notifications or not. Defaults to
         * false. This applies only to intermediate local notifications (initialization, submitting
         * the deployment, and starting the deployment). Success and failures will still show as they
         * arrive from the events service.
         */
        suppressDefaultNotifications?: boolean;
        /**
         * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
         */
        deploymentMode?: TemplateDeploymentMode;
    }
    /**
     * ARM template deployment polling options.
     */
    interface TemplateDeploymentPollingOptions extends DeploymentApiArgs {
        /**
         * The correlation id (aka tracking id).
         */
        correlationId: string;
        /**
         * Report all ARM operations as progress. Defaults to false.
         */
        getAllOperations?: boolean;
        /**
         * Timestamp when the deployment request was initiated.
         */
        requestTimestamp: Date;
    }
    /**
     * ARM template deployment result.
     */
    interface TemplateDeploymentResult extends DeploymentApiArgs {
        /**
         * The deployment status code.
         */
        deploymentStatusCode: DeploymentStatusCode;
        /**
         * The correlation id (aka tracking id).
         */
        correlationId: string;
        /**
         * The provisioning state.
         */
        provisioningState: string;
        /**
         * The timestamp when the operation was completed.
         */
        timestamp: Date;
        /**
         * The list of deployment operations.
         */
        operations?: TemplateDeploymentOperation[];
        /**
         * Timestamp when the deployment request was initiated.
         */
        requestTimestamp?: Date;
    }
    /**
     * ARM template deployment operation.
     */
    interface TemplateDeploymentOperation {
        /**
         * The URI for the deployed entity.
         */
        id: string;
        /**
         * The operation id.
         */
        operationId: string;
        /**
         * The operation properties.
         */
        properties: TemplateDeploymentOperationProperties;
    }
    /**
     * ARM template deployment operation.
     */
    interface TemplateDeploymentOperationProperties {
        /**
         * The resource being operated upon.
         */
        targetResource: StringMap<string>;
        /**
         * The timestamp when the operation was completed.
         */
        timestamp: string;
        /**
         * The unique id for this deployment operation.
         */
        trackingId: string;
        /**
         * The status of the operation.
         */
        statusCode: string;
        /**
         * The detailed status message for the operation returned by the resource provider.
         */
        statusMessage: string;
    }
    /**
     * ARM template deployment error.
     */
    interface TemplateDeploymentError extends FxImpl.Azure.SimplifiedError {
        /**
         * The deployment status code.
         */
        deploymentStatusCode: DeploymentStatusCode;
        /**
         * The ARM template deployment options used in the deployment operation.
         */
        templateDeploymentOptions: TemplateDeploymentOptions;
        /**
         * The correlation id.
         */
        correlationId?: string;
        /**
         * Timestamp when the last notification was published.
         */
        notificationTimestamp: Date;
    }
    /**
     * ARM template validation result.
     */
    interface TemplateValidationError {
        /**
         * The error code.
         */
        code: DeploymentStatusCode;
        /**
         * The error message.
         */
        message: string;
        /**
         * The error object.
         */
        error?: any;
        /**
         * The error status.
         */
        status?: number;
    }
    /**
     * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
     */
    enum TemplateDeploymentMode {
        /**
         * Submit a deployment request to ARM only (this does not wait till the resouces are provisioned).
         * The 'deployTemplate' API will return a promise that resolves with ARM's response to the request.
         */
        RequestDeploymentOnly = 1,
        /**
         * Submit a deployment request to ARM and wait till provisioning the resources has completed
         * (silent polling). The 'deployTemplate' API will return a promise that reports progress only
         * once, when the request is accepted. The promise resolves when provisioning the resources
         * has completed.
         */
        DeployAndAwaitCompletion = 2,
        /**
         * Submit a deployment request to ARM and wait till provisioning the resources has completed,
         * while reporting all updates from ARM. The 'deployTemplate' API will return a promise that
         * reports progress when the request is accepted, followed by all ARM operations on every poll.
         * The promise resolves when provisioning the resources has completed.
         */
        DeployAndGetAllOperations = 3,
        /**
         * Execute all the deployment preflight actions without submitting the deployment request
         * (sanity check, provisioning the resource group, registering the resource providers,
         * getting a valid deployment name, and running ARM's preflight validation).
         */
        PreflightOnly = 4,
    }
    /**
     * The deployment status codes.
     */
    enum DeploymentStatusCode {
        /**
         * Template preflight, validation or deployment failure (based on the operation performed).
         */
        Failure = -1,
        /**
         * Deployment was accepted or successful (based on the operation performed).
         */
        Success = 0,
        /**
         * ARM rejected the deployment request.
         */
        DeploymentRequestFailed = 1,
        /**
         * Deployment failed.
         */
        DeploymentFailed = 2,
        /**
         * Deployment status unknown.
         */
        DeploymentStatusUnknown = 3,
        /**
         * An unexpected error occurred while provisioning the resource group.
         */
        ErrorProvisioningResourceGroup = 4,
        /**
         * An unexpected error occurred while submitting the deployment request.
         */
        ErrorSubmittingDeploymentRequest = 5,
        /**
         * An unexpected error occurred while getting the deployment status.
         */
        ErrorGettingDeploymentStatus = 6,
        /**
         * Invalid arguments.
         */
        InvalidArgs = 7,
        /**
         * An unexpected error occurred while registering the resource providers.
         */
        ErrorRegisteringResourceProviders = 8,
        /**
         * Deployment canceled.
         */
        DeploymentCanceled = 9,
        /**
         * Unknown error.
         */
        UnknownError = 10,
    }
    /**
     * Deploys an ARM deployment template.
     *
     * @param options The template deployment options.
     * @return A promise resolved with the template deployment result, and possibly reports progress
     *      (based on the options).
     */
    function deployTemplate(options: TemplateDeploymentOptions): FxBase.PromiseVN<TemplateDeploymentResult, TemplateDeploymentResult>;
    /**
     * Polls for an ARM deployment updates.
     *
     * @param options The template deployment polling options.
     * @return A promise resolved with the template deployment result, and possibly reports progress
     *      (based on the options).
     */
    function pollForDeployment(options: TemplateDeploymentPollingOptions): FxBase.PromiseVN<TemplateDeploymentResult, TemplateDeploymentResult>;
    /**
     * The ARM deployments APIs.
     */
    module Deployments {
        /**
         * Deploys an ARM deployment template.
         *
         * NOTE: The returned promise will resolve with an object that has a success flag on it. If
         * the flag is set to true, then the object is the template deployment result (success). If
         * the flag is set to false, then the object is the template deployment error (expected
         * failure). The promise will reject only in the case of an unexpected failure.
         *
         * @param options The template deployment options.
         * @return A promise resolved with the template deployment result, and possibly reports progress
         *      (based on the options).
         */
        function deployTemplate(options: TemplateDeploymentOptions): FxBase.PromiseVN<TemplateDeploymentResult | TemplateDeploymentError, TemplateDeploymentResult>;
        /**
         * Polls for an ARM deployment updates.
         *
         * NOTE: The returned promise will resolve with an object that has a success flag on it. If
         * the flag is set to true, then the object is the template deployment result (success). If
         * the flag is set to false, then the object is the template deployment error (expected
         * failure). The promise will reject only in the case of an unexpected failure.
         *
         * @param options The template deployment polling options.
         * @return A promise resolved with the template deployment result, and possibly reports progress
         *      (based on the options).
         */
        function pollForDeployment(options: TemplateDeploymentPollingOptions): FxBase.PromiseVN<TemplateDeploymentResult | TemplateDeploymentError, TemplateDeploymentResult>;
        /**
         * Validates an ARM template.
         *
         * @param options The template deployment options.
         * @returns A promise with the template validation result.
         */
        function validateTemplate(options: TemplateDeploymentOptions): FxBase.PromiseVN<any, ResourceManager.TemplateValidationError>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceManager\Lock.d.ts
/**
 * Lock RPC endpoints.
 */
declare module FxImpl.Azure.ResourceManager {
    module Lock {
        import HubsLock = HubsExtension.Azure.Lock;
        import FxRpcFuncEndPointDefinition = MsPortalFx.Base.Rpc.Internal.FuncEndPointDefinition;
        const getLockValidation: string;
        /**
         * Internal RPC enpoint to get validation result for
         */
        const isLockedEndpoint: FxRpcFuncEndPointDefinition<HubsLock.LockCheck, boolean>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceManager\Pickers\LocationPicker.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Location {
    import LocationDropDown = MsPortalFx.Azure.Locations.DropDown;
    /**
     * The data model used by the location picker.
     */
    interface DataModel {
        /**
         * The display name of the location.
         */
        displayName: KnockoutObservableBase<string>;
        /**
         * The normalized name of the location.
         */
        name: KnockoutObservableBase<string>;
        /**
         * The latitude of the location.
         */
        latitude: KnockoutObservableBase<number>;
        /**
         * The longitude of the location.
         */
        longitude: KnockoutObservableBase<number>;
    }
    /**
     * The config used by the location picker.
     */
    interface Config {
        /**
         * The subscription id used to filter locations.
         */
        subscriptionId: string;
        /**
         * The list of resource types used to filter locations.
         */
        resourceTypes: string[];
        /**
         * Optional, location filters.
         */
        filter?: LocationFilter;
    }
    /**
     * The location filters.
     */
    interface LocationFilter extends LocationDropDown.LocationFilter {
    }
    /**
     * The allowed locations.
     */
    interface AllowedLocations extends LocationDropDown.AllowedLocations {
    }
    /**
     * The disallowed location.
     */
    interface DisallowedLocation extends LocationDropDown.DisallowedLocation {
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceManager\Pickers\ResourceGroupPicker.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.ResourceGroup {
    /**
     * The data model used by the resource group picker.
     */
    interface DataModel {
        /**
         * The id of the resource group.
         */
        id: KnockoutObservableBase<string>;
        /**
         * The name of the resource group.
         */
        name: KnockoutObservableBase<string>;
        /**
         * The resource group location.
         */
        location: KnockoutObservableBase<string>;
    }
    /**
     * The config used by the resource group picker.
     */
    interface Config {
        /**
         * The subscription id used to filter resource groups.
         */
        subscriptionId: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceManager\Pickers\Specs\Common.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Specs {
    import SpecPickerTypes = HubsExtension.Azure.SpecPicker.ParameterCollectionV3;
    /**
     * Configuration data for a spec picker blade
     */
    interface InitialData extends SpecPickerTypes.SpecPickerProviderCollectorParameterFromCollector {
    }
    /**
     * Spec data returned from the spec picker blade
     */
    interface Result extends SpecPickerTypes.SpecPickerProviderCollectorParameterFromProvider {
    }
}
declare module FxImpl.Azure.ResourceManager.Pickers.Specs {
    import FxViewModels = MsPortalFx.ViewModels;
    import SpecPicker = MsPortalFx.Azure.ResourceManager.Pickers.Specs;
    import SpecPickerTypes = HubsExtension.Azure.SpecPicker.ParameterCollectionV3;
    import OriginControl = HubsExtension.Azure.SpecPicker.OriginControl;
    /**
     * Options to pass into the CollectorControl
     */
    interface Options {
        /**
         * A callback that supplies initial data for the parameter provider
         * in the child blade each time it opens.
         *
         * Note that the object received by the parameter provider will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed (and sometimes stored) in a serialized form.
         *
         * @return Initial data for the child blade.
         */
        supplyInitialData(): SpecPicker.InitialData;
        /**
         * A callback to be invoked when the child blade supplies a result
         * and closes.
         *
         * @param result The result given by the child blade.
         */
        receiveResult?(result: SpecPicker.Result): void;
    }
    /**
     * Base class which interfaces with a spec picker blade.
     */
    class CollectorControl {
        /**
         * ParameterCollector created to interface with the spec picker blade ParameterProvider
         */
        collector: FxViewModels.ParameterCollector<SpecPickerTypes.SpecPickerProviderCollectorParameter>;
        protected controlType: OriginControl;
        /**
         * Constructs a control which launches a spec picker blade and a collector that recieves a spec
         *
         * @param container The container associated with the part or other composition item hosting this parameter collector.
         * @param selectable The selectable associated with the <BladeAction> connected to this Control.
         * @param value The observable to place the Result from the spec picker blade.
         * @param options The options object which contains callbacks for providing initial data and receiving results.
         */
        constructor(container: FxViewModels.ContainerContract, selectable: FxViewModels.Selectable<FxViewModels.DynamicBladeSelection>, value: KnockoutObservableBase<SpecPicker.Result>, options: Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceManager\Pickers\Specs\InfoBox.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Specs {
    import Controls = MsPortalFx.ViewModels.Controls;
    import Internal = FxImpl.Azure.ResourceManager.Pickers.Specs;
    module InfoBox {
        interface Options extends Internal.Options, Controls.InfoBox.BaseInfoBoxOptions {
        }
    }
    /**
     * InfoBox which creates a collector and selector that launches a spec picker blade
     */
    class InfoBox extends Internal.CollectorControl {
        /**
         * InfoBox.ViewModel The info box control.
         */
        control: Controls.InfoBox.ViewModel;
        /**
         * KnockoutObservable<Result> The selected spec.
         */
        value: KnockoutObservable<Result>;
        /**
         * Constructs a InfoBox with for a spec ViewModel with a collector to a spec picker blade attached
         *
         * @param container The container associated with the part or other composition item hosting this parameter collector.
         * @param infoBox options that extends both the colector and the BaseInfoBoxOptions
         */
        constructor(container: MsPortalFx.ViewModels.ContainerContract, options: InfoBox.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceManager\Pickers\Specs\Selector.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Specs {
    import Internal = FxImpl.Azure.ResourceManager.Pickers.Specs;
    import FxViewModels = MsPortalFx.ViewModels;
    import Forms = FxViewModels.Forms;
    module Selector {
        /**
         * Data contract options passed into the SpecSelectorCollector
         */
        interface Options extends Internal.Options, Forms.Selector.Options<Result> {
            /**
             * The Form ViewModel for the selector control.
             */
            form: Forms.Form.ViewModel<any>;
            /**
             * The path to the property on the Form data model being set
             * Used instead of accessor
             */
            pathOrAccessor: string | Forms.EditScopeAccessors<Result>;
        }
    }
    class Selector extends Internal.CollectorControl {
        /**
         * Selector.ViewModel The Selector ViewModel created.
         */
        control: Forms.Selector.ViewModel<Result>;
        constructor(container: FxViewModels.ContainerContract, options: Selector.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\ResourceManager\Provisioner.d.ts
declare module MsPortalFx.Azure.ResourceManager {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import ParameterCollection = FxViewModels.ParameterCollectionV3;
    import Pricing = HubsExtension.Azure.Pricing;
    import Telemetry = FxBase.Diagnostics.Telemetry;
    let armValidateFeatureEnabled: boolean;
    /**
     * An ARM provisioner allows for provisioning the deployment of an ARM template, and adds an
     * ARM provisioning startboard part if needed. Provisioning is triggered automatically if the
     * provisioner is hooked up with a parameter provider and an action bar, or manually by calling
     * the 'startProvisioning' method.
     */
    class Provisioner<TData> extends ParameterCollection.Provisioner<TData> {
        /**
         * The selectable to activate the pricing summary blade.
         */
        pricingSelectable: FxViewModels.Internal.Selectable<FxViewModels.DynamicBladeSelection>;
        /**
         * The selectable to activate the ARM errors blade.
         */
        errorsSelectable: FxViewModels.Internal.Selectable<FxViewModels.DynamicBladeSelection>;
        private _armOptions;
        private _deploymentOptions;
        private _legalTermsBladeShown;
        private _legalTermsCommitId;
        private _pricingSummaryCommitId;
        private _purchaseInProgress;
        private _showPricingSummary;
        private _showAutomationOptions;
        private _parameterProvider;
        /**
         * Constructs a new instance of an ARM provisioner.
         *
         * @param container The container into which the part containing the provisioner is being placed.
         * @param initialState Initial state of the containing view model.
         * @param options The ARM provisioner options.
         */
        constructor(container: FxViewModels.ContainerContract, initialState: any, options: Provisioner.Options<TData>);
        /**
         * The ARM provisioner configuration passed originally from the collector, to the provisioner,
         * to this provisioning part.
         */
        armProvisioningConfig: Provisioner.Config;
        /**
         * Manually start provisioning. This is usually used with collector view models. This must
         * not be used if the provisioner is configured with a provider and an action bar (automatically)
         * triggered). This method uses the 'supplyStartboardInfo' to define a startboard part if you
         * want provisioning to happen on the startboard, or return null or undefined if you want it
         * to run in the background.
         *
         * @param data The provisioning data that will be passed to the provisioning operation.
         * @return A promise that represents the provisioning operation.
         */
        startProvisioning(data: TData): FxBase.PromiseVN<any, any>;
        protected _deployTemplate(templateDeploymentOptions: TemplateDeploymentOptions): FxBase.PromiseVN<TemplateDeploymentResult, TemplateDeploymentResult>;
        protected _validateTemplate(templateDeploymentOptions: TemplateDeploymentOptions): FxBase.PromiseVN<any, TemplateValidationError>;
        private _supplyProvisioningPromise(data);
        private _supplyStartboardInfo(data);
        private _setUpActionBarValidation(container, options);
        private _setActionBarProgress(value);
        private _getStartboardPartInputs(data, templateDeploymentOptions);
        private _setUpActionBarWatcher(container);
        private _launchTemplateViewerBlade();
        private _launchPricingSummaryBlade();
        private _launchLegalTermsBlade();
        private _getPricingBladeInputs();
        protected _traceProvisioningStarted(): Telemetry.TelemetryEvent;
        protected _traceProvisioningEnded(result: any, resolved: boolean): Telemetry.TelemetryEvent;
    }
    module Provisioner {
        var armValidationTimeout: number;
        /**
         * Azure resource manager provisioning part definition.
         * This is the default part when ARM provisioning is invoked.
         */
        var azureResourceManagerProvisioningPart: ParameterCollection.ExtensionElement;
        /**
         * Interface that defines why the supplyTemplateDeploymentOptions is being called
         */
        enum GetTemplateDeploymentOptionsMode {
            /**
             * The function is being called to do a create.
             */
            Create = 0,
            /**
             * The function is being called to export the template.
             * No create is being performed.
             */
            ExportTemplate = 1,
            /**
             * The function is being called for validating the options.
             * No create is being performed.
             */
            Validate = 2,
        }
        /**
         * ARM provisioning part options.
         */
        interface Options<TData> {
            /**
             * A callback that supplies the template deployment options that will be used in provisioning
             * the deployment of the ARM template.
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically, the data is the same data returned to the collector (by the
             *      'mapOutgoingDataForCollector' method). If the provisioner is triggered automatically,
             *      the data is whatever is passed to the 'startProvisioning' method.
             * @param mode The mode for why the function is being called. This function can be
             *      called when a user wants to export the deployment template or when doing an acutal create.
             *      Extensions can use the mode for their own logging purposes. The output of the function
             *      *should* not change based on the mode.
             * @return A promise resolved with the template deployment options.
             */
            supplyTemplateDeploymentOptions: (data: TData, mode: GetTemplateDeploymentOptionsMode) => FxBase.PromiseV<TemplateDeploymentOptions>;
            /**
             * A callback that supplies the provisioner with the startboard info (which provisioning part
             * to use, and which startboard part to mutate into). Use this callback if you want to override
             * the startboard part info defined in the UI definition file of the gallery package.
             *
             * If provisioning is automatically triggered, and if the user wants provisioning to happen
             * on the startboard, the startboard info returned will be used for that purpose. If invalid
             * startboard info is returned, the provisioner will throw an exception and provisioning will
             * fail. Null or undefined are not acceptable.
             *
             * If provisioning is manually triggered, returning null or undefined indicates that you don't
             * want provisioning to happen on the startboard. If you return invalid startboard info, the
             * provisioner will throw an exception. If you return valid startboard info, a provisioning
             * part will be added to the startboard for provisioning to take place.
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically (it's hooked up with a provider and an action bar), the data
             *      is the same data returned to the collector (by the 'mapOutgoingDataForCollector'
             *      method). If the provisioner is triggered automatically, the data is whatever was
             *      passed to the 'startProvisioning' method.
             * @return A startboard info object indicating which provisioning part to use and which
             *      startboard the provisioning part will mutate into.
             */
            supplyStartboardInfo?: (data: TData) => ParameterCollection.StartboardInfo;
            /**
             * A callback that supplies the provisioner with the gallery create config options. This is
             * only required when provisioning is manually triggered (config usually comes from the collector
             * in the automatic trigger case).
             *
             * @return The gallery create config options.
             */
            supplyGalleryCreateOptions?: () => GalleryCreateOptions;
            /**
             * The action bar view model. This is the action bar on your provider blade. Defining this
             * property means you also need to define a parameter provider.
             */
            actionBar?: FxViewModels.ActionBars.Base.Contract;
            /**
             * The parameter provider. This is the parameter provider on your provider view model.
             * Defining this property means you also need to define an action bar.
             */
            parameterProvider?: FxViewModels.ParameterProvider<TData, any>;
            /**
             * The features added to a create experience.
             */
            createFeatures?: CreateFeatures;
            /**
             * A callback that supplies the pricing config required by the pricing summary and/or the
             * legal terms blade. This is required if the 'createFeatures' specifies the
             * 'ShowPricingSummary' and/or 'ShowLegalTerms' flags.
             *
             * @return The pricing config required by the pricing blades.
             */
            supplyPricingConfig?: () => Provisioner.PricingConfig;
            /**
             * A callback that gets called if ARM validation succeeds.
             * Allows extensions to run additional validations on the ARM response.
             * This is only called if CreateFeatures.EnableArmValidation is set.
             *
             * @param armValidationResult The ARM validation result.
             * @return A promise that returns a validation result.
             */
            postValidationCallback?: (armValidationResult: any) => FxBase.PromiseV<FxViewModels.ValidationResult>;
        }
        /**
         * The ARM provisioner configuration that a collector can pass to the provider part.
         */
        interface Config extends ParameterCollection.Provisioner.Config {
            /**
             * Gallery-create config options.
             */
            galleryCreateOptions: GalleryCreateOptions;
        }
        /**
         * The features that can be added to a create experience.
         */
        enum CreateFeatures {
            /**
             * None (default).
             */
            None = 0,
            /**
             * Shows the pricing summary. This adds a "Pricing summary" link next to the create button
             * on the action bar. Clicking the link launches the pricing summary blade.
             */
            ShowPricingSummary = 1,
            /**
             * Shows the legal terms. This launches the legal terms blade once the create button on
             * the create action bar is clicked. Clicking "Buy" on the legal terms blade will kick
             * off create.
             */
            ShowLegalTerms = 2,
            /**
             * Shows the automation options. This cannot be set if the show pricing summary link is also set.
             * This adds a "Automation options" link next to the create button on the action bar.
             * Clicking the link launches the template viewer blade where users can download
             * automation scripts for creating resources
             */
            ShowAutomationOptions = 4,
            /**
             * Do not show the export template option. If explicity opting out of showing export template, this flag should be set.
             * This removes the "Automation options" link next to the create button on the action bar.
             */
            HideExportTemplate = 8,
            /**
             * Opts out of ARM validation.
             */
            DisableArmValidation = 16,
            /**
             * Opts in for ARM validation.
             */
            EnableArmValidation = 32,
        }
        /**
         * The ARM provisioner configuration that a collector can pass to the provider part.
         */
        interface PricingConfig {
            /**
             * A callback to supply the pricing info required by the pricing summary and/or legal terms
             * blades.
             */
            supplyPricingInfo: () => Pricing.PricingInfo;
            /**
             * Optional. A boolean observable that shows/hides the pricing summary link. If not supplied,
             * the pricing summary link will always be visible if the 'createFeatures' on the ARM
             * provisioner options specifies the 'ShowPricingSummary' flags.
             */
            showPricingSummaryLink?: KnockoutObservableBase<boolean>;
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\Storage.d.ts
declare module FxImpl {
    import FxBase = MsPortalFx.Base;
    import FxRpc = FxBase.Rpc.Internal;
    module InternalAzure {
        /**
         * Internal RPC endpoint to get a sas uri for a storage account's queue.
         */
        const getSasUriForQueueEndPoint: FxRpc.FuncEndPointDefinition<Azure.Storage.GetSasUriForQueueOptions, string>;
    }
    module Azure.Storage {
        /**
         * Bit-wise OR permissions attached to the generated sas token.
         */
        const enum SharedAccessQueuePermissions {
            /**
             * Can do nothing to the storage queue.
             */
            None = 0,
            /**
             * Can read from the storage queue.
             */
            Read = 1,
            /**
             * Can add to the storage queue.
             */
            Add = 2,
            /**
             * Can update the storage queue.
             */
            Update = 4,
            /**
             * Can process messages for the storage queue.
             */
            ProcessMessages = 8,
        }
        /**
         * Parameters that must be passed when calling the GetQueueSasUri function.
         */
        interface GetSasUriForQueueOptions {
            /**
             * The shared access expiry time, in seconds.
             */
            durationInSeconds: number;
            /**
             * The permissions for the sas token.
             */
            permissions: SharedAccessQueuePermissions;
            /**
             * The storage account name.
             */
            accountName: string;
            /**
             * The primary key for the storage account.
             */
            accountKey: string;
            /**
             * The name of the storage queue for which a sas token will be generated.
             */
            queueName: string;
        }
        /**
         * Returns a sas token uri for the requested queue.
         *
         * @param args Parameters required by the function.
         * @return A promise that resolves to the sas uri string.
         */
        function getSasUriForQueue(args: GetSasUriForQueueOptions): FxBase.PromiseV<string>;
    }
}
declare module "MsPortalFx/Azure/Storage" {
    import Impl = FxImpl.Azure.Storage;
    export = Impl;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\Subscriptions.d.ts
declare module FxImpl.Azure {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxRpc = FxBase.Rpc.Internal;
    import FxServices = MsPortalFx.Services;
    import FxGalleryItem = FxServices.Gallery.GalleryItem;
    import Subscription = MsPortalFx.Azure.Subscription;
    /**
     * Validate subscription object, used to validate a list of subscriptions against a gallery item
     * through the Marketplace.
     */
    interface ValidateSubscription {
        /**
         * The gallery item.
         */
        galleryItem: FxGalleryItem;
        /**
         * The subscriptions to validate.
         */
        subscriptions: Subscription[];
    }
    /**
     * Inputs to validating whether a set of subscriptions can perform operations on a given gallery item.
     */
    interface SubscriptionValidationInputs {
        /**
         * The gallery item to validate against.
         */
        galleryItem: FxGalleryItem;
    }
    /**
     * Inputs to get subscription info.
     */
    interface SubscriptionInfoInputs {
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The cloud name.
         */
        cloudName: string;
    }
    /**
     * Result of validating whether a set of subscriptions can perform operations on a given gallery item.
     */
    interface SubscriptionValidationResult {
        /**
         * Failure details for subscriptions that did not validate successfully.
         */
        invalidSubscriptions: SubscriptionValidationFailure[];
        /**
         * Error blade to launch if there no valid subscriptions
         */
        noValidSubscriptionsErrorBlade?: FxViewModels.DynamicBladeSelection;
    }
    /**
     * Failure details for subscriptions that did not validate successfully.
     */
    interface SubscriptionValidationFailure {
        /**
         * Id of the subscription that failed to validate
         */
        subscriptionId: string;
        /**
         * Text to display for the validation failure
         */
        displayText: string;
    }
    /**
     * Inputs to for the canRegisterSubWithRPs endpoint.
     */
    interface CanRegisterSubWithRPsInputs {
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The list of resource providers.
         */
        resourceProviders: string[];
        /**
         * The cloud name.
         */
        cloudName: string;
    }
    /**
     * Result for the canRegisterSubWithRPs endpoint.
     */
    interface CanRegisterSubWithRPsResult {
        /**
         * True if the subscription is already registered or can register with all given resource
         * providers. False otherwise.
         */
        success: boolean;
        /**
         * The list of resource providers that the subscription failed to register with. Empty if
         * success is true.
         */
        failedRPs: string[];
        /**
         * The list of resource providers that the subscription is not allowed to register with.
         */
        disallowedRPs: string[];
    }
    /**
     * Internal RPC endpoint to get the detailed info for a subscription.
     */
    const getSubscriptionInfoEndPoint: FxRpc.FuncEndPointDefinition<SubscriptionInfoInputs, Subscription>;
    /**
     * Internal RPC endpoint to get the list of all subscriptions.
     */
    const getAllSubscriptionsEndPoint: FxRpc.FuncEndPointDefinition<string, Subscription[]>;
    /**
     * Internal RPC endpoint to get the list of selected subscriptions for a given cloud.
     */
    const getSelectedSubscriptionsEndPoint: FxRpc.FuncEndPointDefinition<string, Subscription[]>;
    /**
     * Internal RPC endpoint to check if the subscription can register with a list or resource providers
     * (if not already registered)
     */
    const canRegisterSubWithRPsEndPoint: FxRpc.FuncEndPointDefinition<CanRegisterSubWithRPsInputs, CanRegisterSubWithRPsResult>;
    /**
     * Returns the detailed info for a subscription.
     *
     * @param rpcClient The RPC client.
     * @param subscriptionIs Id of the subscription.
     * @param cloudName The cloud name.
     * @return A promise that resolves to the detailed info for the subscription.
     */
    function getSubscriptionInfo(rpcClient: FxRpc.Client, subscriptionId: string, cloudName: string): FxBase.PromiseV<Subscription>;
    /**
     * Returns the list of all subscriptions.
     *
     * @param rpcClient The RPC client.
     * @param cloudName The cloud name.
     * @return A promise that resolves to the list of all subscriptions.
     */
    function getAllSubscriptions(rpcClient: FxRpc.Client, cloudName: string): FxBase.PromiseV<Subscription[]>;
    /**
     * Returns the list of selected subscriptions.
     *
     * @param rpcClient The RPC client.
     * @param cloudName The cloud name. Must be specified if invoked from shell or Hubs extension.
     * @return A promise that resolves to the list of selected subscriptions.
     */
    function getSelectedSubscriptions(rpcClient: FxRpc.Client, cloudName: string): FxBase.PromiseV<Subscription[]>;
    /**
     * Checks if the subscription can register with a list or resource providers (if not already registered).
     * @param subscriptionId The subscription id.
     * @param resourceProviders The resource types.
     * @param cloudName The clound name.
     * @return Resolves with a list of resource providers that the subscription can't register with
     *     (or an empty array otherwise).
     */
    function canRegisterSubWithRPs(rpcClient: FxRpc.Client, subscriptionId: string, resourceProviders: string[], cloudName: string): FxBase.PromiseV<CanRegisterSubWithRPsResult>;
    /**
     * Returns a value indicating whether the subscription is a free trial subscription.
     *
     * @param subscription The subscription to check.
     * @return Boolean true if the subscription is a free trial subscription.
     */
    var isFreeTrialSubscription: (subscription: Subscription) => boolean;
    /**
     * Returns a value indicating whether the subscription is a DreamSpark subscription.
     *
     * @param subscription The subscription to check.
     * @return Boolean true if the subscription is a DreamSpark subscription.
     */
    var isDreamSparkSubscription: (subscription: Subscription) => boolean;
    /**
     * Returns a value indicating whether the subscription is a BizSpark subscription.
     *
     * @param subscription The subscription to check.
     * @return Boolean true if the subscription is a BizSpark subscription.
     */
    var isBizSparkSubscription: (subscription: Subscription) => boolean;
    /**
     * Returns a value indicating whether the subscription is a ZeroCap subscription.
     *
     * @param subscription The subscription to check.
     * @return Boolean true if the subscription is a ZeroCap subscription.
     */
    var isZeroCapSubscription: (subscription: Subscription) => boolean;
}
declare module MsPortalFx.Azure {
    import FxBase = MsPortalFx.Base;
    import FxServices = MsPortalFx.Services;
    import FxGalleryService = FxServices.Gallery;
    import FxGalleryItem = FxGalleryService.GalleryItem;
    import Impl = FxImpl.Azure;
    /**
     * Data contract for a single Azure subscription.
     */
    interface Subscription {
        /**
         * Unique display name, that includes disabled state aswell as subscription id (if display name is not unique).
         */
        uniqueDisplayName: string;
        /**
         * Friendly name of the azure subscription.
         */
        displayName: string;
        /**
         * Id of the azure subscription.
         */
        subscriptionId: string;
        /**
         * Id of the Active Directory tenant containg this subscription.
         */
        tenantId: string;
        /**
         * The subscription state.
         */
        state: string;
        /**
         * The subscription policies. May be null.
         */
        subscriptionPolicies: SubscriptionPolicies;
        /**
         * The users authorization type for the subscriptions. Values are Legacy, RoleBased, Legacy, RoleBased.
         */
        authorizationSource: string;
    }
    /**
     * Data contract for Azure subscription policies.
     */
    interface SubscriptionPolicies {
        /**
         * The subscription location placement id.
         */
        locationPlacementId: string;
        /**
         * The subscription quota id.
         */
        quotaId: string;
        /**
         * The subscription spending limit Values "On", "Off", "CurrentPeriodOff"
         */
        spendingLimit?: string;
    }
    /**
     * Subscriptions namespace.
     */
    module Subscriptions {
        import BaseDropDown = Impl.BaseResourceDropDown;
        import FxViewModels = MsPortalFx.ViewModels;
        import Forms = FxViewModels.Forms;
        /**
         * DropDown namespace.
         */
        module DropDown {
            /**
             * Subscription drop down options.
             */
            interface Options extends BaseDropDown.Options<Subscription> {
                /**
                 * Optional. Flag allowing the selection of disabled subscriptions. Defaults to false.
                 */
                allowSelectingDisabledSubscriptions?: boolean;
                /**
                  * The gallery item to validate against.
                  */
                filterByGalleryItem?: KnockoutObservableBase<FxGalleryItem | ResourceManager.GalleryItemExtract>;
                /**
                 * The list of required permissions the subscription must have. (If you need to check
                 * for resource provider registration permissions, use the resourceProviders property
                 * instead.)
                 */
                requiredPermissions?: KnockoutObservableBase<RequiredPermissions>;
                /**
                 * Optional. An observable that holds the list of resource providers that the
                 * subscription needs to be registered with. Providing the list will NOT register
                 * the subscription with the resource provider, but will only check if the user has
                 * the necessary permissions to register them (only if they aren't registered already).
                 */
                resourceProviders?: KnockoutObservableBase<string[]>;
            }
        }
        function filterObjectByName(item: Subscription, name: string): boolean;
        function itemToHierarchicalFormOption(item: Subscription): Forms.FilterComboBox.HierarchicalFormOption<string>;
        /**
         * The location drop down. Commonly used in create blades.
         */
        class DropDown extends BaseDropDown<Subscription> {
            /**
             * The selected subscription id.
             */
            subscriptionId: KnockoutObservableBase<string>;
            private _options;
            private _marketplaceValidation;
            private _cloudName;
            /**
             * Instantiates a new locations drop down control.
             *
             * @param container The container into which the part containing this control is being placed.
             * @param options The set of options to configure the locations drop down.
             */
            constructor(container: FxViewModels.ContainerContract, options: DropDown.Options);
            private _isSubDisabled(subscription);
            private _isSubAllowedForGalleryItem(subscription);
            private _fetchItems();
        }
    }
    /**
     * Returns the detailed info for a subscription.
     *
     * @param subscriptions Id of the subscription.
     * @return A promise that resolves to the detailed info for the subscription.
     */
    function getSubscriptionInfo(subscriptionId: string): FxBase.PromiseV<Subscription>;
    /**
     * Returns the list of selected subscription.
     *
     * @return A promise that resolves to the list of selected subscriptions.
     */
    function getSelectedSubscriptions(): FxBase.PromiseV<Subscription[]>;
    /**
     * Returns the list of all subscription.
     *
     * @return A promise that resolves to the list of all subscriptions.
     */
    function getAllSubscriptions(): FxBase.PromiseV<Subscription[]>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Azure\Validators.d.ts
declare module MsPortalFx.Azure {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import FxCustomFormValidation = FxViewModels.CustomFormValidation;
    import FxPromiseV = FxBase.PromiseV;
    import FxViewModels = Fx.ViewModels;
    import FxValidation = FxViewModels.Validation;
    import ValidationResult = FxViewModels.ValidationResult;
    module Internal {
        /**
         * The reserved resource name validator. Used to check whether the specified name is permitted
         * for a given resource (validated against ARM).
         */
        class ReservedResourceNameValidator extends FxValidation implements FxCustomFormValidation {
            /**
             * Function that returns whether the data is valid or not.
             */
            validate: (value: any) => FxPromiseV<ValidationResult>;
            /**
             *  The message that is shown to the user if a message is not included as part of the validation result.
             */
            message: string;
            /**
             * Constructs a reserved resource name validator.
             * @param resourceType The resource type. Example "microsoft.resources/subscriptions/resourcegroups".
             * @param message . The message that is shown to the user if the validation fails.
             * @param endpoint . The ARM endpoint.
             */
            constructor(resourceType: string, message: string, endpoint: string);
        }
    }
    /**
     * The options returned by the required permissions callback.
     */
    interface RequiredPermissionsValidatorOptions {
        /**
         * The entity to check the permissions for (must be a resource id, a subscription id, or a
         * resource group id).
         */
        entityId: string;
        /**
         * The actions being to checked.
         */
        actions: string[];
        /**
         * Optional. The message that is shown to the user if the validation fails.
         */
        message?: string;
    }
    /**
     * The required permissions validator callback definition.
     * @param value The value from the control to be validated.
     * @return A promise resolved with the required permission validator options.
     */
    type RequiredPermissionsValidatorCallback = (value: string) => FxPromiseV<RequiredPermissionsValidatorOptions>;
    /**
     * The required permissions validator. Used to check if the current user has permissions to perform
     * a set of actions against an entity.
     */
    class RequiredPermissionsValidator extends FxValidation implements FxCustomFormValidation {
        /**
         * Function that returns whether the data is valid or not.
         */
        validate: (value: any) => FxPromiseV<ValidationResult>;
        /**
         *  The message that is shown to the user if a message is not included as part of the validation result.
         */
        message: string;
        /**
         * Constructs a required permissions validator.
         * @param callback The required permissions validator callback function. The function takes
         *                 the value to be validated as an input, and returns a promise resolved with
         *                 the required permission validator options as an output.
         */
        constructor(callback: RequiredPermissionsValidatorCallback);
    }
    /**
     * The reserved resource name validator. Used to check whether the specified name is permitted
     * for a given resource (validated against ARM).
     */
    class ReservedResourceNameValidator extends Internal.ReservedResourceNameValidator implements FxCustomFormValidation {
        /**
         * Constructs a reserved resource name validator.
         * @param resourceType The resource type. Example "microsoft.resources/subscriptions/resourcegroups".
         * @param message Optional. The message that is shown to the user if the validation fails.
         */
        constructor(resourceType: string, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\BackCompat.d.ts
declare module MsPortalFx {
    module Base {
        module Amd {
            /**
             * Deprecated. Please use MsPortalFx.require instead.
             *
             * BACKCOMPAT 2016/08/28
             */
            const loadAsync: Obsolete;
        }
        module Utilities {
            /**
             * Deprecated. Please use MsPortalFx.arrayEquals instead.
             */
            const arrayEquals: typeof MsPortalFx.arrayEquals;
            /**
             * Deprecated. Please use MsPortalFx.deepEquals instead.
             */
            const deepEquals: typeof MsPortalFx.deepEquals;
            /**
             * Deprecated. Please use MsPortalFx.getUniqueIdGenerator instead.
             */
            const getUniqueIdGenerator: typeof MsPortalFx.getUniqueIdGenerator;
            /**
             * Deprecated. Please use MsPortalFx.getIdGenerator instead.
             */
            const getIdGenerator: typeof MsPortalFx.getIdGenerator;
            /**
             * Deprecated. Please use MsPortalFx.getUniqueId instead.
             */
            const getUniqueId: () => string;
            /**
             * Deprecated. Please use MsPortalFx.getUriAuthority instead.
             */
            const getUriAuthority: typeof MsPortalFx.getUriAuthority;
            /**
             * Deprecated. Please use MsPortalFx.isObject instead.
             */
            const isObject: typeof MsPortalFx.isObject;
            /**
             * Deprecated. Please use MsPortalFx.isIFrame instead.
             */
            function isIFrame(): boolean;
            /**
             * Deprecated. Please use MsPortalFx.isNullOrUndefined instead.
             */
            const isNullOrUndefined: typeof MsPortalFx.isNullOrUndefined;
            /**
             * Deprecated. Please use MsPortalFx.isNullOrWhiteSpace instead.
             */
            const isNullOrWhiteSpace: typeof MsPortalFx.isNullOrWhiteSpace;
            /**
             * Deprecated. Please use MsPortalFx.isSubdomain instead.
             */
            const isSubdomain: typeof MsPortalFx.isSubdomain;
            /**
             * Deprecated. Please use MsPortalFx.isUriAbsolute instead.
             */
            const isUriAbsolute: typeof MsPortalFx.isUriAbsolute;
            /**
             * Deprecated. Please use MsPortalFx.map instead.
             */
            const map: typeof MsPortalFx.map;
            /**
             * Deprecated. Please use MsPortalFx.newGuid instead.
             */
            const newGuid: () => string;
            /**
             * Deprecated. Please use MsPortalFx.noop instead.
             */
            const noop: () => void;
            /**
             * Deprecated. Please use MsPortalFx.split instead.
             */
            const split: typeof MsPortalFx.split;
            /**
             * Deprecated. Please use MsPortalFx.xor instead.
             */
            const xor: typeof MsPortalFx.xor;
        }
    }
    module Polyfills {
        /**
         * Deprecated. Please use MsPortalFx.regexEscape instead.
         */
        const regexEscape: typeof MsPortalFx.regexEscape;
    }
    module Util {
        /**
         * Deprecated. Please use MsPortalFx.isNull instead.
         */
        const isNull: typeof MsPortalFx.isNull;
        /**
         * Deprecated. Please use MsPortalFx.isUndefined instead.
         */
        const isUndefined: typeof MsPortalFx.isUndefined;
        /**
         * Deprecated. Please use MsPortalFx.isNullOrUndefined instead.
         */
        const isNullOrUndefined: typeof MsPortalFx.isNullOrUndefined;
        /**
         * Deprecated. Please use MsPortalFx.newGuid instead.
         */
        const newGuid: () => string;
        /**
         * Deprecated. Please use MsPortalFx.random instead.
         */
        const random: typeof MsPortalFx.random;
        /**
         * Deprecated. Please use MsPortalFx.regexEscape instead.
         */
        const regexEscape: typeof MsPortalFx.regexEscape;
        /**
         * Deprecated. Please use MsPortalFx.shallowCopyFromObject instead.
         */
        const shallowCopyFromObject: typeof MsPortalFx.shallowCopyFromObject;
        /**
         * Deprecated. Please use MsPortalFx.round instead.
         */
        function toNiceFixed(value: number, fractionDigits?: number): string;
        /**
         * Deprecated. Please use MsPortalFx.truncate instead.
         */
        const truncate: typeof MsPortalFx.truncate;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Callbacks.d.ts
declare module MsPortalFx.Base {
    /**
     * The function that will be invoked when a callback is fired.
     */
    interface Callback<T> {
        (arg: T): void;
    }
    /**
     * Defines a collection of functions that can be invoked in order when an event occurs.
     */
    class Callbacks<T> {
        private _entries;
        private _names;
        /**
         * Constructs a callback list.
         */
        constructor();
        /**
         * Adds a callback to the collection.
         *
         * @param entry The callback to be added.
         * @param name Optional name of the callback (for use in removal).
         * @return The current instance.
         */
        add(entry: Callback<T>, name?: string): Callbacks<T>;
        /**
         * Removes a callback from the collection.
         *
         * @param entry The callback to be removed.
         * @return The current instance.
         */
        remove(entry: Callback<T>): Callbacks<T>;
        remove(entry: string): Callbacks<T>;
        /**
         * Clears all callbacks from the collection.
         *
         * @return The current instance.
         */
        clear(): Callbacks<T>;
        /**
         * Fires the callbacks in order with the given parameter.
         *
         * @return The current instance.
         */
        fire(arg: T): Callbacks<T>;
        private _init();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Constants.d.ts
declare module MsPortalFx.Base.Constants {
    /**
     * Shell/framework name.
     */
    const Shell: string;
    /**
     * The name for the default cloud.
     */
    const DefaultCloudName: string;
    /**
     * The cloud name for hubs extension.
     */
    const HubsCloudName: string;
    /**
     * Empty cloud name for normalizing.
     */
    const EmptyCloudName: string;
    /**
     * Extension names for specialized extensions.
     */
    module ExtensionNames {
        /**
         * The name of the well-known hubs extension.
         */
        const Hubs: string;
        /**
         * The name of the billing extension.
         */
        const Billing: string;
        /**
         * The name of the Azure expert extension.
         */
        const AzureExpert: string;
        /**
         * The name of the Azure insights extension.
         */
        const AzureInsights: string;
        /**
         * The name of the Azure monitoring extension.
         */
        const AzureMonitoring: string;
        /**
         * The name of the Azure Active Directory extension.
         */
        const ActiveDirectory: string;
        /**
         * The name of the Marketplace extension.
         */
        const Marketplace: string;
        /**
         * The name of the Resources extension.
         */
        const Resources: string;
        /**
         * The name of the Support extension.
         */
        const Support: string;
        /**
         * The name of the Websites extension.
         */
        const Websites: string;
    }
    /**
     * Asset type names for global asset types.
     */
    module AssetNames {
        /**
         * The resource groups asset type name.
         */
        const ResourceGroups: string;
        /**
         * The browse "all" asset type name.
         */
        const BrowseAllBlade: string;
        /**
         * The browse "all resources" asset type name.
         */
        const BrowseAllResources: string;
        /**
         * The browse "recent resources" asset type name.
         */
        const BrowseRecentResources: string;
        /**
         * The browse "all" asset type name with a default type.
         */
        const BrowseAllBladeWithType: string;
        /**
         * The browse services asset type name.
         */
        const BrowseServiceBlade: string;
        /**
         * The browse resource groups asset type name.
         */
        const BrowseResourceGroupBlade: string;
        /**
         * The browse resources asset type name.
         */
        const BrowseResourceBlade: string;
        /**
         * The browse instance link asset type name.
         */
        const BrowseInstanceLinkBlade: string;
        /**
         * The gallery asset type name.
         */
        const Gallery: string;
        /**
         * The store provided gallery asset type name.
         */
        const StoreGallery: string;
        /**
         * The deployments asset type name.
         */
        const Deployments: string;
        /**
         * The arm explorer asset type name.
         */
        const ArmExplorer: string;
        /**
         * The whats new asset type name.
         */
        const WhatsNew: string;
        /**
         * The browse dynamic resource asset type name.
         */
        const BrowseDynamicResource: string;
        /**
         * The browse dynamic asset asset type name.
         */
        const BrowseDynamicAsset: string;
        /**
         * The subscriptions asset type name.
         */
        const SubscriptionDetail: string;
        /**
         * The asset type name for a non-asset resource (resource fallback).
         */
        const NonAssetResource: string;
    }
    /**
     * Resource type names for global resource types.
     */
    module ResourceTypes {
        /**
         * The subscriptions resource type name.
         */
        const Subscriptions: string;
        /**
         * The resource groups resource type name.
         */
        const ResourceGroups: string;
        /**
         * The placeholder for all resources supported in the portal.
         */
        const AllResources: string;
        /**
         * The placeholder for recent resources supported in the portal.
         */
        const RecentResources: string;
    }
    /**
     * Part names for global parts.
     */
    module PartNames {
        /**
         * Part names for hubs extension parts.
         */
        module Hubs {
            /**
             * The browse service pinned part which launches browse V1 for a particular service (asset type).
             */
            const BrowseServicePinnedPart: string;
            /**
             * The browse resource pinned part which launches browse V2 for a particular resource type.
             */
            const BrowseResourcePinnedPart: string;
            /**
             * The browse resource group pinned part which launches browse V2 for resource groups.
             */
            const BrowseResourceGroupPinnedPart: string;
        }
    }
    /**
     * Blade names for global parts.
     */
    module BladeNames {
        /**
         * Blades names for Billing.
         */
        module Billing {
            /**
             * The create subscriptions blade.
             */
            const SubscriptionsBlade: string;
        }
        /**
         * Blades names for hubs.
         */
        module Hubs {
            /**
             * The create hub blade.
             */
            const CreateHubBlade: string;
            /**
             * The browse link blade.
             */
            const BrowseLinkBlade: string;
            /**
             * The browse resource blade.
             */
            const BrowseResourceBlade: string;
            /**
             * The browse all resources blade.
             */
            const BrowseAllResourcesBlade: string;
            /**
             * The browse resource group blade.
             */
            const BrowseResourceGroupBlade: string;
            /**
             * The browse service blade.
             */
            const BrowseServiceBlade: string;
            /**
             * The unauthorized asset blade.
             */
            const UnauthorizedAssetBlade: string;
            /**
             * The not found asset blade.
             */
            const NotFoundAssetBlade: string;
            /**
             * The unavailable asset blade.
             */
            const UnavailableAssetBlade: string;
            /**
             * The resource menu blade.
             */
            const ResourceMenuBlade: string;
            /**
             * The resource properties blade.
             */
            const ResourceProperties: string;
            /**
             * The resource group blade.
             */
            const ResourceGroupMapBlade: string;
        }
        /**
         * Blades names for Marketplace.
         */
        module Marketplace {
            /**
             * The create hub blade.
             */
            const GalleryFeaturedMenuItemBlade: string;
            /**
             * The create results blade.
             */
            const GalleryResultsListBlade: string;
            /**
             * The name of version 2 of the legal terms blade.
             */
            const LegalTermsV2Blade: string;
        }
        /**
         * Blades names for AzureInsights.
         */
        module AzureInsights {
            /**
             * The notification action blade.
             */
            const NotificationActionBlade: string;
        }
    }
    /**
     * View model type constants.
     */
    module ViewModelTypes {
        /**
         * A generic view model.
         */
        const ViewModel: string;
        /**
         * A view model for a part.
         */
        const PartViewModel: string;
    }
    /**
     * Telemetry common constants.
     */
    module Telemetry {
        /**
         * Feature adoption telemetry source.
         */
        const FeatureAdoption: string;
        /**
         * Feature obsolete telemetry source.
         */
        const FeatureObsolete: string;
    }
    module TelemetrySharing {
        /**
         * Register an extension to receive shell telemetry.
         */
        const RegisterExtension: string;
        /**
         * Receives shell telemetry.
         */
        const TraceTelemetry: string;
    }
    /**
     * Gallery Menu item types.
     */
    module GalleryMenuItems {
        /**
         * Home (everything) menu item id.
         */
        const HomeMenuItem: string;
    }
    module BladeParameterNames {
        /**
         * Blade input used to identify the edit scope.
         */
        const EditScopeId: string;
        /**
         * Optional blade input containing additional config from the component which opened the blade.
         */
        const ReferrerInfo: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Debouncer.d.ts
declare module MsPortalFx.Base {
    import FxBase = MsPortalFx.Base;
    /**
     * If you need to implement DebouncerDataMerger, you need to handle both T|T[].
     * default is to use MsPortalFx.merge which call array.prototype.concat to do things correctly.
    */
    interface DebouncerDataMerger<T> {
        (oldData: T | T[], newData: T | T[]): T[];
    }
    interface DebouncerExecutor<T> {
        (data: T[]): FxBase.Promise;
    }
    interface DebouncerOptions {
        /**
         * The time period after which each batch of optional data should be processed.
         */
        optionalDataInterval?: number;
        /**
         * The maximum batch size suported by the execution method. It combines both required data and optional data.
         */
        maxBatchSize?: number;
    }
    interface DebouncerPostOptions {
        uri: string;
        headers?: StringMap<string>;
        isBackgroundTask?: boolean;
        setAuthHeader?: boolean;
        collectTelemetry?: boolean;
    }
    interface IDebouncer<T> {
        execute: (data: T[], optionalData?: boolean) => void;
        flush: () => Q.Promise<void>;
    }
    /**
     * Allows multiple async-operations to be sequenced and batched, while processing only one batch at a time.
     */
    class Debouncer<T> implements IDebouncer<T> {
        /**
         * Returns a function that can be used to merge two sets of data in the debouncer into an array.
         * New data is appended to existing data to return a new array.
         *
         * @return A DebouncerDataMerger function.
         */
        static getMergeIntoArrayDataMerger(): DebouncerDataMerger<any>;
        /**
         * Returns a function that can be used to merge two sets of data in the debouncer into an array.
         * New data is appended to existing data to return a new array.
         *
         * @param uri The URI where the data is to be posted.
         * @param isBackgroundTask Specifies if the deboncer should make background calls.
         * @return A DebouncerExecutor function.
         */
        static getPostArrayExecutor(options: DebouncerPostOptions): DebouncerExecutor<any>;
        /**
         * Updates the data in the queue.
         */
        execute: (data: T[], optionalData?: boolean) => void;
        /**
         * Resolves all tasks in the queue.
         *
         * @return The promise of the last task in the queue.
         */
        flush: () => Q.Promise<void>;
        /**
         * Initializes a new instance of the Debouncer class.
         *
         * @param mergeFunc A function that is invoked to merge two batches of data.
         * This function is invoked when a second batch comes in before the first has been dispatched.
         * It is also invoked when there is an error processing the first batch and a second one is enqueued.
         * This allows the first batch to be piggy-backed with the second.
         * @param executor The function that processes a batch of data.
         * @param interval The time period after which each batch should be processed.
         * @param resetTimerOnUpdate True if it resets timer of calling the update method.
         * @param options Options.
         */
        constructor(mergeFunc: DebouncerDataMerger<T>, executor: DebouncerExecutor<T>, interval?: number, resetTimerOnUpdate?: boolean, options?: DebouncerOptions);
    }
}
declare module FxImpl {
    import FxBase = MsPortalFx.Base;
    /**
     * Returns an instance of the Standard Debouncer.
     *
     * @param uploadUri The uri for uploading data.
     * @param interval The time period after which each batch should be processed.
     * @param collectTelemetry Whether telemetry should be collected from the network call.
     */
    function getStandardDebouncer<T>(uploadUri: string, collectTelemetry: boolean, extensionName: string, interval?: number, maxBatchSize?: number): FxBase.IDebouncer<T>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Diagnostics.d.ts
declare module FxImpl.Diagnostics {
    /**
     * Stringifies the specified message.
     */
    function getLogFriendlyMessage(message: any): string;
    /**
     * We capture errors occuring during the script load and send them to the shell. That way
     * we can correlate script errors to the extension load failures.
     *
     * @param kind The type of message
     * @param node The <script> node to listen to the errors on
     * @param url The url of the script we are downloading
     * @param moduleName? The name of the requirejs module
     */
    function addScriptErrorListener(kind: FxImpl.Boot.MessageKind, node: HTMLScriptElement, url: string, moduleName?: string): void;
    /**
     * Get the HTTP status code and message for a given url.
     *
     * @param url
     * @param callback
     */
    function getStatusCode(url: string, callback: (statusCode: number, message: any, statusText?: string) => any): void;
}
declare module MsPortalFx.Base.Diagnostics {
    /**
     * Trace level.
     */
    enum LogEntryLevel {
        /**
         * Custom events.
         */
        Custom = -2,
        /**
         * Debug level.
         */
        Debug = -1,
        /**
         * Verbose level.
         */
        Verbose = 0,
        /**
         * Warning level.
         */
        Warning = 1,
        /**
         * Error level.
         */
        Error = 2,
    }
    /**
     * Schema of a log entry.
     */
    interface LogEntry {
        /**
         * Timestamp
         */
        timestamp: number;
        /**
         * Level
         */
        level: LogEntryLevel;
        /**
         * Portal, etc
         */
        area: string;
        /**
         * The message to be logged.
         */
        message: string;
        /**
         * The message code.
         */
        code: number;
        /**
         * Any additional data to be logged.
         */
        args?: any[];
    }
    interface LogBufferFullCallback {
        (entries: LogEntry[]): LogEntry[];
    }
    /**
     * For tests only.
     */
    function getMaxBufferSize(): number;
    interface WriteEntryHelperFunc {
        (level: LogEntryLevel, area: string, entryType: string, message: string | Error, code: number, restArgs: any[]): void;
    }
    function setWriter(func?: WriteEntryHelperFunc): WriteEntryHelperFunc;
    function setupErrorDetection(errorCallback: (entry: LogEntry) => void, warningCallback: (entry: LogEntry) => void): void;
    /**
     * Logging facilities.
     */
    class Log {
        private _area;
        private _type;
        /**
         * Set this value to true if you want failed assertions to break in the debugger.
         */
        debugBreak: boolean;
        /**
         * Creates the logger instance.
         *
         * @param logArea The name of the information area.
         */
        constructor(logArea: string);
        /**
         * Logs event.
         *
         * @param level Information level type.
         * @param area Name of information area.
         * @param message Information that is to be logged.
         * @param restArgs Any other parameters that should be captured.
         */
        static writeEntry(level: LogEntryLevel, area: string, message: string | Error, ...restArgs: any[]): void;
        /**
         * Logs event.
         *
         * @param level Information level type.
         * @param area Name of information area.
         * @param message Information that is to be logged.
         * @param code The message code.
         * @param restArgs Any other parameters that should be captured.
         */
        static writeEntry2(level: LogEntryLevel, area: string, message: string | Error, code: number, restArgs?: any[]): void;
        /**
         * Gets the logged entries buffer.
         *
         * @param level The level of entries to return. All entries greater than or equal to this level will be returned.
         * @return An array of log entries.
         */
        static getEntries(level: LogEntryLevel): LogEntry[];
        /**
         * Clears the log buffer.
         */
        static clear(): void;
        /**
         * Flushes the buffer and calls _setBufferFullCallback.
         */
        static flush(): void;
        /**
         * Specify logging level of messages to console and remotely.
         *
         * @param consoleLevel The level which is to be enabled for the console. If not specified, all levels are enabled.
         * @param remoteLevel The level which is to be enabled for remote logging. If not specified, it will be the same as the console level.
         */
        static initialize(consoleLevel?: LogEntryLevel, remoteLevel?: LogEntryLevel): void;
        /**
         * Disables the log.
         */
        static disable(): void;
        /**
         * Log verbose information.
         *
         * @param entry The message to log.
         * @param restArgs[] Extra information to log with the message.
         */
        verbose(entry: string, ...restArgs: any[]): void;
        /**
         * Log warning information.
         *
         * @param entry The message to log.
         * @param code The message code.
         * @param restArgs[] Extra information to log with the message.
         */
        warning(entry: string | Error, code?: number, ...restArgs: any[]): void;
        /**
         * Log error information.
         *
         * @param entry The message to log.
         * @param code The message code.
         * @param restArgs[] Extra information to log with the message.
         */
        error(entry: string | Error, code?: number, ...restArgs: any[]): void;
        /**
         * Log debug information.
         *
         * @param entry The message to log.
         * @param restArgs[] Extra information to log with the message.
         */
        debug(entry: string, ...restArgs: any[]): void;
        /**
         * Log custom information.
         *
         * @param entry The message to log.
         * @param code The message code.
         * @param restArgs[] Extra information to log with the message.
         */
        custom(entry: string, code?: number, ...restArgs: any[]): void;
        /**
         * Asserts in debug mode.
         *
         * @param assertion A boolean value or a function that returns a boolean value.
         * @param entry The message to log if the assertion is falsy.
         * @param code The message code.
         * @param arg Extra information to log with the message.
         */
        assert(assertion: boolean | Func<boolean>, entry: string, code?: number, arg?: any): void;
        static _setBufferFullCallback(callback: LogBufferFullCallback): void;
        /**
         * Log information.
         *
         * @param level Information level type.
         * @param entry The message to log.
         * @param code The message code.
         * @param args[] Extra information to log with the message.
         */
        writeEntry(level: LogEntryLevel, entry: string | Error, code: number, args: any[]): void;
    }
    module Internal {
        function pushLogEntry(entry: LogEntry): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Diagnostics.ErrorReporter.d.ts
declare module FxImpl {
    module Boot {
        const enum MessageKind {
            BootGet = 0,
            BootReturn = 1,
            BootError = 2,
            Initialize = 3,
            UnhandledError = 4,
            ScriptError = 5,
        }
    }
}
declare module MsPortalFx.Base.Diagnostics {
    import FxErrors = MsPortalFx.Errors;
    import FxError = FxErrors.Error;
    /**
     * Creates an instance of the logger.
     *
     * @param localRequire The require variable injected in an AMD module. This is defined by TypeScript.
     * If not using AMD, use the Log class constructor to create a log instance directly.
     * @return The Log instance to use for logging.
     */
    function createLog(localRequire: LocalRequire): Log;
    /**
     * Helper function to create Error object to ignore unhandled promise rejection will only log as warning instead of error in the current Frame
     * Note that if this exception throw across the RPC, the other side will still log as Error. Thus will reflect to ErrorTracker.
     * @param message Error object message
     * @param stack Optional stack, if not provided, current stack will be used.
     *
     * @returns Error object
     */
    function createIgnoreUnhandledRejectionError(message: string, stack?: string): FxError;
    interface ExceptionMessage {
        reason: string;
        callStack: string;
    }
    /**
     * Helper function to create RPC exception, such that it's call stack will contain special RPC prefix for unhandled promise to always log as error.
     * @param exceptionMessage Exception message
     *
     * @returns Error object
     */
    function createRpcException(exceptionMessage: ExceptionMessage): Error;
    /**
     * Sets the promise error capture period.
     * @param value The period in milliseconds.
     *
     * @returns The previous period.
     */
    function setPromiseErrorCapturePeriod(value?: number): number;
    /**
     * Exported for testing only.
     */
    function clearPromiseErrorCaptureTimeout(): void;
    module ErrorReporter {
        var lastError: Error;
        /**
         * Initializes the error handler
         * @param postLogCallback Function to run after error is logged.
         * @param resetCounter Boolean to reset the special message counter..
         */
        function initialize(postLogCallback?: () => void, resetCounter?: boolean): void;
        /**
         * Logs the error
         */
        function handleError(evt: ErrorEvent): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Diagnostics.Telemetry.d.ts
declare type TelemetryEventBase = TelemetryEvent;
declare module MsPortalFx.Base.Diagnostics.Telemetry {
    import FxBase = MsPortalFx.Base;
    /**
     * Trace processor interface for pluggable telemetry service.
     */
    interface TelemetryEventProcessor {
        /**
         * Sends browser environment data to the data store.
         */
        traceBrowserInfo(): void;
        /**
         * Sends a telemetry data event to the data store.
         */
        trace(evt: TelemetryEvent): void;
        /**
         * Flushes all current telemetry events.
         */
        flush(): FxBase.Promise;
    }
    /**
     * A telemetry event to be sent to the server.
     */
    type TelemetryEvent = TelemetryEventBase;
    /**
     * List of constants to be used for Telemetry data points.
     */
    module ActionModifier {
        const Start: string;
        const Complete: string;
        const Reset: string;
        const Cancel: string;
        const Mark: string;
    }
    /**
     * Initializes the telemetry system with the built-in event processor.
     *
     * @param extensionName The name of the current extension.
     * @param traceBrowserInformation Whether the browser information should be logged to telemetry right away.
     * @return The previous processor or processors, if any existed.
     */
    function initialize(extensionName: string, traceBrowserInformation?: boolean): TelemetryEventProcessor[];
    /**
     * Registers an extension to receive shell telemetry.  Extensions can either specify a custom TelemetryEventProcessor
     * or use the current telemetry configuration.
     *
     * @param processor The optional processor to use when receiving telemetry.
     */
    function registerForShellTelemetry(processor?: TelemetryEventProcessor): void;
    module Internal {
        /**
         * Initializes the telemetry system with the built-in event processor.
         *
         * @param extensionName The name of the current extension.
         * @param traceBrowserInformation Whether the browser information should be logged to telemetry right away.
         * @param processors The trace processors to use. The default processors are used if none is specified.
         * @return The previous processor or processors, if any existed.
        */
        function initialize(extensionName: string, traceBrowserInformation: boolean, processors: TelemetryEventProcessor[]): TelemetryEventProcessor[];
    }
    /**
     * Records a telemetry event.
     *
     * @param evt The telemetry event.
     */
    function trace(evt: TelemetryEvent): void;
    /**
     * Starts a timed telemetry data event but does not record it.
     * The end/complete/cancel trace methods will still be logged.
     * This is preferred over startTrace since it has less impact
     * on the network.
     * @param evt The telemetry event.
     */
    function start(evt: TelemetryEvent): string;
    /**
     * Starts a timed telemetry data event.
     *
     * @param evt The telemetry event.
     */
    function startTrace(evt: TelemetryEvent): string;
    /**
     * Cancels a timed telemetry data event.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     * @param data Any additional context information for the event being recorded (optional).
     */
    function cancelTrace(key: string, data?: any): number;
    /**
     * Completes a timed telemetry data event.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     * @param data Any additional context information for the event being recorded (optional).
     */
    function completeTrace(key: string, data?: any): number;
    /**
     * Ends a timed telemetry data event with a provided action modifier.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     * @param actionModifier One of the action modifiers of the event.
     * @param data Any additional context information for the event being recorded (optional).
     */
    function endTrace(key: string, actionModifier: string, data?: any): number;
    /**
     * Resets the stopwatch for a timed telemetry data event.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     */
    function resetTrace(key: string): void;
    /**
     * Flushes all current telemetry events.
     */
    function flush(): FxBase.Promise;
    function addProcessor(processor: TelemetryEventProcessor): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Diagnostics.Telemetry.Context.d.ts
declare module MsPortalFx.Base.Diagnostics.Telemetry.Context {
    /**
     * Base class for providing ambient context information.
     */
    interface ContextValue {
        /**
         * User defined identifier to correlate logical activities through async and component boundaries.
         */
        id: string;
    }
    interface CompositionContext extends ContextValue {
        instanceId: string;
    }
    interface PartContext extends CompositionContext {
        bladeId: string;
        bladeInstanceId: string;
        onBlade: boolean;
        onStartBoard: boolean;
        bladeCustomized: boolean;
        loadDelayed: boolean;
    }
    const getPartContext: Func<PartContext>;
    const getBladeContext: Func<CompositionContext>;
    const getJourneyContext: Func<ContextValue>;
    const getCompositionItemContext: Func<ContextValue>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Diagnostics.Telemetry.Helpers.d.ts
declare module MsPortalFx.Base.Diagnostics.Telemetry {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * Adds a watcher to the activated items of the given selectable data and calls the appropriate callbacks.
     *
     * @param lifetimeManager The lifetime manager for the watcher.
     * @param selectableData The selectable data that we are going to watch.
     * @param selectionActivated The callback called when a selection is activated.
     * @param selectionDeactivated The callback called when a selection is deactivated.
     */
    function addActivatedItemsWatcher<T, U>(lifetimeManager: FxBase.LifetimeManager, selectableData: FxViewModels.SelectableSet<T, U>, selectionActivated: (selection: U) => void, selectionDeactivated?: (selection: U) => void): void;
    /**
     * Adds a telemetry trace watcher to the activated items of the given selectable data and traces with the
     * appropriate source action. This takes a callback to prepare the base properties which are then merged into
     * the result telemetry event to be traced.
     *
     * @param lifetimeManager The lifetime manager for the watcher.
     * @param selectableData The selectable data that we are going to watch.
     * @param source The source for the telemetry trace.
     * @param activatedAction The action for the telemetry trace when a selection is activated.
     * @param deactivatedAction The action for the telemetry trace when a selection is deactivated.
     * @param prepareTelemetryBase Callback used internally to prepare the base properties for the telemetry trace.
     */
    function addActivatedItemsTelemetryWatcher<T, U>(lifetimeManager: FxBase.LifetimeManager, selectableData: FxViewModels.SelectableSet<T, U>, source: string, activatedAction: string, deactivatedAction: string, prepareTelemetryBase: (selection: U) => ActivatedItemsTelemetryBase): void;
    interface ActivatedItemsTelemetryBase {
        /**
         * The extension that is logging the event. Automatically filled in by the framework.
         */
        extension?: string;
        /**
         * The asset type for the telemetry data (optional).
         */
        assetType?: string;
        /**
         * Any additional context information for the event being recorded (optional).
         */
        data?: any;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Diagnostics.Upload.d.ts
declare module MsPortalFx.Base.Diagnostics.Upload {
    /**
     * Initializes the uploading of client traces.
     * The traces are posted periodically to the specified server URI.
     * If a null or empty URI is specified the upload is skipped.
     * and the traces are just discarded.
     *
     * @param uploadUri The URI where the buffered messages will be posted.
     */
    function initialize(uploadUri?: string): void;
    function upload(data: any): void;
    /**
     * Immediately execute outstanding data.
     */
    function flush(): MsPortalFx.Base.Promise;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Disposable.d.ts
declare module MsPortalFx.Base {
    /**
     * An object that is disposable.
     */
    interface Disposable {
        /**
         * A function called on the object when it is disposed.
         */
        dispose(): void;
    }
    type ActionOrDisposable = Action | Disposable;
    interface RegisterForDisposeFunction {
        (disposables: ActionOrDisposable[]): LifetimeManagerBase;
        (disposable: ActionOrDisposable): LifetimeManagerBase;
    }
    /**
     * An object that can limit the lifetime of other objects. When a LifetimeManager object
     * is disposed, it will dispose all other objects that were registered for disposal.
     */
    interface LifetimeManagerBase {
        /**
         * Registers an object to be disposed.  It will throw if the object doesn't have dispose method.
         *
         * @param disposable An object to be disposed once the LifetimeManager object itself is disposed.
         */
        registerForDispose: RegisterForDisposeFunction;
    }
    interface LifetimeManager extends LifetimeManagerBase {
        /**
         * Create a createChildLifetime to localize the LifetimeManager.
         * It will provide the function on tracking who create it and when it dispose, it will remove itself from Container's lifetimeManager
         *
         */
        createChildLifetime(): DisposableLifetimeManager;
    }
    interface DisposableLifetimeManager extends Disposable, LifetimeManager {
        /**
         * A value indicating whether or not the lifetime is disposed.
         */
        isDisposed(): boolean;
    }
}
declare module FxImpl {
    /**
     * An object that tracks and invokes disposal callbacks. This can be used
     * in other classes that wish to implement LifetimeManager.
     */
    class TriggerableLifetimeManager implements MsPortalFx.Base.DisposableLifetimeManager {
        private _disposables;
        private _isDisposed;
        private _isDisposing;
        private _container;
        private _children;
        private _failToDispose;
        private _diagnosticCreateStack;
        static setDevMode(value: boolean): void;
        static setDiagnosticMode(value: boolean): void;
        constructor();
        /**
         * Gets a value indicating whether or not the lifetime is disposed.
         */
        isDisposed(): boolean;
        /**
         * See interface.
         */
        registerForDispose: MsPortalFx.Base.RegisterForDisposeFunction;
        /**
         * See interface.
         */
        createChildLifetime(): MsPortalFx.Base.DisposableLifetimeManager;
        /**
         * Causes the instance to regard itself as disposed, and to trigger any
         * callbacks that were already registered.
         */
        dispose(): void;
        _unregisterChildForDispose(disposable: MsPortalFx.Base.Disposable): void;
        _isRegistered(disposable: MsPortalFx.Base.Disposable): boolean;
        _registerForDispose(disposable: MsPortalFx.Base.Disposable): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.EventTypes.d.ts
declare module MsPortalFx.Base {
    /**
     * The manifest of all the strongly typed event types.
     * Instead of using string when triggering/listening to events,
     * the strongly typed event type should be used.
     */
    const EventTypes: {
        doubleclick: string;
        mousewheel: string;
        fxpinblade: string;
        fxrightclick: string;
        animationstart: string;
        blur: string;
        change: string;
        click: string;
        contextmenu: string;
        dragover: string;
        dragstart: string;
        dragend: string;
        dragenter: string;
        dragleave: string;
        drop: string;
        focus: string;
        hashchange: string;
        input: string;
        keydown: string;
        keypress: string;
        keyup: string;
        mousedown: string;
        mouseenter: string;
        mouseleave: string;
        mousemove: string;
        mouseout: string;
        mouseover: string;
        mouseup: string;
        popstate: string;
        resize: string;
        rightclick: string;
        scroll: string;
        selectstart: string;
        transitionend: string;
        focusin: string;
        focusout: string;
        remove: string;
        fxactionbarclick: string;
        fxactionbarresize: string;
        fxactionbarvalidationtargetupdated: string;
        fxactionbarvalidationtargetmutated: string;
        fxactivatepairmaster: string;
        fxaddparts: string;
        fxautosettings: string;
        fxbladestatusbarclicked: string;
        fxbreadcrumbclick: string;
        fxcollapsedstateupdated: string;
        fxcontextmenu: string;
        fxcontextmenurequest: string;
        fxcontextpaneclosing: string;
        fxcopybuttonclick: string;
        fxcreatepart: string;
        fxcreateabandoned: string;
        fxensurebladevisible: string;
        fxensureviewportvisible: string;
        fxenterorganizemode: string;
        fxerrorpartclicked: string;
        fxexitorganizemode: string;
        fxhomebuttonclick: string;
        fxopeninnewtab: string;
        fxnotificationclickinmenu: string;
        fxopenshortcutslegend: string;
        fxpancomplete: string;
        fxpartcreated: string;
        fxpartgallerypivotinitialized: string;
        fxportalcontrolloadfailed: string;
        fxreadyforfocus: string;
        fxrearrange: string;
        fxrecomposeframepart: string;
        fxredrawblade: string;
        fxregistermenu: string;
        fxresourcesummaryready: string;
        fxrotatetheme: string;
        fxsettingsbuttonclick: string;
        fxnotificationsbuttonclick: string;
        fxshowstartboard: string;
        fxsizechange: string;
        fxsizechanged: string;
        fxsummarycollapsed: string;
        fxtoastclick: string;
        fxwidthchanged: string;
        fxunpin: string;
        touchcancel: string;
        touchend: string;
        touchmove: string;
        touchstart: string;
        lostpointercapture: string;
        pointercancel: string;
        pointerdown: string;
        pointermove: string;
        pointerup: string;
    };
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.ExtensionStatus.d.ts
declare module FxImpl.Extension {
    import Rpc = MsPortalFx.Base.Rpc.Internal;
    const extensionStatusEndPoint: Rpc.ActionEndPointDefinition<ExtensionStatus>;
    /**
     * Types of events an extension can notify the shell about.
     */
    const enum ExtensionStatusCode {
        /**
         * The extension is operating normally.
         */
        Normal = 0,
        /**
         * The extension has detected that it's server version has changed.
         */
        VersionChanged = 1,
        /**
         * The extension has detected that it is no longer authorized for its server.
         */
        AuthorizationExpired = 2,
        /**
         * When ajax calls return a status code 0,
         * Usually happens when unable to connect to the network, firewall issues or browser extensions.
         */
        UnknownNetworkError = 4,
        /**
         * Disconnected from Relex.
         */
        RelexDisconnected = 5,
    }
    interface ExtensionStatus {
        code: ExtensionStatusCode;
        message?: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Factory.d.ts
declare module MsPortalFx.Base {
    /**
     * The interface of generic factory class, without any arguments in the creation method.
     *
     * Example: if it is needed to new up an instance of a certain class during the execution of a method,
     * the recommended approach is to inject the factory instance in the constructor,
     * and use the factory to create the instance of interest, in order to achieve the loose coupling
     * with the concrete implementation of the instance of interest.
     * Ref: http://msdn.microsoft.com/en-us/library/ee817667.aspx
     */
    interface ObjectFactory<TProduct> {
        /**
         * Create a product.
         *
         * @return The instance of the product of the specified type.
         */
        create(): TProduct;
    }
    /**
     * The interface of generic factory class, with arguments in the creation method.
     */
    interface ParameterObjectFactory<TProduct, TParam> {
        /**
         * Create a product.
         *
         * @param param The arguments provided for the creation of the product.
         * @return The instance of the product of the specified type.
         */
        create(param: TParam): TProduct;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Helpers.d.ts
interface JQueryDeferred {
    catch(catchCallback: (reason?: any) => any): JQueryDeferred;
    finally(finallyCallback: () => any): JQueryDeferred;
}
interface JQueryDeferredV<TValue> {
    catch(catchCallback: (reason?: any) => any): JQueryDeferredV<TValue>;
    finally(finallyCallback: () => any): JQueryDeferredV<TValue>;
}
interface JQueryDeferredVR<TValue, TReject> {
    catch(catchCallback: (reason?: any) => any): JQueryDeferredVR<TValue, TReject>;
    finally(finallyCallback: () => any): JQueryDeferredVR<TValue, TReject>;
}
interface JQueryDeferredR<TReject> {
    catch(catchCallback: (reason?: any) => any): JQueryDeferredR<TReject>;
    finally(finallyCallback: () => any): JQueryDeferredR<TReject>;
}
interface JQueryDeferredVRN<TValue, TReject, TNotify> {
    catch(catchCallback: (reason?: any) => any): JQueryDeferredVRN<TValue, TReject, TNotify>;
    finally(finallyCallback: () => any): JQueryDeferredVRN<TValue, TReject, TNotify>;
}
interface JQueryPromise {
    catch(catchCallback: (reason?: any) => any): JQueryPromise;
    finally(finallyCallback: () => any): JQueryPromise;
}
interface JQueryPromiseV<TValue> {
    catch(catchCallback: (reason?: any) => any): JQueryPromiseV<TValue>;
    finally(finallyCallback: () => any): JQueryPromiseV<TValue>;
}
interface JQueryPromiseVV<TValue1, TValue2> {
    catch(catchCallback: (reason?: any) => any): JQueryPromiseVV<TValue1, TValue2>;
    finally(finallyCallback: () => any): JQueryPromiseVV<TValue1, TValue2>;
}
interface JQueryPromiseVVV<TValue1, TValue2, TValue3> {
    catch(catchCallback: (reason?: any) => any): JQueryPromiseVVV<TValue1, TValue2, TValue3>;
    finally(finallyCallback: () => any): JQueryPromiseVVV<TValue1, TValue2, TValue3>;
}
interface JQueryPromiseVR<TValue, TReject> {
    then<UValue, UReject>(doneCallbacks: {
        (arg: TValue): JQueryPromiseVR<UValue, UReject>;
    }, failCallbacks?: {
        (arg: any): UReject;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseVR<UValue, UReject>;
    then<UValue, UReject>(doneCallbacks: {
        (arg: TValue): UValue;
    }, failCallbacks?: {
        (arg: any): UReject;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseVR<UValue, UReject>;
    then<UValue>(doneCallbacks: {
        (arg: TValue): JQueryDeferredVR<UValue, TReject>;
    }, failCallbacks?: {
        (arg: any): void;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseVR<UValue, TReject>;
    then<UValue>(doneCallbacks: {
        (arg: TValue): JQueryPromiseVR<UValue, TReject>;
    }, failCallbacks?: {
        (arg: any): void;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseVR<UValue, TReject>;
    then<UValue>(doneCallbacks: {
        (arg: TValue): UValue;
    }, failCallbacks?: {
        (arg: any): void;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseV<UValue>;
    then<UReject>(doneCallbacks: {
        (arg: TValue): void;
    }, failCallbacks?: {
        (arg: any): UReject;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseR<UReject>;
    then(doneCallbacks: {
        (arg: TValue): void;
    }, failCallbacks?: {
        (arg: any): void;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromise;
    catch(catchCallback: (reason?: any) => any): JQueryPromiseVR<TValue, TReject>;
    finally(finallyCallback: () => any): JQueryPromiseVR<TValue, TReject>;
}
interface JQueryPromiseVRN<TValue, TReject, TProgress> {
    then<UValue, UReject>(doneCallbacks: {
        (arg: TValue): UValue;
    }, failCallbacks: {
        (arg: any): UReject;
    }, progressCallbacks?: {
        (arg: TProgress): void;
    }): JQueryPromiseVR<UValue, UReject>;
    then<UValue>(doneCallbacks: {
        (arg: TValue): JQueryDeferredVRN<UValue, TReject, TProgress>;
    }, failCallbacks?: {
        (arg: any): void;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseVRN<UValue, TReject, TProgress>;
    then<UValue>(doneCallbacks: {
        (arg: TValue): JQueryPromiseVRN<UValue, TReject, TProgress>;
    }, failCallbacks?: {
        (arg: any): void;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseVRN<UValue, TReject, TProgress>;
    then<UValue>(doneCallbacks: {
        (arg: TValue): UValue;
    }, failCallbacks?: {
        (arg: any): void;
    }, progressCallbacks?: {
        (arg: TProgress): void;
    }): JQueryPromiseV<UValue>;
    then<UReject>(doneCallbacks: {
        (arg: TValue): void;
    }, failCallbacks: {
        (arg: any): UReject;
    }, progressCallbacks?: {
        (arg: TProgress): void;
    }): JQueryPromiseR<UReject>;
    then(doneCallbacks: {
        (arg: TValue): void;
    }, failCallbacks?: {
        (arg: any): void;
    }, progressCallbacks?: {
        (arg: TProgress): void;
    }): JQueryPromise;
    catch(catchCallback: (reason?: any) => any): JQueryPromiseVRN<TValue, TReject, TProgress>;
    finally(finallyCallback: () => any): JQueryPromiseVRN<TValue, TReject, TProgress>;
}
interface JQueryPromiseR<TReject> {
    then<UValue, UReject>(doneCallbacks: {
        (): UValue;
    }, failCallbacks: {
        (arg: any): UReject;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseVR<UValue, UReject>;
    then(doneCallbacks: {
        (): JQueryDeferredR<TReject>;
    }, failCallbacks?: {
        (arg: any): void;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseR<TReject>;
    then(doneCallbacks: {
        (): JQueryPromiseR<TReject>;
    }, failCallbacks?: {
        (arg: any): void;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseR<TReject>;
    then<UReject>(doneCallbacks: {
        (): void;
    }, failCallbacks?: {
        (arg: any): UReject;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromiseR<UReject>;
    then(doneCallbacks: {
        (): void;
    }, failCallbacks: {
        (arg: any): void;
    }, progressCallbacks?: {
        (): void;
    }): JQueryPromise;
    catch(catchCallback: (reason?: any) => any): JQueryPromiseR<TReject>;
    finally(finallyCallback: () => any): JQueryPromiseR<TReject>;
}
interface JQueryPromiseAny {
    always(...alwaysCallbacks: {
        (...args: any[]): void;
    }[]): JQueryPromiseAny;
    done(...doneCallbacks: {
        (...args: any[]): void;
    }[]): JQueryPromiseAny;
    fail(...failCallbacks: {
        (...args: any[]): void;
    }[]): JQueryPromiseAny;
    progress(...progressCallbacks: {
        (...args: any[]): void;
    }[]): JQueryPromiseAny;
    state(): string;
    promise(target?: any): JQueryPromiseAny;
    then(doneCallbacks: {
        (...args: any[]): any;
    }, failCallbacks: {
        (...args: any[]): any;
    }, progressCallbacks?: {
        (...args: any[]): any;
    }): JQueryPromiseAny;
}
interface JQueryDeferredAny {
    always(...alwaysCallbacks: {
        (...args: any[]): void;
    }[]): JQueryDeferredAny;
    done(...doneCallbacks: {
        (...args: any[]): void;
    }[]): JQueryDeferredAny;
    fail(...failCallbacks: {
        (...args: any[]): void;
    }[]): JQueryDeferredAny;
    progress(...progressCallbacks: {
        (): void;
    }[]): JQueryDeferredAny;
    notify(...args: any[]): JQueryDeferredAny;
    notifyWith(context: any, args: any[]): JQueryDeferredAny;
    promise(target?: any): JQueryPromiseAny;
    reject(...args: any[]): JQueryDeferredAny;
    rejectWith(context: any, args: any[]): JQueryDeferredAny;
    resolve(...args: any[]): JQueryDeferredAny;
    resolveWith(context: any, args: any[]): JQueryDeferredAny;
    state(): string;
    then(doneCallbacks: {
        (...args: any[]): any;
    }, failCallbacks: {
        (...args: any[]): any;
    }, progressCallbacks?: {
        (...args: any[]): any;
    }): JQueryDeferredAny;
}
interface JQueryPromiseN<TNotify> {
    catch(catchCallback: (reason?: any) => any): JQueryPromiseN<TNotify>;
    finally(finallyCallback: () => any): JQueryPromiseN<TNotify>;
}
interface JQueryPromiseNNNN<TNotify1, TNotify2, TNotify3, TNotify4> {
    catch(catchCallback: (reason?: any) => any): JQueryPromiseNNNN<TNotify1, TNotify2, TNotify3, TNotify4>;
    finally(finallyCallback: () => any): JQueryPromiseNNNN<TNotify1, TNotify2, TNotify3, TNotify4>;
}
interface JQueryXHR<T> {
    catch(catchCallback: (reason?: any) => any): JQueryXHR<T>;
    finally(finallyCallback: () => any): JQueryXHR<T>;
}
declare module MsPortalFx.Base.Net {
    /**
     * DEPRECATED. Please use MsPortalFx.Base.Promise.
     */
    interface JQueryPromiseXhr<T> extends MsPortalFx.Base.Net2.JQueryPromiseXhr<T> {
    }
}
declare module MsPortalFx.Base.Net2 {
    /**
     * Internal.
     */
    interface JQueryPromiseXhr<T> {
        catch(catchCallback: (reason?: any) => any): JQueryPromiseXhr<T>;
        finally(finallyCallback: () => any): JQueryPromiseXhr<T>;
    }
}
declare module MsPortalFx.Helpers {
    interface XMLHttpRequestLike {
        getResponseHeader(header: string): string;
        getAllResponseHeaders(): string;
        readyState: number;
        status: number;
        statusText: string;
        responseText?: string;
    }
    interface JQueryXHRLike<T> extends XMLHttpRequestLike {
        always(alwaysCallback: () => void): void;
        state(): string;
        then(doneCallbacks: (data: T, textStatus: string, jqXHR: JQueryXHRLike<T>) => void, failCallbacks?: (jqXHR: JQueryXHRLike<T>, textStatus: string, errorThrown: any) => void, progressCallbacks?: () => void): void;
    }
    var ajax: <T>(settings: JQueryAjaxSettings<T>) => JQueryXHRLike<T>;
    const selector: JQueryStatic;
    const Callbacks: {
        (flags?: string): JQueryCallback;
        <T>(flags?: string): JQueryCallback1<T>;
        <T1, T2>(flags?: string): JQueryCallback2<T1, T2>;
        <T1, T2, T3>(flags?: string): JQueryCallback3<T1, T2, T3>;
        <T1, T2, T3, T4>(flags?: string): JQueryCallback4<T1, T2, T3, T4>;
    };
    const data: {
        (element: Document, key?: string, value?: any): any;
        (element: Element, key: string, value: any): any;
        (element: Element, key: string): any;
        (element: Element): any;
    };
    const removeData: {
        (element: Document, name?: string): JQuery;
        (element: Element, name?: string): JQuery;
    };
    const Deferred: {
        (fn?: (d: JQueryDeferred) => void): JQueryDeferred;
        <TDeferred extends _JQueryDeferred>(fn?: (d: TDeferred) => void): TDeferred;
        new (fn?: (d: JQueryDeferred) => void): JQueryDeferred;
        new <TDeferred extends _JQueryDeferred>(fn?: (d: TDeferred) => void): TDeferred;
    };
    /**
     * Returns a promise that is resolved wiht an optional value.
     *
     * @param value Optional value to resolve with.
     * @return A resolved promise.
     */
    function resolve<TValue>(value: TValue): JQueryPromiseV<TValue>;
    function resolve(): JQueryPromise;
    /**
     * Returns a promise that is rejected with an optional reason.
     *
     * @param reason Optional reason to reject with.
     * @return A rejected promise.
     */
    function reject<TReject>(reason: TReject): JQueryPromiseR<TReject>;
    function reject(): JQueryPromise;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Image.d.ts
declare module MsPortalFx.Base {
    /**
     * Data type used for rendering images's.
     */
    interface Image {
        /**
         * Stores the type of image (custom SVG/image or a built in SVG).
         */
        type: number;
        /**
         * Stores the SVG element, or URI to image file.
         */
        data?: string;
        /**
         * Stores the palette of the element.
         */
        palette?: number;
        /**
         * Stores the options of the element.
         */
        options?: ImageOptions;
    }
    interface ImageOptions {
        /**
         * Stores the palette of the element.
         */
        palette?: number;
        /**
         * Title attribute of the svg.
         */
        title?: string;
        /**
         * Description of the svg.
         */
        description?: string;
        /**
         * Badge
         */
        badge?: MsPortalFx.Base.ImageBadge;
        /**
         * Used to flag icon as a logo, will preserve non-standard colors.
         */
        isLogo?: boolean;
        /**
         * Adds a single custom class, must start with msportalfx or the extension prefix for CSS: "ext-".
         */
        customClass?: string;
    }
    /**
     * Data type used for rendering a images's badge.
     */
    interface ImageBadge {
        /**
         * Badge icon.
         */
        image: MsPortalFx.Base.Image;
        /**
         * Override the default width, must be in a percentage ie (width: 10).
         */
        width?: number;
    }
    enum ImagePalette {
        None = 0,
        White = 1,
        Black = 2,
        Blue = 3,
        Green = 4,
        Gray = 5,
        Inherit = 99,
        Disabled = 100,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Images.d.ts
declare module MsPortalFx.Base.Images {
    import FxBase = MsPortalFx.Base;
    import ImageOptions = FxBase.ImageOptions;
    type ImageFunc = (options?: ImageOptions) => Image;
    function CustomImageWithBadge(customImage: FxBase.Image, badge: FxBase.ImageBadge): Image;
    function CustomImageWithOptions(customImage: FxBase.Image, options: ImageOptions): Image;
    /**
     * Generates a properly formatted image datatype from a image's URI.
     * For use with the 'image' custom data-binding & custom png/jpeg/gifs/etc.
     *
     * @param URI to image resource.
     * @return properly formatted image datatype for consumtion by the 'image' data-binding.
     */
    function ImageUri(uri: string): Image;
    const Add: ImageFunc;
    const AddBoxed: ImageFunc;
    const AddTeamMember: ImageFunc;
    const AddTile: ImageFunc;
    const Attachment: ImageFunc;
    const AvatarDefault: ImageFunc;
    const AvatarUnknown: ImageFunc;
    const AzurePortal: ImageFunc;
    const AzureQuickstart: ImageFunc;
    const Backlog: ImageFunc;
    const Blank: ImageFunc;
    const Book: ImageFunc;
    const Canceled: ImageFunc;
    const Check: ImageFunc;
    const Clock: ImageFunc;
    const Clone: ImageFunc;
    const Code: ImageFunc;
    const Collapse: ImageFunc;
    const Commit: ImageFunc;
    const Commits: ImageFunc;
    const Connect: ImageFunc;
    const Console: ImageFunc;
    const Customize: ImageFunc;
    const Delete: ImageFunc;
    const Disable: ImageFunc;
    const Disabled: ImageFunc;
    const Discard: ImageFunc;
    const Disconnect: ImageFunc;
    const Download: ImageFunc;
    const Edit: ImageFunc;
    const Ellipsis: ImageFunc;
    const Error: ImageFunc;
    const Expand: ImageFunc;
    const Favorite: ImageFunc;
    const Feedback: ImageFunc;
    const File: ImageFunc;
    const Filter: ImageFunc;
    const ForPlacementOnly: ImageFunc;
    const Gear: ImageFunc;
    const GetMoreLicense: ImageFunc;
    const GetStarted: ImageFunc;
    const Go: ImageFunc;
    const Guide: ImageFunc;
    const Hamburger: ImageFunc;
    const HeartPulse: ImageFunc;
    const History: ImageFunc;
    const Hyperlink: ImageFunc;
    const Inactive: ImageFunc;
    const LaunchCurrent: ImageFunc;
    const Link: ImageFunc;
    const Lock: ImageFunc;
    const Log: ImageFunc;
    const Monitoring: ImageFunc;
    const Paused: ImageFunc;
    const Pending: ImageFunc;
    const Person: ImageFunc;
    const PersonWithFriend: ImageFunc;
    const Pin: ImageFunc;
    const Plus: ImageFunc;
    const Postpone: ImageFunc;
    const PowerUp: ImageFunc;
    const Properties: ImageFunc;
    const Publish: ImageFunc;
    const Question: ImageFunc;
    const Queued: ImageFunc;
    const Redo: ImageFunc;
    const Refresh: ImageFunc;
    const Release: ImageFunc;
    const Request: ImageFunc;
    const Retain: ImageFunc;
    const Save: ImageFunc;
    const Signout: ImageFunc;
    const SmileyHappy: ImageFunc;
    const SmileyNeutral: ImageFunc;
    const SmileySad: ImageFunc;
    const Start: ImageFunc;
    const Stop: ImageFunc;
    const Subtract: ImageFunc;
    const Support: ImageFunc;
    const Swap: ImageFunc;
    const Tasks: ImageFunc;
    const Tools: ImageFunc;
    const TrendDown: ImageFunc;
    const TrendUp: ImageFunc;
    const Triangle: ImageFunc;
    const Unlock: ImageFunc;
    const Unpin: ImageFunc;
    const Upload: ImageFunc;
    const Variables: ImageFunc;
    const Warning: ImageFunc;
    const Wrench: ImageFunc;
    const Info: ImageFunc;
    const AddAlternate: ImageFunc;
    const ArrowDown: ImageFunc;
    const ArrowLeft: ImageFunc;
    const ArrowRight: ImageFunc;
    const ArrowUp: ImageFunc;
    const CaretDown: ImageFunc;
    const CaretUp: ImageFunc;
    const Columns: ImageFunc;
    const Diagnostics: ImageFunc;
    const FolderAlternate: ImageFunc;
    const GearAlternate: ImageFunc;
    const Globe: ImageFunc;
    const InstallVisualStudio: ImageFunc;
    const Key: ImageFunc;
    const Mail: ImageFunc;
    const Message: ImageFunc;
    const Query: ImageFunc;
    const SaveAll: ImageFunc;
    const Search: ImageFunc;
    const Star: ImageFunc;
    const Tag: ImageFunc;
    const Tags: ImageFunc;
    const Tour: ImageFunc;
    const Undo: ImageFunc;
    const WebHostingPlan: ImageFunc;
    const GitLogo: (options?: ImageOptions) => FxBase.Image;
    const GitLogoBox: (options?: ImageOptions) => FxBase.Image;
    const VisualStudio: (options?: ImageOptions) => FxBase.Image;
    const VisualStudioLogoBox: (options?: ImageOptions) => FxBase.Image;
    /**
     * Logos icons.
     */
    module Logos {
        const Bitbucket: ImageFunc;
        const BitbucketBox: ImageFunc;
        const Channel9: ImageFunc;
        const CodePlex: ImageFunc;
        const CodePlexBox: ImageFunc;
        const Dropbox: ImageFunc;
        const DropboxBox: ImageFunc;
        const ExternalRepositoryBox: ImageFunc;
        const Git: ImageFunc;
        const GitBox: ImageFunc;
        const GitHub: ImageFunc;
        const GitHubBox: ImageFunc;
        const Redis: ImageFunc;
        const StackOverflow: ImageFunc;
        const VisualStudio: ImageFunc;
        const VisualStudioBox: ImageFunc;
        const Microsoft: ImageFunc;
        const MicrosoftSquares: ImageFunc;
    }
    /**
     * Loading.
     */
    module Loading {
        const EllipsisSquare: (options?: ImageOptions) => FxBase.Image;
        function Spinner(): Image;
        function Loader(): Image;
    }
    /**
     * Emoticon icons.
     */
    module Emoticon {
        const Happy: (options?: ImageOptions) => FxBase.Image;
    }
    /**
     * Multicolor images.
     */
    module Polychromatic {
        const ActiveDirectory: ImageFunc;
        const ApiManagement: ImageFunc;
        const AppInsights: ImageFunc;
        const Automation: ImageFunc;
        const AvailabilitySet: ImageFunc;
        const Backlog: ImageFunc;
        const Backup: ImageFunc;
        const BillingHub: ImageFunc;
        const BizTalk: ImageFunc;
        const BlobBlock: ImageFunc;
        const BlobPage: ImageFunc;
        const Branch: ImageFunc;
        const Browser: ImageFunc;
        const Bug: ImageFunc;
        const Builds: ImageFunc;
        const Cache: ImageFunc;
        const Cdn: ImageFunc;
        const Certificate: ImageFunc;
        const Chart: ImageFunc;
        const ClearDBDatabase: ImageFunc;
        const Clock: ImageFunc;
        const CloudService: ImageFunc;
        const Code: ImageFunc;
        const Commit: ImageFunc;
        const Controls: ImageFunc;
        const ControlsHorizontal: ImageFunc;
        const Counter: ImageFunc;
        const Cubes: ImageFunc;
        const CustomDomain: ImageFunc;
        const Database: ImageFunc;
        const Discs: ImageFunc;
        const ErrorIcon: ImageFunc;
        const EventHub: ImageFunc;
        const Extensions: ImageFunc;
        const DevConsole: ImageFunc;
        const Download: ImageFunc;
        const File: ImageFunc;
        const Files: ImageFunc;
        const FolderBlank: ImageFunc;
        const FolderCube: ImageFunc;
        const FolderWebsite: ImageFunc;
        const Ftp: ImageFunc;
        const Gear: ImageFunc;
        const Globe: ImageFunc;
        const GlobeError: ImageFunc;
        const GlobeSuccess: ImageFunc;
        const GlobeWarning: ImageFunc;
        const Grid: ImageFunc;
        const Guide: ImageFunc;
        const Heart: ImageFunc;
        const Image: ImageFunc;
        const Info: ImageFunc;
        const InputOutput: ImageFunc;
        const IpAddress: ImageFunc;
        const JourneyHub: ImageFunc;
        const Key: ImageFunc;
        const LaunchPortal: ImageFunc;
        const LoadBalancer: ImageFunc;
        const LoadTest: ImageFunc;
        const Location: ImageFunc;
        const Log: ImageFunc;
        const LogDiagnostics: ImageFunc;
        const LogStreaming: ImageFunc;
        const ManagementPortal: ImageFunc;
        const Media: ImageFunc;
        const MediaFile: ImageFunc;
        const Mobile: ImageFunc;
        const MobileEngagement: ImageFunc;
        const Module: ImageFunc;
        const Monitoring: ImageFunc;
        const NetworkInterfaceCard: ImageFunc;
        const Notification: ImageFunc;
        const OperationalInsights: ImageFunc;
        const Owl: ImageFunc;
        const Power: ImageFunc;
        const Powershell: ImageFunc;
        const PowerUp: ImageFunc;
        const ProcessExplorer: ImageFunc;
        const Preview: ImageFunc;
        const ProductionReadyDb: ImageFunc;
        const RemoteApp: ImageFunc;
        const ResourceDefault: ImageFunc;
        const ResourceGroup: ImageFunc;
        const ResourceGroupList: ImageFunc;
        const ResourceLinked: ImageFunc;
        const ResourceList: ImageFunc;
        const ResourceRole: ImageFunc;
        const Scale: ImageFunc;
        const Scheduler: ImageFunc;
        const Search: ImageFunc;
        const SearchGrid: ImageFunc;
        const ServerFarm: ImageFunc;
        const ServiceBus: ImageFunc;
        const SiteRecovery: ImageFunc;
        const SqlDatabase: ImageFunc;
        const SqlDataBaseServer: ImageFunc;
        const SSD: ImageFunc;
        const SslCustomDomains: ImageFunc;
        const Storage: ImageFunc;
        const StorageAzureFiles: ImageFunc;
        const StorageContainer: ImageFunc;
        const StorageQueue: ImageFunc;
        const Store: ImageFunc;
        const StorSimple: ImageFunc;
        const StreamAnalytics: ImageFunc;
        const Support: ImageFunc;
        const Table: ImageFunc;
        const TeamProject: ImageFunc;
        const TfsVcRepository: ImageFunc;
        const Toolbox: ImageFunc;
        const TrafficManager: ImageFunc;
        const Versions: ImageFunc;
        const VirtualMachine: ImageFunc;
        const VirtualNetwork: ImageFunc;
        const WebEnvironment: ImageFunc;
        const WebHosting: ImageFunc;
        const WebJobs: ImageFunc;
        const Website: ImageFunc;
        const WebsitePower: ImageFunc;
        const WebsiteStaging: ImageFunc;
        const WebSlots: ImageFunc;
        const WebTest: ImageFunc;
        const Workflow: ImageFunc;
        const PolyTrafficManagerDisabled: (options?: ImageOptions) => FxBase.Image;
        const PolyTrafficManagerEnabled: (options?: ImageOptions) => FxBase.Image;
        const TrafficManagerDisabled: (options?: ImageOptions) => FxBase.Image;
        const TrafficManagerEnabled: (options?: ImageOptions) => FxBase.Image;
        const QuickStart: (options?: ImageOptions) => FxBase.Image;
    }
    module Shell {
        const Add: ImageFunc;
        const ArrowWideUp: ImageFunc;
        const ArrowWideDown: ImageFunc;
        const Chevron: ImageFunc;
        const Close: ImageFunc;
        const Collapse: ImageFunc;
        const CornerCheck: ImageFunc;
        const Customize: ImageFunc;
        const DefaultBlade: ImageFunc;
        const Dots: ImageFunc;
        const Filter: ImageFunc;
        const Fullscreen: ImageFunc;
        const Gear: ImageFunc;
        const HeaderDots: ImageFunc;
        const Maximize: ImageFunc;
        const Mini: ImageFunc;
        const Minimize: ImageFunc;
        const Restore: ImageFunc;
        const Share: ImageFunc;
        const Trash: ImageFunc;
        const TrashOutline: ImageFunc;
        const TripleArrow: ImageFunc;
        module JumpBar {
            const Home: (options?: ImageOptions) => FxBase.Image;
            const Alerts: (options?: ImageOptions) => FxBase.Image;
            const Journey: (options?: ImageOptions) => FxBase.Image;
            const Browse: (options?: ImageOptions) => FxBase.Image;
            const Billing: (options?: ImageOptions) => FxBase.Image;
            const Create: (options?: ImageOptions) => FxBase.Image;
        }
    }
    /**
     * Status badges.
     */
    module StatusBadge {
        const Canceled: (options?: ImageOptions) => FxBase.Image;
        const Critical: (options?: ImageOptions) => FxBase.Image;
        const Disabled: (options?: ImageOptions) => FxBase.Image;
        const Error: (options?: ImageOptions) => FxBase.Image;
        const Failed: (options?: ImageOptions) => FxBase.Image;
        const Info: (options?: ImageOptions) => FxBase.Image;
        const None: (options?: ImageOptions) => FxBase.Image;
        const Pending: (options?: ImageOptions) => FxBase.Image;
        const Stopped: (options?: ImageOptions) => FxBase.Image;
        const Success: (options?: ImageOptions) => FxBase.Image;
        const Unknown: (options?: ImageOptions) => FxBase.Image;
        const Warning: (options?: ImageOptions) => FxBase.Image;
        module Outline {
            const Critical: (options?: ImageOptions) => FxBase.Image;
            const Error: (options?: ImageOptions) => FxBase.Image;
            const Failed: (options?: ImageOptions) => FxBase.Image;
            const Info: (options?: ImageOptions) => FxBase.Image;
            const Stopped: (options?: ImageOptions) => FxBase.Image;
            const Success: (options?: ImageOptions) => FxBase.Image;
            const Unknown: (options?: ImageOptions) => FxBase.Image;
            const Update: (options?: ImageOptions) => FxBase.Image;
            const Warning: (options?: ImageOptions) => FxBase.Image;
        }
        module Solid {
            const Error: (options?: ImageOptions) => FxBase.Image;
            const Info: (options?: ImageOptions) => FxBase.Image;
            const Warning: (options?: ImageOptions) => FxBase.Image;
        }
    }
    /**
     * Part gallery
     */
    module PartGallery {
        const CollectionPartWithRollup: () => FxBase.Image;
        const CollectionSummary: () => FxBase.Image;
        const DonutChart: () => FxBase.Image;
        const DonutChartPartial: () => FxBase.Image;
        const Extensions: () => FxBase.Image;
        const GridWithMoreData: () => FxBase.Image;
        const Map: () => FxBase.Image;
        const MultiLineChartMultiTrendLine: () => FxBase.Image;
        const MultiScatterChart: () => FxBase.Image;
        const MultiStackedBarChart: () => FxBase.Image;
        const MutliLineChart: () => FxBase.Image;
        const PricingTier: () => FxBase.Image;
        const QuotaGauge: () => FxBase.Image;
        const ResourceMap: () => FxBase.Image;
        const SingleAreaChart: () => FxBase.Image;
        const SingleAreaChartSingleThreshold: () => FxBase.Image;
        const SingleAreaChartSingleTrendline: () => FxBase.Image;
        const SingleBarChartLarge: () => FxBase.Image;
        const SingleBarChartSmall: () => FxBase.Image;
        const SingleLineChart: () => FxBase.Image;
        const SingleScatterChart: () => FxBase.Image;
        const SingleScatterSingleThreshold: () => FxBase.Image;
        const SingleValueGauge: () => FxBase.Image;
        const SplitBarChart: () => FxBase.Image;
        const StackedAreaChart: () => FxBase.Image;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.KnockoutExtensions.d.ts
interface KnockoutReadOnlyObservableArray<T> extends KnockoutReadOnlyObservable<T[]> {
    /**
     * Subscribes to observable array edit notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param callback The callback that will be invoked when edits are made to the array.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    subscribeArrayEdits(lifetime: MsPortalFx.Base.LifetimeManager, callback: (edits: KnockoutArrayEdit<T>[]) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array add and delete notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param addedCallback The callback that will be invoked when an item is added to the array.
     * @param deletedCallback The callback that will be invoked when an item is deleted from the array.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    subscribeArrayChanges(lifetime: MsPortalFx.Base.LifetimeManager, addedCallback: (addedItem: T) => void, deletedCallback: (deletedItem: T) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array bulk changes.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param callback The callback that will be invoked once with all the adds and deletes corresponding to an array change.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    subscribeArrayBulkChanges(lifetime: MsPortalFx.Base.LifetimeManager, callback: (addedItems: T[], deletedItems: T[]) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array add notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param addedCallback The callback that will be invoked when an item is added to the array.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    subscribeArrayAdds(lifetime: MsPortalFx.Base.LifetimeManager, addedCallback: (addedItem: T) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array delete notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param deletedCallback The callback that will be invoked when an item is deleted from the array.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    subscribeArrayDeletes(lifetime: MsPortalFx.Base.LifetimeManager, deletedCallback: (deletedItem: T) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Maps the array into the destination array.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param mapping The callback that will be invoked to map a source item to a destination item.
     * @param destination The observable array that the source array is mapped into.  If not provided a new array is created.
     * @return The destination array is returned.
     */
    mapInto<U>(lifetime: MsPortalFx.Base.LifetimeManager, mapping: (itemLifetime: MsPortalFx.Base.LifetimeManager, item: T) => U, destination?: KnockoutObservableArray<U>): KnockoutObservableArray<U>;
}
interface KnockoutObservableArrayDisposable<T> extends KnockoutObservableArray<T>, KnockoutDisposable {
}
interface KnockoutArraySplice<T> {
    /**
     * The start index for the splice.
     */
    start: number;
    /**
     * The count of items to be deleted by the splice.
     */
    deleteCount: number;
    /**
     * The items to be added by the splice.
     */
    items: T[];
    /**
     * Indicates that the deleted and added items of this splice are simply moving within the array.
     * When not set the deleted items are being removed and the added items are newly added.
     * This flag is undefined unless the splices are created with the identifyMoves option.
     */
    move?: boolean;
}
interface KnockoutUtils {
    /**
     * Obsoleted on 9/18/2015.
     * Use adjustArrayEdits or createArraySplices.
     * adjustArrayEdits does the same fixup as fixupArrayEdits but returns new edits instead of modifying the supplied edits.
     * createArraySplices generates splice arguments for multi-element splices which can be used efficiently with applyArraySplices.
     */
    fixupArrayEdits(): void;
    /**
     * Creates edits with adjusted indexes for sequenced application.
     *
     * @param edits The original unadjusted edits.
     * @return A new set of edits with adjusted indexes for sequential insertion/deletion.
     */
    adjustArrayEdits<T>(edits: KnockoutArrayEdit<T>[]): KnockoutArrayEdit<T>[];
    /**
     * Creates edits with adjusted indexes for sequenced application.
     *
     * @param edits The original unadjusted edits.
     * @param target The array to target.
     * @param mapFuns Maps edit items to target array items when creating new entries for the target array.
     * @return A new set of edits with adjusted indexes for sequential insertion/deletion.
     */
    adjustArrayEdits<T, U>(edits: KnockoutArrayEdit<T>[], target: U[], mapFunc: (value: T) => U): KnockoutArrayEdit<U>[];
    applyArrayEdits<T>(target: T[], edits: KnockoutArrayEdit<T>[]): void;
    applyArrayEdits<T>(target: KnockoutObservableArray<T>, edits: KnockoutArrayEdit<T>[]): void;
    applyArrayEdits<T, U>(target: U[], edits: KnockoutArrayEdit<T>[], mapFunc: (value: T) => U): void;
    applyArrayEdits<T, U>(target: KnockoutObservableArray<U>, edits: KnockoutArrayEdit<T>[], mapFunc: (value: T) => U): void;
    /**
     * Merges the knockout array edits into splices that can be applied to a target array.
     * This does the work of adjusting the indexes similar to adjustArrayEdits.
     *
     * @param edits The knockout array edits.
     * @param identifyMoves Creates seperate splices for items that are moved within the array.
     * @return Returns an array of splices that can be applied to a target array.
     */
    createArraySplices<T>(edits: KnockoutArrayEdit<T>[], identifyMoves?: boolean): KnockoutArraySplice<T>[];
    /**
     * Merges the knockout array edits into splices that can be applied to the target array.
     * This does the work of adjusting the indexes similar to adjustArrayEdits.
     *
     * @param edits The knockout array edits.
     * @param target The array to target.
     * @param mapFuns Maps edit items to target array items when creating new entries for the target array.
     * @return Returns an array of splices that can be directly applied to the target array.
     */
    createArraySplices<T, U>(edits: KnockoutArrayEdit<T>[], identifyMoves: boolean, target: U[], mapFunc: (value: T) => U): KnockoutArraySplice<U>[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @return Returns an array of the removed items.
     */
    applyArraySplices<T>(target: T[], splices: KnockoutArraySplice<T>[]): T[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @return Returns an array of the removed items.
     */
    applyArraySplices<T>(target: KnockoutObservableArray<T>, splices: KnockoutArraySplice<T>[]): T[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @param mapFunc Maps splice items to target items.
     * @return Returns an array of the removed items.
     */
    applyArraySplices<T, U>(target: U[], splices: KnockoutArraySplice<T>[], mapFunc: (value: T) => U): U[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @param mapFunc Maps splice items to target items.
     * @return Returns an array of the removed items.
     */
    applyArraySplices<T, U>(target: KnockoutObservableArray<U>, splices: KnockoutArraySplice<T>[], mapFunc: (value: T) => U): U[];
    /**
     * Establishes a two-way binding between the specified observables.
     *
     * @param The first observable whose initial value take precedence while setting up the binding.
     * @param The second observable.
     * @return The subscriptions that are used for setting up the binding. Dispose these subscriptions to disconnect
     * the binding.
     */
    twoWayBinding<T>(source: KnockoutObservableBase<T>, destination: KnockoutObservableBase<T>): KnockoutSubscription<T>[];
    /**
     * Cleans knockout properties and disposables from descendents of the specified node
     * without cleaning the node itself.
     *
     * @param node The root node to start from.
     */
    cleanDescendantNodes(node: Element): void;
    cleanDescendantNodes(node: JQuery): void;
    /**
     * Wraps a value (not an array) in an observable or return the value if it already was observable
     *
     * @param value The value to wrap.
     */
    wrap<T>(value: T | KnockoutObservableBase<T>): KnockoutObservableBase<T>;
    /**
     * Wraps an array in an observable or return the value if it already was an observable array
     *
     * @param value The array to wrap.
     */
    wrapArray<T>(array: T[] | KnockoutObservableArray<T>): KnockoutObservableArray<T>;
    /**
     * Unwraps a property value specified by a path.
     * Stops evaluation if any intermediate property in the path returns a falsey value.
     *
     * @param value The value to read the property from.
     * @param path The property path using . delimeters.
     * @param unwrapLast Indicates if the last value of the path should be unwrapped.  The default is true.
     * @return The value of the property or undefined if not evaluated.
     */
    unwrapObservablePath(value: any, path: string, unwrapLast?: boolean): any;
    /**
     * Peeks a property value specified by a path.
     * Stops evaluation if any intermediate property in the path returns a falsey value.
     *
     * @param value The value to read the property from.
     * @param path The property path using . delimeters.
     * @param peekLast Indicates if the last value of the path should be peeked.  The default is true.
     * @return The value of the property or undefined if not evaluated.
     */
    peekObservablePath(value: any, path: string, peekLast?: boolean): any;
}
declare module MsPortalFx.Base.KnockoutExtensions {
    import FxBase = MsPortalFx.Base;
    module Internal {
        /**
         * Internal high performance ApplyArrayEdits.  Apply minimum amount splice call given arrayEdits.
         *
         * @param underlyingArray The array to target.
         * @param edits ArrayEdits return by ko.utils.compareArray.
         * @param Options addition argument.
         *          spliceFunc: allow custom splice-like function to be pass in.  Othersize, Array.splice is the default to perform on the array.
         *          inplaceFixup: if the arrayEdits index haven't fix up yet.  pass true to adjust arrayEditIndex while look for the minimum splice to called.  It will not change arrayEdit.index
         * @return spliceCalls : return the number of splice performed on target Array.
         */
        var quickApplyArrayEdits: <T>(underlyingArray: T[], arrayEdits: KnockoutArrayEdit<T>[], options?: {
            spliceFunc?: {
                (start: number): any[];
                (start: number, deleteCount: number, ...items: any[]): any[];
            };
            inplaceFixup?: boolean;
        }) => number;
    }
    module Internal {
        /**
         * Merges the knockout array edits into splices that can be applied to the target array.
         * This does the work of adjusting the indexes similar to fixupArrayEdits.
         *
         * @param edits The knockout array edits.
         * @param identifyMoves Creates seperate splices for items that are moved within the array.
         * @param target The array to target.
         * @param mapFunc Maps edit items to target array items when creating new entries for the target array.
         * @return Returns an array of splices that can be directly applied to the target array.
         */
        function createArraySplicesInternal<T, U>(edits: KnockoutArrayEdit<T>[], identifyMoves: boolean, target?: U[], mapFunc?: (value: T[]) => U[]): KnockoutArraySplice<U>[];
    }
    /**
     * Subscribes to observable array edit notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param source The array to subscribe to.
     * @param callback The callback that will be invoked when edits are made to the array.
     * @param context The optional this context for the callback.
     * @return The knockout subscription.
     */
    function subscribeArrayEdits<T>(lifetime: FxBase.LifetimeManager, source: KnockoutReadOnlyObservableArray<T> | KnockoutProjectableComputedArray<T>, callback: (edits: KnockoutArrayEdit<T>[]) => void, context?: any): KnockoutSubscription<T>;
    var markIgnoreHighDependenciesCount: (koComputed: KnockoutSubscribable<any>) => void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.KnockoutExtensions.Lifetime.d.ts
declare module ko {
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    function explicitComputed<T, U>(lifetime: MsPortalFx.Base.LifetimeManager, dependency: KnockoutObservableBase<U>, func: (dependencyValue?: U) => T, context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    function explicitComputed<T>(lifetime: MsPortalFx.Base.LifetimeManager, dependencies: KnockoutObservableBase<any>[], func: ((...dependenciesValues: any[]) => T) | (() => T), context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    function explicitComputed<T>(lifetime: MsPortalFx.Base.LifetimeManager, dependency: KnockoutObservableBase<any>, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    function explicitComputed<T>(lifetime: MsPortalFx.Base.LifetimeManager, dependencies: KnockoutObservableBase<any>[], options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Sets up a reactor, i.e., something that watches for changes to a set of observables
     * or computeds, and takes some action each time any of them changes.
     *
     * @param lifetime The lifetime of the reactor, meaning that it will automatically be disposed when the lifetime object is disposed.
                       Typically this should be the 'container' supplied to a UI component such as a part.
     * @param evaluator A callback function that reads one or more observables/computeds and takes some action.
                        This will be invoked once initially, and then any time any dependency changes.
                        The set of dependencies may change arbitrarily on each evaluation.
     */
    function reactor<T>(lifetime: MsPortalFx.Base.LifetimeManager, dependency: KnockoutObservableBase<T>, evaluator: (dependencyValue?: T) => void): void;
    function reactor(lifetime: MsPortalFx.Base.LifetimeManager, dependencies: KnockoutObservableBase<any>[], evaluator: ((...dependenciesValues: any[]) => void) | (() => void)): void;
    function reactor(lifetime: MsPortalFx.Base.LifetimeManager, evaluator: () => void): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.KnockoutExtensions.Lifetime.ambient.d.ts
interface KnockoutSubscribable<T> {
    /**
     * Subscribes to receive notification when the observable/computed changes value.
     *
     * @param lifetime The lifetime of the subscription, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param callback The callback to be invoked when the observable/computed changes value.
     * @param target If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param topic If specified, determines which kind of change notification to respond to.
     *              You can omit this if you simply want notifications when the observable/computed changes value.
     *              See Knockout documentation for more details.
     * @return A subscription instance. Note that you don't need to dispose this manually if the 'lifetime' object will itself get disposed.
     */
    subscribe(lifetime: MsPortalFx.Base.LifetimeManager, callback: (newValue: T) => void, target?: any, topic?: string): KnockoutSubscription<T>;
    /**
     * Subscribes to receive notification when the observable/computed changes value and run subscription once.
     *
     * @param lifetime The lifetime of the subscription, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param callback The callback to be invoked when the observable/computed changes value.
     * @param target If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param topic If specified, determines which kind of change notification to respond to.
     *              You can omit this if you simply want notifications when the observable/computed changes value.
     *              See Knockout documentation for more details.
     * @return A subscription instance. Note that you don't need to dispose this manually if the 'lifetime' object will itself get disposed.
     */
    subscribeAndRun(lifetime: MsPortalFx.Base.LifetimeManager, callback: (newValue: T) => void, target?: any, topic?: string): KnockoutSubscription<T>;
}
interface KnockoutComputedStatic {
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T, U>(lifetime: MsPortalFx.Base.LifetimeManager, dependency: KnockoutObservableBase<U>, func: (dependencyValue?: U) => T, context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, dependencies: KnockoutObservableBase<any>[], func: ((...dependenciesValues: any[]) => T) | (() => T), context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, dependency: KnockoutObservableBase<any>, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, dependencies: KnockoutObservableBase<any>[], options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates a Knockout computed instance.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, func: () => T, context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates a Knockout computed instance.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param options See Knockout documentation.
     * @return A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
}
interface KnockoutReadOnlyObservableArray<T> extends KnockoutReadOnlyObservable<T[]> {
    /**
     * Produces a new array by mapping each item in the source array.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the mapped array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param mapping A function that transforms input array entries to output array entries.
     * @return A computed array value representing the mapping result.
     */
    map<TResult>(lifetime: MsPortalFx.Base.LifetimeManager, mapping: (itemLifetime: MsPortalFx.Base.LifetimeManager, value: T) => TResult): KnockoutProjectableComputedArray<TResult>;
    /**
     * Produces a new array by filtering the source array according to a predicate.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the filtered array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param predicate A predicate that determines which entries should be included in the output array.
     * @return A computed array value representing the mapping result.
     */
    filter(lifetime: MsPortalFx.Base.LifetimeManager, predicate: (value: T) => boolean): KnockoutProjectableComputedArray<T>;
}
interface KnockoutProjectableComputedArray<T> extends KnockoutComputed<T[]> {
    /**
     * Produces a new array by mapping each item in the source array.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the mapped array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param mapping A function that transforms input array entries to output array entries.
     * @return A computed array value representing the mapping result.
     */
    map<TResult>(lifetime: MsPortalFx.Base.LifetimeManager, mapping: (itemLifetime: MsPortalFx.Base.LifetimeManager, value: T) => TResult): KnockoutProjectableComputedArray<TResult>;
    /**
     * Produces a new array by filtering the source array according to a predicate.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the filtered array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param predicate A predicate that determines which entries should be included in the output array.
     * @return A computed array value representing the mapping result.
     */
    filter(lifetime: MsPortalFx.Base.LifetimeManager, predicate: (value: T) => boolean): KnockoutProjectableComputedArray<T>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.LruMap.d.ts
declare module MsPortalFx.Base {
    /**
     * A map that automatically deletes entries that have not been accessed.
     */
    class LruMap<T> {
        private _map;
        private _capacity;
        private _lastAccessed;
        /**
         * Gets a value indicating the count of this collection.
         *
         * @return A number indicating the count.
         */
        count: number;
        /**
         * Creates a new last recently used map.
         *
         * @param capacity If declared, will auto-trim after inserts to specified capacity.
         */
        constructor(capacity?: number);
        /**
         * If the item with the given key is not present, adds an item with the given key and value to the collection. Otherwise, updates the value of this item.
         *
         * @param key The key of the item.
         * @param value The value of the item.
         */
        addOrUpdate(key: string, value: T, skipTrim?: boolean): boolean;
        /**
         * Gets a value indicating whether the item with the given key exists.
         *
         * @param settings The collection of settings to write.
         * @return A boolean value.
         */
        contains(key: string): boolean;
        /**
         * Sets the size of this collection to the requested size.
         *
         * @param capacity The requested size.
         */
        trim(capacity?: number): void;
        /**
         * Gets the item with the requested key. If the item does not exist, calls the valueFactory argument to create the item.
         *
         * @param capacity The requested size.
         * @return The value.
         * @throws Throws if the item does not exist and the valueFactory argument is null or undefined.
         */
        getOrAdd(key: string, valueFactory?: (key: string) => T): T;
        /**
         * Gets the requested item or returns null.
         */
        get(key: string): T;
        /**
         * Removes the item with the requested key.
         *
         * @param key The key of the item.
         */
        remove(key: string): void;
        /**
         * Clears the collection.
         */
        clear(): void;
        /**
         * Returns list of items in the cache
         * This is for use in scenarios where the list needs to be displayed in UI.
         * The list is sorted with most recent first in the list.
         */
        getList(): T[];
        /**
         * Merges two lists together.  This is too support updating of a LruMap that is shared between multiple sessions.
         *
         * @param sourceList the source list that is to be merged in
         * @param comparisonFn  function provided by the caller.   1 means  itemA is newer, 0 means itemA and itemB are same, -1 means itemA is older than itemB
         */
        merge(sourceList: LruMap<T>, comparisonFn: (itemA: T, itemB: T) => number): void;
        /**
         * Return an item based on it's key making sure to set it's lastAccessed
         * attribute to properly age it.
         * Can optionally throw if the item is not found.
         */
        private _getItem(key, throwIfNotFound?);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Net.d.ts
declare module MsPortalFx.Base {
    import Fx = MsPortalFx;
    import FxHelpers = Fx.Helpers;
    import FxImplExtension = FxImpl.Extension;
    import FxBase = Fx.Base;
    module Net2 {
        /**
         * The HTTP status codes matches the .NET HttpStatusCode enumeration.
         */
        const enum HttpStatusCode {
            Continue = 100,
            SwitchingProtocols = 101,
            Ok = 200,
            Created = 201,
            Accepted = 202,
            NonAuthoritativeInformation = 203,
            NoContent = 204,
            ResetContent = 205,
            PartialContent = 206,
            Ambiguous = 300,
            MultipleChoices = 300,
            Moved = 301,
            MovedPermanently = 301,
            Found = 302,
            Redirect = 302,
            RedirectMethod = 303,
            SeeOther = 303,
            NotModified = 304,
            UseProxy = 305,
            Unused = 306,
            RedirectKeepVerb = 307,
            TemporaryRedirect = 307,
            BadRequest = 400,
            Unauthorized = 401,
            PaymentRequired = 402,
            Forbidden = 403,
            NotFound = 404,
            MethodNotAllowed = 405,
            NotAcceptable = 406,
            ProxyAuthenticationRequired = 407,
            RequestTimeout = 408,
            Conflict = 409,
            Gone = 410,
            LengthRequired = 411,
            PreconditionFailed = 412,
            RequestEntityTooLarge = 413,
            RequestUriTooLong = 414,
            UnsupportedMediaType = 415,
            RequestedRangeNotSatisfiable = 416,
            ExpectationFailed = 417,
            UpgradeRequired = 426,
            InternalServerError = 500,
            NotImplemented = 501,
            BadGateway = 502,
            ServiceUnavailable = 503,
            GatewayTimeout = 504,
            HttpVersionNotSupported = 505,
        }
        /**
         * Contract for parameters returned by the cachedAjax function
         */
        interface AjaxCachedResult<T> {
            cachedAjax?: boolean;
            data?: T;
            modified?: boolean;
            textStatus?: string;
            cacheTagValue?: string;
            jqXHR?: JQueryXHR<T>;
        }
        /**
         * Authorization options for targeted tokens.
         */
        interface AuthorizationOptions {
            /**
             * The resource name to get the token for.
             */
            resourceName: string;
        }
        /**
         * Internal.
         */
        interface JQueryPromiseXhr<T> {
            always(...alwaysCallbacks: Array<{
                (): void;
            }>): JQueryPromiseXhr<T>;
            done(...doneCallbacks: Array<JQueryPromiseXHRDoneCallback<T>>): JQueryPromiseXhr<T>;
            fail(...failCallbacks: Array<JQueryPromiseXHRFailCallback<T>>): JQueryPromiseXhr<T>;
            progress(...progressCallbacks: Array<{
                (): void;
            }>): JQueryPromiseXhr<T>;
            finally(...alwaysCallbacks: Array<{
                (): void;
            }>): JQueryPromiseXhr<T>;
            state(): string;
            promise(target?: any): JQueryPromiseXhr<T>;
            then(doneCallbacks: JQueryPromiseXHRDoneCallback<T>, failCallbacks?: JQueryPromiseXHRFailCallback<T>, progressCallbacks?: {
                (): void;
            }): JQueryPromise;
            then<UValue>(doneCallbacks: {
                (data: T, textStatus: string, jqXHR: JQueryXHR<T>): UValue;
            }, failCallbacks?: JQueryPromiseXHRFailCallback<T>, progressCallbacks?: {
                (): void;
            }): JQueryPromiseV<UValue>;
            then<UValue, UReject>(doneCallbacks: {
                (data: T, textStatus: string, jqXHR: JQueryXHR<T>): UValue;
            }, failCallbacks?: {
                (data: T, textStatus: string, jqXHR: JQueryXHR<T>): UReject;
            }, progressCallbacks?: {
                (): void;
            }): JQueryPromiseVR<UValue, UReject>;
            then<UReject>(doneCallbacks: JQueryPromiseXHRDoneCallback<T>, failCallbacks?: {
                (data: T, textStatus: string, jqXHR: JQueryXHR<T>): UReject;
            }, progressCallbacks?: {
                (): void;
            }): JQueryPromiseR<UReject>;
        }
        /**
         * The contract of a JQueryPromise that is returned by Base.Net2.ajax.
         */
        interface NetAjaxSettings<T> extends JQueryAjaxSettings<T> {
            /**
             * Determines whether the ajax request is part of a background task.
             * If true the request is executed one at a time so only one background task is in flight at a time.
             */
            isBackgroundTask?: boolean;
            /**
             * Determines whether to check compatibility between the server and browser version headers.
             * If undefined, the check is done automatically for all relative URIs, but skipped for absolute URIs.
             */
            checkVersion?: boolean;
            /**
             * Determines whether to retry the ajax call if one of the following conditions is met:
             *  1. Failure appears to be coming from an intermediary proxy
             *  2. Request times out
             *  3. Response status code is 500
             */
            performRetry?: boolean;
            /**
             * If this option is set to a string (typically "api/invoke") and the input URI is an absolute URI,
             * the URI is parsed and the path and query is set on the x-ms-path-query header that is used when talking to
             * external services (ARM). Using this header instead of the path and query string of the URI helps amortize
             * the overhead of the CORS OPTIONS calls. Typically we can get down to 1 OPTIONS call for all calls to ARM
             * down from the typical of one per request.
             */
            invokeApi?: string;
            /**
             * Determines whether to automatically obtain and append an authorization header.
             * If undefined, the authorization header is appendended automatically for all relative URIs,
             * but skipped for absolute URIs.
             *
             * Set to true to append the default authorization header.
             * Set to { resourceName: 'audienceName'} to append an authorization token targeted at a specific audience.
             */
            setAuthorizationHeader?: boolean | AuthorizationOptions;
            /**
             * Determines whether to append a telemetry header for ARM calls.
             *
             * Set to a non-empty string to append the header. The value should be 60 characters or less and will be trimmed
             * if longer.
             */
            setTelemetryHeader?: string;
            /**
             * If this option is undefined or false and the response returns 403 containing 'x-ms-failure-cause: gateway' header,
             * will result in retrying the request with 'cache-control: none' header. This is done to bypass server side caching
             * by external services (ARM).
             */
            skipRetryOnForbidden?: boolean;
            /**
             * Determines whether to avoid all headers that are included by the framework.
             */
            useRawAjax?: boolean;
            /**
             * Determines whether to return the detailed error (this is set to true) or the simple string error.
             */
            detailedError?: boolean;
            /**
             * The response type of the request
             */
            responseType?: string;
            /**
             * Determines whether telemetry should be collected from the network request. The default is false.
             */
            collectTelemetry?: boolean;
            /**
             * The URI to make the request to.
             */
            uri: string;
        }
        /**
         * The contract for the detailed error values when the detailedError flag is set on the AJAX settings. This
         * replaces the simple string error value with a composite object which includes the simple error value and
         * the response text.
         */
        interface NetAjaxDetailedError {
            /**
             * The error which would have been the simple error value.
             */
            error: string;
            /**
             * The response text in the case of an error.
             */
            responseText: string;
        }
        /**
         * The base contract for extended information provided by responses of ajax calls.
         */
        interface BaseResponse<T> {
            /**
             * The XHR of the response.
             */
            jqXHR: JQueryXHR<T>;
            /**
             * The text status.
             */
            textStatus: string;
        }
        /**
         * The contract for extended information provided by responses of succeeded ajax calls.
         */
        interface Response<T> extends BaseResponse<T> {
            /**
             * The content of the response.
             */
            content: T;
        }
        /**
         * The contract for extended information provided by responses of failed ajax calls.
         */
        interface ErrorResponse<T> extends BaseResponse<T> {
            errorThrown: string;
        }
        /**
         *  Extensions can opt out of the automatic ajax version check if their data APIs are not
         *  compatible for some reason.
         */
        function disableAjaxServerVersionCheck(): void;
        /**
         * Extensions can set a callback which will be called when an Ajax call that results
         * in a server error response. This type is the shape of the callback method.
         * Parameters are per Base.Diagnostics.Log.error(), the default method that is used.
         */
        type AjaxLogFunc = (entry: string | Error, code?: number, ...restArgs: any[]) => void;
        /**
         * Extensions can set a callback which will be called when an Ajax call that results
         * in a server error response. This method allows the callback method to be set.
         * The callback method shoud be of type AjaxLogFunc which matches the same shape as
         * Base.Diagnostics.Log.error().
         *
         * @param callback The function called when an Ajax call results in a server error response.
         */
        function setAjaxLogFunc(callback: AjaxLogFunc): void;
        /**
         * Extensions can set a the function that will be called for executing Ajax call.
         *
         * @param func The function called to invoke an Ajax call.
         */
        function setAjaxFunc(func: typeof FxHelpers.ajax): void;
        module Internal {
            /**
             * Internal interface. Do not use.
             */
            interface NetAjaxSettings<T> extends MsPortalFx.Base.Net2.NetAjaxSettings<T> {
                cloudName?: string;
            }
            interface Environment {
                retryDelay: number;
            }
            var environment: Environment;
            /**
             * Performs an ajax request with the appropriate headers set. (Internal use only.)
             *
             * @param settings The settings that are to be passed to the ajax call.
             * @return A promise for the ajax call.
             */
            function ajaxExtended<T>(settings: NetAjaxSettings<T>): FxBase.PromiseV<Response<T>>;
            /**
             * Internal class. Do not use.
             */
            class AjaxCaller {
                ajaxStatus: KnockoutObservable<FxImplExtension.ExtensionStatus>;
                unknownErrorStatusCode: number;
                skipVersionCheck: boolean;
                private initialized;
                private acceptLanguage;
                private effectiveLocale;
                private currentGetAuthTokenFunc;
                private version;
                private extensionFlagsValue;
                private shouldStall;
                private traceAjaxErrors;
                private unknownErrors;
                private backgroundTaskSingleton;
                private armEndpoint;
                initialize(version: string, getAuthorizationTokenFunc: (options?: FxImplExtension.GetAuthorizationTokenOptions) => FxBase.PromiseV<string>, extensionFlags?: any, effectiveLocale?: string, traceAjaxErrors?: boolean): void;
                postJSON<T>(settings: NetAjaxSettings<T>, data: any): FxBase.PromiseV<T>;
                oldPostJSON<T>(settings: NetAjaxSettings<T>, data: any): JQueryPromiseXhr<T>;
                ajaxExtended<T>(settings: NetAjaxSettings<T>): FxBase.PromiseV<Response<T>>;
                oldAjax<T>(settings: NetAjaxSettings<T>): JQueryPromiseXhr<T>;
                ajax<T>(settings: NetAjaxSettings<T>): FxBase.PromiseV<T>;
                private _executeAjaxCall<T, Promise>(settings, deferred);
                cachedAjax<T>(settings: NetAjaxSettings<T>): FxBase.PromiseV<AjaxCachedResult<T>>;
                oldCachedAjax<T>(settings: NetAjaxSettings<T>): JQueryPromiseXhr<AjaxCachedResult<T>>;
                private _worker<T, Promise>(settings, executionContext, deferred);
                private _stall(reason, message);
            }
            /**
             * Internal function. Do not use.
             */
            function reset(): void;
        }
        /**
         * Performs an ajax request with the appropriate headers set.
         *
         * @param settings The settings that are to be passed to the ajax call.
         * @return A promise for the ajax call.
         */
        function postJSON<T>(settings: NetAjaxSettings<T>, data: any): FxBase.PromiseV<T>;
        /**
         * Performs an ajax request using caching with the appropriate headers set.
         *
         * @param settings The settings that are to be passed to the ajax call.
         * @return A promise for the ajax call.
         */
        function ajax<T>(settings: NetAjaxSettings<T>): FxBase.PromiseV<T>;
        /**
        * Performs an ajax request using caching with the appropriate headers set and returns XML Http Response.
        *
        * @param settings The settings that are to be passed to the ajax call.
        * @return A promise for the ajax call including XML Http Response.
        */
        function ajaxExtended<T>(settings: NetAjaxSettings<T>): FxBase.PromiseV<Response<T>>;
        /**
         * Internal. Do not use.
         */
        function getSingleton(): Net2.Internal.AjaxCaller;
        /**
         * Performs an ajax POST request.
         *
         * @param settings The settings that are to be passed to the ajax call.
         *                 uri is the only required parameter in settings.
         *                 The contentType, data, and type properties of the settings will be overwritten with the right values for posting JSON.
         * @param data The data to be sent to the server. The data will be run through JSON.stringify before posting (even if it is alaready a string).
         * @return A promise for the ajax call.
         */
        function cachedAjax<T>(settings: NetAjaxSettings<T>): FxBase.PromiseV<AjaxCachedResult<T>>;
        /**
         * Invalidate the cache header for cachedAjax.
         *
         * @param headers Set of ajax headers.
         */
        function invalidateCacheHeader(headers: any): void;
        /**
         * Set the cache header value for cachedAjax.
         *
         * @param headers Set of ajax headers.
         * @return mutated result with cache tag header set.
         */
        function setCacheHeader(headers: any, cacheTagValue: string): any;
        /**
         * Initialize the Base.Net module.
         *
         * @param getAuthorizationTokenFunc The callback that returns the authorization token.
         */
        function initialize(getAuthorizationTokenFunc: (options?: FxImplExtension.GetAuthorizationTokenOptions) => FxBase.PromiseV<string>): void;
        /**
         * Gets the logged out promise.
         *
         * @return The status of the Ajax (logged out, or .
         */
        var status: KnockoutComputed<FxImplExtension.ExtensionStatus>;
        /**
         * Disables AJAX version checking.
         *
         */
        function disableVersionCheck(): void;
    }
    /**
     * DEPRECATED
     */
    module Net {
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.HttpStatusCode.
         */
        const HttpStatusCode: any;
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.AjaxCachedResult<T>.
         */
        interface AjaxCachedResult<T> extends MsPortalFx.Base.Net2.AjaxCachedResult<T> {
        }
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.AuthorizationOptions.
         */
        interface AuthorizationOptions extends MsPortalFx.Base.Net2.AuthorizationOptions {
        }
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Promise.
         */
        interface JQueryPromiseXhr<T> extends MsPortalFx.Base.Net2.JQueryPromiseXhr<T> {
        }
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.NetAjaxSettings.
         */
        interface NetAjaxSettings<T> extends MsPortalFx.Base.Net2.NetAjaxSettings<T> {
        }
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.NetAjaxDetailedError.
         */
        interface NetAjaxDetailedError extends MsPortalFx.Base.Net2.NetAjaxDetailedError {
        }
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.invalidateCacheHeader.
         */
        const disableAjaxServerVersionCheck: typeof FxBase.Net2.disableAjaxServerVersionCheck;
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.postJSON.
         */
        function postJSON<T>(settings: NetAjaxSettings<T>, data: any): JQueryPromiseXhr<T>;
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.ajax.
         */
        function ajax<T>(settings: NetAjaxSettings<T>): JQueryPromiseXhr<T>;
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.cachedAjax.
         */
        function cachedAjax<T>(settings: NetAjaxSettings<T>): JQueryPromiseXhr<T>;
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.invalidateCacheHeader.
         */
        const invalidateCacheHeader: typeof FxBase.Net2.invalidateCacheHeader;
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.setCacheHeader.
         */
        const setCacheHeader: typeof FxBase.Net2.setCacheHeader;
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.initialize.
         */
        const initialize: typeof FxBase.Net2.initialize;
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.status.
         */
        var status: KnockoutComputed<FxImplExtension.ExtensionStatus>;
        /**
         * DEPRECATED. Please use MsPortalFx.Base.Net2.disableVersionCheck.
         */
        const disableVersionCheck: typeof FxBase.Net2.disableVersionCheck;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Promises.d.ts
declare module MsPortalFx.Base.Internal {
    /**
    * An object that supports "then". Treated as a promise.
    */
    interface ThenableV<TValue> {
        then(onFulfill: (value: TValue) => void): any;
    }
    /**
    * The base type of a promise.
    */
    interface PromiseBase<TPromise, TProgressFunc> {
        /**
        * Registers a callback to be invoked when the promise is rejected.
        *
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        catch<UValue extends Object>(onReject: (reason?: any) => ThenableV<UValue>): PromiseV<UValue>;
        /**
        * Registers a callback to be invoked when the promise is rejected.
        *
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        catch<UValue extends Object>(onReject: (reason?: any) => UValue): PromiseV<UValue>;
        /**
        * Registers a callback to be invoked when the promise is rejected.
        *
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        catch(onReject: (reason?: any) => void): Promise;
        /**
        * Registers a callback to be invoked when the promise is settled.
        *
        * @return A new promise.
        */
        finally(finallyCallback: () => void): TPromise;
        /**
        * Registers a callback to be invoked when the promise issues progress notification.
        *
        * @param progressCallback A callback to be invoked when the promise issues progress notification.
        * @return A new promise.
        */
        progress(progressCallback: TProgressFunc): TPromise;
    }
    /**
    * The base type of a promise that does not have a value.
    */
    interface PromiseOfNonValueBase<TPromise, TProgressFunc> extends PromiseBase<TPromise, TProgressFunc> {
        /**
        * Registers callbacks to be invoked when the promise is settled.
        *
        * @param onFulfill A callback to be invoked when the promise is fulfilled.
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        then<UValue extends Object>(onFulfill: () => ThenableV<UValue>, onReject?: (reason?: any) => ThenableV<UValue>): PromiseV<UValue>;
        /**
        * Registers callbacks to be invoked when the promise is settled.
        *
        * @param onFulfill A callback to be invoked when the promise is fulfilled.
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        then<UValue extends Object>(onFulfill: () => ThenableV<UValue>, onReject?: (reason?: any) => UValue): PromiseV<UValue>;
        /**
        * Registers callbacks to be invoked when the promise is settled.
        *
        * @param onFulfill A callback to be invoked when the promise is fulfilled.
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        then<UValue extends Object>(onFulfill: () => UValue, onReject?: (reason?: any) => ThenableV<UValue>): PromiseV<UValue>;
        /**
        * Registers callbacks to be invoked when the promise is settled.
        *
        * @param onFulfill A callback to be invoked when the promise is fulfilled.
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        then<UValue extends Object>(onFulfill: () => UValue, onReject?: (reason?: any) => UValue): PromiseV<UValue>;
        /**
        * Registers callbacks to be invoked when the promise is settled.
        *
        * @param onFulfill A callback to be invoked when the promise is fulfilled.
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        then(onFulfill: () => void, onReject?: (reason?: any) => void): Promise;
    }
    /**
    * The base type of a promise that has a value.
    */
    interface PromiseOfValueBase<TPromise, TProgressFunc, TValue> extends PromiseBase<TPromise, TProgressFunc> {
        /**
        * Registers callbacks to be invoked when the promise is settled.
        *
        * @param onFulfill A callback to be invoked when the promise is fulfilled.
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        then<UValue extends Object>(onFulfill: (value: TValue) => ThenableV<UValue>, onReject?: (reason?: any) => ThenableV<UValue>): PromiseV<UValue>;
        /**
        * Registers callbacks to be invoked when the promise is settled.
        *
        * @param onFulfill A callback to be invoked when the promise is fulfilled.
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        then<UValue extends Object>(onFulfill: (value: TValue) => ThenableV<UValue>, onReject?: (reason?: any) => UValue): PromiseV<UValue>;
        /**
        * Registers callbacks to be invoked when the promise is settled.
        *
        * @param onFulfill A callback to be invoked when the promise is fulfilled.
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        then<UValue extends Object>(onFulfill: (value: TValue) => UValue, onReject?: (reason?: any) => ThenableV<UValue>): PromiseV<UValue>;
        /**
        * Registers callbacks to be invoked when the promise is settled.
        *
        * @param onFulfill A callback to be invoked when the promise is fulfilled.
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        then<UValue extends Object>(onFulfill: (value: TValue) => UValue, onReject?: (reason?: any) => UValue): PromiseV<UValue>;
        /**
        * Registers callbacks to be invoked when the promise is settled.
        *
        * @param onFulfill A callback to be invoked when the promise is fulfilled.
        * @param onReject A callback to be invoked when the promise is rejected.
        * @return A new promise.
        */
        then(onFulfill: (value: TValue) => void, onReject?: (reason?: any) => void): Promise;
    }
}
declare module MsPortalFx.Base {
    /**
     * A promise representing an activity that may complete asynchronously. This may be a Q Promise, or
     * any other object that is compliant with the Promises/A+ spec {@link http://promises-aplus.github.io/promises-spec/}.
     */
    interface Promise extends Internal.PromiseOfNonValueBase<Promise, () => void> {
    }
    /**
    * A promise representing an activity that may complete asynchronously. This may be a Q Promise, or
    * any other object that is compliant with the Promises/A+ spec {@link http://promises-aplus.github.io/promises-spec/}.
    */
    interface PromiseV<TValue> extends Internal.PromiseOfValueBase<PromiseV<TValue>, () => void, TValue> {
    }
    /**
    * A promise representing an activity that may complete asynchronously. This may be a Q Promise, or
    * any other object that is compliant with the Promises/A+ spec {@link http://promises-aplus.github.io/promises-spec/}.
    */
    interface PromiseN<TProgress> extends Internal.PromiseOfNonValueBase<PromiseN<TProgress>, (progressInfo: TProgress) => void> {
    }
    /**
    * A promise representing an activity that may complete asynchronously. This may be a Q Promise, or
    * any other object that is compliant with the Promises/A+ spec {@link http://promises-aplus.github.io/promises-spec/}.
    */
    interface PromiseVN<TValue, TProgress> extends Internal.PromiseOfValueBase<PromiseVN<TValue, TProgress>, (progressInfo: TProgress) => void, TValue> {
    }
}
declare module MsPortalFx.Base.Promises {
    import FxErrors = MsPortalFx.Errors;
    import CanceledError = FxErrors.CanceledError;
    /**
     * Promise states constants.
     */
    module PromiseStates {
        /**
         * Fulfilled.
         */
        const fulfilled: string;
        /**
         * Rejected.
         */
        const rejected: string;
    }
    /**
     * Wraps a promise to make to make it cancelable.
     * Does not call catch or finally handlers when canceled.
     * See also makeCancelable which does the same with different semantics.
     *
     * Creates a wrapper class around the underlying promise that handles calls to
     * then, progress, finally, and catch.  The wrapper is returned to look like the same
     * type as the underlying promise.  However, method calls beyond those mentioned
     * previously will crash.
     *
     * The wrapper verifies cancelation status before calling any handler attached.  If
     * the status is canceled it will not call the handler.
     *
     * Cancelation does not effect the promise resolution.  If the promise was succeeding
     * when canceled the chained promises will be resolved successfully without calling
     * the handlers.  If the promise was failing when canceled the chainded promises will
     * be rejected with the failure and the handlers will not be called.
     *
     * Here are the semantics in code form:
     *
     * wrapWithCancelablePromise(promise, token).then((value) => {
     *     // Work that will not be called if the cancelationToken is canceled before it
     * }).then((value) => {
     *     // More work that will not be called if the cancelationToken is canceled before it
     * }).catch((error) => {
     *     // Error handling that will not be called if the cancelationToken is canceled before it
     * }).finally(() => {
     *     // Cleanup that will not be called if the cancelationToken is canceled before it
     * });
     *
     * @param underlyingPromise Promise to add cancelation to.
     * @param cancelationToken Cancellation token.
     * @return Cancelable promise.
     */
    function wrapWithCancelablePromise<T extends Promise>(underlyingPromise: T, cancelationToken: CancelationToken): T;
    /**
     * Wraps a promise to make to make it cancelable.
     * Calls catch and finally handlers when canceled.
     * See also wrapWithCancelablePromise which does the same with different semantics.
     *
     * Creates a deferred promise that wraps the underlying promise results.  The returned
     * promise is a Q promise.  The promise will return similarly cancelable promises
     * for each fulfillment or progress handler that is attached.  Catch and finally handlers
     * will not be cancelable and stop the cancelable promise chain.
     *
     * This method aggresively cancels promises.  When canceled all pending chained promises
     * are immediately rejected with a cancelation error.  Work that is pending will keep running
     * to completion or failure but will not change the promise resolution.
     *
     * Here are the semantics in code form:
     *
     * makeCancelable(promise, token).then((value) => {
     *     // Work that will not be called if the cancelationToken is canceled before it
     * }).then((value) => {
     *     // More work that will not be called if the cancelationToken is canceled before it
     * }).catch((error) => {
     *     // Error handling that will be called if there is a failure or cancelation.
     *     // When canceled the error will be an MsPortalFx.Errors.CanceledError as specified by token.cancel(error)
     * }).finally(() => {
     *     // Cleanup that will always be called
     * });
     * or
     * makeCancelable(() => promise, token).then((value) => {
     *     // Work that will not be called if the cancelationToken is canceled before it
     * }).then((value) => {
     *     // More work that will not be called if the cancelationToken is canceled before it
     * }).catch((error) => {
     *     // Error handling that will be called if there is a failure or cancelation.
     *     // When canceled the error will be an MsPortalFx.Errors.CanceledError as specified by token.cancel(error)
     * }).finally(() => {
     *     // Cleanup that will always be called
     * });
     *
     * If you have cleanup where you need to do one thing if successful and another if failed/canceled you can
     * attach a then(fulfill, reject) with both fulfill and reject handlers.  Specifying the reject handler will
     * terminate the cancelable chain.
     *
     * @param promiseOrTaskToExecuate
           If type is a Promise to add cancelation to.
           If Type is a function < taskToExecute () => Promise> to add cancelation to.  Note: If cancelation token is already canceled, it make sure taskToExecute will not be executed.
     * @param cancelationToken Cancellation token.
     * @return Cancelable promise.
     */
    const makeCancelable: <T>(promiseOrTaskToExecute: PromiseV<T> | (() => PromiseV<T> | T), cancelationToken: MsPortalFx.Base.Promises.CancelationToken) => Q.Promise<T>;
    /**
     * Cancels the promise if the lifetime is disposed or null prior to resolution or rejection.
     *
     * If canceled the promise will be rejected with MsPortalFx.Errors.CancelationError.
     * @param lifetime The lifetime that causes cancelation.  May be null indicating the lifetime was already disposed.
     * @param promiseOrTaskToExecuate
           If type is a Promise to add cancelation to.
           If Type is a function <taskToExecute: () => PromiseV<T>> to add cancelation to.  If cancelation token is already canceled, it make sure taskToExecute will not be executed.
     * @param message The cancelation error message.
     * @return Promise that will be rejected with a CancelationError if disposed before the promise parameter is resolved or rejected.
     */
    function cancelOnDispose<T>(lifetime: MsPortalFx.Base.LifetimeManager, promiseOrTaskToExecute: PromiseV<T> | (() => PromiseV<T> | T), message?: string): Q.Promise<T>;
    /**
     * An object that defines whether or not its associated CancelablePromise instances
     * have been canceled. Once the 'canceled' flag is set, it cannot be unset.
     */
    class CancelationToken {
        /**
         * Gets the cancellation reason.
         */
        cancelation: KnockoutReadOnlyObservable<CanceledError>;
        /**
         * True if the associated CancelablePromise instances have been canceled; false otherwise.
         */
        canceled: boolean;
        /**
         * Ensures the CancelationToken has been set so that associated CancelablePromise instances have been canceled.
         *
         * @param cancelation Optional error for specifying the cancelation when using makeCancelable.
         * @return The first cancelation applied.
         */
        cancel(cancelation?: CanceledError): CanceledError;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.ProxiedObservables.d.ts
declare module MsPortalFx.Base.ProxiedObservables {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    /**
     * Gets an object to used to store data for the given object. Returns undefined if no object can be provided.
     *
     * @param obj The object with which the returned object is associated.
     * @return An object.  Can be null if metadataContainer is null;
     */
    const dataContainer: (obj: any) => StringMap<any>;
    /**
     * Gets an object to used to store disposable data for the given object. Returns undefined if no object can be provided.
     *
     * @param obj The object with which the returned object is associated.
     * @return An object.  Can be null if metadataContainer is null;
     */
    const disposableDataContainer: (obj: any) => StringMap<FxBase.Disposable>;
    /**
     * Returns data from the given object with the given key.
     * Or Set value for the given object with the given key.
     *
     * @param obj The object with which the returned object is associated.
     * @param key The key for the data.
     * @param value The value to write.
     * @return The value.
     */
    const data: (obj: any, key: string, value?: any) => any;
    /**
     * Returns data from the given object with the given key.
     * Or Set value for the given object with the given key.
     *
     * @param obj The object with which the returned object is associated.
     * @param key The key for the data.
     * @param value The value to write.
     * @return The value.
     */
    const disposableData: <T extends Disposable>(obj: any, key: string, value?: T) => T;
    /**
     * Marks an object as non-serializable. An error is raised for non-serializable objects that are proxied across.
     *
     * @param obj The object to be marked non-serializable.
     */
    function markNonSerializable(obj: Object): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.ProxiedObservablesV2.d.ts
declare module FxImpl.Po {
    import Fx = MsPortalFx;
    /**
     * WeakMapShim is a implementation of the WeakMap wrapper.
     * WeakMapShim.create play the trick for it.
     *  In the debug mode, it provide better tracking data.
     *  In non debug mode, it provide the fall back on the browser which doesn't support Weakmap.
     *
     * @param obj The object to be marked non-serializable.
     */
    interface WeakMapLike<TKey, TValue> {
        get(obj: TKey): TValue;
        set(obj: TKey, container: TValue): void;
    }
    const enum TrackingMetadataFlags {
        None = 0,
        AllowRemoteChanges = 1,
    }
    const enum PropertyFreezeLevel {
        None = 0,
        NotDeletable = 1,
        ReadOnly = 2,
    }
    interface SerializationOptions {
        shouldFullFreeze: boolean;
        desiredMetadataFlags: TrackingMetadataFlags;
    }
    interface MetadataContainerBase {
        /**
         * When this property is been set, the corresponding object cannot be serialize.
         */
        isNonSerializableCallStack?: string;
        /**
         * This flag indicates whether remote mutation is disallowed.
         */
        disallowRemoteMutations?: boolean;
    }
    /**
     * Specifies the promise state.
     */
    const enum PromiseState {
        Pending = 0,
        Resolved = 1,
        Rejected = 2,
        Max = 3,
    }
    /**
     * Specifies how an array element was modified with respect to the array.
     */
    const enum ArrayChangeKind {
        /**
         * The element was added.
         */
        Added = 0,
        /**
         * The element was deleted.
         */
        Deleted = 1,
    }
    /**
     * Defines the metadata data structure.
     * In one iframe, one object have only one metadata.
     *
     */
    interface Metadata extends MetadataContainerBase {
        /** Metadata also been used to store original array. When serializing observable array, Po will
         * shallow clone its underlying array and save it to metadata, we call it original array, the
         * original array will be used when handle array change.
         *   For example:
         *   1. var arr1 = ko_observableArray([1, 2]);
         *   2. When serializing arr1, Po will save [1, 2] to its metadata:
         *        metadata[poManager.arrayId] = originalArray;
         *   3. When observableArray been updated:
         *        arr1.push(3);
         *   4. PoManager will compare arr1.peek() with originalArray and get the differences
         *   5. PoManager will send the differences to another po:
         *        [{ k: add, i: 2, v: ["3"]]
         */
        [key: string]: any | any[];
        /**
         * The id that identifies this proxied object. One object have unique id within browser.
         */
        id: string;
        /**
         * The desired value when apply observable change.
         */
        desiredValue?: any;
        disallowRemoteMutations?: boolean;
    }
    /**
     * Defines the jquery promise value metadata data structure.
     */
    interface JQueryPromiseValueMetadata {
        value?: any;
    }
    /**
     * Defines serialization result.
     */
    interface SerializationResult extends Array<any> {
    }
    /**
     * Defines release event descriptor.
     * Use abbreviations because this object been sent across iframes
     *
     * The lifecycle of gc:
     *  1. Primary Po starts gc process, loops map and finds out all objects which doesn't referenced by rootObject.
     *  2. Primary Po sends pending disposed object ids (iIds) to secondary Po.
     *  3. Secondary Po dispose objects and sends cIds to Primary Po.
     *  4. Primary Po disposes pending disposed objects.
     */
    interface ReleaseEventDescriptor {
        /**
         * The root object id.
         * This property being used to release the single root object, when
         * this property set, all other property will be undefined. for example: {rId:"00-0.content.title"}
         */
        rId?: string;
        /**
         * The initial ids.
         */
        iIds?: string[];
        /**
         * The confirmed ids.
         */
        cIds?: string[];
    }
    /**
     * Defines release event descriptor.
     * Use abbreviations because this object been sent across iframes
     * The description of a change of an array, this interface been used inside ChangeDescriptor.
     */
    interface ArrayChange {
        /**
         * The array change kind
         * How the array element was changed.
         */
        k: ArrayChangeKind;
        /**
         * The index indicate where the array element was changed.
         */
        i: number;
        /**
         * The new value of the array element if the element was added.
         */
        v?: SerializationResult;
    }
    /**
     * Defines a change of an observable/observableArray.
     * Use abbreviations because this object been sent across iframes
     */
    interface ChangeDescriptor {
        /**
         * The proxied observable object id, this value is unique within browser.
         */
        id: string;
        /**
         * The new object change (set to observable), this property being used when observable updated.
         */
        o?: SerializationResult;
        /**
         * The array changes, this property being used when observable array updated.
         */
        a?: ArrayChange[];
        /**
         *The full array, this property being used to recover observable array after simultaneous changes.
         */
        fa?: SerializationResult[];
        /**
         * The change number of the observable/observable array.
         */
        cn: number;
        /**
         * The serial number of the observable array.
         * It's undefined by default, this number will incremental update when there is simultaneous change
         */
        sn?: number;
    }
    /**
     * Defines promise event descriptor.
     * Use abbreviations because this object been sent across iframes
     */
    interface PromiseEventDescriptor {
        /**
         * The promise id, this value is unique within browser
         */
        id: string;
        /**
         * The promise state
         */
        s: PromiseState;
        /**
         * The promise value
         */
        v?: SerializationResult;
    }
    /**
     * Defines function invocation descriptor.
     * Use abbreviations because this object been sent across iframes
     */
    interface ProxyFunctionInvocationDescriptor {
        /**
         * The function call id.
         * One function can be called multiple times in a short period of time, use funcCallId to identify the different calls.
         */
        cid: string;
        /**
         * The function id, this value is unique within browser
         */
        fid: string;
        /**
         * "this" pointer of the function call.
         */
        t: SerializationResult;
        /**
         * The function call arguments.
         */
        a: SerializationResult[];
    }
    interface PromiseAdapter {
        type: number;
        deferred: Q.Deferred<any>;
        promise: Q.Promise<any>;
        getState(): PromiseState;
        getValue(): any;
        always(finallyCallback: (value: any) => any): void;
    }
    const enum ExceptionCode {
        UnsupportedPromiseCompleteState = 100,
        UnsupportedPromiseState = 101,
        UnsupportedAdapterPromiseState = 102,
        UnsupportedFunctionResultKind = 103,
        UnsupportedReferenceDataType = 104,
        UnsupportedSerializationResultDataType = 105,
        UnsupportedArrayChangeKind = 106,
        UnsupportedFixupDataType = 107,
        FailedToReleaseRootObject = 202,
        FailedToGetPromiseValue_CannotFindMetadata = 203,
        FailedToApplyObservableChange_InvalidDescriptor = 204,
        FailedToReleaseRootObject_TheInputIsNotARootObjectId = 206,
        FailedToGetObject_ObjectHasBeenFreed = 207,
        FailedToInvokeFunction_DeserializeThisFailed = 209,
        FailedToDecide_PrimaryLocalWindowIdEqualsToRemoteWindowId = 210,
        FailedToReset_SomePoNotBeenDispose = 211,
        FailedToDeserialize_ObjectHasBeenReleased = 212,
        FailedToDeserialize_CircularReferenceDetected = 213,
        FailedToDeserialize_CannotFindPrototype = 214,
        FailedToApplyObservableChange_DisallowRemoteMutations = 216,
        FailedToSerialize_ObjectIsNonSerializable = 217,
        FailedToDeserialize_InputIsNotValid = 218,
        FailedToSerialize_ObjectMetadataIsNotClean = 219,
        CannotFindObject_onFunctionPromise = 220,
        CannotFindObject_ApplyPromiseChanges = 221,
        CannotFindObject_ProxyFunction = 222,
        CannotFindObject_ApplyChange = 224,
        CannotFindObject_InvokeFunction = 225,
        CannotFindObject_IsDisallowRemoteMutations = 226,
        FailedToSerialize_ObjectUsedReservedCharacterAsKey = 227,
        FailedToSerialize_ObjectUsedReservedCharacterAsValue = 228,
        FailedToMoveObject_ConfirmSecondaryPoGc = 231,
        CannotFindObject_FixupObject = 232,
        CannotFindObject_FixupObservableOrObservableArray = 233,
        CannotFindObject_FixupDeferredOrPromise = 234,
        CannotFindMetadata_HandleUnderlyingArrayChanges = 235,
        CannotFindMetadata_PromiseProgress = 236,
        CannotFindMetadata_PromiseAlways = 237,
        CannotFindMetadata_ApplyPromiseChanges = 238,
        CannotFindMetadata_ReleaseObject = 239,
        CannotFindMetadata_ApplyObservableArrayChanges = 240,
        FailedToSerialize_EncounteredException = 241,
        FailedToApplyPromiseChange_DisallowRemoteMutations = 242,
        DetectedSimultaneousChange = 301,
        DetectedCycleSubscription = 302,
        DetectedNonArrayValueInObservableArray = 303,
        DetectedCancelablePromiseInObject = 304,
    }
    interface FunctionCallMetadata {
        promise: PromiseAdapter;
        objs: any[];
    }
    /**
     * Provides functions that serialize and deserialize object.
     * - One iframe can have multiple poManager instances.
     * - One connection must have two poManager instance, one in each iframe.
     * - In one iframe, one object can belong to multiple poManagers.
     */
    class ProxiedObjectManager {
        /**
         * The gc interval handle
         **/
        private _gcIH;
        disposed: boolean;
        /**
         * One ProxiedObjectManager has one id, and the id is unique across the entire web browser.
         * It's also the prefix of all object ids which serialized by this ProxiedObjectManager.
         */
        id: string;
        /**
         * The changeNumberId, one ProxiedObjectManager has one changeNumberId, and the changeNumberId is unique across the entire web browser.
         * The changeNumberId be used to get/set observable changeNumber, the usage is like: metadata[poManager.changenumber];
         *
         * For example:
         *  1. There are two ProxiedObjectManagers in one iframe, po1 and po2
         *  2. The po1.changeNumberId = "c-1", po2.changeNumberId = "c-2".
         *  3. One knockout observable belongs to both po1 and po2. Mostly, this observable have different change numbers in different po Managers.
         *  3. This observable's metadata will look like metadata = {id:"13","c-1":19,"c-2":3}.
         *  4. metadata[po1.changeNumberId] will return its changeNumber in po1, metadata[po2.changeNumberId] will return its changeNumber in po2.
         */
        cnId: string;
        /**
         * The serialId, one ProxiedObjectManager has one serialId, and the serialId is unique across the entire web browser.
         * The serialId be used to get/set the observable serial number, the usage is: metadata[poManager.lostSyncId] = true;
         */
        sId: string;
        /**
         * The arrayId, one ProxiedObjectManager has one arrayId, and the arrayId is unique across the entire web browser.
         * The arrayId be used to get/set original array from metadata
         */
        aId: string;
        /**
         * The knockout subscription id, one ProxiedObjectManager has one koSubId, and the koSubId is unique across the entire web browser.
         * The koSubId be used to get/set knockout subscription to pureComputed object
         */
        kId: string;
        /**
         * The promise subscription id, one ProxiedObjectManager has one promise self inflicted number id, and the promiseSId is unique across the entire web browser.
         * The promise subscription id be used to get/set promise self inflicted number. The self inflicted number design is the same as POv1.
         */
        pId: string;
        isPrimary: boolean;
        raiseRemoteException: Action1<string>;
        /**
         * The change listener
         */
        onChange: Action1<ChangeDescriptor>;
        /**
         * The promise listener
         */
        onPromise: Action1<PromiseEventDescriptor>;
        /**
         * The proxy function invocation listener
         */
        onFunction: Action1<ProxyFunctionInvocationDescriptor>;
        /**
         * The release listener
         */
        onRelease: Action1<ReleaseEventDescriptor>;
        /**
         * The operation history
         */
        ops: any[];
        /**
         * A hash-table to have one to one mapping between objectId and object.
         * Object won't be collected by WebBorwser when it belongs to map. The purpose of ProxiedObjectManager.gc() is to remove unused objects from map.
         */
        map: StringMap<any>;
        pending: StringMap<any>;
        roots: StringMap<any>;
        receivedChangeNumbers: StringMap<number>;
        functionCalls: StringMap<FunctionCallMetadata>;
        freedIds: string[];
        revivedIds: StringMap<any>;
        /**
         * The remote window id, used for log
         */
        remoteWindowId: string;
        /**
         * The gc initialIds from primary po
         * This property is only been set in secondary po
         */
        gcIIds: string[];
        /**
         * A map to have gc initialIds
         * This property is only been set in secondary po
         */
        gcIIdMap: StringMap<boolean>;
        /**
         * Generate id function
         */
        genId: Func<string>;
        /**
         * Generate function call id function
         */
        genFuncCallId: Func<string>;
        /**
         * Generate release id function
         */
        genReleaseId: Func<string>;
        serializeObject(data: any, serializationOptions?: SerializationOptions): SerializationResult;
        deserializeObject(encodedData: SerializationResult, remoteWindowId?: string): any;
        applyPromiseEvent(descriptor: PromiseEventDescriptor): void;
        applyChange(descriptor: ChangeDescriptor): void;
        applyRelease(descriptor: ReleaseEventDescriptor): void;
        invokeFunction(descriptor: ProxyFunctionInvocationDescriptor): void;
        scheduleGc(): void;
        /**
         * Release an input object. In Po, releaseObject function can only release rootObject.
         * For example: after user closed a blade, this method will been called multiple times to release all PartViewModels.
         * @param object The input object to be released
         */
        releaseObject(object: any): void;
        /**
         * Start garbage collect in primary po manager.
         *
         * The lifecycle of gc:
         *  1. Primary Po starts gc process, loops map and finds out all objects which doesn't referenced by rootObject.
         *  2. Primary Po sends pending disposed object ids (iIds) to secondary Po.
         *  3. Secondary Po dispose objects and sends cIds to Primary Po.
         *  4. Primary Po disposes pending disposed objects.
         *
         */
        gc(): void;
        /**
         * Dispose poManager and its references
         */
        dispose(): void;
    }
    function createPoManager(metadataIdPrefix: string, raiseRemoteException: Action1<string>, changeListener: Action1<ChangeDescriptor>, promiseEventListener: Action1<PromiseEventDescriptor>, proxyFunctionInvocationListener: Action1<ProxyFunctionInvocationDescriptor>, releaseListener: Action1<ReleaseEventDescriptor>, localWindowId: string, remoteWindowId: string, notScheduleGc?: boolean): ProxiedObjectManager;
    /**
     * Once an object been serialized/deseialized. poManager will generate a metadata and save the
     * entire entry to metdataMap. This function allows external module get metadata by object
     * @param obj The input object.
     * @returns The metadata of input object.
     */
    function getMetadata(obj: any): Metadata;
    function getMetadataId(obj: any): string;
    /**
     * Get or create empty metadata
     * @param obj The input object.
     * @returns The metadata of input object.
     */
    function getOrCreateMetadata(obj: any): Metadata;
    /**
     * Marks that the given object is disallowed from being mutated by its remote copy.
     */
    function disallowRemoteMutations(obj: any): void;
    /**
     * Custom level of Assertion.
     */
    const enum AssertLevel {
        UserError = 0,
        BugInPO = 1,
    }
    var assert: (assertLevel: AssertLevel, value: any, message: string) => void;
    /**
     * Clean all objects, V2.managers, V2.metadataMap and V2.jqueryPromiseValueMap.
     * Export this function for unit test only.
     */
    function reset(): void;
    /**
     * Create promise adapter.
     * Export this function for unit test only.
     */
    function createPromiseAdapter(promiseOrDeferred: any): PromiseAdapter;
    /**
     * Override enableCompatibilityMode and enableDiagnostics.
     * Export this function for unit test only.
     */
    function override(newEnableCompatibilityMode?: boolean, newEnableDiagnostics?: boolean): void;
    function getMetadataByPoManager(obj: any, poManager: Po.ProxiedObjectManager): Metadata;
    interface DiagnosticOptions {
        enableDiagnostics?: boolean;
        disableArrayPerformanceCheck?: boolean;
        enableArrayMutationLogging?: boolean;
    }
    function setDiagnosticOptions(options: DiagnosticOptions): DiagnosticOptions;
    var exportForDevMode: {
        bucketIdRegex: RegExp;
        bucketIdReplacement: string;
        splitter: string;
        removeUserStringValues: (serializationResult: SerializationResult) => SerializationResult;
        log: Fx.Base.Diagnostics.Log;
        hasFreed: (poManager: ProxiedObjectManager, id: string) => boolean;
        handleException: (exceptionCode: ExceptionCode, detailMessage: string, parameter?: any, logOnly?: boolean) => void;
        ignoredSimultaneousErrorBucketIds: RegExp;
    };
    /**
     * Return some objects and variables for diagnostics purpose.
     */
    function getDiagnostics(): {
        compatibilityMode: boolean;
        diagnostics: boolean;
        metadataMap: WeakMapLike<Object, Metadata>;
        jQPromise: WeakMapLike<Object, JQueryPromiseValueMetadata>;
        managers: ProxiedObjectManager[];
    };
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.QExtensions.d.ts
declare module Q {
    interface Promise<T> {
        /**
         * Catches errors that are instances of the specified error type.
         * If not of the specified type the error continues to propagate.
         *
         * Works for all errors of type Error and derivations of Error
         * on non-proxied promises.  For proxied promises it will only
         * work on errors of types deriving from MsPortalFx.Errors.Error.
         *
         * .catchError(MsPortalFx.Errors.CanceledError, (error) => {
         *     // error is a CanceledError of somthing deriving from it
         * })
         *
         * @param errorType The type of errors to catch.
         * @param onError The error handler.
         * @return Promise that is resolved or rejected according to the error handler.
         */
        catchError<U, E extends MsPortalFx.Errors.Error>(errorType: MsPortalFx.Errors.ErrorType<E>, onError: (error: E) => U | IPromise<U>): Promise<U>;
    }
}
declare module FxImpl.QExtensions {
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Resources.d.ts
interface Window {
    Resources: any;
}
declare module MsPortalFx {
    module Base.Resources {
        function initialize(fxEnvironment?: FxEnvironment, resources?: any): void;
        /**
         * Gets the image URIs from the given node using the image root.
         *
         * @param node The node which contains the node image strings.
         * @return Copy of the node with the node image strings converted to URIs.
         */
        function getImages<T>(node: T): T;
        /**
         * Gets an object that contains all the localized strings for a given widget/control.
         *
         * @param control The name of the control.
         */
        function getStrings(control: string): any;
        /**
         * Returns whether the given URI is an absolute URI.
         *
         * @param uri The URI.
         * @return A boolean value indicating whether the URI is absolute.
         */
        const isUriAbsolute: typeof MsPortalFx.isUriAbsolute;
        /**
         * Gets the path to the named content.
         *
         * @param uri The uri of the content.
         * @param coerceAbsoluteUri Forces the returned uri to be an absolute uri. The default value is true.
         * @return The uri.
         */
        function getContentUri(uri: string, coerceAbsoluteUri?: boolean): string;
        /**
         * Gets the path to the named script file
         *
         * @param uri The uri of the script file.
         * @return The uri.
         */
        function getScriptUri(uri: string): string;
        /**
         * Gets the path to the application relative uri.
         *
         * @param uri The application relative uri.
         * @return The uri.
         */
        function getAppRelativeUri(uri: string): string;
        /**
         * Gets the path to the named content with the version segment.
         *
         * @param uri The uri of the content.
         * @param coerceAbsoluteUri Forces the returned uri to be an absolute uri. The default value is true.
         * @return The uri.
         */
        function getVersionlessContentUri(uri: string, coerceAbsoluteUri?: boolean): string;
        /**
         * Internal only. For use by Resource generation code.
         */
        function _getImageMap(fileHierarchy: Array<any>, className: string): StringMap<string>;
    }
    /**
     * Internal only. For use by Resource generation code.
     */
    const getImages: typeof Base.Resources._getImageMap;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Rpc2.d.ts
declare module MsPortalFx.Base.Rpc.Internal {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import Diagnostics = FxBase.Diagnostics;
    import LifetimeManager = FxBase.LifetimeManager;
    var WindowLoadTimeoutsInSec: number[];
    var minTraceDurationInMs: number;
    var timeToDelayWindowUnload: number;
    interface InvokeRpcMessage {
        requestId: string;
        name: string;
        arg: any;
    }
    interface OrderedObject<T> {
        seq: number;
        data: T[];
    }
    interface WindowHandshake {
        sequenceStart: number;
        destinationId: string;
        /**
         * A handshake happens in two steps. The initiating iframe first sends a packet with handshakeData
         * with the isResponse set to false. The receiving iframe handles this packet and sends its own handshakeData
         * with isResponse set to true. Having isResponse set to true tells the initiating iframe that the handshake
         * is complete.
         */
        isResponse: boolean;
    }
    interface WindowMessage extends OrderedObject<RoutedMessage> {
        signature: string;
        originId: string;
        handshakeData?: WindowHandshake;
    }
    const enum RoutedMessageKind {
        Reset = 0,
        Shutdown = 1,
        Exception = 2,
        RefCount = 3,
        StatelessRpcInvoke = 4,
        StatelessRpcReturn = 5,
        StatelessRpcError = 6,
        PoAcquireObjectRequest = 7,
        PoAcquireObjectResponseError = 8,
        PoConnectionEvent = 9,
    }
    interface MessageOperation {
        begin: number;
        end: number;
    }
    interface MessageTimestamps {
        tag: string;
        enqueueTime: number;
        operations: StringMap<MessageOperation>;
        sendTime: number;
        receiveTime: number;
    }
    interface MessageContext {
        callStack: string;
        srcWindowId: string;
        destWindowId: string;
        timestamps?: MessageTimestamps;
        initiatingTimestamps?: MessageTimestamps;
    }
    interface MultiplexedMessage<TKind> {
        kind: TKind;
        data: any;
    }
    interface RoutedMessage extends MessageContext {
        routeInstanceIndex: number;
        data: MultiplexedMessage<RoutedMessageKind>;
    }
    interface MessageEventLike<T> {
        source: WindowLike<T>;
        origin: string;
        data: T;
    }
    interface PostMessageObject<T> {
        postMessage(message: T, host: string): void;
    }
    interface WindowLike<T> extends PostMessageObject<T> {
        addEventListener(type: "message", handler: Action1<MessageEventLike<T>>): void;
        addEventListener(type: string, handler: Action1<any>): void;
        removeEventListener(type: "message", handler: Action1<MessageEventLike<T>>): void;
        removeEventListener(type: string, handler: Action1<any>): void;
    }
    class DisposableValue<T> implements Disposable {
        private _value;
        private _disposeCallbacks;
        constructor(value: T);
        getValue(): T;
        dispose(): void;
        onDispose(callback: Action1<T>): void;
    }
    interface RpcWindowOptions {
        source: PostMessageObject<any>;
        window: PostMessageObject<any>;
        trustedHost: string;
        initializationFunc: Action1<RpcWindow<any>>;
    }
    class RpcWindow<T> extends DisposableValue<PostMessageObject<T>> {
        private _initFunc;
        private _trustedHost;
        private _source;
        constructor(options: RpcWindowOptions);
        getSource(): PostMessageObject<any>;
        initialize(): void;
        isHostAllowed(messageHost: string): boolean;
        postMessage(message: T): void;
        getTrustedHost(): string;
    }
    interface ActionEndPointHandler<T> {
        (arg: T, context: MessageContext, lifetime: LifetimeManager): Promise | void;
    }
    interface FuncEndPointHandler<T, R> {
        (arg: T, context: MessageContext, lifetime: LifetimeManager): PromiseV<R> | R;
    }
    type AllowedOrigins = string | string[];
    interface EndPointRegistrationOptions<T, R> {
        /**
         * A list of extension names that can be allowed to invoke this RPC callback. If a falsey value is specific, then all extensions are allowed to invoke this callback.
         */
        allowedOrigin: AllowedOrigins;
        /**
         * The callback function of the RPC callback.
         */
        handler: FuncEndPointHandler<T, R>;
        /**
         * Success callback.
         */
        onSuccess?: (value: DisposableValue<any>, endPointOptions: EndPointRegistrationOptions<T, R>, originalOnSuccess: (value: DisposableValue<any>, endPointOptions: EndPointRegistrationOptions<T, R>) => void) => void;
    }
    interface ProxiedObjectEndPointRegistrationOptions<T, R> extends EndPointRegistrationOptions<T, R> {
        /**
         * Indicates whether remote changes are allowed.
         */
        allowRemoteChanges: boolean;
    }
    interface Client {
        /**
         * Registers an RPC callback
         */
        registerRpcEndPoint<T, R>(name: string, options: EndPointRegistrationOptions<T, R>): void;
        /**
         * Registers an object factory function that can be used to create objects that are to be proxied to the caller.
         */
        registerObjectFactory<T, R>(name: string, options: ProxiedObjectEndPointRegistrationOptions<T, R>): void;
        /**
         * Invokes an RPC callback that does return a value.
         *
         * @param name A string that uniquely identifies the object type.
         * @param destination The extension of where the object is to be acquired.
         * @param arg Arguments passed to the object factory handler.
         */
        invokeRpc<T, R>(name: string, destination: string, arg: T): PromiseV<R>;
        /**
         * Acquires a proxied object from the given destination extension.
         *
         * @param name A string that uniquely identifies the object type.
         * @param destination The extension of where the object is to be acquired.
         * @param arg Arguments passed to the object factory handler.
         * @param onObjectAcquired A callback being called with the acquired object before additional messages are processed.
         */
        acquireObject<T, R>(name: string, destination: string, arg: T, onObjectAcquired?: (object: DisposableValue<R>) => void): PromiseV<DisposableValue<R>>;
    }
    interface AsyncAction1<T> {
        (value: T): Promise | void;
    }
    interface InternalClient extends Client {
        getTotalRefCountTo(windowId: string): KnockoutReadOnlyObservableBase<number>;
        acquireWindow(windowId: string, durationInSeconds?: number): AcquireWindowResult;
        registerEndPointFilter(callback: AsyncAction1<string>): Disposable;
    }
    type LoadWindowFunc = (windowId: string) => RpcWindow<any>;
    /**
     * Given a set objects that implement OrderedObject therefore have a sequence number associated
     * with each object, this class provides a way to apply a handler function on each object in the
     * order denoted by the sequence number. If the objects are added out of order, then Sequencer
     * will internally reorder the objects and ensure that the handler is applied in the correct order.
     */
    class Sequencer<T> {
        private _outerList;
        private _outerListIndex;
        private _innerList;
        private _innerListIndex;
        private _handler;
        constructor(startIndex: number, handler: Action1<T>);
        private _processInnerList(array?);
        addItem(item?: OrderedObject<T>): void;
        isEmpty(): boolean;
    }
    interface Sender<T> {
        (destination: string, data: T): void;
    }
    interface MessageRelay<TKind, TContext> {
        registerHandler<TData>(kind: TKind, handler: Action2<TData, TContext>): Sender<TData>;
    }
    interface RoutedMessageSource {
        localInstanceIndex: number;
        remoteInstanceIndex: number;
        remoteId: string;
    }
    const enum RefCountKind {
        AcquireWindow = 0,
        OutstandingPoObjects = 1,
        PendingPoObjectRequests = 2,
        Rpc = 3,
    }
    class AcquireWindowResult extends DisposableValue<string> {
        constructor();
    }
    interface RefCounter {
        setRefCount(associatedDestination: string, kind: RefCountKind, isActivating: boolean, value: number): void;
    }
    interface RoutedMessageClientContext extends RefCounter {
        raiseRemoteException(destination: string, message: ExceptionMessage): void;
        routedMessageRelay: MessageRelay<RoutedMessageKind, RoutedMessage>;
        localWindowId: string;
    }
    interface ExceptionMessage extends Diagnostics.ExceptionMessage {
    }
    interface ResetMessage extends ExceptionMessage {
        windowId: string;
    }
    interface RoutedMessageClient {
        handleResetMessage(message: ResetMessage, routedMessage: RoutedMessage): void;
        handleShutdownMessage(routedMessage: RoutedMessage): void;
    }
    function invokeWithContext<T>(message: MessageContext, action: () => T): T;
    class RoutedMessageDispatcher implements RoutedMessageClientContext, Disposable {
        private _routedMessageClients;
        private _shellRefCounter;
        private _sendRefCount;
        private _baseDispatcher;
        routedMessageRelay: MessageRelay<RoutedMessageKind, RoutedMessage>;
        localWindowId: string;
        raiseRemoteException: Sender<ExceptionMessage>;
        constructor(localWindowId: string, loadWindowFunc: LoadWindowFunc, dispatcherOptions: WindowMessageDispatcherOptions);
        handleMessage(message: RoutedMessage, route: RoutedMessageSource): void;
        getTotalRefCounts(targetId: string): KnockoutObservable<number>;
        createClient<T extends RoutedMessageClient, U>(factory: new (context: RoutedMessageClientContext, endPoints: U) => T, arg: U): T;
        setRefCount(targetWindowId: string, kind: RefCountKind, isActivating: boolean, value: number): void;
        start(): void;
        dispose(): void;
    }
    interface WindowMessageDispatcherOptions {
        hostWindow: WindowLike<WindowMessage>;
        parentTrustedOrigin: string;
        parentWindow: WindowLike<WindowMessage>;
    }
    class WindowMessageDispatcher implements Disposable {
        private _routes;
        private _preStartReceiveBuffer;
        private _eventHandler;
        private _window;
        private _routedMessageMultiplexer;
        constructor(options: WindowMessageDispatcherOptions);
        getRoute(windowId: string): RoutedMessageSource;
        sendMessage(destination: string, message: RoutedMessage): void;
        start(routedMessageMultiplexer: RoutedMessageDispatcher): void;
        setRouteWindow(windowId: string, rpcWindow: RpcWindow<WindowMessage>): void;
        dispose(): void;
        private _registerRoute(isParentRoute, windowId);
        private _handleMessage(ev);
    }
    /**
     * Determines if the given error represents an RPC timeout.  This can used to retry on timeout or ignore timeout
     * errors.
     *
     * @param error The error to check.
     * @param methodName The RPC method name to check.
     * @param destination The RPC destination to check.
     * @return Boolean true if the error represents an RPC timeout, otherwise false.
     */
    function errorIsRpcTimeout(error: any, methodName: string, destination: string): boolean;
    function dumpTrackedObjects(): any[];
    class ClientImpl implements InternalClient {
        private _dispatcher;
        private _rpcEndPoints;
        private _poEndPoints;
        private _endPointFilterManager;
        private _rpcClient;
        private _poClient;
        private _windowAcquirer;
        constructor();
        registerRpcEndPoint<T, R>(name: string, options: EndPointRegistrationOptions<T, R>): void;
        registerObjectFactory<T, R>(name: string, options: ProxiedObjectEndPointRegistrationOptions<T, R>): void;
        private _assertReady();
        invokeRpc<T, R>(name: string, destination: string, arg: T): PromiseV<R>;
        acquireObject<T, R>(name: string, destination: string, arg: T, onObjectAcquired?: (object: DisposableValue<R>) => void): PromiseV<DisposableValue<R>>;
        getTotalRefCountTo(windowId: string): KnockoutObservable<number>;
        acquireWindow(windowId: string, durationInSeconds?: number): AcquireWindowResult;
        registerEndPointFilter(callback: AsyncAction1<string>): Disposable;
        start(dispatcher: RoutedMessageDispatcher): void;
        reset(): void;
    }
    interface StartOptions {
        originId: string;
        loadWindow: LoadWindowFunc;
        parentWindow: WindowLike<WindowMessage>;
    }
    function start(options: StartOptions): void;
    /**
     * The RPC client that can used to register and invoke RPC callbacks.
     */
    var client: Client;
    const internalClient: InternalClient;
    class EndPointDefinition {
        private _name;
        constructor(name: string);
        getName(): string;
    }
    class ActionEndPointDefinition<T> extends EndPointDefinition {
        register(client: Client, allowedOrigin: AllowedOrigins, handler: ActionEndPointHandler<T>): void;
        invoke(client: Client, destination: string, arg: T): Promise;
    }
    class FuncEndPointDefinition<T, R> extends EndPointDefinition {
        register(client: Client, allowedOrigin: AllowedOrigins, handler: FuncEndPointHandler<T, R>): void;
        invoke(client: Client, destination: string, arg: T): PromiseV<R>;
    }
    class ProxiedObjectTypeDefinition<T, R> extends EndPointDefinition {
        registerObjectFactory(client: Client, options: ProxiedObjectEndPointRegistrationOptions<T, R>): void;
        acquireObject(client: Client, destination: string, arg: T, onObjectAcquired?: (object: DisposableValue<R>) => void): PromiseV<DisposableValue<R>>;
    }
    var load: number;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.RpcContext.d.ts
declare module MsPortalFx.Base.Rpc.Internal {
    interface StackAnnotatedObject {
        stack: string;
    }
    var messageContext: MessageContext;
    function createCallStack(stack: string, messageContext?: MessageContext, endPointName?: string): string;
    function addRpcStack(obj: StackAnnotatedObject): void;
    function getCurrentCallStack(force?: boolean): string;
    module Measurement {
        const ON_INPUTS_SET_CALLED: string;
        const VIEW_MODEL_CTOR: string;
        const OBJECT_DESERIALIZE: string;
        const ENDPOINT_INVOKED: string;
        const CONTENT_REVEALED: string;
        const getTimestamp: () => number;
        function newTimestamps(time: number): MessageTimestamps;
        function markOperationEnd(operationName: string, before: number, context?: MessageContext): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Scheduler.d.ts
declare module MsPortalFx.Base {
    /**
      * devMode only test helper
      */
    function setSchedulerRunTask(newRunTask: () => Q.Promise<any>): () => Q.Promise<any>;
    /**
      * devMode only test helper
      */
    function resetSchedulerRunTask(): void;
    interface ScheduledTask {
        /**
         * Optional if delayInMs is not specified. The absolute time the task should execute.
         */
        absoluteTime?: number;
        /**
         * Optional if absoluteTime is not specified. The delay before the task executes.
         */
        delayInMs?: number;
        /**
         * Determines if the task is asynchronous.
         */
        isAsync?: boolean;
        /**
         * Name of the task.
         */
        name?: string;
        /**
         * Optional. Not compatible with absolute time. Should not be used if task is async.
         * (instead, call scheduleTask again on completion of the async task).
         * If set to true the task will be automatically rescheduled after completion (or failure).
         */
        recurring?: boolean;
        /**
         * Function to call that executes the task.
         */
        scheduledTask: Function;
        /**
         * Arguments to pass to the scheduled task.
         */
        args?: any[];
        /**
         * Optional. If true, diagnostic output for this task will not be logged.
         */
        silent?: boolean;
    }
    class Scheduler {
        /**
         * Schedules a task
         */
        static scheduleTask(task: ScheduledTask, allowDuplicates?: boolean): void;
        /**
         * Deletes a scheduled task
         */
        static deleteTask(task: ScheduledTask): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Security.d.ts
declare module MsPortalFx.Base.Security {
    import FxBase = MsPortalFx.Base;
    import InternalExtension = FxImpl.Extension;
    /**
     * Interface for options used to get authorization tokens.
     */
    interface GetAuthorizationTokenOptions {
        resourceName: string;
    }
    /**
     * Interface for authentication tokens received by the extension.
     */
    interface AuthorizationToken {
        /**
         * The authorization header needed to make API calls to a service.
         */
        header: string;
        /**
         * The time at which the token expires.
         */
        expiresAt: number;
    }
    interface GetAuthorizationTokenResponse {
        /**
         * The authorization token.
         */
        token?: AuthorizationToken;
        /**
         * Any errors in obtaining the token.
         */
        error?: string;
        /**
         * An error details if any errors in obtaining the token.
         */
        errorMessage?: string;
    }
    interface UserInfo {
        /**
         * Email name of the identity.
         */
        email: string;
        /**
         * First name of the identity.
         */
        givenName: string;
        /**
         * Last name of the identity.
         */
        surname: string;
        /**
         * The identity's directory.
         */
        directoryId: string;
        /**
         * The identity's directory name.
         */
        directoryName: string;
        /**
         * The identity's unique directory name, that show both directory and domain name when directory name isn't unique.
         */
        uniqueDirectoryName: string;
        /**
         * The tenant's domain name.
         */
        domainName: string;
    }
    /**
     * Interface for authentication tokens cache.
     */
    interface IAuthTokenCache {
        /**
         * Gets a security token needed to make API calls to a back end service.
         *
         * @param options Optional options containing the resource name and the cloud name of the extension wants access to.
         * @return A security token for the named service or if no such token is available undefined.
         */
        getToken(options: InternalExtension.GetAuthorizationTokenOptions): FxBase.PromiseV<AuthorizationToken>;
        /**
         * Gets the timestamp a resources token will expire at.
         *
         * @param cloudName The cloud the resource belongs to.
         * @param resourceName The resource to get token expiration for.
         * @return The timestamp a token will expire at or if no such token is available undefined.
         */
        getTokenExpiresAt(cloudName: string, resourceName: string): number;
    }
    /**
     * Creates an instance of the authentication token cache.
     *
     * @param getTokenFunc function that returns authentication tokens.
     * @param seedData initial seed data for the cache.
     * @return An instance of the authentication token cache.
     */
    function createAuthTokenCache(getTokenFunc: (options?: InternalExtension.GetAuthorizationTokenOptionsExtended) => FxBase.PromiseV<AuthorizationToken>, seedData?: StringMap<AuthorizationToken>): IAuthTokenCache;
    /**
     * Gets the security token an extension uses to make calls against
     * secured back end services.
     *
     * @param options Options that control which token is obtained.
     * @return A security token for the named service or if no such token is available undefined.
     * @remarks Do not cache or resuse the returned token as there is no way to tell when it will expire.
     *          Always calling it makes sure your extension picks up a new token when it is refreshed by the shell.
     */
    function getAuthorizationToken(options?: GetAuthorizationTokenOptions): FxBase.PromiseV<AuthorizationToken>;
    /**
     * Gets the signed in user and directory info.
     *
     * @return The info for the currently signed in user and directory.
     */
    function getUserInfo(): FxBase.PromiseV<UserInfo>;
    /**
     * Checks to see if the current user has permissions to perform a set of actions against an entity.
     * secured back end services.
     *
     * @param entityId The entity to check for permissions. The entity ID MUST be a resource ID, a subscription ID or a resource group ID.
     * @param actions The actions being to checked.
     * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
     */
    function hasPermission(entityId: string, actions: string[]): FxBase.PromiseV<boolean>;
    /**
     * Checks to see if the current user has permissions to perform a set of actions against an asset.
     * secured back end services.
     *
     * @param assetId The asset to check for permissions. The asset MUST have an associated resource type.
     * @param actions The actions being to checked.
     * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
     */
    function assetHasPermission(assetId: MsPortalFx.Assets.AssetTriplet, actions: string[]): FxBase.PromiseV<boolean>;
}
declare module FxImpl.Security {
    import FxBase = MsPortalFx.Base;
    import FxSecurity = FxBase.Security;
    import InternalExtension = FxImpl.Extension;
    import FxAuthorizationToken = FxSecurity.AuthorizationToken;
    import FxGetAuthorizationTokenResponse = FxSecurity.GetAuthorizationTokenResponse;
    const tokenErrors: {
        unknown: string;
        accessDenied: string;
        sessionEnded: string;
        credentialsExpired: string;
        networkError: string;
        requiresMFA: string;
        accountDisabled: string;
        nullToken: string;
    };
    /**
     * Implementation for IAuthTokenCache
     */
    class AuthTokenCacheImpl implements FxSecurity.IAuthTokenCache {
        private _getTokenWorker;
        private _cachedTokenMap;
        private _refreshBeforeExpiryMS;
        private _stalledPromise;
        constructor(getTokenFunc: (options?: InternalExtension.GetAuthorizationTokenOptionsExtended) => FxBase.PromiseV<FxGetAuthorizationTokenResponse>, seedData?: StringMap<FxAuthorizationToken>, refreshBeforeExpiryMilliseconds?: number);
        /**
         * See interface.
         */
        getToken(options: InternalExtension.GetAuthorizationTokenOptions): FxBase.PromiseV<FxAuthorizationToken>;
        /**
         * See interface.
         */
        getTokenExpiresAt(cloudName: string, resourceName: string): number;
        private _refreshTokenWorker(options, isBackground, retryDelay, authTokenCacheEntry);
        private _refreshTokenWorkerInternal(options, retryDelay, authTokenCacheEntry);
        private _initTokenCacheEntry(authTokenCacheEntry);
    }
    /**
     * Checks to see if the current user has permissions to perform a set of actions against an entity.
     * secured back end services.
     *
     * @param entityId The entity to check for permissions. The entity ID MUST be a resource ID, a subscription ID or a resource group ID.
     * @param actions The actions being to checked.
     * @param cloudName The cloud name.
     * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
     */
    function hasPermission(entityId: string, actions: string[], cloudName: string): FxBase.PromiseV<boolean>;
    /**
     * Checks to see if the current user has permissions to perform a set of actions against an asset.
     * secured back end services.
     *
     * @param assetId The asset to check for permissions. The asset MUST have an associated resource type.
     * @param actions The actions being to checked.
     * @param cloudName The cloud name.
     * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
     */
    function assetHasPermission(assetId: MsPortalFx.Assets.AssetTriplet, actions: string[], cloudName: string): FxBase.PromiseV<boolean>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Stopwatch.d.ts
declare module MsPortalFx.Base.Stopwatch {
    /**
     * Callback function for a stopwatch operation.
     */
    interface StopwatchOperationFunc {
        (options: any): void;
    }
    /**
     * Callback function for a stopwatch elapsed time callback.
     */
    interface StopwatchElapsedFunc<T> {
        (status: T, options: any, elapsed: number): void;
    }
    /**
     * The telemetry stopwatch class provides elapsed timespans in milliseconds for timing operations.
     */
    class TelemetryStopwatch {
        private _startTimestamp;
        /**
         * Initializes a new instance of the telemetry clock and marks the start timestamp.
         */
        constructor();
        /**
         * Get the number of milliseconds that have elapsed since the clock was created.
         * This number may include fractional values since this may be a high-resolution timer where supported.
         *
         * @return The number of milliseconds elapsed since the clock was created.
         */
        millisecondsElapsed: number;
        /**
         * Resets the clock to start at the current timestamp.
         */
        reset(): void;
        /**
         * Times a single operation.  The callback is called when completed and the time elapsed is passed to the
         * callback.
         *
         * @param options An opaque object passed directly to the callback.
         * @param callback The stopwatch operation callback which is called and measured.
         * @return The number of milliseconds elapsed during the operation.
         */
        static timeOperation(options: any, callback: StopwatchOperationFunc): number;
    }
    /**
     * Times a single async operation.  The callbacks are called when resolved, rejected or during progress and
     * the time elapsed is passed to each callback.
     *
     * @param options An opaque object passed directly to the callbacks.
     * @param done The stopwatch elapsed callback which is called when the promise is done.
     * @param fail The optional stopwatch elapsed callback which is called when the promise is failed.
     * @param progress The optional stopwatch elapsed callback which is called when the promise has progress.
     */
    function timeAsyncOperation<TValue, TReject, TNotify>(options: any, delegate: MsPortalFx.Base.PromiseVN<TValue, TNotify>, done: StopwatchElapsedFunc<TValue>, fail?: StopwatchElapsedFunc<TReject>, progress?: StopwatchElapsedFunc<TNotify>): Q.Promise<any>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Themes.d.ts
declare module MsPortalFx.Base.Themes {
    const enum ThemeMode {
        Light = 0,
        Dark = 1,
    }
    interface Theme {
        /**
         * Theme color code.
         */
        colorCode: string;
        /**
         * Theme sample image uri.
         */
        imageUri: string;
        /**
         * Theme name.
         */
        name: string;
        /**
         * Theme title.
         */
        title: string;
        /**
         * Theme mode.
         */
        mode?: ThemeMode;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.UriBuilder.d.ts
declare module MsPortalFx.Base {
    /**
     * Provides basic query string manipulation functions.
     */
    class QueryStringBuilder {
        private _qs;
        private _qsMap;
        private _leadingSeparator;
        /**
         * Initializes a new instance of the query string builder.
         *
         * @param qs The initial query string.
         * @param leadingSeparator The leading character of the query string. ? by default.
         */
        constructor(qs?: string, leadingSeparator?: string);
        /**
         * Removes all query string values.
         *
         * @return The QueryStringBuilder instance.
         */
        clear(): QueryStringBuilder;
        /**
         * Sets multiple parameters in the query string. Overwrites any existing values.
         *
         * @param keys The object that represents the key value pairs.
         * @return The QueryStringBuilder instance.
         */
        setParameters(keys: StringMap<any>): QueryStringBuilder;
        private getParameterIndex(key);
        /**
         * Sets a parameter in the query string. Overwrites any existing values.
         *
         * @param key The key of the parameter.
         * @param value The value of the parameter.
         * @return The QueryStringBuilder instance.
         */
        setParameter(key: string, value: any): QueryStringBuilder;
        /**
         * Gets the value of a parameter in the query string.
         *
         * @param key The key of the parameter.
         * @return The value of the parameter. Undefined if the value doesn't exist.
         */
        getParameter(key: string): string;
        /**
         * Gets all values of the query string as a stringmap.
         *
         * @return StringMap of all query string key/value pairs.
         */
        getParameters(): StringMap<any>;
        /**
         * Removes multiple parameters from the query string.
         *
         * @param keys The keys of the parameter.
         * @return The QueryStringBuilder instance.
         */
        removeParameters(keys: string[]): QueryStringBuilder;
        /**
         * Removes a parameter from the query string.
         *
         * @param key The key of the parameter.
         * @return The QueryStringBuilder instance.
         */
        removeParameter(key: string): QueryStringBuilder;
        /**
         * Returns a string representation of the URI.
         *
         * @param includeLeadingSeparator Whether to emit the leading ?. Defaults to true.
         * @return A string representation of the URI.
         */
        toString(includeLeadingSeparator?: boolean): string;
    }
    /**
     * Provides basic URI manipulation functions.
     */
    class UriBuilder {
        private _oq;
        /**
         * Gets or sets the path part of the URI. This includes the protocol, domain, port, and virtual path.
         */
        path: string;
        /**
         * Gets or sets the query string part of the URI. This is represented as key value pairs.
         */
        query: QueryStringBuilder;
        /**
         * Gets or sets the fragment of the URI. This includes everything after the # separator in the URI.
         */
        fragment: string;
        /**
         * Initializes a new instance of the URI.
         */
        constructor(uri?: string);
        /**
         * Gets the original query string associated with the URI.
         * Avoids any data loss that might be associated with encoding/decoding of the query string.
         */
        getOriginalQuery(): string;
        /**
         * Returns a string representation of the URI.
         */
        toString(): string;
        /**
         * Gets the authority part of the URI (Ex: www.test.com:880).
         */
        getAuthority(): string;
        /**
         * Gets the scheme and authority part of the URI (Ex: http://www.test.com:880).
         */
        getSchemeAndAuthority(): string;
        /**
         * Gets the relative path of the URI.
         * Ex: Given a URI http://www.test.com:880/test/mypath returns /test/mypath.
         */
        getRelativePath(): string;
        /**
         * Sets the relative path of the URI.
         * Ex: Given a URI http://www.test.com:880/test/mypath and a parameter otherPath.
         * It will change the URI to http://www.test.com:880/otherPath.
         */
        setRelativePath(relativePath: string): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Utilities.d.ts
declare module MsPortalFx.Base.Utilities {
    /**
     * Returns whether code that could have a performance impact but would assist with development should be enabled.
     */
    var isDiagnosticsEnabled: boolean;
    /**
     * Extends the target object with the properties from source object.
     *
     * @param target The object that is to be extended. This object is modified and returned.
     * @param source The object whose properties are to be copied over.
     * @param deep A flag indicating whether the operation is to be performed recursively.
     * @return The same target object (after extension).
     */
    function extend(target: any, source: any, deep?: boolean): any;
    /**
     * Clones the source object.
     *
     * @param source The object whose properties are to be copied over.
     * @param deep A flag indicating whether the operation is to be performed recursively.
     * @param noWrapPrimitives If true, top-level primitives such as 'null' will be returned unchanged. If false, top-level primitives will be converted into objects. Defaults to false.
     * @return A new cloned object.
     */
    function clone<T>(source: T, deep?: boolean, noWrapPrimitives?: boolean): T;
    /**
     * Encodes the input into a string that has none of these characters: <>&.
     *
     * @param value Input to encode.
     * @return Encoded HTML.
     */
    function htmlEncode(value?: any): string;
    /**
     * Encodes the input into a string that has none of these characters: "'`.
     *
     * @param value Input to encode.
     * @return Encoded string.
     */
    function attributeEncode(value?: any): string;
    /**
     * Generates the current JavaScript call stack.
     * On IE9 there is no stack so we get empty string.
     *
     * @param force If true, the call stack is returned even if it is expensive to compute.
     * @return The call stack.
     */
    function getCurrentCallStack(force?: boolean): string;
    /**
     * Generates a deterministic string representation for an object.
     *
     * For objects with single properties, the default serialization is used.
     *   For example: {"prop":value}
     * For objects with multiple properties, an array is used to mantain a deterministic order of (sorted) properties.
     *   For example: { b:2, a:1 } => {#:[{a:1},{b:2}]}
     *
     * @param obj Object to serialize.
     * @param properties Optional root properties to include in the serialization.
     * @return String representation of object.
     */
    function toSortedString(obj: any, rootProperties?: string[]): string;
    /**
     * Parses a string generated by "toSortedString" method and rehydrates the original object.
     *
     * Similar to JSON.stringfy/parse, the rehydrated object will have all the properties
     * from original object, except properties that were set to 'undefined' when serializing.
     *
     * @param sortedString Sorted string.
     * @return Deserialized object.
     */
    function parseSortedString(sortedString: string): any;
    /**
     * Disposes various properties of a view model object.
     *
     * @param viewModel The view model.
     */
    function disposeViewModelProperties(viewModel: any): void;
    /**
     * Generates a property that is not serializable.
     *
     * @param The string to use as part of the property name.
     * @return The non-serializable property name.
     */
    function generateNonSerializableProperty(str: string): string;
    /**
     * Determines whether or not the specified property represents a serializable property.
     *
     * @param propertyName The property name to check.
     * @return True if it's serializable property; false if not.
     */
    function isSerializableProperty(propertyName: string): boolean;
    const getFunctionName: (func: Function) => string;
    function getObjectConstructorName(obj: Object): string;
    /**
     * Helper function to get the objectDescriptor string.
     * Initial design is to help capture when we try to serialized a object which contains cyclic.
     * But doesn't have enough informaiton for the live site issue to pass on to the right team.
     * The data is intend for event log, thus by default doesn't prinit out the data since value might contains
     * user information and security object.
     * In addition, since the object is already cyclic, it only capture the first level property.
     *
     * You should be wary about the performance. This is equavlent to runtime reflection.
     * In addition, In the deepRecursive Mode, it mark the visisted object as "visited", if the object is been ask the second time to serialized the object again.
     * it will mark it as [potential circular].  The reason is that the object can be cached in legit way in two different property and ko.observable. It will break it out to avoid forever loop.
     * Do not use [potential circular] as detection mechanism, this is mainly for the logging purpose.
     *
     * @param obj the object to get the ObjectDescriptor on
     * @param deepRecursive:recursively get into the object to get the string.
     * @return string of object representation.
     *   Here is a dump of StackedAreaChart from the sample.
     *   x = ko.dataFor($0).data
     *   getObjectDescriptor(x)
     *   Here is the return string.
     *{
     *  <ViewModel>: {
     *  disabled: <function>observable,
     *  title: <function>observable,
     *  showTitle: <function>observable,
     *  width: <function>observable,
     *  height: <function>observable,
     *  noDataMessage: <string>,
     *  series: <function>observable,
     *  xAxis: <Axis>,
     *  yAxis: <Axis>,
     *  secondaryXAxes: <function>observable,
     *  secondaryYAxes: <function>observable,
     *  views: <function>observable,
     *  legendPosition: <function>observable,
     *  interactionBehavior: <function>observable,
     *  autogenerateSeriesViews: <function>observable,
     *  events: <Events>,
     *  seriesSelections: <function>observable,
     *  seriesHovers: <function>observable,
     *  hoveredID: <function>observable,
     *  enableTrackXSlider: <function>observable,
     *  disableXSliderMouseout: <function>observable,
     *  xSliderCoordinate: <function>observable,
     *  xSliderFilterHoverThreshold: <function>observable
     *  }
     *}
     * In the dev mode, you can pass in the second argument as deepRecursive
     * getObjectDescriptor(x, enableDebugMode /* true* /);
     *{
     *  <ViewModel>: {
     *    disabled: {
     *      <function>observable: <boolean>
     *    },
     *    title: {
     *      <function>observable: <string>
     *    },
     *    showTitle: {
     *      <function>observable: <boolean>
     *    },
     *    width: {
     *      <function>observable: <number>
     *    },
     *    height: {
     *      <function>observable: <number>
     *    },
     *    noDataMessage: <string>,
     *    series: {
     *      <function>observable: <Array[6]>
     *    },
     *    xAxis: {
     *      <Axis>: {
     *        name: {
     *          <function>observable: <string>
     *        },
     *        scale: {
     *          <function>observable: <number>
     *        },
     *        ticks: {
     *          <function>observable: <number>
     *        },
     *        position: {
     *          <function>observable: <number>
     *        },
     *    .... skip...
     *}
     */
    function getObjectDescriptor(obj: any, deepRecursive?: boolean): string;
    /**
     * Converts a source array to a string map of key => item.
     *
     * @param sourceArray The source array to convert to a map.
     * @param getKeyCallback The callback used to provide the key for the item.
     * @param getValueCallback The optional callback used to provide the key for the item, otherwise the item itself is used.
     * @return The string map of key => item for the source array.
     */
    function convertArrayToMap<T>(sourceItems: T[], getKeyCallback: (item: T, index?: number) => string): StringMap<T>;
    function convertArrayToMap<T, U>(sourceItems: T[], getKeyCallback: (item: T, index?: number) => string, getValueCallback: (item: T, index?: number, key?: string) => U): StringMap<U>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Utilities.Internal.JQuery.d.ts
/**
 * Code in this file is derived from the jQuery JavaScript Library - http://jquery.com/
 * Copyright 2005, 2014 jQuery Foundation and other contributors
 * Released under the MIT license - http://jquery.org/license
 */
declare module MsPortalFx.Base.Utilities.Internal.JQuery {
    function isPlainObject(obj: any): boolean;
    function isEmptyObject(obj: any): boolean;
    function isWindow(obj: any): boolean;
    function type(obj: any): any;
    function isFunction(obj: any): boolean;
    function extend(...allArgs: any[]): any;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Utilities.Serialization.d.ts
declare module MsPortalFx.Base.Utilities.Internal.Serialization {
    /**
     * Converts an object graph into a form that can be JSON-serialized while retaining
     * information about which properties are observable.
     *
     * Note that information about computed properties is not retained: they will be
     * treated as non-computed observables, since the evaluators cannot be serialized
     * in general.
     *
     * @param root The root of the object graph that may contain observables.
     * @return A serializable object.
     */
    function toSerializableObject(root: any): any;
    /**
     * Returns whether the given object was serialized using the toSerializableObject API.
     *
     * @param object Object to test.
     * @return True if the object was serialized by the Serialization utility.
     */
    function isSerializedObject(object: Object): boolean;
    /**
     * Converts an object previously returned by toSerializableObject into a regular
     * object graph. This recovers the object with the equivalent properties being observable or
     * observable arrays.
     *
     * Note that information about computed properties is not retained: they will be
     * treated as non-computed observables, since the evaluators cannot be serialized
     * in general.
     *
     * @param serializableObject An object previously returned by toSerializableObject (possibly having been passed through JSON serialization).
     * @return An object graph that may include observables.
     */
    function fromSerializableObject(serializableObject: any): any;
    var _setReportCycleError: (func?: (message: string, root: any) => any) => void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Base.Version.d.ts
declare module MsPortalFx.Base {
    /**
     * Runtime represention of a version number.
     */
    interface Version {
        /**
         *  The major component of the version number.
         */
        major: number;
        /**
         * The minor component of the version number.
         */
        minor: number;
        /**
         * The build component of the version number.
         */
        build: number;
        /**
         * The revision component of the version number.
         */
        revision: number;
        /**
         * Serializes this version number to a string represntion.
         * The build and revision components of the version are optional and are omitted from the string if
         * they are not defined.
         *
         * @return String represention of the version number in the format major.minor[.build[.revision]].
         */
        toString(): string;
        /**
         * Compares this instance to another version.
         *
         * @param version The version which is this instance is being compared to
         * @return 0 if both versions are the same, -1 if this instance is a smaller version, 1 if this instance is a larger version.
         */
        compareTo(version: Version): number;
    }
    /**
     * Parses a version string and returns the runtime represention of the version number.
     * Version strings are in the format "major.minor[.build[.revision]]".
     * Build and revision are optional components in the version.   major and minor are required.
     * All component values cannot be negative and must be valid integers.
     * There cannot be more than 4 components in the string.
     *
     * @param version string represention of a version.
     * @return The runtime represention of the version number.
     * @throws Will throw a Error if the string is not a valid version string.
     */
    function getVersionFromString(version?: string): Version;
    /**
     * Tries to convert the string representation of a version number to an equivalent
     * MsPortalFx.Base.Version object, and returns a result that indicates whether the conversion
     * succeeded and the version object if it did.
     *
     * A string that contains a version number to convert.
     */
    function tryParseVersion(version: string): Version;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Internal\Base.Diagnostics.Net.d.ts
declare module FxImpl.NetDiagnostics {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import FxHelpers = Fx.Helpers;
    import NetAjaxSettings = FxBase.Net2.NetAjaxSettings;
    function tryCreateTelemetry<T>(settings: NetAjaxSettings<T>): NetworkTelemetry<T>;
    function resetTelemetryTimer(): void;
    class NetworkTelemetry<T> {
        private _settings;
        private _startTime;
        constructor(settings: NetAjaxSettings<T>);
        success(jqXHR: FxHelpers.XMLHttpRequestLike): void;
        error(jqXHR: FxHelpers.XMLHttpRequestLike): any;
        private _result(jqXHR, actionModifier, duration);
        private _size(data);
    }
    function registerTelemetrySubmissionHandler(): void;
    function traceResourceDownloads(entries?: PerformanceResourceTiming[]): void;
    function traceDocumentNavigation(): BootstrapTelemetry;
    /**
     * Add a trace of the CDN instance used.
     */
    function traceCdnIndex(): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Internal\Base.Intl.d.ts
declare module MsPortalFx.Intl {
    interface NumberFormatOptions {
        /**
         * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
         */
        localeMatcher?: string;
        /**
         * The formatting style to use. Possible values are "decimal" for plain number formatting, "currency" for currency formatting, and "percent" for percent formatting; the default is "decimal".
         */
        style?: string;
        /**
         * The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB. There is no default value; if the style is "currency", the currency property must be provided.
         */
        currency?: string;
        /**
         * How to display the currency in currency formatting. Possible values are "symbol" to use a localized currency symbol such as , "code" to use the ISO currency code, "name" to use a localized currency name such as "dollar"; the default is "symbol".
         */
        currencyDisplay?: string;
        /**
         * Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators. Possible values are true and false; the default is true.
         */
        useGrouping?: boolean;
        /**
         * The minimum number of integer digits to use. Possible values are from 1 to 21; the default is 1.
         */
        minimumIntegerDigits?: number;
        /**
         * The minimum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information).
         */
        minimumFractionDigits?: number;
        /**
         * The maximum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0.
         */
        maximumFractionDigits?: number;
        /**
         * The minimum number of significant digits to use. Possible values are from 1 to 21; the default is 1.
         */
        minimumSignificantDigits?: number;
        /**
         * The maximum number of significant digits to use. Possible values are from 1 to 21; the default is minimumSignificantDigits.
         */
        maximumSignificantDigits?: number;
    }
    interface DateTimeFormatOptions {
        /**
         * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
         */
        localeMatcher?: string;
        /**
         * The representation of the weekday. Possible values are "narrow", "short", "long".
         */
        weekday?: string;
        /**
         * The representation of the era. Possible values are "narrow", "short", "long".
         */
        era?: string;
        /**
         * The representation of the year. Possible values are "numeric", "2-digit".
         */
        year?: string;
        /**
         * The representation of the month. Possible values are "numeric", "2-digit", "narrow", "short", "long".
         */
        month?: string;
        /**
         * The representation of the day. Possible values are "numeric", "2-digit".
         */
        day?: string;
        /**
         * The representation of the hour. Possible values are "numeric", "2-digit".
         */
        hour?: string;
        /**
         * The representation of the minute. Possible values are "numeric", "2-digit".
         */
        minute?: string;
        /**
         * The representation of the second. Possible values are "numeric", "2-digit".
         */
        second?: string;
        /**
         * The representation of the time zone name. Possible values are "short", "long".
         */
        timeZoneName?: string;
        /**
         * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
         */
        formatMatcher?: string;
        /**
         * Whether to use 12-hour time (as opposed to 24-hour time). Possible values are true and false; the default is locale dependent.
         */
        hour12?: boolean;
        /**
         * The time zone to use. The only value implementations must recognize is "UTC"; the default is the runtime's default time zone. Implementations may also recognize the time zone names of the IANA time zone database, such as "Asia/Shanghai", "Asia/Kolkata", "America/New_York".
         */
        timeZone?: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Internal\Internal.Base.Diagnostics.Telemetry.Context.d.ts
declare module FxImpl.TelemetryContext {
    import ContextValue = MsPortalFx.Base.Diagnostics.Telemetry.Context.ContextValue;
    enum ContextType {
        Journey = 0,
        Part = 1,
        Blade = 2,
        CompositionItem = 3,
    }
    /**
    * The current values for all provided context types.
    */
    interface ContextValues extends StringMap<ContextValue> {
    }
    /**
     * Allows saving and restoring all context state when logical operations begin and end.
     */
    interface State {
    }
    /**
     * Contributes data of the specified type to the current context.
     *
     * @param contextType The type of context.
     * @param value Value of the context.
     */
    function setContextValue(contextType: ContextType, value: ContextValue): void;
    /**
     * Removes the most recent value for this context type.
     *
     * @param name The type of context.
     */
    function resetContextValue(contextType: ContextType): void;
    /**
     * Provide a context value during an operation.
     *
     * @param action The operation to execute.
     * @param contextType The type of context.
     * @param value Value of the context.
     * @return The return value of the operation.
     */
    const provideContext: <T>(action: () => T, contextType: ContextType, value: ContextValue) => T;
    /**
     * Gets the most recent value for this context type.
     *
     * @param contextType The type of context.
     * @return The value if one.
     */
    function getCurrentValue<T extends ContextValue>(contextType: ContextType): T;
    /**
     * Gets all of the most recent values for all context types.
     *
     * @return The values.
     */
    function getCurrentValues(): ContextValues;
    /**
     * Returns the current state that can be restored later.
     *
     * @return The state.
     */
    function getState(): State;
    /**
    * Provide a state during an operation.
    *
    * @param action The operation to execute.
    * @param state The state.
    * @return The return value of the operation.
    */
    const usingState: <T>(action: () => T, state: State) => T;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Base\Internal\ObservableMap.d.ts
declare module MsPortalFx.Base.Internal {
    /**
     * An observable map. This interface is immutable.
     * All method except latch SHOULD prefix with "_" such that PO should not expose the other side of iFrame.  None should use any of these methods across iframe.
     */
    interface IObservableMap<T> {
        /**
         * Equivalent to doing () on an observable. Triggers updates in computeds, etc.
         * This is intentional to expose latch as KnockoutObservable such that the other IFrame can get access to the data as a method call.
         *
         *
         * @return The underlying map.
         */
        latch: KnockoutReadOnlyObservableBase<StringMap<T>>;
        /**
         * Returns the item associated with key in the map.
         *
         * @param key The key to look up.
         * @return The item associated with the key value pair.
         */
        lookup(key: string): T;
        /**
         * Iterates through each object in the observable map.
         *
         * @param callback The function that gets called on each item in the map.
         */
        forEach(callback: (value: T, key: string) => void, thisArg?: any): void;
        /**
         * Determines whether all the members of an array satisfy the specified test.
         *
         * @param callbackfn A function that accepts up to two arguments. The every method calls the callbackfn function for each element in the map until the callbackfn returns false, or until the end of the map.
         * @return True if the callback function returns true for all map elements, false otherwise.
         */
        every(callbackfn: (value: T, key: string) => boolean, thisArg?: any): boolean;
        /**
         * Determines whether the specified callback function returns true for any element of a map.
         *
         * @param callbackfn A function that accepts up to two arguments. The some method calls the callbackfn function for each element in the map until the callbackfn returns true, or until the end of the map.
         * @return True if the callback function returns true for at least one map element, false otherwise.
         */
        some(callbackfn: (value: T, key: string) => boolean, thisArg?: any): boolean;
        /**
         * Creates an Array<T> from the elements of the map.
         * @return The instance of the array with flattened map elements.
         */
        toArray(): Array<T>;
        /**
         * Creates a projection of the observable map.
         *
         * @param transform A function that transforms object in this map into objects in the projection.
         * @param transform A function that transforms object in this map into objects in the projection, optionally using the old generated value.
         * @return The projected map.
         */
        map<U>(lifetimeManager: MsPortalFx.Base.LifetimeManager, transform: (value: T, oldValue?: U) => U): IObservableMap<U>;
        /**
         * Gets the number of items in the observable map.
         */
        count: number;
        /**
         * Disposes of the map. Don't call this. Any maps that need cleaning up will require a lifetime manager.
         */
        dispose(): void;
        /**
         * Subscribes to an observable map.
         *
         * @param lifetimeManager The manager responsible for disposing of the subscription.
         * @param callback Called when the map changes.
         * @param target See observable subscribe function.
         * @param topic See observable subscribe function.
         * @return The subscription to the map.
         */
        subscribe(lifetimeManager: Base.LifetimeManager, callback: (newValue: StringMap<T>) => void, target?: any, topic?: string): KnockoutSubscription<StringMap<T>>;
    }
    /**
     * An observable map. This interface is mutable.
     * All method SHOULD prefix with "_" none of the object method expected to be executed in the other iFrame.
     */
    interface IMutableObservableMap<T> extends IObservableMap<T> {
        /**
         * Associates the passed key with the passed value.
         *
         * @param the key of the key/value pair.
         * @param the value of the key/value pair.
         */
        put(key: string, value: T): void;
        /**
         * Prevents any knockout notifications until the passed callback executes.
         * Anytime you need to push lots of key value pairs, you should do it in the passed callback.
         * This function also locks any dependant maps (projections or unions) so they too only fire one
         * update.
         *
         * @param callback the function to call before notifying subsribers.
         */
        modify(callback: () => void): void;
        /**
         * Removes all items from the observable map.
         */
        clear(): void;
        /**
         * Removes the key/value pair from the map. Throws if the key is not present in the map.
         *
         * @param key The key (and its corresponding value) to remove from the map.
         */
        remove(key: string): void;
    }
    /**
     * An observable map/dictionary. When you add or remove key value pairs, it notifies subscribers.
     * Can be used in computeds and like any other observable except that you use .latch() to read the map
     * and put, remove, and clear to mutate the map.
     */
    class ObservableMap<T> implements IMutableObservableMap<T> {
        /**
         * Actual string map that stores the values.
         */
        _modifyMap: StringMap<T>;
        /**
         * Maps, dependent on this one.
         */
        _dependantMaps: ObservableMap<any>[];
        /**
         * The internal workings of observable map. For access the readonly observable, please use latch()
         */
        private _observable;
        private _isInModifyBlock;
        /**
         * See interface.
         */
        put(key: string, value: T): void;
        /**
         * See interface.
         */
        lookup(key: string): T;
        /**
         * See interface.
         */
        modify(callback: () => void): void;
        /**
         * See interface.
         */
        latch: KnockoutObservable<StringMap<T>>;
        /**
         * See interface.
         */
        clear(): void;
        /**
         * See interface.
         */
        count: number;
        /**
         * See interface.
         */
        remove(key: string): void;
        /**
         * See interface.
         */
        forEach(callback: (value: T, key: string) => void, thisArg?: any): void;
        /**
         * See interface.
         */
        some(callback: (value: T, key: string) => boolean, thisArg?: any): boolean;
        /**
         * See interface.
         */
        every(callback: (value: T, key: string) => boolean, thisArg?: any): boolean;
        /**
         * See interface.
         */
        toArray(): Array<T>;
        /**
         * See interface.
         */
        dispose(): void;
        /**
         * See interface.
         */
        subscribe(lifetimeManager: Base.LifetimeManager, callback: (newValue: StringMap<T>) => void, target?: any, topic?: string): KnockoutSubscription<StringMap<T>>;
        /**
         * See interface.
         */
        map<U>(lifetimeManager: MsPortalFx.Base.LifetimeManager, transform: (value: T, oldValue?: U) => U): IObservableMap<U>;
        /**
         * Adds a map as a dependant. Whenever the user adds or removes a key, this change gets reflected
         * in all dependant maps.
         *
         * @param map The map that depends on us. Generic parameter is any instead of T because projections are generally a different type.
         */
        _addDependantMap(map: ObservableMap<any>): void;
        /**
         * Removes a dependant observable map. The map will no longer receive updates from this map.
         *
         * @param map The map to remove as a dependancy. Generic parameter is any instead of T because projections are generally a different type.
         */
        _removeDependantMap(map: ObservableMap<any>): void;
        /**
         * Called when an an upstream map adds a key value pair.
         *
         * @param key The added key.
         * @param value The added value. Type is any because projections may have a different type than the parent map.
         */
        _putNotification(key: string, value: any): void;
        /**
         * Called when an upstream map removes a key.
         *
         * @param key The key removed.
         */
        _removeNotification(key: string): void;
        /**
         * Called when an upstream map removes all keys
         *
         * @param map The map being cleared.
         */
        _clearNotification(map: IObservableMap<any>): void;
        private _validateKey(key);
    }
    /**
     * A projection of an observable map. Whenever a key/value pair gets added to the base map,
     * a transformed object with the same key gets added to the projection. Removing from or clearing
     * the base map reflects in the projection as well.
     * Map.project is an easier was to create these.
     */
    class ObservableMapProjection<T, U> extends ObservableMap<U> {
        private _transform;
        private _map;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, map: ObservableMap<T>, transform: (value: T) => U);
        /**
         * See parent.
         */
        dispose(): void;
        /**
         * Projections are immutable. Throws an exception.
         */
        put(key: string, value: U): void;
        /**
         * Projections are immutable. Throws an exception.
         */
        remove(key: string): void;
        /**
         * Projections are immutable. Throws an exceptions.
         */
        clear(): void;
        /**
         * See parent.
         */
        _putNotification(key: string, value: T): void;
        /**
         * See parent.
         */
        _removeNotification(key: string): void;
        /**
         * See parent.
         */
        _clearNotification(map: IObservableMap<any>): void;
    }
    /**
     * Contains the union of key/value pairs on any number of other maps.
     */
    class ObservableMapUnion<T> extends ObservableMap<T> {
        private _maps;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, ...maps: IObservableMap<T>[]);
        /**
         * See interface.
         */
        dispose(): void;
        /**
         * Unions are immutable. Throws an exceptions.
         */
        put(key: string, value: T): void;
        /**
         * Unions are immutable. Throws an exceptions.
         */
        remove(key: string): void;
        /**
         * Unions are immutable. Throws an exceptions.
         */
        clear(): void;
        /**
         * See parent.
         */
        _putNotification(key: string, value: T): void;
        /**
         * See parent.
         */
        _removeNotification(key: string): void;
        /**
         * See parent.
         */
        _clearNotification(map: IObservableMap<any>): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Blades\BladesBase.d.ts
declare module MsPortalFx.Blades {
    /**
     * Blade pairing states.
     */
    enum BladePairing {
        /**
         * Blade is not paired.
         */
        None = 0,
        /**
         * Blade is the master of the blade pair.
         */
        Master = 1,
        /**
         * Blade is the details of the blade pair.
         */
        Details = 2,
    }
    /**
     * Blade pairing modes.
     */
    enum BladePairingMode {
        /**
         * Blades are not paired.
         */
        None = 0,
        /**
         * Blades are paired in fullscreen mode.
         */
        Fullscreen = 1,
        /**
         * Blades are paired in windowed mode.
         */
        Windowed = 2,
    }
    /**
     * Represents the different display states of the blade.
     */
    enum DisplayState {
        /**
         * The blade is minimized.
         */
        Minimized = 0,
        /**
         * The blade is displayed in its regular format.
         */
        Normal = 1,
        /**
         * The blade is maximized.
         */
        Maximized = 2,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Blades\BladeStyle.d.ts
declare module MsPortalFx.Blades {
    enum BladeStyle {
        /**
         * The action blade, the one that has commands. This is also the default blade.
         */
        Action = 1,
        /**
         * The information blade.
         */
        Info = 2,
        /**
         * The blade style for the create scenario, which contains an action bar.
         */
        Create = 3,
        /**
         * The blade style for the filter scenario.
         */
        Context = 4,
        /**
         * The blade style for help content.
         */
        Help = 5,
        /**
         * The blade that displays basic information and has no padding around its content.
         */
        Basic = 6,
        /**
         * The context blade style with commands.
         */
        ContextAction = 7,
        /**
         * The blade that displays basic information and has no padding around its content. Allows for commands.
         */
        BasicWithCommands = 8,
        /**
         * The blade style for hub.
         */
        Hub = 9,
        /**
         * The blade style for hub submenu.
         */
        HubSubMenu = 10,
        /**
         * The blade style for settings blade.
         */
        ResourceSetting = 11,
        /**
         * The app blade.
         */
        App = 12,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Blades\BladeWidth.d.ts
declare module MsPortalFx.Blades {
    enum BladeWidth {
        /**
         * A small blade width, using 3 azure grid columns.
         */
        Small = 0,
        /**
         * A medium blade width, using 6 azure grid columns.
            This is the default width when unspecified.
         */
        Medium = 1,
        /**
         * A large blade width, using 9 azure grid columns.
         */
        Large = 2,
        /**
         * An extra large blade width, using 12 azure grid columns.
         */
        XLarge = 3,
        /**
         * A blade width used for rendering a blade with a menu.
         */
        Menu = 51,
        /**
         * A blade that expand based on its content, using a minimum of 9 azure grid columns.
         */
        Expandable = 101,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Blades\PairParentWidth.d.ts
declare module MsPortalFx.Blades {
    enum PairParentWidth {
        /**
         * A small blade width, using 3 azure grid columns.
            This is the default width when unspecified.
         */
        Small = 0,
        /**
         * A medium blade width, using 6 azure grid columns.
         */
        Medium = 1,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Composition\Composition.Blade.d.ts
declare module FxImpl.Composition.Blade {
    import FxCompositionConfiguration = MsPortalFx.Composition.Configuration;
    import ShieldType = MsPortalFx.ViewModels.ShieldType;
    interface OperationOptions {
        /**
         * If true, indicates that the Part UI should be blocked (non-interactive) until the operation finishes.
         */
        blockUi: boolean;
        /**
         * The type of blocking shield that will appear if UI is blocked.
         */
        shieldType?: ShieldType;
    }
    interface OperationList {
        /**
         * Adds an operation to the list.
         *
         * @param promise A promise representing the operation to be added.
         * @param options Additional options describing how the operation should be visualized.
         */
        add(promise: MsPortalFx.Base.Promise, options?: OperationOptions): void;
        /**
         * Removes an operation from the list.
         *
         * @param promise The promise matching the operation to remove.
         */
        remove(promise: MsPortalFx.Base.Promise): void;
        /**
         * Updates the options associated with an operation list entry.
         *
         * @param promise The promise matching the operation to update.
         * @param options New options for the operation.
         */
        update(promise: MsPortalFx.Base.Promise, options: OperationOptions): void;
        /**
         * Describes the options associated with an operation list entry.
         *
         * @param promise The promise matching the operation to update.
         * @return Options associated with the operations.
         */
        getOptionsForOperation(promise: MsPortalFx.Base.Promise): OperationOptions;
    }
    interface Container extends MsPortalFx.ViewModels.ContainerContract, MsPortalFx.ViewModels.BladeManagement {
        /**
         * Activates this Blade's 'Configuration', which is an API that enables the Blade to manage parameter and settings overrides/inheritance via
         * configuration UI (typically via a Context Blade).  See the MsPortalFx.Composition.Configuration.Contract interface for details.
         *
         * @param options Options used to initialize the Configuration API for this Part
         * @return The Configuration API for this Part
         */
        activateConfiguration<TSettings>(options?: FxCompositionConfiguration.Blade.Options<TSettings>): FxCompositionConfiguration.Blade.Contract<TSettings>;
        /**
         * Tracks the list of asynchronous operations being performed by the Blade.
         */
        operations: OperationList;
        /**
         * Moves the blade into a 'not found' display mode, allowing for an optional custom error message.
         *
         * @param message An optional custom error message.
         */
        notFound(message?: string): void;
        /**
         * Moves the blade into an 'unauthorized' display mode, allowing for an an optional custom error message.
         *
         * @param message A custom error message in place of the default.
         */
        unauthorized(message?: string): void;
        /**
         * Shows an error message.
         *
         * @param message A message that will be displayed to the user when the blade fails.
         */
        fail(message: string): void;
        /**
         * Removes any 'failed' error message and brings the blade back to 'ready' state.
         * If the blade was not already in a 'failed' state, this method does nothing.
         */
        recover(): void;
        /**
         * Causes the blades's content to be revealed immediately, regardless of any onInputsSet promise that
         * might not yet have completed. This removes the opaque 'loading' spinner and makes the blae interactive,
         * so you must also disable or hide any UI elements that the user should not be able to see or interact with
         * until data is fully loaded.
         */
        revealContent(): void;
        /**
         * The message displayed by the Part when it has no data to display.
         */
        noDataMessage: KnockoutObservable<string>;
        /**
         * Closes this blade
         *
         * @param data Optional value to return back to the parent blade
         * @return a promise that resolves to true if the this blade is successfully closed.
         */
        closeCurrentBlade(data?: any): Q.Promise<boolean>;
        /**
         * Closes the child blade that is currently open
         *
         * @return a promise that resolves to true if the child blade is successfully closed.
         */
        closeChildBlade(): Q.Promise<boolean>;
        /**
         * Closes the context blade that was opened by this part
         *
         * @returns a promise that resolves to true if the context blade is sucessfully closed.
         */
        closeContextBlade(): Q.Promise<boolean>;
    }
}
declare module "Fx/Composition/Blade" {
    import Impl = FxImpl.Composition.Blade;
    export = Impl;
}
declare module FxImpl.Composition.BladeContainer {
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * This class is purely implementation and should never be referenced by extensions
     */
    class BladeContainer extends FxViewModels.PartContainer {
        constructor(internal: FxImpl.ViewModels.FrameworkPartViewModelContract, options?: FxViewModels.PartContainerOptions);
        /**
         * This is a public property on the class, but it is prefixed with a _ so it is not proxied to the shell.
         * This property is accessed by parameter provider to listen for output from the actionbar.
         */
        _actionBar: KnockoutObservable<FxViewModels.ActionBars.Base.ViewModel>;
    }
    function bindActionBar(container: BladeContainer, viewModel: any): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Composition\Composition.Configuration.d.ts
declare module MsPortalFx.Composition.Configuration {
    namespace Part {
        /**
         * This is the Part Configuration API which is available as 'container.activateConfiguration()'.
         *
         * This Configuration is an opt-in means of expanding upon the Part such that:
         * - 'onInvoke'/'onInputsSet' is passed both:
         *   - parameters (passable from caller, bindable to values at the Dashboard level) and
         *   - settings (internal, persisted state that is never passed from caller or acquired from the Dashbaord).
         * - Parameter values can be overridden by the user (via configuration in the Context Pane).  When overridden, values passed by the
         * caller or acquired from the Dashboard via binding are ignored.
         */
        interface Contract<TParameters, TSettings> {
            /**
             * A means of extracting all current parameter/settings values along with their metadata.
             * Typically, this is called in a 'supplyInitialData' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @return Current Configuration values along with value metadata.
             */
            getValues(): ValuesWithMetadata<TParameters, TSettings>;
            /**
             * A means of atomically committing Configuration changes, typically from a ParameterProvider Blade.
             * Typically, this is called from a 'receiveResult' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @param newValues New Configuration values and value metadata reflecting the new state of the Part Configuration.
             */
            updateValues(newValues: ValuesWithMetadata<TParameters, TSettings>): void;
        }
        /**
         * Options passed to 'container.activateConfiguration()'.
         */
        interface Options<TParameters, TSettings> {
        }
        /**
         * A representation of the current values in a Part's Configuration, along with metadata for each value.
         * Useful for passing to a "Configure..." ParameterProvider Blade for user-editing of Configuration values.
         * Also useful for returning from this same "Configure..." ParameterProvider Blade to the calling Part.
         */
        interface ValuesWithMetadata<TParameters, TSettings> {
            /**
             * TParameters-typed values that will be supplied to this Part's 'onInvoke'/'onInputsSet'.  In addition to TParameters, this
             * includes metadata describing each parameter value.
             */
            parameters: ParameterValuesWithMetadata<TParameters>;
            /**
             * TSettings typed Part settings that will be supplied to this Part's 'onInvoke'/'onInputsSet'.
             */
            settings: TSettings;
        }
        /**
         * TParameters-typed values that will be supplied to this Part's 'onInvoke'/'onInputsSet'.  In addition to TParameters, this
         * includes metadata describing each parameter value.
         */
        interface ParameterValuesWithMetadata<TParameters> {
            /**
             * The parameter values.
             */
            values: TParameters;
            /**
             * Currently relevant for Parts only (and not for Blades).
             * Metadata covering each of the parameter values.
             */
            metadata: StringMap<ParameterMetadata>;
        }
    }
    namespace Blade {
        /**
         * Options passed to 'container.activateConfiguration()'.
         */
        interface Options<TSettings> {
        }
        /**
         * This is the Blade Configuration API which is available as 'container.activateConfiguration()'.
         *
         * This Configuration is an opt-in means of expanding upon the Blade such that:
         * - 'onInvoke'/'onInputsSet' is passed:
         *   - settings (internal, persisted state).
         */
        interface Contract<TSettings> {
            /**
             * A means of extracting all current settings values along with their metadata.
             * Typically, this is called in a 'supplyInitialData' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @return Current Configuration values along with value metadata.
             */
            getValues(): ValuesWithMetadata<TSettings>;
            /**
             * A means of atomically committing Configuration changes, typically from a ParameterProvider Blade.
             * Typically, this is called from a 'receiveResult' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @param newValues New Configuration values and value metadata reflecting the new state of the Blade Configuration.
             */
            updateValues(newValues: ValuesWithMetadata<TSettings>): void;
        }
        /**
          * A representation of the current values in a Blade's Configuration, along with metadata for each value.
          * Useful for passing to a "Configure..." ParameterProvider Blade for user-editing of Configuration values.
          * Also useful for returning from this same "Configure..." ParameterProvider Blade to the calling Blade.
          */
        interface ValuesWithMetadata<TSettings> {
            /**
             * TSettings typed Blade settings that will be supplied to this Blade's 'onInvoke'/'onInputsSet'.
             */
            settings: TSettings;
        }
    }
    /**
     * Per-parameter metadata returned from 'config.getValues()' or supplied by the extension when calling 'config.updateValues()'.
     */
    interface ParameterMetadata {
        /**
         * Reflects whether the corresponding Part is currently situated on a Dashboard and, if so, whether this parameter value can
         * be bound to values at the Dashboard-level.  For the extension, a non-empty array here should determine whether -- in the
         * "Configure..." Context Pane -- the user should be presented with UI to choose whether to bind to a Dashboard-level value.
         */
        bindingSources: ParameterBindingSource[];
        /**
         * Used only if the 'bindingSources' array above is non-empty.
         * Re: 'config.getValues()', indicates whether this pContractarameter value is currently bound to a value from the containing Dashboard.
         * Re: 'config.updateValues()', determines whether this parameter value should be bound to a value from the containing Dashboard.
         * If 'activeBindingSourceName' is not supplied, then any user-specified value for this parameter will be used to override
         * the value that would otherwise be acquired via binding from the containing Dashboard.
         */
        activeBindingSourceName: string;
        /**
         * Re: 'config.updateValues()', determines whether this updated parameter value should be applied to the containing dashboard.
         * This value is used only if the 'bindingSources' array is non-empty and 'activeBindingSourceName' names a binding source from
         * 'bindingSources'.
         */
        applyUpdatedValueToActiveBindingSource?: boolean;
    }
    /**
     * A description of a Dashboard-level property to which a parameter can be bound.
     */
    interface ParameterBindingSource {
        /**
         * The runtime name of the property at the Dashboard level.
         */
        name: string;
        /**
         * Indicates whether this Dashboard-level property accepts value updates (see
         * 'ParameterMetadata.applyUpdatedValueToActiveBindingSource').
         */
        acceptsValueUpdates: boolean;
    }
    /**
     * Part/Blade parameter and settings values.
     */
    interface Values<TParameters, TSettings> {
        /**
         * Parameter values.
         */
        parameters: TParameters;
        /**
         * Settings values.
         */
        settings: TSettings;
    }
    /**
     * Represents either an absolute or relative time range.
     */
    interface TimeRange {
        /**
         * An absolute time range.
         */
        absolute?: {
            /**
             * The start of the time range.
             */
            from: Date;
            /**
             * The end of the time range.
             */
            to: Date;
        };
        /**
         * A relative time range.
         */
        relative?: {
            /**
             * The duration for the relative time range.
             */
            duration: number;
            /**
             * The time unit for the duration of the relative time range.
             */
            timeUnit: TimeUnit;
        };
    }
    /**
     * Values represent units of time.  Used in TimeRange.
     */
    enum TimeUnit {
        Minute = 0,
        Hour = 1,
        Day = 2,
        Week = 3,
        Month = 4,
        Year = 5,
    }
    /**
     * A parameter value type that a Part can acquired from its Dashboard via binding.
     */
    type ValueType = string;
    /**
     * A value type that for TimeRange.
     */
    const TimeRangeValueType: string;
}
declare module FxImpl.Composition {
    import FxCompositionConfiguration = MsPortalFx.Composition.Configuration;
    /**
     * The signature for a callback that informs the Part/Blade that its Configuration has changed value in some way.
     */
    type ConfigurationChangedHandler = (values: FxCompositionConfiguration.Part.ValuesWithMetadata<any, any>) => void;
    /**
     * See the MsPortalFx.Composition.Configuration.Contract for details.
     */
    class Configuration<TParameters extends StringMap<any>, TSettings extends StringMap<any>> implements FxCompositionConfiguration.Part.Contract<TParameters, TSettings>, FxCompositionConfiguration.Blade.Contract<TSettings> {
        private _persistedValues;
        private _configChangedHandler;
        /**
         * Constructs a Configuration object.
         *
         * @param options Options that determine the behavior of the Configuration object.
         * @param configChangedHandler A callback that notifies when the Part/Blade's Configuration has changed in some way.
         */
        constructor(options: FxCompositionConfiguration.Part.Options<TParameters, TSettings>, configChangedHandler: ConfigurationChangedHandler);
        /**
         * This will be called by the FX/Shell once the Part has been bound into its containing dashboard/Blade.
         *
         * @param values Parameter and settings values including metadata describing whether parameters are bound/bindable
         * to the containing dashboard or Blade.
         */
        setValues(values: FxCompositionConfiguration.Part.ValuesWithMetadata<any, any>): void;
        /**
         * See interface.
         */
        getValues(): FxCompositionConfiguration.Part.ValuesWithMetadata<TParameters, TSettings>;
        /**
         * See interface.
         */
        updateValues(newValues: FxCompositionConfiguration.Part.ValuesWithMetadata<TParameters, TSettings>): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Composition\Composition.PartReference.d.ts
declare module MsPortalFx.Composition {
    interface PartReferenceOptions {
        /**
         * The name of the extension that owns the part.
         */
        extensionName?: string;
        /**
         * The initial size of the part.
         */
        initialSize?: MsPortalFx.Parts.PartSize;
        /**
         * If initialSize is Custom, this specifies the number of grid rows to cover.
         */
        initialHeight?: number;
        /**
         * If initialSize is Custom, this specifies the number of grid columns to cover.
         */
        initialWidth?: number;
    }
    /**
     * Identifies the part that is referenced
     */
    class PartReference<TParameters> {
        /**
         * The name of the part.
         */
        partName: string;
        /**
         * Parameters that are passed to the target part
         */
        parameters: TParameters;
        /**
         * Options to create the target part
         */
        options: PartReferenceOptions;
        /**
         * PartReference constructor
         *
         * @param partName partName of the referenced part
         * @param parameters parameters that are passed to the target part
         * @param options options that are used to create the target part
         */
        constructor(partName: string, parameters: TParameters, options?: PartReferenceOptions);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Composition\Composition.Selectable2.d.ts
declare module FxImpl {
    /**
     * Interface to expose the internal cloudName property from an instance of PdlBladeReference or its children classes.
     * Do not implement this interface, it is for strongly typed casting only.
     * Extension authors should not use it.
     */
    interface CloudAwareBladeReference {
        /**
         * Name of the cloud
         */
        cloudName?: string;
    }
    /**
     * Method for accessing the interface which is used as a channel of communication between
     * the shell and the public facing SDK Apis that extension use.
     *
     * @param viewModel framework view model that the shell interface is attached to.   This view model is the public facing API
     * @param initialValue if not null, the shell interface is initialized with the provided object
     */
    function shellInterface<T>(viewModel: any, initialValue?: T): T;
    module CompositionCore {
        /**
         * Supplies the reason a Blade was closed, for instance, to the opening BladeReference's 'onClosed' callback.
         */
        const enum BladeClosedReason {
            /**
             * The blade was closed in reaction to some user navigation.
             */
            UserNavigation = 1,
            /**
             * The child blade closed itself programmatically.
             */
            ChildClosedSelf = 2,
        }
        /**
         * The function typing for 'onClosed' callbacks for Blades.
         */
        type BladeClosedHandler = (reason: BladeClosedReason) => void;
        /**
         * The function typing for 'onClosed' callbacks for Blades, returning data from the Blade to the callback.
         */
        type BladeClosedWithDataHandler<TData> = (reason: BladeClosedReason, data: TData) => void;
        /**
         * A view model that represents a click target that opens a link.
         */
        class ClickableLink extends MsPortalFx.ViewModels.ClickableLink {
        }
    }
    module Composition.Selectable {
        /**
         * Identifies the target blade that is to be opened
         */
        class BladeReference<TParameters> {
            private _msPortalFxCallbacks;
            /**
             * BladeReference constructor
             *
             * @param parameters parameters that are passed to the target blade
             */
            constructor(parameters: TParameters, callbacks?: any);
            /**
             * Parameters that are passed to the target blade
             */
            parameters: TParameters;
            /**
             * Create a copy of this blade reference with new parameters
             *
             * @param parameters new set of parameters to pass to the child blade
             */
            clone(parameters: TParameters): BladeReference<TParameters>;
        }
        /**
         * Callbacks for PDL generated blades
         */
        interface PdlBladeCallbacks<TOutputs> {
            /**
             * This method is invoked when outputs are returned from a child blade
             */
            onOutputsChanged: (outputs: TOutputs) => void;
        }
        /**
         * Properties which describe the blade that is too be opened
         */
        interface PdlBladeMetadata {
            /**
             * List of outputs to receive from the child blade
             */
            outputParameters?: string[];
            /**
             * If true this blade is opened as a context blade
             */
            isContextBlade?: boolean;
            /**
             * if the blade will be opened in the context pane, true open as context, false open as detail blade
             */
            persistentContextPane?: boolean;
        }
        /**
         * Options for configuring the PdlBladeReference class
         */
        interface PdlBladeReferenceOptions<TParameters, TOutputs> {
            /**
             * Parameters to pass to the child blade
             */
            parameters?: TParameters;
            /**
             * Callbacks to invoke
             */
            callbacks?: PdlBladeCallbacks<TOutputs>;
            /**
             * Optional callback that is invoked when the blade is closed.
             */
            onClosed?: CompositionCore.BladeClosedWithDataHandler<any>;
        }
        /**
         * Base class for PDL generated blade references.
         * Extension authors should not be directly creating this class
         */
        class PdlBladeReference<TParameters, TOutputs> extends BladeReference<TParameters> {
            /**
             * Name of the blade
             */
            bladeName: string;
            /**
             * Name of the extension which this contains the blade
             */
            extensionName: string;
            /**
             * Options for this blade reference
             */
            options: PdlBladeReferenceOptions<TParameters, TOutputs>;
            /**
             * Descriptor contains blade attributes
             */
            metadata: PdlBladeMetadata;
            constructor(bladeName: string, extensionName?: string, options?: PdlBladeReferenceOptions<TParameters, TOutputs>, metadata?: PdlBladeMetadata);
        }
        interface ParameterProviderOptions<TParameters, TResult, TConfig> extends PdlBladeReferenceOptions<TParameters, void> {
            /**
             * A callback that supplies initial data for the parameter provider
             * in the child blade each time it opens.
             *
             * Note that the object received by the parameter provider will be a
             * deep clone of the value you give, rather than the original instance,
             * because it is passed (and sometimes stored) in a serialized form.
             *
             * @return Initial data for the child blade.
             */
            supplyInitialData?(): TResult;
            /**
             * A callback that supplies additional configuration options for the
             * provider each time it opens. You can use this to pass non-editable
             * data, for example configuring how a form will be displayed.
             *
             * @return Arbitrary configuration options for the child blade.
             */
            supplyProviderConfig?(): TConfig;
            /**
             * A callback to be invoked when the child blade supplies a result
             * and closes.
             *
             * @param result The result given by the child blade.
             * @param activatedItem The object whose selection launched this parameter collection process. The result refers to that object.
             */
            receiveResult?(result: TResult): void;
            /**
             * Provides an easy way to integrate a parameter collector with an EditScope.
             *
             * The collector will supply initial data to the provider from this edit scope
             * property, and will automatically insert the provider's output into this edit
             * scope property. The net result is that your parameter collector will act as
             * an editor for the specified edit scope property.
             *
             * If you specify this option, do not also specify either supplyInitialData or
             * receiveResult.
             */
            editScopeAccessor?: MsPortalFx.ViewModels.Forms.EditScopeAccessors<TResult>;
        }
        class ParameterProviderBladeReference<TParameters, TResult, TConfig> extends PdlBladeReference<TParameters, void> {
            constructor(bladeName: string, extensionName: string, options: ParameterProviderOptions<TParameters, TResult, TConfig>, metadata?: PdlBladeMetadata);
        }
        /**
         * Base class for selectable objeccts
         */
        abstract class SelectableBase<TBladeReference extends BladeReference<any>> {
            /**
             * Renavigate changes the blade which is currently opened.  It can be used to change the blade parameters
             * for a existing blade (rebinding) or open a different blade
             *
             * @param bladeReference Descriptor of the new blade to navigate too
             */
            renavigateActivatedBlade(bladeReference: TBladeReference): void;
        }
        /**
         * Configuration to pass to the selectable constructor
         */
        interface Selectable2Options<TBladeReference> {
            /**
             * This callback is invoked by the portal when a new blade is to be opened
             * in response to a user-invoked navigation.
             *
             * @return A blade reference that describes the blade to open.  This value cannot be null or undefined.
             */
            supplyBladeReference?: () => TBladeReference;
            /**
             * This callback is invoked by the portal when a new blade is to be opened
             * asychronously in response to a user-invoked navigation.
             *
             * @return A promise that returns a blade reference that describes the blade to open.  This value cannot be null or undefined.
             */
            supplyBladeReferenceAsync?: () => Q.Promise<TBladeReference>;
        }
        /**
         * Selectable class that is used to open blades in response to user clicks
         */
        class Selectable2<TBladeReference extends BladeReference<any>> extends SelectableBase<TBladeReference> {
            constructor(options: Selectable2Options<TBladeReference>);
        }
        /**
         * View models which are selectable implement this interface
         */
        interface SelectableViewModel {
            configureSelectable<TBladeReference extends BladeReference<any>>(options: Selectable2Options<BladeReference<any>>): Selectable2<TBladeReference>;
        }
        /**
         * Click handler
         */
        type OnClickHandler = () => void;
        /**
         * List click handler
         */
        type OnListClickHandler<T> = (selectedItem: T) => void;
    }
    const BladeReference: typeof Composition.Selectable.BladeReference;
    type SelectableViewModel = Composition.Selectable.SelectableViewModel;
    const enum SelectableFlags {
        None = 0,
        IsSelectable = 1,
        ActivateAsync = 2,
    }
    const enum BladeReferenceSource {
        None = 0,
        Fetch = 1,
        Renavigate = 2,
        OpenBlade = 3,
    }
    /**
     * Represents the tuple of config and initial state that is sent to
     * a provider blade.
     */
    interface InitialProviderBladeConfig<TResult, TConfig> {
        initialState: TResult;
        config: TConfig;
    }
    const enum ShellInterfaceType {
        /**
         * The interface type used to facility communication
         * between Fx.Composition.Selectable2 (extension selectable 2 API) and Base.Selectable2 (shell)
         *
         * 0x5332 is the ascii codes for 'S2';
         */
        Selectable2 = 21298,
        /**
         * The interface used for consumption by a internal shell collector instance
         */
        ParameterProviderBladeReference = 20560,
    }
    /**
     * This is the interface through which the shell interacts with
     * the ParameterProviderBladeReference instance
     */
    interface ParameterProviderShellContract<TResult, TConfig> {
        /**
         * interface type
         */
        type: ShellInterfaceType;
        /**
         * This member is used to pin the initial config that is passed to the blade.
         * This is to ensure the config PO proxy is not prematurely garbaged collected
         */
        bladeConfig: KnockoutObservable<InitialProviderBladeConfig<TResult, TConfig>>;
        /**
         * This method is invoked by the shell to get the inital config before opening the new blade on question.
         */
        getBladeConfig(seletedItem?: any): InitialProviderBladeConfig<TResult, TConfig>;
        /**
         * This method is invoked by the shell when a result is returned from the provider blade
         */
        receiveResult(result: TResult): void;
    }
    const enum OpenBladeRequestFlags {
        OpenInContextPane = 1,
        OpenAsSubJourney = 2,
    }
    interface OpenBladeRequest<TBladeReference> {
        /**
         * The reason the request is being issued to the blade opener
         */
        reason: BladeReferenceSource;
        /**
         * Blade reference
         */
        bladeReference: TBladeReference;
        /**
         * tracking id for this request
         *   Used for -
         *     Notification of open blade completion
         *     Lifetime management of callbacks (same blade reference/callback used to open same blade more than one time)
         *     Diagnostics/debugging
         */
        operationId: any;
        /**
         * various open blade flags
         */
        flags: OpenBladeRequestFlags;
        /**
         * Optional metadata attached to the open blade request by the control
         */
        controlMetadata?: any;
        /**
         * for selectable set, the selected item associated with the request
         */
        selectedItem?: any;
    }
    interface OpenBladeResult {
        operationId: any;
        success: boolean;
    }
    interface OpenBladeShellInterface<TBladeReference extends Composition.Selectable.BladeReference<any>> {
        /**
         * current blade reference that was assigned by extension to this selectable
         */
        request: KnockoutObservable<OpenBladeRequest<TBladeReference>>;
        /**
         * the result of the last open blade request.
         * this is pushed from the shell and read by the extension iFrame
         */
        result: KnockoutObservable<OpenBladeResult>;
    }
    /**
     * This is the channel through which the selectable communicates with the shell.
     *
     * Not the word interface mabye confusing here.   This is not a reference to the TypeScript type.
     */
    interface SelectableShellInterface<TBladeReference extends Composition.Selectable.BladeReference<any>> extends OpenBladeShellInterface<TBladeReference> {
        /**
         * interface type
         */
        type: ShellInterfaceType;
        /**
         * flags indicate capabilities
         */
        flags: SelectableFlags;
        /**
         * this method is invoked when shell requires a open blade request to open a new blade
         * A open blade request contains the blade reference + additional metadata
         */
        fetchRequest: () => OpenBladeRequest<TBladeReference> | Q.Promise<OpenBladeRequest<TBladeReference>>;
    }
    /**
     * This interface is the internal contract between the shell ahd the selectable view model.
     * A selectable view model is a dual honed object that supports both the legacy selectable and the new selectable.
     * This type exists for backward compat reasons.  New features probably don't need to implement this.
     *
     * This is internal implementation detail and not intended to be accessed directly by extensions.
     */
    interface SelectableViewModelContract {
        _msPortalFxIsSelectableViewModel: boolean;
        _msPortalFxSelectable: MsPortalFx.ViewModels.Selectable<any>;
        _msPortalFxSelectable2: Composition.Selectable.Selectable2<Composition.Selectable.BladeReference<any>>;
    }
    /**
     * Initializes a view model which contains a selectable.
     * Also provides a generic implementation of SelectableViewModel interface as well via a mixin.
     *
     * @param viewModel A view model that is hosting a selectable.
     * @param selectable Legacy support for selectable v1
     */
    function initializeSelectableViewModel(viewModel: SelectableViewModel, selectable: MsPortalFx.ViewModels.Selectable<any>): void;
    /**
     * Assigns a legacy selectable to a selectable view model.  To be during view model construction.
     *
     * @param viewModel the selectable view model that supports both selectable and selectable 2
     * @param selectable The legacy selectable instance
     */
    function assignSelectable(viewModel: SelectableViewModel, selectable: MsPortalFx.ViewModels.Selectable<any>): void;
    /**
     * Tries to get the internal selectable viewmodel interface for a selectable view model.
     *
     * @param viewModel The view mode for which we want to get the internal interface.
     * @returns null if the view model is not a selectable view model
     */
    function tryGetSelectableViewModelContract(viewModel: SelectableViewModel): SelectableViewModelContract;
    /**
     * Returns true if the view model is a selectable view model.
     */
    function isSelectableViewModel(viewModel: any, requireSelectable2?: boolean): viewModel is SelectableViewModelContract;
    /**
     * Returns true if view model is a selectabe 2 instance
     */
    function isSelectable2(viewModel: any): viewModel is Composition.Selectable.Selectable2<Composition.Selectable.BladeReference<any>>;
    /**
     * Helper method used by the shell to invoke a callback on a blade reference
     */
    function invokeCallback<TBladeReference extends Composition.Selectable.BladeReference<any>>(bladeReference: TBladeReference, name: string, parameters: any[]): void;
}
declare module "Fx/Composition/Selectable" {
    import Impl = FxImpl.Composition.Selectable;
    export = Impl;
}
declare module "Fx/Composition" {
    import Impl = FxImpl.CompositionCore;
    export = Impl;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Controls\Hotspot2.d.ts
declare module FxImpl {
    module Controls.HotSpot {
        import BaseViewModel = MsPortalFx.ViewModels.Controls.HotSpot.BaseViewModel;
        import Selectable = FxImpl.Composition.Selectable;
        /**
         * View model for hotspots
         */
        class ViewModel2 extends BaseViewModel {
            /**
             * Selectable that tracks if hotspot selection state
             */
            selectable: Selectable.Selectable2<any>;
            /**
             * Creates a HotSpot ViewModel.
             */
            constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, selectableOptions?: Selectable.Selectable2Options<any>, clickableDuringCustomize?: boolean);
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Controls\Menu.d.ts
declare module FxImpl {
    import FxComposition = FxImpl.Composition.Selectable;
    import Selectable = FxComposition.Selectable2;
    module Controls.Menu {
        /**
         * Attributes common to all items and groups in the menu.
         */
        interface MenuItemBase {
            /**
             * Gets the ID for the item.
             */
            id: string;
            /**
             * The display text for the item.
             */
            displayText: string;
            /**
             * A space-delimited list of keywords associated to the item.
             */
            keywords?: string | string[];
        }
        /**
         * Defines an item in a group of the menu.
         */
        interface MenuItem extends MenuItemBase, FxComposition.Selectable2Options<FxComposition.BladeReference<any>> {
            /**
             * The icon associated to the menu item.
             */
            icon: MsPortalFx.Base.Image;
            /**
             * A value indicating whether or not the item is enabled.
             */
            enabled?: KnockoutObservableBase<boolean>;
            /**
             * A value indicating whether or not the item should be visible in the menu.
             */
            visible?: KnockoutObservable<boolean>;
        }
        /**
         * Defines a group in the menu.
         */
        interface MenuGroup extends MenuItemBase {
            /**
             * The menu items in the group.
             */
            items: MenuItem[];
        }
        /**
         * The options for the menu.
         */
        interface Options {
            /**
             * Defines the overview item.
             */
            overview?: MenuItem;
            /**
             * The ID of the item to be selected by default.
             */
            defaultId?: string;
        }
    }
    interface MenuItem extends Controls.Menu.MenuItem {
        /**
         * The group that the item belongs to.
         */
        group: string;
        /**
         * The aggregated list of keywords for the menu item.
         */
        aggregatedKeywords: string;
    }
    interface MenuData {
        /**
         * The unpivoted list of menu items from all groups.
         */
        items: KnockoutObservableArray<MenuItem>;
        /**
         * A map of selectables associated to menu items.
         */
        selectableMap: KnockoutObservable<StringMap<Selectable<any>>>;
        /**
         * The Promise for the default ID.
         */
        options: KnockoutObservable<FxImpl.Controls.Menu.Options>;
        /**
         * Promise for the overview item.
         */
        overviewPromise: MsPortalFx.Base.PromiseV<MenuItem>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Dashboard.d.ts
declare module MsPortalFx.Dashboard {
    /**
     * The input of the dashboard part.
     */
    interface DashboardPartInput {
        /**
         * The name of the input.
         */
        name: string;
        /**
         * The value of the input.
         */
        value?: any;
        /**
         * The name of the target property.
         */
        binding?: string;
        /**
         * Whether or not the input is optional.
         */
        isOptional?: boolean;
    }
    /**
     * The asset info of the dashboard part.
     */
    interface DashboardPartAssetInfo {
        /**
         * The type of the asset.
         */
        type: string;
        /**
         * The name of the asset id input.
         */
        idInputName: string;
    }
    /**
     * The dashboard part.
     */
    interface DashboardPart {
        /**
         * The position of the dashboard part on the dashboard.
         */
        position: {
            /**
             * The horizontal position in dashboard cell.
             */
            x: number;
            /**
             * The vertical position in dashboard cell.
             */
            y: number;
            /**
             * The horizontal span in dashboard cell.
             */
            colSpan: number;
            /**
             * The vertical span in dashboard cell.
             */
            rowSpan: number;
        };
        /**
         * The metadata of the dashboard part.
         */
        metadata: {
            /**
             * The type of the dashboard part.
             */
            type: string;
            /**
             * The inputs of the dashboard part.
             */
            inputs: DashboardPartInput[];
            /**
             * The settings of the dashboard part.
             */
            settings?: any;
            /**
             * Whether or not it is an adapted part.
             */
            isAdapter?: boolean;
            /**
             * The view state of the dashboard part.
             */
            viewState?: any;
            /**
             * The asset info of the dashboard part.
             */
            asset?: DashboardPartAssetInfo;
            /**
             * The id of default menu item of the dashboard part.
             */
            defaultMenuItemId?: string;
        };
    }
    /**
     * The property of the dashboard model.
     */
    interface DashboardModelProperty {
        /**
         * The value of the property.
         */
        value: any;
        /**
         * The type of the property.
         */
        type: MsPortalFx.Composition.Configuration.ValueType;
    }
    /**
     * The model of the dashboard.
     */
    type DashboardModel = StringMap<DashboardModelProperty>;
    /**
     * The dashboard data.
     */
    interface Dashboard {
        /**
         * The title of the dashboard.
         */
        title: string;
        /**
         * The parts of the dashboard.
         */
        parts: DashboardPart[];
        /**
         * The model of the dashboard.
         */
        model?: DashboardModel;
    }
    /**
     * The provider of the dashboard data.
     */
    interface DashboardProvider {
        /**
         * Gets the dashboard according to the given dashboard parameter.
         */
        getDashboard(dashboardParam: string): MsPortalFx.Base.PromiseV<Dashboard>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.AtomizationOptions.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplies atomization context options.
     * If supplied, as objects sharing the same entity ID are added to the cache, only a single object instance will be used for a given entity ID.
     */
    interface AtomizationOptions {
        /**
         * Supplies the atomization context id used for cached DataSets.
         * If 'null' or 'undefined' is supplied, a default atomization context will be used.
         * Otherwise, 'atomizationContextId' identifies the atomization context to be used.
         */
        atomizationContextId?: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.DataCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A base interface for QueryCache and EntityCache.
     */
    interface DataCache<TData, TParams> {
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.DataCacheConfig.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplies configuration options for a DataCacheLoader.
     */
    interface DataCacheLoaderConfig<TEntity, TParams> {
        /**
         * Provides a URI from which data should be retrieved. The URI is a function
         * of the supplied parameters.
         *
         * Note that 'sourceUri' and 'loader' are mutually exclusive. One of these
         * must be specified, but not both.
         *
         * @param params Parameters describing the data to be retrieved. For EntityCaches, this will be the entity ID. For QueryCaches, it will be query parameters.
         * @return The URI from which data should be retrieved.
         */
        sourceUri?(params: TParams): string;
        /**
         * If true, requests issued by this DataCache will include the user's authorization header.
         *
         * This cannot be used in conjunction with supplyData, because in that case, you are taking manual control over the
         * requests that are issued.
         */
        setAuthorizationHeader?: boolean;
        /**
         * If specified, overrides how query params are mapped to cache entries.
         *
         * If you specify this, ensure that any two logically different parameter objects map to different
         * strings, and that any two logically equivalent parameter objects map to the same string.
         *
         * If not specified here, and not overridden in a custom DataCacheLoader, the default behavior
         * is to regard cache entries as equivalent if and only if they map to the same URI, not differentiating
         * by HTTP method or any other HTTP headers.
         */
        serializeParams?(params: TParams): string;
        /**
         * Specifies the HTTP method that should be used when retrieving data from
         * the configured 'sourceUri'. The default data cache loader uses 'GET' if no
         * 'httpMethod' is configured.
         *
         * Note that you can only specify an 'httpMethod' if you have specified a 'sourceUri',
         * in other words, if you are not supplying a custom loader object.
         */
        httpMethod?: string;
        /**
         * Optional. If provided, the default data loader will use any registered
         * metadata for the entity type to share entity instances across caches.
         */
        entityTypeName?: string;
        /**
         * If true, causes the loader to poll the server for updates. Defaults to false, meaning that the
         * data will only be fetched when first requested or explicitly refreshed.
         */
        poll?: boolean;
        /**
         * Specifies the interval, in milliseconds, between polls. If not set, the recommended default polling interval will be used.
         * This option only takes effect if polling is enabled. The minimum allowed value is 10000.
         */
        pollInterval?: number;
        /**
         * By default, each time the loader polls the server, it updates the local dataset to match the record order
         * in the server's response. Setting this flag to true means that the loader should skip that behavior and
         * instead preserve the client's existing record order when polling.
         */
        pollPreservesClientOrdering?: boolean;
        /**
         * If specified, the DataCache loader should call this to obtain raw JSON data to be merged into the cache.
         * A typical implementation simply performs an ajax request. Usually, the parameters (httpMethod, uri, etc.)
         * are determined by the corresponding options on your DataCacheConfig, but if you implement a custom DataCache
         * loader, then it's possible to vary these programmatically.
         *
         * @param httpMethod The HTTP method to be used.
         * @param uri The URI from which data should be fetched.
         * @param headers Any HTTP headers that should be sent with the request.
         * @param data Any data to be sent in the body of the request.
         * @param params The parameters describing the cache entry for which data is being fetched.
         * @param entryLifetime A lifetime manager object representing the duration that the entry remains in the cache.
         * @return A promise representing the completion of the request. The promise's result value should be a JavaScript object or array representing the response.
         */
        supplyData?(httpMethod: string, uri: string, headers: StringMap<any>, data: any, params: TParams, entryLifetime: MsPortalFx.Base.LifetimeManager): MsPortalFx.Base.Promise;
        /**
         * If specified, the DataCache loader will call this each time any data is fetched. This callback
         * should translate the response object into a data array, and optionally, navigation metadata.
         *
         * @param responseData The response object to be processed.
         * @return A DataCacheProcessedResponse representing the data, and optionally navigation metadata.
         */
        processServerResponse?(responseData: any): DataCacheProcessedResponse;
        /**
         * If supplied, as objects sharing the same entity ID are added to the cache, only a single object instance will be used for a given entity ID.
         */
        atomizationOptions?: AtomizationOptions;
    }
    /**
     * Supplies configuration options for a DataCache (an EntityCache or QueryCache).
     */
    interface DataCacheConfig<TEntity, TParams> extends DataCacheLoaderConfig<TEntity, TParams> {
        /**
         * An object that can supply data for a DataCache.
         *
         * Note that 'sourceUri' and 'loader' are mutually exclusive. One of these
         * must be specified, but not both.
         */
        loader?: DataCacheLoader<TEntity, TParams>;
        /**
         * Deprecated. Causes cache entries to remain in memory for a specified period after
         * their last referrer is removed.
         *
         * Please do not use this option. It is deprecated and will be removed. Instead, set
         * the 'extendEntryLifetimes' option to 'true'.
         */
        evictionDelay?: number;
        /**
         * If true, cache entries will be retained in memory for a framework-controlled period even when
         * no other objects are referring to them. This makes the cache perform better: future 'fetch'
         * operations are more likely to be satisfied without needing to wait for HTTP requests.
         *
         * We recommend that you always enable this option. Please ensure that none of your other code
         * relies on cache entries being evicted synchronously.
         */
        extendEntryLifetimes?: boolean;
    }
    /**
     * Represents data that may be merged into a cache.
     */
    interface DataCacheProcessedResponse {
        /**
         * The item object, or items array, that should be merged into the cache.
         */
        data: any;
        /**
         * Optional navigation metadata corresponding to the cache entry. This supports
         * navigation in standard controls, such as paging in grids.
         */
        navigationMetadata?: DataNavigationMetadata;
        /**
         * An optional collection of partial errors returned by the server, possibly in
         * addition to any data received successfully.
         */
        partialErrors?: MsPortalFx.Data.PartialError[];
    }
    /**
     * Options for configuring a DataView.
     */
    interface DataViewConfig<TEntity, TParams> extends FxImpl.Data.ObjectViewConfig<TEntity, TParams> {
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.DataCacheLoader.d.ts
declare module MsPortalFx.Data {
    /**
     * A promise that completes with a DataSet instance, and also knows ahead of time what the DataSet instance's
     * name will be.
     */
    interface DataSetPromise extends MsPortalFx.Base.PromiseV<Data.DataSet> {
        dataSetName: string;
    }
    /**
     * An object that can supply data for a DataCache.
     */
    class DataCacheLoader<TEntity, TParams> {
        protected _dataType: string;
        private _uriForParams;
        private _httpMethod;
        private _polls;
        private _pollInterval;
        protected _atomizationOptions: AtomizationOptions;
        private _serializeParams;
        private _supplyData;
        private _processServerResponse;
        private _preservesClientOrder;
        private _setAuthHeader;
        /**
         * Constructs an instance of DataCacheLoader<TEntity, TParams>.
         *
         * @param config Configuration options specifying how the data should be loaded.
         */
        constructor(config: DataCacheLoaderConfig<TEntity, TParams>);
        /**
         * Returns a boolean reflecting whether this DataCacheLoader will do background polling refresh
         * of its cached data.
         */
        doesPoll: boolean;
        /**
         * Provides an arbitrary string representation of the specified query parameters. Any two
         * logically different parameter objects must map to different strings. Any two logically
         * equivalent parameter objects must map to the same string.
         *
         * @param params The query parameters to be serialized.
         * @return A string representation of the parameters.
         */
        serializeParams(params: TParams): string;
        /**
         * Begins loading a DataSet corresponding to the specified query parameters. The resulting
         * DataSet must have the specified name.
         *
         * Subclasses of DataCacheLoader may override this method to customise the loader options
         * that get passed on to the loadDataSet method.
         *
         * @param dataSetName A name for the resulting DataSet.
         * @param params Parameters representing the data to be loaded.
         * @param entryLifetime Lifetime object of the cache entry being created.
         * @return A DataSetPromise instance.
         */
        loadDataSetForParams(dataSetName: string, params: TParams, entryLifetime: MsPortalFx.Base.LifetimeManager): DataSetPromise;
        /**
         * Begins loading a DataSet corresponding to the specified loader options. The resulting
         * DataSet must have the specified name.
         *
         * @param dataSetName A name for the resulting DataSet.
         * @param dataSetLoaderOptions Options describing the URI, HTTP headers, etc., to be used in the request.
         * @return A DataSetPromise instance.
         */
        loadDataSet(dataSetName: string, dataSetLoaderOptions: DataSetLoaderOptions): DataSetPromise;
        /**
         * Begins a new request that will cause the specified DataSet to have its data observably refreshed.
         *
         * @param dataSetPromise A DataSetPromise that, when completed, refers to the DataSet to be disposed.
         * @return A promise that completes when the refresh has completed.
         */
        refreshDataSet(dataSetPromise: DataSetPromise): Base.PromiseV<FetchData>;
        /**
         * Notifies the loader that the specified DataSet is no longer in use. Any polling for the DataSet
         * will be stopped, and it may be released from memory.
         *
         * @param dataSetPromise A DataSetPromise that, when completed, refers to the DataSet to be disposed.
         */
        disposeDataSet(dataSetPromise: DataSetPromise): void;
        /**
         * Obtains the named data set, if it is already loaded and populated.
         *
         * @param dataSetName The name of the DataSet.
         * @return The DataSet instance if it is already loaded, otherwise null.
         */
        getLoadedDataSet(dataSetName: string): MsPortalFx.Data.DataSet;
        /**
         * Determines whether or not the specified data set is awaiting a response to an already-issued request.
         * @param dataSetName The name of the data set.
         * @return True if a request is in flight; false otherwise.
         */
        isLoadingDataSet(dataSetName: string): boolean;
    }
    class DataCacheLoader2<TEntity, TParams> extends DataCacheLoader<TEntity, TParams> {
        /**
         * Constructs an instance of DataCacheLoader2<TEntity, TParams>.
         *
         * @param config Configuration options specifying how the data should be loaded.
         */
        constructor(config: DataCacheLoaderConfig<TEntity, TParams>);
        /**
         * Creates a DataSet in the underlying loader, populating the DataSet with some initial data.
         *
         * @param dataSetName The name of the DataSet.
         * @param data Initial data for the DataSet.
         */
        establishDataSet(dataSetName: string, params: TParams, data: any, entryLifetime: MsPortalFx.Base.LifetimeManager): DataSet;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.DataProvider.d.ts
declare module MsPortalFx.Data.DataProvider {
    /**
     * The contract of DataProvider.
     */
    interface DataProvider {
        /**
         * processResult function is an option for Data.Loader.
         */
        processResult?: ProcessResultFunction;
        /**
         * shapeQuery function.
         */
        shapeQuery?: ShapeQueryFunction;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.DataProvider.DataContractJsonSerializer.d.ts
declare module MsPortalFx.Data.DataProvider {
    var DataContractJsonSerializer: DataProvider;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.DataProvider.OData.d.ts
declare module MsPortalFx.Data.DataProvider {
    interface ODataQuery {
        /**
         * String result should be filtered with.
         */
        $filter?: string;
        /**
         * Name of property by which result should be ordered.
         */
        $orderby?: string;
        /**
         * Number of entries that should be skipped.
         */
        $skip?: number;
        /**
         * Cap number of result entries.
         */
        $top?: number;
        /**
         * Should include result entries count.
         */
        $inlinecount?: string;
    }
    var OData: DataProvider;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.DataSet.d.ts
declare module MsPortalFx.Data {
    /**
     * DataSet is a simple data abstraction exposing managed values through single property.
     */
    class DataSet {
        private _type;
        private _data;
        private _navigationMetadata;
        private _partialErrors;
        private _lifetime;
        _atomizationContext: FxImpl.Data.AtomizationContext;
        /**
         * Creates a data set.
         *
         * @param type The type of the data to be cached in the data set.
         * @param lifetime Data set lifetime object.
         * @param atomizationOptions Atomization options, if not provided, data set will not be atomized.
         */
        constructor(type?: string, lifetime?: MsPortalFx.Base.LifetimeManager, atomizationOptions?: MsPortalFx.Data.AtomizationOptions);
        /**
         * The data cached in this data set.
         */
        data: any;
        /**
         * Lifetime manager of this data set. Only atomized data sets have lifetime managers.
         */
        lifetime: MsPortalFx.Base.LifetimeManager;
        /**
         * Type of data cached in this data set.
         */
        type: string;
        /**
         * Navigation metadata, if available, for this data set.
         */
        navigationMetadata: KnockoutObservable<DataNavigationMetadata>;
        /**
         * Error information associated with this data set.
         */
        partialErrors: KnockoutObservableArray<MsPortalFx.Data.PartialError>;
        /**
         * Locks a data item such that the item cannot be updated or deleted during merge. This is done to guard
         * against fetched server data overwriting client-side-only creates and updates.
         *
         * @param item The data item to be locked.
         * @param editKind The kind of client-side edit that preceded this lock.
         */
        static lockItem(item: any, editKind: EditKind): void;
        /**
         * Indicates whether any items within the data set have been recently unlocked and not yet subsequently merged
         * from server data.
         *
         * @param data The data to be examined for unmerged client changes.  If null or not supplied, all data cached
         * in the data set will be considered.
         * @return A boolean indicating whether the data has unmerged client changes.
         */
        static hasUnmergedClientChanges(data: any): boolean;
        /**
         * Unlocks a data item so that the item can be updated or deleted during merge. This is done once a client-side
         * create/update has been acknowledged by the server.
         *
         * @param item The data item to be unlocked.
         * @param rememberLockUntilMerged Indicates that the lock is to be remembered as an indicator of an item that
         * is not synchronized with respect to its server-side counterpart.  See 'hasUnmergedClientChanges'.  Defaults
         * to 'true' if not supplied.
         */
        static unlockItem(item: any, rememberLockUntilMerged: boolean): void;
        /**
         * Determines if a data item is locked.
         *
         * @param item The data item.
         * @return A boolean value indicating whether the data item is locked.
         */
        static isLockedItem(item: any): boolean;
        /**
         * Gets the names of those data item properties that uniquely identify a data item among its peers in a cached array.
         *
         * @param dataSetOrArray The data set or array cached within a data set for which the id properties will be determined.
         * @return An array of property names or null.
         */
        static getIdPropertyNames(dataSetOrArray: any): string[];
        /**
         * Gets the name of that data item property that uniquely identifies a data item among its peers in a cached array.
         *
         * @param dataSetOrArray The data set or array cached within a data set for which the id property will be determined.
         * @return A property name or null.
         */
        static getIdPropertyName(dataSetOrArray: any): string;
        /**
        * Merges new data onto a discrete array/object contained in the data set.
        * This method should not be used with DataSets that are enabled for data atomization.
        * For scenarios using data atomization, use the "merge" instance method on DataSet.
        *
        * @param source The new data to be merged onto cached data.
        * @param target The cached data onto which the new data will be merged.
        * @param mergeOptions An optional object describing merge options, look at MsPortalFx.DataSet.DataSetMergeOptions documentation.
        */
        static mergeWithoutAtomization(source: any, target: any, mergeOptions?: MsPortalFx.Data.DataSetMergeOptions): void;
        /**
         * Adds an item in an observable manner to an array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param sourceArray Objects to be inserted into array. These objects will be cloned and appropriately decorated before being added to target.
         * @param mergeOptions Merge options.
         * If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param lock Indicates whether the item should be locked. Defaults to true.
         * @param targetArray Target array in DataSet.
         */
        addItems(index: number, sourceArray: any[], mergeOptions?: DataSetMergeOptions, lock?: boolean, targetArray?: KnockoutObservableArray<any>): void;
        /**
         * Adds an item in an observable manner to an array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param sourceArray Objects to be inserted into array. These objects will be cloned and appropriately decorated before being added to target.
         * @param mergeOptions Merge options.
         * If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param lock Indicates whether the item should be locked. Defaults to true.
         * @param targetArray Target array in DataSet.
         */
        addItems(index: number, sourceArray: any[], mergeOptions?: DataSetMergeOptions, lock?: boolean, targetArray?: any[]): void;
        /**
         * Removes an item in an observable manner from a data set or array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param howMany How many elements should be removed from the array.
         * @param type Target's type. If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param targetArray Target array in DataSet.
         */
        removeItems(index: number, howMany?: number, type?: string, targetArray?: KnockoutObservableArray<any>): void;
        /**
         * Removes an item in an observable manner from a data set or array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param howMany How many elements should be removed from the array.
         * @param type Target's type. If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param targetArray Target array in DataSet.
         */
        removeItems(index: number, howMany?: number, type?: string, targetArray?: any[]): void;
        /**
         * Removes an item in an observable manner from a data set or array within a data set.
         *
         * @param item Item to be removed from within target array.
         * @param type Type of the item.
         * @param targetArray Target array from which item will be removed. If not provided, operation will be performed on data set root.
         */
        removeItem(item: any, type?: string, targetArray?: any): void;
        /**
         * Sets property of a target with a given value.
         *
         * @param propertyName Name of a property on target object in DataSet.
         * @param source Value object, which target[propertyName] will be set to.
         * This object will be cloned and associated with enity type metadata before being added to target.
         * @param mergeOptions Merge options.
         * If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param target Target object in DataSet.
         */
        setProperty(propertyName: string, source: any, mergeOptions?: DataSetMergeOptions, target?: any): void;
        /**
         * Merges new data into the data set.
         *
         * @param source The new data to be merged into this data set.
         * @param mergeOptions An optional object describing merge options, look at MsPortalFx.DataSet.DataSetMergeOptions documentation.
         */
        merge(source: any, mergeOptions?: DataSetMergeOptions): void;
        /**
         * Indicates whether any items within the data set have been recently unlocked and not yet subsequently merged
         * from server data.
         *
         * @param data The data to be examined for unmerged client changes.  If null or not supplied, all data cached
         * in the data set will be considered.
         * @return A boolean indicating whether the data has unmerged client changes.
         */
        hasUnmergedClientChanges(): boolean;
        static _mergeArrayOrObject: any;
        static _mergeArray: any;
        static _mergeArrayPreserveSourceItemsOrdering: any;
        static _mergeArrayPreserveTargetItemsOrdering: any;
        static _mergeObject: any;
        static _attachPropertyValue: any;
        static _processForAdd: any;
        static _atomizeOrMap: any;
        static _atomizeOrMapObject: any;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.DataSetMergeOptions.d.ts
declare module FxImpl.Data {
    interface DataSetMergeOptions {
        /**
            * When merging an array, indicates that the ordering of the new array should be preserved.
            */
        preserveNewItemsOrdering?: boolean;
        /**
            * Indicates that items are not to be removed from arrays during this merge.
            */
        preventItemRemoval?: boolean;
        /**
            * The time at which the fetch for the new data was initiated. New data will only be merged into the cache
            * if it was sourced after its cached counterpart was unlocked.
            */
        fetchStart?: number;
        /**
            * A name used to tag diagnostic output from this merge.
            */
        dataSetName?: string;
    }
}
declare module MsPortalFx.Data {
    /**
        * Describes possible MsPortalFx.Data.DataSet merge options.
        */
    interface DataSetMergeOptions extends FxImpl.Data.DataSetMergeOptions {
        /**
            * The type of the data being merged (if not supplied during construction).
            */
        type?: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.EditScope.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplied at construction time, reflects the kind of EditScope instance that will be created.
     */
    enum EditScopeKind {
        /**
         * A copy of the input data becomes 'editScope.root', the editable data to which UI is bound.
         */
        Copy = 0,
        /**
         * The input data itself becomes 'editScope.root', the editable data to which UI is bound.
         */
        InPlace = 1,
    }
    /**
     * Reflects the edit state of an item.
     */
    enum EditState {
        /**
         * The item has not been edited since it was loaded from the server.
         */
        None = 0,
        /**
         * The item is one that was created in memory but not yet created on the server.
         */
        Created = 1,
        /**
         * The item is one that is marked for deletion but not yet deleted on the server.
         */
        Deleted = 2,
        /**
         * The item is one whose property values have been updated in memory but not yet saved to the server.
         */
        Updated = 3,
    }
    /**
     * Editable copy of input data, which can then be utilized in editable, revertable view models.
     */
    interface EditScope<TData> extends MsPortalFx.Base.Disposable {
        /**
         * The editable, revertable copy of the input data.
         */
        root: TData;
        /**
         * Is 'true' if the EditScope contains edited entities (entities in 'Updated', 'Deleted' or 'Created' states).
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * Is 'true' if the EditScope is currently refreshing (its 'refresh' method has been called and the
         * corresponding operation is in progress).
         */
        refreshing: KnockoutObservableBase<boolean>;
        /**
         * Is 'true' if the EditScope is currently saving its changes (its 'saveChanges' method has been called and the
         * corresponding operation is in progress).
         */
        saving: KnockoutObservableBase<boolean>;
        /**
         * Marks an entity in the EditScope as being deleted, putting the entity in the 'Deleted' state.
         *
         * @param entity The entity.
         */
        markForDelete(entity: Object): void;
        /**
         * Creates a new empty entity that can be added to the given array of entities when the edits are saved.
         *
         * @param entityArray The entity array to which the new, empty entity will be added.
         * @return The empty entity that has not yet been added to the given array of entities.
         */
        create<TEntity>(entityArray: TEntity[]): TEntity;
        /**
         * Creates a new empty entity that can be added to the given array of entities when the edits are saved.
         *
         * @param entityArray The entity array to which the new, empty entity will be added.
         * @return The empty entity that has not yet been added to the given array of entities.
         */
        create<TEntity>(entityArray: KnockoutObservableBase<TEntity[]>): TEntity;
        /**
         * Adds a created entity to the given array of entities when the edits are saved.
         * The entity is added in the array of created entities retrieved using 'getCreated'.  The entity will
         * be in the 'Created' state.
         *
         * @param entity The entity to be added to the array of created entitites.
         * @param entityArray The entity array to which the new, empty entity will be added.
         */
        addCreated<TEntity>(entity: TEntity, entityArray: TEntity[]): void;
        /**
         * Adds a created entity to the given array of entities when the edits are saved.
         * The entity is added in the array of created entities retrieved using 'getCreated'.  The entity will
         * be in the 'Created' state.
         *
         * @param entity The entity to be added to the array of created entitites.
         * @param entityArray The entity array to which the new, empty entity will be added.
         */
        addCreated<TEntity>(entity: TEntity, entityArray: KnockoutObservableBase<TEntity[]>): void;
        /**
         * Reverts any creates, updates, deletes applied to this entity, return it to the 'None' edit state.
         * Created entities are removed from their 'getCreated' entities array.  Updated entities are restored
         * to their original values.  Deleted entities are no longer marked for delete.
         *
         * @param entity The entity being reverted.
         */
        revert(entity: Object): void;
        /**
         * Reverts any creates, updates, deletes applied to the EditScope.
         * Created entities are removed from their 'getCreated' entities array.  Updated entities are restored
         * to their original values.  Deleted entities are no longer marked for delete.
         */
        revertAll(): void;
        /**
         * Gets an observable EditState value, reflecting the create/update/delete state of the supplied entity.
         *
         * @param entity The entity being reverted.
         * @return The observable EditState value.
         */
        getEditState(entity: Object): KnockoutObservableBase<EditState>;
        /**
         * Gets the original data for a given editable entity or editable array of entities.
         *
         * @param entityOrEntityArray The editable entity or array of entities.
         * @return The data reflecting the original state of the editable data.
         */
        getOriginal(entityOrEntityArray: any): any;
        /**
         * Gets an array of created entities that will be created in the entity array when the EditScope edits are saved.
         *
         * @param entityArray The entity array to which entities have been added via 'create'.
         * @return The array of entities in the 'Created' state.
         */
        getCreated<TEntity>(entityArray: TEntity[]): KnockoutObservableArray<TEntity>;
        /**
         * Gets an array of created entities that will be created in the entityArray when the EditScope edits are saved.
         *
         * @param entityArray The entity array to which entities have been added via 'create'.
         * @return The array of entities in the 'Created' state.
         */
        getCreated<TEntity>(entityArray: KnockoutObservableBase<TEntity[]>): KnockoutObservableArray<TEntity>;
        /**
         * This method is available only on EditScopes created via EditScopeKind.CopyInputDataToMakeEditableData.
         *
         * Updates the EditScope so that 'editScope.root' (the editable data) reflects the current values in the
         * original data.
         *
         * This method should be used:
         * - To load original data asynchronously after the EditScope has been created and bound into view models.
         * - To incrementally load more or different original data into the EditScope ("show more" or "sort" in a grid).
         */
        mergeFromOriginal(): void;
        /**
         * Applies updates to EditScope data in such a way that updates are not confused with user-enacted edits and,
         * thus, do not dirty the EditScope.
         *
         * When this method completes, editable and original entities will both reflect their refreshed state.
         * User-enacted property-level updates will be over-written by newly loaded values.
         */
        refresh(): MsPortalFx.Base.Promise;
        /**
         * Initiates an async save operation to commit EditScope edits to a server.  Requires that the corresponding
         * EditScopeCache has been configured with a 'saveEditScopeChanges' callback.
         *
         * When the operation completes, the EditScope will be back in a non-dirty state, reflecting the now-saved
         * data.
         */
        saveChanges(): MsPortalFx.Base.Promise;
        /**
         * Resets the value of an EditScope observable, in a manner where the reset is not confused as a user-authored
         * edit.
         */
        resetValue<TValue>(accessor: EditScopeAccessors<TValue>, newValue: EditScope.ResetValue<TValue>): void;
        /**
         * For a given entity array, returns an array representation that includes the user's edits.  Here:
         * - 'Created' entities are appended and;
         * - 'Updated' entities are represented with user-edited property values and;
         * - 'Deleted' entities are excluded.
         * Additionally, this method returns discrete arrays of 'Created', 'Updated' and 'Deleted' entities (to save
         * explicit calls to 'editScope.getCreated()' and filtering based on 'editScope.getEditState()').
         */
        getEntityArrayWithEdits<TEntity>(entityArray: TEntity[] | KnockoutObservableBase<TEntity[]>): EntityArrayWithEdits<TEntity>;
        /**
         * Applies any differences between 'sourceArray' and 'targetArray' as user edits to the supplied EditScope
         * 'targetArray'.
         *
         * If 'targetArray' is an EditScope entity array (that is, an array described by type metadata that includes
         * '{ entityType: true }'), then differences are applied as follows:
         * - 'Created' entities: Any entities that are exclusive to 'sourceArray' (that is, not in 'targetArray') will be
         * represented as 'Created' entities (see 'editScope.addCreated()' and 'editScope.getCreated()').
         * - 'Updated' entities: For entities common to 'sourceArray' and 'targetArray', updated property values in the
         * entity from 'sourceArray' will be applied to the corresponding entity in 'targetArray'.
         * - 'Deleted' entities: Any entities missing from 'sourceArray' (that is, are in 'targetArray' only) will be
         * represented in 'targetArray' as 'Deleted' entities.
         *
         * If 'targetArray' is an EditScope array that is not entity-typed (not described by type metadata at all or
         * described by type metadata that doesn't include '{ entityType: true }'), then the items in 'targetArray' will
         * be replaced entirely by those in 'sourceArray'.  In this case, 'sourceArray' and 'targetArray' are treated
         * like single values.
         *
         * It is recommended that 'targetArray' be modeled as an entity array, as then, user edits can be persisted in
         * a small, space-efficient format.  In contrast, any user edit to a non-entity typed array requires that the
         * persisted edit include the entire array contents (which can be large).
         */
        applyArrayAsEdits<TItem>(sourceArray: TItem[], targetArray: TItem[]): void;
        /**
         * Applies any differences between 'sourceArray' and 'targetArray' as user edits to the supplied EditScope
         * 'targetArray'.
         *
         * If 'targetArray' is an EditScope entity array (that is, an array described by type metadata that includes
         * '{ entityType: true }'), then differences are applied as follows:
         * - 'Created' entities: Any entities that are exclusive to 'sourceArray' (that is, not in 'targetArray') will be
         * represented as 'Created' entities (see 'editScope.addCreated()' and 'editScope.getCreated()').
         * - 'Updated' entities: For entities common to 'sourceArray' and 'targetArray', updated property values in the
         * entity from 'sourceArray' will be applied to the corresponding entity in 'targetArray'.
         * - 'Deleted' entities: Any entities missing from 'sourceArray' (that is, are in 'targetArray' only) will be
         * represented in 'targetArray' as 'Deleted' entities.
         *
         * If 'targetArray' is an EditScope array that is not entity-typed (not described by type metadata at all or
         * described by type metadata that doesn't include '{ entityType: true }'), then the items in 'targetArray' will
         * be replaced entirely by those in 'sourceArray'.  In this case, 'sourceArray' and 'targetArray' are treated
         * like single values.
         *
         * It is recommended that 'targetArray' be modeled as an entity array, as then, user edits can be persisted in
         * a small, space-efficient format.  In contrast, any user edit to a non-entity typed array requires that the
         * persisted edit include the entire array contents (which can be large).
         */
        applyArrayAsEdits<TItem>(sourceArray: TItem[], targetArray: KnockoutObservableBase<TItem[]>): void;
    }
    /**
     * A snapshot representation of an user-edited entity array, where the representation includes 'Created' entities
     * but doesn't include 'Deleted' entities.  This representation is suitable for returning from a ParameterProvider
     * Blade back to a corresponding ParameterCollector, where the array can be applied to the ParameterCollector's
     * EditScope using 'editScope.applyArrayAsedits()'.
     */
    interface EntityArrayWithEdits<TEntity> {
        /**
         * An array representation of an entity array where:
         * - 'Created' entities are appended and;
         * - 'Updated' entities are represented with edited property values and;
         * - 'Deleted' entities are not represented at all (are excluded).
         */
        arrayWithEdits: TEntity[];
        /**
         * 'Created' entities in the containing entity array.  These could otherwise be accessed using
         * 'editScope.getCreated()'.
         */
        createdEntities: TEntity[];
        /**
         * 'Updated' entities in the containing entity array.  These could otherwise be determined using
         * 'editScope.getEditState()' and filtering entities that are in the 'Updated' state.
         */
        updatedEntities: TEntity[];
        /**
         * 'Deleted' entities in the containing entity array.  These could otherwise be determined using
         * 'editScope.getEditState()' and filtering entities that are in the 'Deleted' state.
         */
        deletedEntities: TEntity[];
    }
    /**
     * A description of an entity edited in the EditScope.  An array of these is supplied as part of an EditScope
     * 'saveChanges' operation.  See EditScopeCacheOptions.saveEditScopeChanges.
     */
    interface EditScopeEdit {
        /**
         * Reflects the kind of edit for this entity (create, update or delete).
         */
        editState: EditState;
        /**
         * The type name of the edited entity.
         */
        entityTypeName: string;
        /**
         * The edited entity.
         */
        entity: any;
    }
    /**
     * Different actions to be taken -- after an EditScope 'saveChanges' operation completes successfully --
     * to reflect the user's now-saved edits in the EditScope.  See EditScopeCacheOptions.saveEditScopeChanges.
     */
    enum AcceptEditScopeChangesAction {
        /**
         * When this action is returned, the user's client-side edits are accepted as the new EditScope values once
         * the 'saveChanges' operations completes successfully.  It assumed that these client-side edits reflect the state
         * saved to the server.
         */
        AcceptClientChanges = 0,
        /**
         * When this action is returned, the user's client-side edits accumulated in the EditScope are
         * discarded/reverted once the 'saveChanges' operation completes successfully.  This is useful for scenarios
         * where a user completes a form and clicks 'add' to add an item to a collection, then the form clears
         * to allow for the addition of successive items.
         */
        DiscardClientChanges = 1,
        /**
         * When this action is returned, the EditScope will be implicitly refreshed once the 'saveChanges' operation completes
         * successfully.  The user's client-side edits will be discarded in favor of those newly saved values returned
         * from the server during the 'refresh' operation.
         */
        RefreshFromServerImplicitly = 2,
        /**
         * When this action is returned, it is assumed that the 'dataToUpdate' parameter to the 'saveEditScopeChanges'
         * callback was updated from the server data by the callback.  In this case, it is assumed that this update
         * reflects both the user's edits and any server-generated values related to the save.  The user's client-side
         * edits will be discarded in favor of those values returned from the server.
         */
        ServerChangesAppliedManually = 3,
        /**
         * When this action is returned, it is expected that the 'dataToMerge' property is additionally supplied and
         * that it contains the newly saved server data.  In this case, it is assumed that 'dataToMerge' reflects both
         * the user's edits and any server-generated values related to the save.  The user's client-side edits will be
         * discarded in favor of those values returned from the server.
         */
        ServerDataReturned = 4,
    }
    /**
     * The promise returned from 'saveEditScopeChanges' on 'EditScopeCache' can resolve with an object of this type.
     * This object describes how/whether user edits are to be accepted as the new, post-'saveChanges' values in the
     * EditScope.
     */
    interface AcceptEditScopeChangesOptions<TData> {
        /**
         * A description of what to do with user edits when the EditScope 'saveChanges' operation concludes.
         */
        action: AcceptEditScopeChangesAction;
        /**
         * When 'action' is 'AcceptEditScopeChangesAction.ServerDataReturned', this is the server data that is be
         * accepted as the new EditScope data.  It is assumed that this data reflects both the user's saved edits
         * as well as any server-generated values related to the save.  The user's client-side edits will be discarded
         * in favor of the values in 'dataToMerge'.
         */
        dataToMerge?: TData;
    }
    /**
     * Represents a pair of functions that can be evaluated to acquire corresponding 'original' and 'editable'
     * observables from an EditScope.
     */
    interface EditScopeAccessors<TValue> {
        /**
         * A function that will return an observable containing the original value for the field.
         */
        getOriginalObservable: (lifetime: MsPortalFx.Base.LifetimeManager) => KnockoutObservableBase<TValue>;
        /**
         * A function that will return an observable containing the editable value for the field.
         */
        getEditableObservable: (lifetime: MsPortalFx.Base.LifetimeManager) => KnockoutObservableBase<TValue>;
    }
}
declare module MsPortalFx.Data.EditScope {
    /**
     * See EditScope's 'resetValue' method.  This represents the values with which to reset a pair of corresponding
     * 'original' and 'editable' EditScope observables.
     */
    interface ResetValue<TValue> {
        /**
         * The new value for the EditScope observable that is being reset with EditScope's 'resetValue'
         * method.  This becomes the value of both the 'editable' and 'original' versions of the data.
         */
        newInputValue: TValue;
        /**
         * Optional.  This should be a different value than 'newInputValue'.  This value will be applied to the
         * 'editable' version data, putting the enclosing entity into an 'Updated' state (since the 'original'
         * and 'editable' values will be different).
         */
        newEditableValue?: TValue;
    }
}
declare module FxImpl.Data {
    import Fx = MsPortalFx;
    import Metadata = Fx.Data.Metadata;
    import EditState = Fx.Data.EditState;
    import MergeVisitorOptions = FxImpl.Data.MergeVisitorOptions;
    import AcceptEditScopeChangesOptions = Fx.Data.AcceptEditScopeChangesOptions;
    import EditScopeKind = Fx.Data.EditScopeKind;
    import PromiseV = Fx.Base.PromiseV;
    /**
     * The flag specifying that some edits can be non-persistent. This applies, for example, to passwords.
     * We consider removing non-persistent objects but decided to keep code supporting it for a while and use this flag for it.
     * The flag should be used for tests only to keep the code for a while.
     * Do not use the flag in PROD code.
     * TODO: Should be removed later with RDTask 4285673:[IaaSV2] Get rid of non-persistent properties at all
     *       (also _shouldPersistObjectPropertyEdits, _removeNonPersistedPropertySentinels, and dependent code)
     */
    var allowNonPersistentEdits: boolean;
    /**
     * Serializable edits collected by an EditScope.
     */
    interface EditScopeEdits {
        /**
         * A version number for the serialization format used to serialize the edits.
         */
        version?: number;
        /**
         * The serializable edits.
         */
        edits: EditScopeEdit[];
    }
    /**
     * A single, serializable edit collected by an EditScope.
     */
    interface EditScopeEdit {
        /**
         * Reflects whether this edit is a create, update or delete.
         */
        state: EditState;
        /**
         * A reference to the entity to which the edit pertains.
         * For 'Updated' and 'Deleted', this is the entity being updated or deleted.
         * For 'Created', this is the entity that nests an entity-typed array into which nested entities are being
         * created.
         */
        entityReference: EntityReference;
        /**
         * For creates in entity array, this is the dot-delimited path into the entity object used to locate
         * the nested array.
         */
        entityPath?: string;
        /**
         * For creates in entity array, these are serialized representations of the created entities.
         */
        createdEntities?: string[];
        /**
         * For entity updates, this is a serialized representation of the entity updates.
         */
        entityUpdates?: string;
    }
    /**
     * A serializable reference to an entity.  Used to create a serializable description of an entity edit.
     */
    interface EntityReference {
        /**
         * The type of the entity.
         */
        type: string;
        /**
         * The id of the entity.
         */
        id: string;
    }
    /**
     * Internal EditScope interface with which we serialize/deserialize EditScope edits.
     */
    interface EditScope<TData> extends Fx.Data.EditScope<TData> {
        /**
         * Gets edits in an EditScope in a serializable form.
         * @return The serializable edits.
         */
        getEdits(): EditScopeEdits;
        /**
         * An observable that signals when 'getEdits()' have changed (and should be saved to user settings).
         * @return The observable whose value changes when 'getEdits()' have changed.
         */
        editsChanged: KnockoutObservableBase<void>;
        /**
         * Applies edits to an EditScope.
         * @param edits The deserialized edits.
         * @return A boolean indicating whether the edits could be applied.  Returns 'false' if the underlying original
         * data has changed in such a way that the edits couldn't be applied.
         */
        applyEdits(edits: EditScopeEdits): boolean;
        /**
         * A boolean reflecting whether the EditScope has been disposed.
         */
        isDisposed: boolean;
    }
    /**
     * Options supplied when instantiating an EditScope.
     */
    interface EditScopeOptions<TData> {
        /**
         * Reflects the kind of EditScope instance that will be created via Internal.Data.EditScope.createEditScope().
         * If not supplied, the default value is EditScopeKind.Copy.
         */
        kind?: EditScopeKind;
        /**
         * Optional name of a type describing the data.  If neither 'typeName' nor 'typeMetadata' is supplied, it is
         * assumed that the data being edited consists of a single entity (with no provision for nesting entities).
         */
        typeName?: string;
        /**
         * Optional type metadata describing the data.  If neither 'typeName' nor 'typeMetadata' is supplied, it is
         * assumed that the data being edited consists of a single entity (with no provision for nesting entities).
         */
        typeMetadata?: Metadata.Metadata;
        /**
         * Optional callback that will be called when the EditScope 'refresh' method is called.  With the callback,
         * the EditScope data can be updated directly via 'dataToUpdate' or the callback can resolve its returned
         * promise with the data for EditScope to merge.
         */
        refresh?: (dataToUpdate: TData) => PromiseV<TData>;
        /**
         * Optional callback that will be called when the EditScope 'saveChanges' method is called.  Once the edits
         * have been saved to the server, the callback can choose to update the EditScope data with saved server data
         * (although this is an uncommon scenario).  To do so, it should resolve its promise with options describing
         * how to merge the saved server data.
         */
        save?: (editScope: Fx.Data.EditScope<TData>, edits: Fx.Data.EditScopeEdit[], dataToUpdate: TData) => PromiseV<AcceptEditScopeChangesOptions<TData>>;
    }
    /**
     * An interface from which Form's EditScopeAccessors will inherit.  Used to identify those EditScopeAccessors
     * that always return observables contained in the EditScope, making these EditScopeAccessors usable by
     * EditScope's 'resetValue' method.
     */
    interface InternalEditScopeAccessors {
        /**
         * Identifies EditScopeAccessors that are usable by the EditScope.resetValue() method.
         */
        returnsObservablesFromEditScope: boolean;
    }
    /**
     * Constructs an EditScope instance.
     *
     * @param data Model data from which an editable copy will be created.
     * @param options Optional options with which the EditScope will be created.
     * @return The created EditScope instance.
     */
    function createEditScope<TData>(data: TData, options?: EditScopeOptions<TData>): EditScope<TData>;
    function logEditsToConsole(edits: EditScopeEdits): void;
    var nonPersistedPropertySentinel: string;
    /**
     * Options supplied when constructing a ApplyEntityArrayAsEditsVisitor.
     */
    interface ApplyEntityArrayAsEditsVisitorOptions<TEntity> extends MergeVisitorOptions {
        /**
         * Delegates to the caller the responsibility of treating the add of an entity to an entity array
         * in the course of applying edits from the source entity array to the target entity array.
         */
        handleAdd: (entityToAdd: TEntity) => void;
        /**
         * Delegates to the caller the responsibility of treating the delete of an entity from an entity array
         * in the course of applying edits from the source entity array to the target entity array.
         */
        handleDelete: (entityToDelete: TEntity) => void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.EditScopeCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A ref-counted cache of EditScopes.
     */
    interface EditScopeCache<TData, TParams> extends MsPortalFx.Base.Disposable {
        /**
         * Creates an EditScopeView that is used by a view model to fetch EditScope instances.
         *
         * @param lifespan Reflects the lifetime of the caller.  This is used to determine when cached EditScopes are no
         * longer referenced.
         * @return An EditScopeView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager): EditScopeView<TData, TParams>;
        /**
         * Invokes a callback for each entry currently in the EditScopeCache.
         *
         * @param callback The callback to be invoked.
         * @return A promise that resolves when callback has been called on all editScopes.
         */
        forEachEditScope(callback: (editScopeId: string, editScope: EditScope<TData>) => void): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.EditScopeCache.Create.d.ts
declare module MsPortalFx.Data.EditScopeCache {
    /**
     * Creates a new instance of EditScopeCache for specified options.
     */
    function createNew<T, TId>(options: MsPortalFx.Data.EditScopeCacheOptions<T, TId>): MsPortalFx.Data.EditScopeCache<T, TId>;
    /**
     * Deprecated -- Creates a new instance of EditScopeCache for specified options.
     */
    function create<T, TId>(options: MsPortalFx.Data.EditScopeCacheOptions<T, TId>): MsPortalFx.Data.EditScopeCache<T, TId>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.EditScopeCacheOptions.d.ts
declare module MsPortalFx.Data {
    import FxBase = MsPortalFx.Base;
    /**
     * Options supplied to EditScopeCache.createNew.
     */
    interface EditScopeCacheOptions<TData, TParams> {
        /**
         * Determines the kind of EditScope that will be created.  Defaults to
         * EditScopeKind.CopyInputDataToMakeEditableData.
         */
        kind?: EditScopeKind;
        /**
         * Type metadata name. Only necessary for EditScopes that contain more than simply a root-level entity
         * (rather, that contain nested entities).
         */
        entityTypeName?: string;
        /**
         * Generates a string that will be used as the cache key for a cached EditScope.  This function should return a
         * unique string for every distinct 'params' in use.
         *
         * @param params Parameters identifying the EditScope data.
         * @return A string represention of the parameters.
         */
        serializeParams?: (params: TParams) => string;
        /**
         * When creating an EditScope<TData> for the cache (in response to a call to EditScopeView.fetchForNewData)
         * this data cache (a QueryCache or EntityCache) is used to retrieve data that will be used as the original
         * data for the new EditScope.
         */
        dataCache?: EditScopeInputDataCache<TData, TParams>;
        /**
         * When creating an EditScope<TData> for the cache (in response to a call to EditScopeView.fetchForNewData)
         * this function returns an instance of type TData that will be used as the original data for the new EditScope.
         * If this function is not supplied, then Metadata.create(entityTypeName) will be used to create an object
         * (and not an array) of type TData.
         *
         * @return Data to be used as the original data for the new EditScope. This can be an object, an array or an
         * observable array of the type described by 'entityTypeName'.
         */
        supplyNewData?: () => TData;
        /**
         * When creating an EditScope<TData> for the cache (in response to a call to EditScopeView.fetchForExistingData)
         * this function retrieves existing data identified by 'params'. This data will be used as the original
         * data for the EditScope.
         * In most cases, it is simpler to supply the 'dataCache' option to retrieve existing data, since
         * QueryCache/EntityCache instances can be simply configured to load server data.
         *
         * @param params Parameters used to retrieve data.
         * @param lifetime An object that issues a notification when the cache entry is evicted. Use this to clean up
         * any resources held by the cache entry.
         * @return A promise resolved with the data.
         */
        supplyExistingData?: (params: TParams, lifetime: MsPortalFx.Base.LifetimeManager) => FxBase.PromiseV<TData>;
        /**
         * Optional callback that will be called when the EditScope 'refresh' method is called.  With the callback,
         * the EditScope data can be updated directly via 'dataToUpdate' or the callback can resolve its returned
         * promise with the data for EditScope to merge.
         *
         * @param params Parameters identifying the EditScope.
         * @param lifetime An object that issues a notification when the refresh is completed.  Typical use it to use
         * 'lifetime' to acquire an EntityView or QueryView with which to refresh EditScope input data.
         * @param dataToUpdate The data which the callback can manually update to reflect server changes.
         * @return A promise reflecting when new server data has been loaded.  If the promise is resolved with new
         * data, the new data will be merged into the EditScope.  Otherwise, it will be assumed that 'dataToUpdate'
         * was updated manually to reflect the latest state of the data on the server.
         */
        refreshEditScope?: (params: TParams, lifetime: FxBase.LifetimeManager, dataToUpdate: TData) => FxBase.PromiseV<TData>;
        /**
         * Optional callback that will be called when the EditScope 'saveChanges' method is called, delegating to the
         * extension to save EditScope edits to their server.
         *
         * @param params Parameters identifying the EditScope.
         * @param editScope The EditScope whose changes are being saved.
         * @param edits A description of the edits accumulated by the EditScope.
         * @param lifetime This should be used in the uncommon case where the extension chooses to -- once the server
         * has accepted the changes -- refresh the EditScope data from the server via a second HTTP call.  Typically,
         * 'lifetime' would be used to acquire an EntityView or QueryView with which to refresh EditScope data once the
         * HTTP call to save has completed.
         * @param dataToUpdate This should be used in the uncommon case where the extension chooses to -- once the server has
         * accepted the changes -- refresh the EditScope data (either based on the HTTP response from the save operation
         * or via a second HTTP call).  Importantly, this covers the case of server-generated values related to the save
         * operation.  'dataToUpdate' is the data which the callback can manually update to reflect the new server data.
         * @return A promise reflecting when the EditScope changes have been saved to the server (and, optionally, the
         * callback has obtained the newly saved data from the server).  The promise can be resolved with a
         * object describing how/whether to reflect the user's now-saved edits as the new values in the EditScope.
         * If the promise is resolved with no value, the user's client-side edits will be accepted and the EditScope
         * will simply be marked as not dirty.
         */
        saveEditScopeChanges?: (params: TParams, editScope: EditScope<TData>, edits: EditScopeEdit[], lifetime: FxBase.LifetimeManager, dataToUpdate: TData) => FxBase.PromiseV<AcceptEditScopeChangesOptions<TData>>;
        /**
         * An optional callback triggered when the EditScope is created and added to the cache.
         *
         * @param lifetime An object that issues a notification when the cached entry is evicted/disposed. Use this to
         * clean up any resources that share the same lifetime as the cached EditScope.
         */
        onEditScopeCreated?: (lifetime?: FxBase.LifetimeManager, editScope?: EditScope<TData>) => any;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.EditScopeInputDataCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A cache of query results for a specific type of data and query parameters, suitable for use as input
     * data to an EditScopeCache.
     */
    interface EditScopeInputDataCache<TData, TParams> {
        /**
         * A boolean reflecting whether this DataCache is one that polls for server changes.
         */
        doesPoll: boolean;
        /**
         * Creates a DataView that provides a convenient way to retrieve data from the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new DataView. A
         * typical example is a PartContainer instance - supplying one means that the DataView's entries may be released
         * when the corresponding Part is removed from the UI.
         * @return A DataView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager): EditScopeInputDataView<TData, TParams>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.EditScopeInputDataView.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides a view of a single entry from an underlying EditScopeInputDataCache. The 'data' property represents the
     * value(s) returned from the most recently issued (and completed) 'fetch' or 'refresh' call.
     */
    interface EditScopeInputDataView<TData, TParams> {
        /**
         * Sets the DataView's current query parameters, changing what data it exposes.  The data will be fetched from
         * the underlying cache, which may or may not already have it in memory.
         *
         * If you call 'fetch' while an earlier load is still in progress, the older load will be superseded,
         * meaning that its promise will never complete.  This is so you do not need manual code to stop superseded
         * promise handlers from performing actions that are now irrelevant.
         *
         * @param params Query parameters describing the data to be fetched.  If you supply null/undefined, then the
         * preceding query will be superseded, but no new query will be begun - the DataView will therefore become
         * empty.
         * @return A promise that completes when the load has completed.
         */
        fetch(params: TParams): MsPortalFx.Base.Promise;
        /**
         * Instructs the underlying data cache to re-fetch and update whatever data is currently being exposed by this
         * instance.
         *
         * If a request is currently in progress, this does not trigger a further request.  So, it is safe to invoke
         * 'refresh' immediately after a 'fetch' if you want to be sure to fetch fresh data and not accept existing
         * cached data.
         *
         * @return A promise that completes when the refresh is done.  Or, if a request was already in progress, a
         * promise that completes when the existing request completes.
         */
        refresh(): MsPortalFx.Base.Promise;
        /**
         * The data loaded for this view.
         *
         * @return The loaded data of type TData (or null/undefined if the data has not been loaded).
         */
        data: TData;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.EditScopeView.d.ts
declare module MsPortalFx.Data {
    import FxPromise = MsPortalFx.Base.Promise;
    interface EditScopeViewContract<TData, TParams> {
        /**
         * An observable containing an EditScope instance reflecting the last successful call to 'fetchForNewData' or
         * 'fetchForExistingData'.
         */
        editScope: KnockoutObservable<EditScope<TData>>;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId'. This view's observable 'editScope'
         * property will be set with the fetched EditScope.
         */
        fetchForNewData(editScopeId: string): FxPromise;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId' and 'query'. This view's observable
         * 'editScope' property will be set with the fetched EditScope.
         */
        fetchForExistingData(editScopeId: string, params?: TParams): FxPromise;
    }
    /**
     * Options for configuring an EditScopeView.
     */
    interface EditScopeViewConfig<TData, TParams> extends FxImpl.Data.ObjectViewConfig<EditScope<TData>, FxImpl.Data.EditScopeKey<TParams>> {
    }
    /**
     * An EditScopeView is a view used to supply EditScopes to a view model. The view's observable 'editScope' changes
     * value to reflect asynchronous calls to 'fetchForNewData' and 'fetchForExistingData'.
     */
    class EditScopeView<TData, TParams> extends FxImpl.Data.ObjectView<EditScope<TData>, FxImpl.Data.EditScopeKey<TParams>> implements EditScopeViewContract<TData, TParams> {
        /**
         * An observable containing an EditScope instance reflecting the last successful call to 'fetchForNewData' or
         * 'fetchForExistingData'.
         */
        editScope: KnockoutObservable<EditScope<TData>>;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId'. This view's observable 'editScope'
         * property will be set with the fetched EditScope.
         */
        fetchForNewData(editScopeId: string): FxPromise;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId' and 'query'. This view's observable
         * 'editScope' property will be set with the fetched EditScope.
         */
        fetchForExistingData(editScopeId: string, params?: TParams): FxPromise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.EntityCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A cache of entities of a specific type.
     */
    class EntityCache<TEntity, TId> extends FxImpl.Data.DataCache<TEntity, TId> implements EditScopeInputDataCache<TEntity, TId>, DataCache<TEntity, TId> {
        private _findCachedEntity;
        /**
         * Constructs an instance of EntityCache<TEntity, TId>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: EntityCacheConfig<TEntity, TId>);
        /**
         * Constructs an instance of EntityCache<TEntity, TId>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: DataCacheConfig<TEntity, TId>);
        /**
         * Creates an EntityView that provides a convenient way to retrieve entities from
         * the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new EntityView. A typical example is a
         * PartContainer instance - supplying one means that the EntityView's entries may be released when the corresponding Part is
         * removed from the UI.
         * @param config Additional options for configuring the EntityView.
         * @return An EntityView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TId>): EntityView<TEntity, TId>;
        protected _tryFindDataInRelatedCache(id: TId, entryLifetime: MsPortalFx.Base.LifetimeManager): TEntity;
        protected _getDataFromDataSet(dataSet: DataSet): KnockoutObservableBase<TEntity[]>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.EntityCacheConfig.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplies configuration options for an EntityCache.
     */
    interface EntityCacheConfig<TEntity, TId> extends DataCacheConfig<TEntity, TId> {
        /**
         * A description of how to locate an entity already loaded into a related DataCache.
         * This is a performance optimization that allows calls to 'entityView.fetch()' to quickly return
         * already-loaded data.  This optimization is important in many master/detail scenarios like browsing
         * resources.
         */
        findCachedEntity?: FindCachedEntityInQueryCacheOptions<TEntity, TId> | FindCachedEntityInDataCacheOptions<TEntity, TId, any, any>;
    }
    /**
     * A description of how to locate an entity already loaded into a related QueryCache<TEntity>.
     * This is a performance optimization that allows a call to 'entityView.fetch()' to quickly return
     * already-loaded data.  This optimization is important in many master/detail scenarios like browsing
     * resources.
     */
    interface FindCachedEntityInQueryCacheOptions<TEntity, TId> {
        /**
         * A QueryCache caching arrays of entities of the same 'TEntity' type.
         */
        queryCache: QueryCache<TEntity, any>;
        /**
         * A function that determines whether a given entity matches an id.
         *
         * @param entity The entity.
         * @param id The ID to compare against this entity's ID.
         * @return True if the entity's ID matched 'id'.
         */
        entityMatchesId(entity: TEntity, id: TId): boolean;
    }
    /**
     * A description of how to locate an entity already loaded into a related DataCache (a QueryCache or EntityCache).
     * This is a performance optimization that allows a call to 'entityView.fetch()' to quickly return
     * already-loaded data.  This optimization is important in many master/detail scenarios like browsing
     * ARM resources.
     */
    interface FindCachedEntityInDataCacheOptions<TEntity, TId, TData, TParams> {
        /**
         * A DataCache caching entities of the same 'TEntity' type, nested in some array or as an object property value.
         */
        dataCache: DataCache<TData, TParams>;
        /**
         * A function used to find -- within a cache entry -- the entity matching a given 'id'.
         *
         * @param cacheEntryParams The parameters which serve as the key of the cache entry.
         * @param cacheEntryData The data of the cache entry.
         * @param id The ID of the entity to find.
         * @return The entity within the cache entry or 'null' if the entity is not found in this cache entry.
         */
        findMatchingEntityInCacheEntry(cacheEntryParams: TParams, cacheEntryData: TData, id: TId): TEntity;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.EntityView.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides a view of a single entity from an underlying EntityCache. The
     * 'item' observable property remains constant but its contents change whenever
     * you request a different entity ID or when that entity's data is updated.
     */
    class EntityView<TEntity, TId> extends FxImpl.Data.DataView<TEntity, TId> implements EditScopeInputDataView<TEntity, TId> {
        private _item;
        /**
         * Internal constructor. Extensions should not invoke this directly. Instead,
         * create an EntityCache and then use its 'createView' method to obtain an EntityView.
         *
         * @param dataSource Internal. Extensions should not use this EntityView constructor directly.
         * @param lifetime Internal. Extensions should not use this EntityView constructor directly.
         * @param config Internal. Extensions should not use this EntityView constructor directly.
         */
        constructor(dataSource: FxImpl.Data.DataViewSource<TEntity, TId>, lifetime: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TId>);
        /**
         * An observable property whose value is the current entity retrieved from the underlying cache.
         * The value is 'null' until the first entity is retrieved.
         *
         * Use the EntityView's 'fetch' method to specify an entity ID that, when loaded, will give the data for this property.
         *
         * Use the EntityView's 'refresh' method to cause this property's data to be updated via a new server request.
         */
        item: KnockoutObservable<TEntity>;
        /**
         * See interface.
         */
        data: TEntity;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.ErrorNotificationTarget.d.ts
declare module MsPortalFx.Data {
    /**
     * Represents an object that receives notifications about errors encountered in the data layer.
     */
    interface ErrorNotificationTarget extends MsPortalFx.Base.LifetimeManager {
        /**
         * Issues a notification that a 'not found' error was encountered in the data layer.
         *
         * @param message Optional error message to be used in place of the default.
         */
        notFound?(message?: string): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.Loader.d.ts
declare module MsPortalFx.Data {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    import FxBaseNet = FxBase.Net2;
    function setCustomMinimumPoolInterval(poolInterval: number): void;
    function resetCustomMinimumPoolInterval(): void;
    /**
     * Specifies the rate at which the data loader should poll the server for updates.
     */
    enum PollFrequency {
        /**
         * The data loader will not poll for updates.
         */
        Never = 1,
        /**
         * The data loader will poll at the recommended rate.
         */
        Normal = 2,
    }
    /**
     * FetchData is the interface for return of name: datasetName, value as DataSet
     */
    interface FetchData extends NameValue<string, DataSet> {
    }
    /**
     * Fetch parameters for fetch start callback.
     */
    interface FetchStartParameters {
        /**
         * The name of the data set
         */
        dataSetName: string;
        /**
         * The fetch promise.
         */
        promise: FxPromiseV<FetchData>;
        /**
         * A flag to distinguish Shell.Data.Loader.getData from polling refresh.
         */
        isClientInitiated: boolean;
    }
    /**
     * Fetch parameters for fetchData function of a Loader.
     */
    interface FetchParameters {
        /**
         * Additional data for a performed fetch.
         */
        data: any;
        /**
         * Additional headers for a performed fetch.
         */
        headers: any;
    }
    /**
     * Loader specific options.
     */
    interface LoaderOptions {
        /**
         * Computes HTTP parameters in preparation for a fetch of server data.
         */
        getFetchParameters?: (dataSetName: string, lastFetchState: any, fetchingSameData: boolean) => FetchParameters;
        /**
         * Function that performs actual data retrieval from a data source.
         */
        fetchData?: (dataSetName: string, uri: string, ajaxData: any, ajaxHeaders: any) => FxPromise;
        /**
         * List of functions processing fetch results of a loader.
         */
        processResult?: Array<ProcessResultFunction>;
    }
    /**
     * Options that control how a DataSet is loaded.
     */
    interface DataSetLoaderOptions {
        /**
         * The URI from which data will be fetched for this data set.
         */
        uri: string;
        /**
         * An optional HTTP method to be used when making requests for this data set.
         */
        httpMethod?: string;
        /**
         * An optional, object-typed value that is passed as the 'data' option to the ajax call.
         */
        ajaxData?: any;
        /**
         * An optional, object-typed value that is passed as the 'headers' option to the ajax call.
         */
        ajaxHeaders?: any;
        /**
         * An optional boolean with a default value of false. If true, will always initiate a fetch from the server, even when this call returns cached data.
         */
        forceCacheRefresh?: boolean;
        /**
         * Adds a fetchStart event handler to the resulting data set, called whenever a fetch from the server is initiated for this data set.  A promise for the fetch is supplied to the handler.
         */
        fetchStartListener?: MsPortalFx.Base.Callbacks<FetchStartParameters>;
        /**
         * The frequency at which the loader should poll the server for updates.
         */
        pollFrequency?: PollFrequency;
        /**
         * Should preserve new items ordering during merge operations on data set.
         */
        preserveNewItemsOrdering?: boolean;
        /**
         * Loader specific options.
         */
        loaderOptions?: LoaderOptions;
        /**
         * An optional type string used to retrieve metadata for use during merging of fetched data.
         */
        type?: string;
        /**
         * See interface.
         */
        atomizationOptions?: AtomizationOptions;
        /**
         * Lifetime referrer of a data set for use in atomization garbage collection mechanism.
         */
        dataSetLifetime?: MsPortalFx.Base.LifetimeManager;
        /**
         * A name for the resulting DataSet.
         */
        dataSetName?: string;
        /**
         * Initial data of the data set.
         */
        initialData?: any;
        /**
         * Determines whether to automatically obtain and append an authorization header.
         * If undefined, the authorization header is appendended automatically for all relative URIs,
         * but skipped for absolute URIs.
         *
         * Set to true to append the default authorization header.
         * Set to { resourceName: 'audienceName'} to append an authorization token targeted at a specific audience.
         */
        setAuthorizationHeader?: boolean | FxBaseNet.AuthorizationOptions;
    }
    /**
     * Polling intervals definitions.
     */
    interface PollingIntervals {
        [interval: string]: number;
        /**
         * Fast polling interval.
         */
        fastPollingInterval?: number;
        /**
         * Normal polling interval.
         */
        pollingInterval?: number;
        /**
         * Slow polling interval.
         */
        slowPollingInterval?: number;
    }
    class Loader {
        static _internal: {
            setDefaultPollingIntervals: (intervals: any) => void;
        };
        /**
         * Fetches data from the cache or server. This is an asynchronous function.
         * Shell.Data.Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: jQueryDeferred, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName The name of the data set being retrieved.
         * If not supplied, the data set name will be inferred the URI supplied as options.uri.
         * @param options An options object.
         * @return A promise reflecting the success or failure of this asynchronous call.
         * The promise is resolved with parameters:
         *   * dataSetName: The name of the data set.
         *   * dataSet: The data set containing the data retrieved.
         * The promise is rejected with parameters:
         *   * dataSetName: The name of the data set.
         *   * jqXHR: The jQuery XmlHttpRequest object used for the server fetch.
         *   * textStatus: A string describing the error type.
         *   * errorThrown: Any error thrown in JavaScript in the course of processing the server fetch.
         */
        static getData(options: DataSetLoaderOptions): FxPromiseV<FetchData>;
        static getData(dataSetName: string, options: DataSetLoaderOptions): FxPromiseV<FetchData>;
        /**
         * Refreshes data in the data set, using the URI, data and headers supplied in the most recent
         * call to Shell.Data.Loader.getData.
         * @param dataSetName Data set name.
         * @return A promise reflecting the success or failure of the server fetch.
         */
        static forceRefresh(dataSetName: string): FxPromiseV<FetchData>;
        /**
         * Retrieves a data set from a local, in-memory cache. This is a synchronous function.
         * Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: FxPromise, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName Data set name.
         * @param create Create a new data set (with no initial value/data) if one is not present in the cache. Defaults to 'false'.
         * @param initialData Initial data merged into data set.
         * @param dataSetLifetime Data set lifetime manager.
         * @param atomizationOptions Data set atomization options.
         * @return The data set named by 'dataSetName' or null if the data set has not yet been created or loaded.
         */
        static getDataSet(dataSetName: string, create?: boolean, initialData?: any, dataSetLifetime?: MsPortalFx.Base.LifetimeManager, atomizationOptions?: AtomizationOptions): DataSet;
        /**
         * Retrieves a data set from a local, in-memory cache. The data set will be created if it doesn't already exist. This is a synchronous function.
         * Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: FxPromise, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName Data set name.
         * @param dataSetType Type of the data set.
         * @param initialData Initial data merged into data set.
         * @param dataSetLifetime Data set lifetime manager.
         * @param atomizationOptions Data set atomization options.
         * @return The data set named by 'dataSetName' or null if the data set has not yet been created or loaded.
         */
        static getDataSet(dataSetName: string, dataSetType?: string, initialData?: any, dataSetLifetime?: MsPortalFx.Base.LifetimeManager, atomizationOptions?: AtomizationOptions): DataSet;
        /**
         * Determines whether or not the specified data set is awaiting a response to an already-issued request.
         * @param dataSetName The name of the data set.
         * @return True if a request is in flight; false otherwise.
         */
        static hasRequestInFlight(dataSetName: string): boolean;
        /**
         * Disposes and clears the data set from that set managed by Shell.Data.Loader.
         * @param dataSetName Data set name.
         */
        static disposeDataSet(dataSetName: string): void;
        /**
         * Enables or disables data refresh at the 'fast' refresh interval, often reflecting that the
         * data set is currently being viewed.
         * @param dataSetName Data set name.
         * @param fast If true, the 'fast' refresh interval is selected for this data set.
         */
        static setFastPolling(dataSetName: string, fast: boolean): void;
        /**
         * Pauses data refresh by increasing a reference count
         */
        static pausePolling(): void;
        /**
         * Resumes data refresh by decreasing a reference count.
         */
        static resumePolling(): void;
        /**
         * Supplies a set of default loader options that will be used when loading data sets.
         * @param loaderOptions The default loader options.
         */
        static setDefaultLoaderOptions(loaderOptions: LoaderOptions): void;
        /**
         * Helper to get current MinimumPoolingInterval (used in Data.DataCacheLoder.ts)
         */
        static getMinPollingInterval(): number;
        /**
         * Supplies a set of polling intervals used to control the rate at which a data set is implicitly
         * refreshed from the server.
         * @param dataSetName Data set name.
         * @param pollingIntervals An object with optional 'fastPollingInterval', 'pollingInterval' and
         * 'slowPollingInterval' properties, all Number-typed and in milliseconds.
         */
        static setPollingIntervals(pollingIntervals: PollingIntervals): void;
        static setPollingIntervals(dataSetName: string, pollingIntervals: PollingIntervals): void;
        /**
         * Reset the polling intervals to default setting that can void the effect by setPollingIntervals
         */
        static resetPollingIntervals(dataSetName?: string): void;
    }
    module Loader.Internal {
        function disposeAllCachedDataSetsForTests(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.LockState.d.ts
declare module MsPortalFx.Data {
    /**
     * An enumeration type representing the kinds of client-side edits to which MsPortalFx.Data.DataSet.lockItem
     * applies.
     */
    enum EditKind {
        /**
         * "Add" type of edit.
         */
        Add = 0,
        /**
         * "Update" type of edit.
         */
        Update = 1,
    }
    /**
     * Defines client-side lock state of an element stored in MsPortalFx.Data.DataSet.
     */
    interface LockState {
        /**
         * Lock type of edit.
         */
        editKind?: MsPortalFx.Data.EditKind;
        /**
         * Date when unlocked.
         */
        unlockedAt?: number;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.Metadata.d.ts
declare module MsPortalFx.Data.Metadata {
    /**
     * Interface describing on of possible type representations of elements stored in MsPortalFx.Data.DataSet.
     */
    interface MetadataProperty {
        /**
         * Type of the property.
         */
        itemType?: string;
        /**
         * Indicates whether property is an array.  Default is 'false'.
         */
        isArray?: boolean;
        /**
         * Indicates whether property is a date.
         */
        isDate?: boolean;
        /**
         * Determines if edits are tracked by EditScope.  Default is 'true'.  If 'false', property value cannot be used with form fields.
         */
        trackEdits?: boolean;
        /**
         * Determines if edits are persisted to User Settings.  Set to 'false' for properties like passwords.  Default is 'true'.
         */
        persistEdits?: boolean;
    }
    /**
     * Interface describing metadata of elements stored in MsPortalFx.Data.DataSet.
     * This interface corresponds with 'TypeMetadata' C# type.
     */
    interface Metadata {
        /**
         * Name of the type.
         */
        name?: string;
        /**
         * List of id properties of a type.
         */
        idProperties?: string[];
        /**
         * List of properties in type.
         */
        properties?: {
            [property: string]: MetadataProperty;
        };
        /**
         * Reflects whether this type is an entity type.  An entity type is one that can be edited and reverted
         * independently from any nesting or nested model data.
         */
        entityType?: boolean;
        /**
         * Indicates whether instances of this type each of a globally unique id.
         */
        hasGloballyUniqueId?: boolean;
    }
    /**
     * Contract for compressed metadata created with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypeName' C# type.
     */
    interface CompressedTypeName {
        /**
         * Index of a part in namespace array.
         */
        namespaceIndex: number;
        /**
         * Type name.
         */
        name: string;
    }
    /**
     * Contract for compressed type property metadata with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypeProperty' C# type.
     */
    interface CompressedTypeProperty {
        /**
         * Index of a type in namespace array.
         */
        typeIndex: number;
        /**
         * Value indicating whether property is enumerable or not.
         */
        isArray: boolean;
        /**
         * Value indicating whether property is a date.
         */
        isDate: boolean;
        /**
         * Determines if edits are tracked by EditScope.  Default is 'true'.  If 'false', property value cannot be used with form fields.
         */
        trackEdits: boolean;
        /**
         * Determines if edits are persisted to user settings.  Set to 'false' for properties like passwords.  Default is 'true'.
         */
        persistEdits: boolean;
    }
    /**
     * Contract for compressed metadata created with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypeMetadata' C# type.
     */
    interface CompressedTypeMetadata {
        /**
         * Type name.
         */
        name: CompressedTypeName;
        /**
         * List of properties in type.
         */
        properties: {
            [property: string]: CompressedTypeProperty;
        };
        /**
         * List of id properties of a type.
         */
        idProperties: string[];
        /**
         * Reflects whether this type is an entity type.  An entity type is one that can be edited and reverted
         * independently from any nesting or nested model data.
         */
        entityType?: boolean;
        /**
         * Indicates whether the entity has a globally unique ids.
         */
        hasGloballyUniqueId?: boolean;
    }
    /**
     * Data visitation callbacks.
     */
    interface TypedDataVisitorCallbacks {
        /**
         * Callback triggered whenever an array is found on travelsal path.
         */
        visitArray: (data: any, type: string) => void;
    }
    /**
     * Contract for compressed metadata created with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypesMetadata' C# type.
     */
    interface CompressedTypesMetadata {
        /**
         * Namespaces array.
         */
        namespaces: string[];
        /**
         * List of metadata.
         */
        metadata: CompressedTypeMetadata[];
        /**
         * Index of root type in types array.
         */
        rootTypeIndex: number;
    }
    /**
     * Gets metadata corresponding to a given type name.
     *
     * @param type The name of the type.
     * @return Metadata for the type.
     */
    function getTypeMetadata(type: string): Metadata;
    /**
     * Gets the type of a property.
     *
     * @param type The name of the type containing the property.
     * @param propertyName The property name.
     * @return The type name of the property.
     */
    function getPropertyType(type: string, propertyName: string): string;
    /**
     * Gets the type of a property.
     *
     * @param typeMetadata Metadata for the type containing the property.
     * @param propertyName The property name.
     * @return The type name of the property.
     */
    function getPropertyType(typeMetadata: Metadata, propertyName: string): string;
    /**
     * Gets type metadata of a property from a given metadata object.
     *
     * @param typeMetadata Metadata object.
     * @param property Property of which metadata is to be found.
     * @return Metadata of a given property.
     */
    function getPropertyTypeMetadata(typeMetadata: Metadata, property: string): Metadata;
    /**
     * Gets the property metadata.
     *
     * @param type The name of the type containing the property.
     * @param propertyName The property name.
     * @return The property metadata.
     */
    function getPropertyMetadata(type: string, propertyName: string): MetadataProperty;
    /**
     * Gets the property metadata.
     *
     * @param typeMetadata Metadata for the type containing the property.
     * @param propertyName The property name.
     * @return The property metadata.
     */
    function getPropertyMetadata(typeMetadata: Metadata, propertyName: string): MetadataProperty;
    /**
     * Gets the cardinality of a property.
     *
     * @param type The name of the type containing the property.
     * @param propertyName The property name.
     * @return Value of the property.isArray value.
     */
    function getPropertyCardinality(type: string, propertyName: string): boolean;
    /**
     * Gets the type of a property.
     *
     * @param typeMetadata Metadata for the type containing the property.
     * @param propertyName The property name.
     * @return Value of the property.isArray value.
     */
    function getPropertyCardinality(typeMetadata: Metadata, propertyName: string): boolean;
    /**
     * Gets the property names for a given type.
     *
     * @param typeMetadata Metadata for the type.
     * @return An array of property names.
     */
    function getProperties(typeMetadata: Metadata): string[];
    /**
     * Gets a boolean reflecting whether the type has at least one id property.
     *
     * @param typeMetadata Metadata describing the type of the item.
     * @return Whether the Metadata has an id.
     */
    function typeHasId(typeMetadata: Metadata.Metadata): boolean;
    /**
     * Gets a string reflecting the identity of a supplied item.
     *
     * @param item The data item.
     * @param type The type name.
     * @return A string representation of the identity of the item.
     */
    function getItemId(item: Object, type: string): string;
    function getItemId(item: Object, metadata: Metadata.Metadata): string;
    /**
     * Gets the names of those data item properties that uniquely identify a data item among its peers in a cached array.
     *
     * @param metadata Type metadata.
     * @return An array of property names or null.
     */
    function getIdPropertyNames(metadata: Metadata.Metadata): string[];
    /**
     * Gets the names of those data item properties that uniquely identify a data item among its peers in a cached array.
     *
     * @param typeName Type name.
     * @return An array of property names or null.
     */
    function getIdPropertyNames(typeName: string): string[];
    /**
     * An utility function that decorates an array or object with typing.
     *
     * @param data The array or object.
     * @param type The type name.
     */
    function decorateWithType(data: any, type: string): void;
    /**
     * Typed data visitation.
     *
     * @param data Data to be visited.
     * @param type Type of visited data.
     * @param callbacks Callbacks to be triggered while traversing.
     */
    function visitTypedData(data: any, type: string, callbacks: TypedDataVisitorCallbacks): void;
    /**
     * Determines the item type of an array.
     *
     * @param array The array (observable or native).
     * @return The item type name.
     */
    function getArrayItemType(array: any): string;
    /**
     * Creates an object of a specified type.
     *
     * @param typeOrMetadata Type of the object to be created.
     * @return The object with undefined-valued property values.
     */
    function createEmptyObject(type: string): any;
    /**
     * Creates an object of a specified type.
     *
     * @param typeOrMetadata Type of the object to be created.
     * @return The object with undefined-valued property values.
     */
    function createEmptyObject(metadata: Metadata): any;
    /**
     * Returns a boolean reflecting whether this type is an entity type.
     *
     * @param typeOrMetadata Type to be created.
     * @return A boolean reflecting whether this type is an entity type.
     */
    function typeIsEntityType(typeMetadata: Metadata.Metadata): boolean;
    /**
     * Sets type information for a supplied type name.
     * Note that there is no provision to unset type metadata, as the assumption is that each extension will have
     * a small, static number of model types.
     *
     * @param type The type name.
     * @param metadata The type information.
     */
    function setTypeMetadata(type: string, metadata: Metadata): void;
    /**
     * Sets type information for a collection of types.
     * Use Microsoft.Portal.Framework.ExtensionData.TypeMetadataGenerator to produce the compressed 'typesMetadata'
     * consumed by this function.
     *
     * @param typesMetadata Compressed type information for a collection of types.
     * @return Type information for the first type name, which by convention is the root type of the collection of types.
     */
    function setTypesMetadata(typesMetadata: CompressedTypesMetadata): Metadata;
    module Internal {
        /**
         * Clears type metadata for all types.
         */
        function clearAllTypesMetadata(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.ObjectCache.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides configuration for an ObjectCache object.
     */
    interface ObjectCacheConfig<TKey, TValue> {
        /**
         * Provides a string representation of the specified cache key. Every distinct cache
         * key must have a distinct string representation.
         *
         * @param key The cache key to serialize.
         * @return A string represention of the cache key.
         */
        serializeKey(key: TKey): string;
        /**
         * Given a key, this function supplies a value for a newly created cache entry. This function will be invoked
         * only when creating new cache entries.
         *
         * @param key The cache key.
         * @param entryLifetime An object that issues a notification when the cache entry is evicted. Use this to clean up any resources held by the cache entry.
         * @return The cache value.
         */
        supplyValue(key: TKey, entryLifetime: MsPortalFx.Base.LifetimeManager): TValue;
        /**
         * A variation of 'supplyValue'.  This function should only return a non-null value if that value is already
         * cached on the client (in some underlying or related cache).  When a cache entry is created using this
         * function, for telemetry purposes, this will be considered a cache hit.  This function will be invoked only
         * when creating new cache entries.
         *
         * @param key The cache key.
         * @param entryLifetime An object that issues a notification when the cache entry is evicted. Use this to clean up any resources held by the cache entry.
         * @return The cache value.
         */
        tryFindValueInRelatedCache?(key: TKey, entryLifetime: MsPortalFx.Base.LifetimeManager): {
            value: TValue;
        };
        /**
         * Optional. Invoked to notify that the given entry is being ejected from the cache.
         *
         * @param entry The entry being ejected.
         * @param key The cache key for the entry being ejected.
         */
        onEntryDisposed?(entry: TValue, key: TKey): void;
        /**
         * Deprecated. Causes cache entries to remain in memory for a specified period after
         * their last referrer is removed.
         *
         * Please do not use this option. It is deprecated and will be removed. Instead, set
         * the 'extendEntryLifetimes' option to 'true'.
         */
        evictionDelay?: number;
        /**
         * If true, cache entries will be retained in memory for a framework-controlled period even when
         * no other objects are referring to them. This makes the cache perform better: future 'fetch'
         * operations are more likely to be satisfied without needing to wait for HTTP requests.
         *
         * We recommend that you always enable this option. Please ensure that none of your other code
         * relies on cache entries being evicted synchronously.
         */
        extendEntryLifetimes?: boolean;
    }
    /**
     * A reference-counted cache of objects of a specific type.
     */
    class ObjectCache<TKey, TValue> {
        private _referrerPropertyName;
        private _referrerUniqueId;
        private _supplyValue;
        private _tryFindValueInRelatedCache;
        private _serializeKey;
        private _entries;
        private _telemetryCollector;
        /**
         * Constructs an instance of ObjectCache.
         *
         * @param config Configuration for the instance.
         */
        constructor(config: ObjectCacheConfig<TKey, TValue>);
        /**
         * Retrieves a value from the cache. If the value was not already cached, it will be created,
         * added to the cache, and then returned.
         *
         * @param key Cache key for the item to retrieve.
         * @param referrer Associates the cache entry with this referrer, so it will remain cached at least until this object notifies that it was disposed.
         * Pass null to avoid participating in the refcounting.
         * @return The cached value.
         */
        getValue(key: TKey, referrer: MsPortalFx.Base.LifetimeManager): TValue;
        /**
         * Ensures that the cache contains an entry for the specified key. If the cache already contains an entry for the specified
         * key, nothing will happen (the entry will not be overwritten).
         *
         * @param key Cache key for the item.
         * @param value The value to be inserted if there was no existing entry.
         * @param referrer Associates the cache entry with this referrer, whether or not it already exists in the cache.
         */
        insertValueIfNotPresent(key: TKey, value: TValue, referrer: MsPortalFx.Base.LifetimeManager): void;
        /**
         * Determines whether or not the cache contains an entry for the specified key.
         *
         * @param key Cache key for the item.
         * @return True if the entry is present; false otherwise.
         */
        hasEntry(key: TKey): boolean;
        /**
         * Removes any association between the specified key and referrer, or does nothing if there was no such association.
         * Once a cache entry has no remaining referrers, it will be removed from the cache.
         *
         * @param key Cache key for the item.
         * @param referrer The referrer to be dissociated from the cache entry.
         */
        dissociateEntry(key: TKey, referrer: MsPortalFx.Base.LifetimeManager): void;
        /**
         * Dissociates all referrers from the entry and evicts the entry from the cache. Does not wait
         * for any eviction delay.
         *
         * @param key The entry to be evicted.
         */
        immediatelyEvictEntry(key: TKey): void;
        /**
         * Invokes a callback for each entry currently in the cache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEntry(callback: (key: TKey, value: TValue) => void): void;
        /**
         * Disposes the cache, so that it releases references to all entries. Once this is done,
         * that cache can no longer store new entries.
         */
        dispose(): void;
        private _getOrCreateReferrerId(referrer);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.PartialError.d.ts
declare module MsPortalFx.Data {
    /**
     * Describes a partial error returned while attempting to fetch data.
     */
    interface PartialError {
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.ProcessedResult.d.ts
declare module MsPortalFx.Data {
    /**
     * The contract of data that's passed as in/out parameter for ProcessResultFunction.
     */
    interface ProcessedResult {
        /**
          * The result from the AJAX request passed in subsequent Data.Loader result processor functions.
          * This is the data that would be merged into the data set.
          */
        data?: any;
        /**
         * Describes the state of navigable data, for example specifying the
         * total number of items or the token needed to fetch further data.
         */
        navigationMetadata?: DataNavigationMetadata;
        /**
         * An optional collection of partial errors returned by the server, possibly in
         * addition to any data received successfully.
         */
        partialErrors?: MsPortalFx.Data.PartialError[];
        /**
         * Determines type of data to be merged into the data set.
         * Can alternatively be supplied as an option to MsPortalFx.Data.Loader.getData.
         */
        type?: string;
        /**
         * Clients can return select response headers and return them here.
         */
        fetchState?: any;
    }
    /**
     * The contract of Data.Loader result processing function.
     */
    interface ProcessResultFunction {
        /**
         * Function that decides whether to merge data in Data.Loader once retrieved. It also shapes the data, type
         * and fetch state before the actual merge happens.
         *
         * @param dataSetName Name of the data set for which data is being fetched.
         * @param result Object passed along the Data.Loader chain of result processors to subsequent
         *     ProcessResultFunction functions calls. Once all functions are called, this object contains the type of
         *     the data to be merged as well as state that is to be saved between this and subsequent server fetches.
         * @param lastFetchState Fetch state returned by the previous fetch for this data set.
         * @param fetchingSameData A boolean indicating that the URI/data/headers have not changed from those used for
         *     the previous fetch for this data set.
         * @param entityType Specifies the type of entities in the data set, or null if unknown.
         * @return Return false if 'result.data' is to be discarded and subsequent result processor functions are not
         *     called. Return true to continue calling subsequent result processor functions. The last such return
         *     value determines whether the fetch result is to be merged into the data set. See ProcessResultOutput
         *     type documentation for details on how 'result' object is used later to determine further actions if
         *     ProcessResultFunction returns true.
         */
        (dataSetName: string, result: ProcessedResult, lastFetchState: any, fetchingSameData: boolean, entityType: string): boolean;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.Query.d.ts
declare module MsPortalFx.Data {
    interface DataSourcePaging {
        /**
         * How many results should be skipped.
         */
        skip?: number;
        /**
         * How many results should be returned.
         */
        take?: number;
    }
    /**
     * Representation of a remote data query.
     */
    interface Query {
        /**
         * Paging options.
         */
        paging?: DataSourcePaging;
        /**
         * Direction of sorting (ascending or descending).
         */
        sort?: any;
        /**
         * Filter format: [{ property: ..., operator: ..., value: ...}, ...]
         */
        filter?: any;
        /**
         * Should query return total number of elements on endpoint side
         */
        includeTotalCount?: any;
    }
    /**
     * The contract of for shaping queries sent to extension endpoint.
     */
    interface ShapeQueryFunction {
        /**
         * Function that shapes representation of the data query to a format that can be included in an HTTP call to fetch server data.
         *
         * @param query Representation of a remote data query.
         * @return Representation of the query used for the HTTP call for server data.
         */
        (query: Query): any;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.QueryCache.d.ts
declare module MsPortalFx.Data {
    /**
     * Options to define how a navigator is created from a QueryCache.
     */
    interface CreateNavigatorOptions<TEntity, TMappedEntity> {
        /**
         * A callback that will be used to produce the 'items' collection on the
         * resulting data navigator. You can use this to project the source entities
         * into a different data format. You should use an observable mapping, for
         * example sourceItems.map(...), so that the navigator can remain up-to-date
         * as it moves through the underlying data.
         *
         * @param lifespan A lifetime object that signals when you should release any resources held by your mapping.
         * @param sourceItems The navigator's underlying items to be mapped.
         * @return The mapped array.
         */
        createMapping?(lifespan: MsPortalFx.Base.LifetimeManager, sourceItems: KnockoutObservableArray<TEntity>): KnockoutObservableBase<TMappedEntity[]>;
    }
    /**
     * A cache of query results for a specific type of entity and query parameters.
     */
    class QueryCache<TEntity, TQueryParams> extends FxImpl.Data.DataCache<KnockoutObservableBase<TEntity[]>, TQueryParams> implements EditScopeInputDataCache<KnockoutObservableBase<TEntity[]>, TQueryParams>, DataCache<KnockoutObservableBase<TEntity[]>, TQueryParams> {
        private _navigationOptions;
        /**
         * Constructs an instance of DataCache<TEntity, TParams>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: MsPortalFx.Data.QueryCacheConfig<TEntity, TQueryParams>);
        /**
         * Creates a QueryView that provides a convenient way to retrieve query results from
         * the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new QueryView. A typical example is a
         * PartContainer instance - supplying one means that the QueryView's entries may be released when the corresponding Part is removed
         * from the UI.
         * @param config Additional options for configuring the QueryView.
         * @return A QueryView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TQueryParams>): QueryView<TEntity, TQueryParams>;
        /**
         * Creates a RemoteDataNavigator that can query and navigate through data supplied by the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held. A typical example is a PartContainer
         * instance - supplying one means that the cache entries may be released when the corresponding Part is removed from the UI.
         * @return A RemoteDataNavigator instance.
         */
        createNavigator(lifespan: MsPortalFx.Base.LifetimeManager): RemoteDataNavigator<TEntity, TQueryParams>;
        /**
         * Creates a RemoteDataNavigator that can query and navigate through data supplied by the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held. A typical example is a PartContainer
         * instance - supplying one means that the cache entries may be released when the corresponding Part is removed from the UI.
         * @param options Options influencing the resulting data navigator.
         * @return A RemoteDataNavigator instance.
         */
        createNavigatorWithOptions<TMappedEntity>(lifespan: MsPortalFx.Base.LifetimeManager, options: CreateNavigatorOptions<TEntity, TMappedEntity>): RemoteDataNavigator<TMappedEntity, TQueryParams>;
        /**
         * Any navigation options configured for this QueryCache.
         */
        navigationOptions: MsPortalFx.Data.QueryCacheNavigationOptions<TEntity, TQueryParams>;
        _findMatchingEntity<TId>(comparer: (entity: TEntity, id: TId) => boolean, id: TId): TEntity;
        protected _getDataFromDataSet(dataSet: DataSet): KnockoutObservableBase<TEntity[]>;
    }
    /**
     * Supplies configuration options for a QueryCache.
     */
    interface QueryCacheConfig<TEntity, TParams> extends DataCacheConfig<TEntity, TParams> {
        /**
         * Describes how any QueryViews based on this cache can navigate through the data.
         */
        navigation?: QueryCacheNavigationOptions<TEntity, TParams>;
    }
    /**
     * Describes how any QueryViews based on a QueryCache are able to navigate through the data.
     */
    interface QueryCacheNavigationOptions<TEntity, TParams> {
        /**
         * If the data source supports skip/take, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         *
         * @param queryView The QueryView instance that should be navigated.
         * @param query Query parameters to be used.
         * @param skip The number of records to skip.
         * @param take The number of records to take.
         * @param filter Any filtering value entered by the user.
         * @return A promise representing the operation.
         */
        loadBySkipTake?(queryView: QueryView<TEntity, TParams>, query: TParams, skip: number, take: number, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
        /**
         * If the data source supports continuation tokens, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         *
         * @param queryView The QueryView instance that should be navigated.
         * @param query Query parameters to be used.
         * @param reset If true, indicates that the first page of data should be loaded. Otherwise, the continuation token in metadata should be used to fetch
         * the next range of data.
         * @param filter Any filtering value entered by the user.
         * @return A promise representing the operation.
         */
        loadByContinuationToken?(queryView: QueryView<TEntity, TParams>, query: TParams, reset: boolean, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.QueryView.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides a view of query results from an underlying QueryCache. The
     * 'items' observable array property remains constant but its contents change
     * whenever you change query parameters, or when the results themselves change.
     */
    class QueryView<TEntity, TQueryParams> extends FxImpl.Data.DataView<TEntity, TQueryParams> implements EditScopeInputDataView<KnockoutObservableBase<TEntity[]>, TQueryParams> {
        private _items;
        private _metadata;
        /**
         * Internal constructor. Extensions should not invoke this directly. Instead,
         * create a QueryCache and then use its 'createView' method to obtain a QueryView.
         *
         * @param dataSource Internal. Extensions should not use this QueryView constructor directly.
         * @param lifetime Internal. Extensions should not use this QueryView constructor directly.
         * @param config Internal. Extensions should not use this QueryView constructor directly.
         */
        constructor(dataSource: FxImpl.Data.QueryViewSource<TEntity, TQueryParams>, lifetime: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TQueryParams>);
        /**
         * An observable array whose contents are the current query results retrieved from the underlying cache.
         * The array is empty until the first query results are obtained.
         *
         * Use the QueryView's 'fetch' method to specify a query that, when completed, will give the data for this array.
         *
         * Use the QueryView's 'refresh' method to cause this array's data to be updated via a new server request.
         */
        items: KnockoutObservableArray<TEntity>;
        metadata: KnockoutObservableBase<DataNavigationMetadata>;
        /**
         * See interface.
         */
        data: KnockoutObservableBase<TEntity[]>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Data.UriFormatter.d.ts
declare module MsPortalFx.Data {
    /**
     * Returns a URI formatting function that uses the specified format string. This can be
     * suppled as the 'sourceUri' parameter on a DataCacheConfig instance.
     *
     * If the parameter value you will later supply is a simple primitive (string or number),
     * then your format string should refer only to a single token, '{id}'.
     * Example: '/products/{id}.json'
     *
     * If the parameter value you will later supply is an object with subproperties,
     * then your format string should instead reference those subproperties by name, for example:
     * Example: '/products/{department}/{category}/all'.
     *
     * @param uriFormat A formatting string.
     * @param encodeTokens If true, tokens will be URI component encoded. If false, tokens will be inserted without encoding, so you must ensure you have already encoded the tokens appropriately.
     * @return A URI formatting function.
     */
    function uriFormatter(uriFormat: string, encodeTokens: boolean): (params: any) => string;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.AtomizationContext.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxLifetimeManager = FxBase.LifetimeManager;
    /**
     * Atomization serves two main goals:
     * 1) Enables several data views to be bound to one data entity, thus giving smooth, consistent
     *    experience to user, where 2 views representing the same asset are always in sync.
     * 2) Minimizes memory trace.
     */
    interface AtomizationContext {
        /**
         * Add a new entity to atomization context.
         * @param type Entity type.
         * @param id Entity id.
         * @param entity Entity itself.
         * @param referrer Lifetime manager of the requesting data set.
         */
        addEntity(type: string, id: string, entity: Object, referrer: FxLifetimeManager): void;
        /**
         * Retrieves an appropriate entity from atomization context. Null if entity is not present.
         * @param type Entity type.
         * @param id Entity id.
         * @param referrer Lifetime manager of the requesting data set.
         * @return Entity itself.
         */
        getEntity(type: string, id: string, referrer: FxLifetimeManager): Object;
        /**
         * Update references to elements removed from an array in atomization context.
         * @param type Entity type.
         * @param removedItemsArray Removed items.
         * @param referrer Lifetime manager of the requesting data set.
         */
        releaseEntities(type: string, removedItemsArray: any[], referrer: FxLifetimeManager): void;
    }
    /**
     * Implementation of a atomization context with garbage collection.
     */
    class RefCountingAtomizationContext implements AtomizationContext {
        private _atomizationCache;
        constructor();
        /**
         * See interface.
         */
        getEntity(type: string, id: string, referrer: FxLifetimeManager): Object;
        /**
         * See interface.
         */
        addEntity(type: string, id: string, entity: Object, referrer: FxLifetimeManager): void;
        /**
         * See interface.
         */
        releaseEntities(type: string, removedItemsArray: any[], referrer: FxLifetimeManager): void;
    }
    module AtomizationContext {
        var atomizationContextCollection: StringMap<FxImpl.Data.AtomizationContext>;
        /**
         * Retrieves a atomization context. Creates one if hasn't been created yet, using
         */
        function get(id?: string): FxImpl.Data.AtomizationContext;
        /**
         * Retrieves information whether a given type can be atomized.
         * @param type Type in question.
         * @return Whether a given type can be atomized.
         */
        function canAtomizeType(type: string): boolean;
        /**
         * Factory of atomization contexts.
         * @return Atomization context.
         */
        function createInstance(): FxImpl.Data.AtomizationContext;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.CloneVisitor.d.ts
declare module FxImpl.Data {
    import Metadata = MsPortalFx.Data.Metadata;
    import ArrayOrObservableArray = Shared.ArrayOrObservableArray;
    /**
     * An interface through which a CloneVisitor is to be used.
     */
    interface CloneVisitorContract {
        /**
         * Deeply clones the supplied data.
         *
         * @param data The data to be cloned.
         * @param typeMetadata Type metadata covering the data.
         *
         * @return A clone of the data.
         */
        clone(data: any, typeMetadata: Metadata.Metadata): any;
    }
    /**
     * Options supplied when constructing a CloneVisitor.
     */
    interface CloneVisitorOptions extends VisitorOptions {
    }
    /**
     * This interface is used to customize a CloneVisitor by supplying mix-in style callbacks.
     */
    interface CloneVisitorCallbacks extends VisitorCallbacks<void, any> {
    }
    /**
     * A visitor that deeply clones supplied data.
     */
    class CloneVisitor extends Visitor<void, any> implements CloneVisitorContract {
        /**
         * Constructs an CloneVisitor instance.
         *
         * @param options Options used in the construction of the CloneVisitor.
         * @param callbacks Optional, mix-in style callbacks that override default CloneVisitor behavior.
         */
        constructor(options: CloneVisitorOptions, callbacks: CloneVisitorCallbacks);
        /**
         * See interface.
         */
        clone(data: any, typeMetadata: Metadata.Metadata): any;
        /**
         * See interface.
         */
        visitArray(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata): ArrayOrObservableArray;
        /**
         * See interface.
         */
        visitObject(obj: StringMap<any>, typeMetadata: Metadata.Metadata): StringMap<any>;
        /**
         * See interface.
         */
        visitEntityTypedObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata): any;
        /**
         * See interface.
         */
        visitObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata): any;
        /**
         * See interface.
         */
        visitDate(date: Date): Date;
        /**
         * See interface.
         */
        visitScalar(value: number | string): any;
        /**
         * See interface.
         */
        visitFunction(fn: Function): any;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.DataCache.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxData = MsPortalFx.Data;
    /**
     * Extends ObjectCacheConfig with framework-internal properties that are not meant
     * for use by extensions.
     */
    interface ObjectCacheConfigInternal<TKey, TValue> extends FxData.ObjectCacheConfig<TKey, TValue> {
        /**
         * Indicates that the cache should measure its hit/miss efficiency and submit
         * telemetry via an RPC call to the Shell.
         */
        collectEfficiencyTelemetry?: boolean;
    }
    /**
     * Provides a specialised API on top of ObjectCache intended for loading DataSet
     * objects via FxData.Loader. This is not intended to be used directly - developers
     * should use one of the two subclasses, EntityCache or QueryCache, depending on whether
     * they want to retrieve single entities by ID, or multiple entities by query.
     */
    abstract class DataCache<TEntity, TParams> implements DataViewSource<TEntity, TParams> {
        private _loader;
        private _cacheByParams;
        private _dataCacheUniqueId;
        private _dataSetUniqueIdWithinDataCache;
        /**
         * Constructs an instance of DataCache<TEntity, TParams>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: FxData.DataCacheConfig<TEntity, TParams>);
        /**
         * Retrieves a DataSetPromise from the cache. If it is not already present in the cache,
         * it will be created (e.g. via the configured loader).
         *
         * @param params Parameters defining what data the cache entry should load.
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed. If you pass 'null', then this call will not force the cache entry to stay in memory.
         * @return A promise that will complete with the retrieved DataSet.
         */
        fetch(params: TParams, referrer: FxBase.LifetimeManager): FxData.DataSetPromise;
        /**
         * Instructs the underlying data loader to refresh data in the DataSet corresponding to the
         * supplied parameters.
         *
         * @param params Parameters defining what data the cache entry should refresh (or load, if not already cached).
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed. If you pass 'null', then this call will not force the cache entry to stay in memory.
         * @return A promise that will complete when the data has finished being refreshed.
         */
        refresh(params: TParams, referrer: FxBase.LifetimeManager): FxBase.Promise;
        /**
         * Instructs the underlying data loader to refresh data in the DataSet corresponding to the
         * specified cache entries.
         *
         * @param predicate A predicate that determines which cache entries should be refreshed. If not specified, all in-memory cache entries will be refreshed.
         */
        refreshAll(predicate?: (params: TParams) => boolean): void;
        /**
         * Immediately removes the specified cache entry, regardless of whether it has active referrers,
         * and without waiting for any eviction delay. This also stops any polling configured for this entry.
         *
         * If there was no cache entry matching the specified parameters, this method does nothing.
         *
         * @param params Parameters defining the entry to be removed.
         */
        forceRemove(params: TParams): void;
        /**
         * Passes each current cache entry to a callback, so that you may mutate it in place (for
         * example, to reflect the result of a create/update/delete operation without waiting for
         * polling to complete).
         *
         * Any in-flight poll/refresh requests for updated cache entries will be discarded and
         * restarted. This ensures the old requests don't overwrite your changes with stale data.
         *
         * @param callback A callback invoked for each cache entry.
         * @param predicate An optional predicate that determines which cache entries are to be updated. If not specified, all cache entries are to be updated.
         */
        applyChanges(callback: (params: TParams, dataSet: FxData.DataSet) => void, predicate?: (params: TParams) => boolean): void;
        /**
         * Disposes the DataCache, which in turn disposes all DataSets it was holding.
         */
        dispose(): void;
        /**
         * See FxData.DataCache interface.
         */
        doesPoll: boolean;
        _findEntity<TEntity, TId, TData>(findCallback: (cacheEntryParams: TParams, cacheEntryData: TData, id: TId) => TEntity, id: TId): TEntity;
        /**
         * Dumps the data currently in the data cache
         *
         * @param dumpAsObjects If not set this function will print all the data in the cache to the console and return nothing. If set to true the function will return the objects in the cache.
         * @return If dumpAsObjects is not set there is no return value. If it is set the data in the cache will be returned.
         */
        dump(dumpAsObjects?: boolean): any;
        protected _tryFindDataInRelatedCache(params: TParams, entryLifetime: FxBase.LifetimeManager): any;
        protected _forEachEntry(callback: (params: TParams, dataSetPromise: FxData.DataSetPromise, dataSet: FxData.DataSet) => void, predicate?: (params: TParams) => boolean): void;
        protected abstract _getDataFromDataSet(dataSet: FxData.DataSet): any;
        private _supplyValue(dataSetName, params, entryLifetime);
        private _establishDataSet(dataSetName, params, data, entryLifetime);
        private _createUniqueDataSetName();
        private _logIgnoredDataCacheLoaderOptions(config);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.DataView.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxData = MsPortalFx.Data;
    /**
     * Provides a convenient way to access results from an underlying ViewSource. Whenever you modify
     * the query parameters associated with the ObjectView, it will fetch a corresponding TObject from
     * the underlying ViewSource.
     *
     * Extension developers are not intended to use this directly, and should instead use one of the
     * specialized subclasses, e.g. EntityView, QueryView, that can be obtained by calling
     * .createView() on an EntityCache or QueryCache instance.
     */
    class DataView<TEntity, TParams> extends ObjectView<FxData.DataSet, TParams> {
        private _partialErrors;
        private _refreshableDataSource;
        /**
         * Internal constructor. Extension developers are not intended to use this directly, and should
         * instead use one of the specialized subclasses, e.g. EntityView, QueryView, that can be obtained
         * by calling .createView() on an EntityCache or QueryCache instance.
         */
        constructor(dataSource: FxImpl.Data.DataViewSource<TEntity, TParams>, lifetime: FxBase.LifetimeManager, config: ObjectViewConfig<TEntity, TParams>);
        partialErrors: KnockoutReadOnlyObservableArray<FxData.PartialError>;
        /**
         * Instructs the underlying data loader to re-fetch and update whatever data is
         * currently being exposed by this instance.
         *
         * If a request is currently in progress, this does not trigger a further request.
         * So, it is safe to invoke 'refresh' immediately after a 'fetch' if you want to
         * be sure to fetch fresh data and not accept existing cached data.
         *
         * @return A promise that completes when the refresh is done. Or, if a request was already in progress, a promise that completes when the existing request completes.
         */
        refresh(): FxBase.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.EditScopeCache.d.ts
declare module FxImpl.Data {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import FxData = Fx.Data;
    import Rpc = FxBase.Rpc.Internal;
    var saveSerializedEditScopeEndPoint: Rpc.ActionEndPointDefinition<SaveSerializedEditScopeParameters>;
    var loadSerializedEditScopeEndPoint: Rpc.FuncEndPointDefinition<string, EditScopeEdits>;
    var onEditScopeDiscardedEndPoint: Rpc.ActionEndPointDefinition<string>;
    var updateEditScopeIsSavingStateEndPoint: Rpc.ActionEndPointDefinition<UpdateEditScopeIsSavingStateParameters>;
    interface SaveSerializedEditScopeParameters {
        editScopeId: string;
        edits: EditScopeEdits;
    }
    interface UpdateEditScopeIsSavingStateParameters {
        editScopeId: string;
        isSaving: boolean;
    }
    enum FetchEditScopeError {
        /**
         * The ajax call to loading original data failed.
         */
        LoadOriginalDataFailed = 0,
        /**
         * The ajax call to load serialized, previously authored edits failed.
         */
        LoadEditsFailed = 1,
        /**
         * Deserialized, previously authored edits are no longer consistent with the current server data.
         */
        ApplyEditsFailed = 2,
    }
    /**
     * Load and save EditScope edits callback interface.
     */
    interface EditScopeCacheEditsCallbacks {
        /**
         * Function called to load EditScope edits.
         */
        loadEdits?: (editScopeId: string) => FxBase.PromiseV<FxImpl.Data.EditScopeEdits>;
        /**
         * Function called to save EditScope edits.
         */
        saveEdits?: (editScopeId: string, editScope: FxImpl.Data.EditScope<any>) => void;
        /**
         * Function called to bracket an async EditScope 'save' operation.
         */
        updateEditScopeIsSavingState?: (editScopeId: string, isSaving: boolean) => void;
    }
    /**
     * Receives editScopeDiscarded events for dirty editScopes from Shell and routes them to the EditScopeCaches.
     */
    class EditScopeDiscardedReceiver {
        private _caches;
        constructor(rpcClient?: Rpc.Client);
        register(editScopeCache: EditScopeCacheBase): void;
        deregister(editScopeCache: EditScopeCacheBase): void;
    }
    var editScopeDiscardedReceiver: EditScopeDiscardedReceiver;
    interface EditScopeCacheBase {
        onEditScopeDiscarded(editScopeId: string): FxBase.Promise;
    }
    /**
     * A cache of EditScopes.
     */
    class EditScopeCache<TData, TParams> implements FxData.EditScopeCache<TData, TParams>, EditScopeCacheBase, FxImpl.Data.ViewSource<EditScopeKey<TParams>> {
        private static _rpcClient;
        private _entityTypeName;
        private _options;
        private _cacheByParams;
        private _loadEdits;
        private _saveEdits;
        private _updateEditScopeIsSavingState;
        private _editScopeEditsChangedSubs;
        /**
         * Initializes a new instance of EditScopeCache.
         */
        constructor(options: FxData.EditScopeCacheOptions<TData, TParams>, callbacks?: EditScopeCacheEditsCallbacks);
        /**
         * Creates a EditScopeView that provides a convenient way to retrieve an EditScope from the cache.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new EditScopeView. A typical example is a PartContainer
         * instance - supplying one means that the QueryView's entries may be released when the corresponding Part is removed from the UI.
         * @param config Additional options for configuring the EditScopeView.
         * @return An EditScopeView instance.
         */
        createView(lifespan: FxBase.LifetimeManager, config?: FxData.EditScopeViewConfig<TData, TParams>): FxData.EditScopeView<TData, TParams>;
        /**
         * Retrieves a FxBase.PromiseV<Data.EditScope> from the cache. If it is not already present in the cache,
         * it will be created (either via a configured supplyExistingData, or supplyNewData).
         *
         * @param key Parameters defining what data the cache entry should load.
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed.
         * @return A promise that will complete with the retrieved EditScope.
         */
        fetch(key: EditScopeKey<TParams>, referrer: FxBase.LifetimeManager): FxBase.PromiseV<EditScope<TData>>;
        /**
         * Invokes a callback for each entry currently in the EditScopeCache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEditScope(callback: (editScopeId: string, editScope: EditScope<TData>) => void): FxBase.Promise;
        /**
         * Disposes the EditScopeCache, which in turn disposes all EditScopes it was holding.
         */
        dispose(): void;
        disposeAndDiscardEdits(editScopeId: string, editScopeView: FxData.EditScopeView<TData, TParams>): void;
        onEditScopeDiscarded(editScopeId: string): FxBase.Promise;
        private static _remoteSaveEditScope(editScopeId, editScope);
        private static _remoteSaveEdits(editScopeId, edits);
        private static _remoteLoadEdits(editScopeId);
        private static _remoteUpdateEditScopeIsSavingState(editScopeId, isSaving);
        private _isDisposed;
        private _serializeKey(key);
        private _getEditScopeForKey(key, lifetime);
        private _acquireEditScope(key, loadOriginalData, lifetime, typeName);
        private _loadAndApplyEdits(editScope, editScopeId);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.EditScopeCacheOld.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    /**
     * A cache of key results for a specific type of EditScope and key parameters.
     */
    class EditScopeCacheOld<T, TParams> implements MsPortalFx.Data.EditScopeCache<T, TParams>, FxImpl.Data.EditScopeCacheBase, FxImpl.Data.ViewSource<EditScopeKey<TParams>> {
        private static _rpcClient;
        private _entityTypeName;
        private _options;
        private _cacheByParams;
        private _loadEdits;
        private _saveEdits;
        private _editScopeEditsChangedSubs;
        /**
         * Initializes a new instance of EditScopeCache.
         */
        constructor(options: MsPortalFx.Data.EditScopeCacheOptions<T, TParams>, callbacks?: EditScopeCacheEditsCallbacks);
        /**
         * Creates a EditScopeView that provides a convenient way to retrieve an EditScope from the cache.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new EditScopeView. A typical example is a PartContainer
         * instance - supplying one means that the QueryView's entries may be released when the corresponding Part is removed from the UI.
         * @param config Additional options for configuring the EditScopeView.
         * @return An EditScopeView instance.
         */
        createView(lifespan: FxBase.LifetimeManager, config?: MsPortalFx.Data.EditScopeViewConfig<T, TParams>): MsPortalFx.Data.EditScopeView<T, TParams>;
        /**
         * Retrieves a FxPromiseV<Data.EditScope> from the cache. If it is not already present in the cache,
         * it will be created (either via a configured supplyExistingData, or supplyNewData).
         *
         * @param key Parameters defining what data the cache entry should load.
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed.
         * @return A promise that will complete with the retrieved EditScope.
         */
        fetch(key: EditScopeKey<TParams>, referrer: FxBase.LifetimeManager): FxPromiseV<EditScope<any>>;
        /**
         * Invokes a callback for each entry currently in the EditScopeCache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEditScope(callback: (editScopeId: string, editScope: EditScope<any>) => void): FxPromise;
        /**
         * Disposes the EditScopeCache, which in turn disposes all EditScopes it was holding.
         */
        dispose(): void;
        disposeAndDiscardEdits(editScopeId: string, editScopeView: MsPortalFx.Data.EditScopeView<T, TParams>): void;
        onEditScopeDiscarded(editScopeId: string): FxPromise;
        private static _remoteSaveEditScope(editScopeId, editScope);
        private static _remoteSaveEdits(editScopeId, edits);
        private static _remoteLoadEdits(editScopeId);
        private _isDisposed;
        private _revertEditScope(editScopeId);
        private _serializeKey(key);
        private _getEditScopeForKey(key, lifetime);
        private _acquireEditScope(key, loadOriginalData, lifetime, typeName);
        private _loadAndApplyEdits(editScope, editScopeId);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.EditScopeKey.d.ts
declare module FxImpl.Data {
    /**
     * Internal EditScope key value for specific T type held in cache.
     */
    interface EditScopeKey<TParams> {
        /**
         * EditScope id.
         */
        editScopeId: string;
        /**
         * Value identifying the data loaded into the EditScope held in the cache.
         * If the data is object-typed, this value is an id identifying that entity.
         * If the data is array-typed, this value is the query processed to return the array items.
         *
         * There are two sentinel values:
         * undefined - implies, that EditScopeView.fetchForNewData was called.
         * null - implies, that EditScopeView.fetchForExistingData was called and no 'params' was passed.
         *        This happens e.g. in scenario, when there's only one array on the server, that user
         *        wants to retrieve.
         */
        params: TParams;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.MergeVisitor.d.ts
declare module FxImpl.Data {
    import Metadata = MsPortalFx.Data.Metadata;
    import ArrayOrObservableArray = Shared.ArrayOrObservableArray;
    /**
     * An interface through which a MergeVisitor is to be used.
     */
    interface MergeVisitorContract<TData> {
        /**
         * Merges supplied source data onto a supplied target.
         *
         * @param source The source data (from which values will be copied).
         * @param target The target (onto which source values will be applied).
         * @param typeMetadata Type metadata covering the source/target data.
         */
        merge(source: TData, target: TData, typeMetadata: Metadata.Metadata): void;
    }
    /**
     * Options supplied when constructing a MergeVisitor.
     */
    interface MergeVisitorOptions extends VisitorOptions {
        /**
         * A callback called when data is detached from the target data.
         *
         * @param data The data.
         * @param typeMetadata Type metadata covering the data.
         */
        onDetach: (data: any, typeMetadata: Metadata.Metadata) => void;
        /**
         * A callback called to clone supplied source data, in the event that the data is new to the target data.
         *
         * @param data The data to be cloned.
         * @param typeMetadata Type metadata covering the data.
         *
         * @return A clone of the data.
         */
        clone: (data: any, typeMetadata: Metadata.Metadata) => any;
    }
    /**
     * This interface is used to customize a MergeVisitor by supplying mix-in style callbacks.
     */
    interface MergeVisitorCallbacks extends VisitorCallbacks<any, boolean> {
    }
    /**
     * A Visitor that observably merges source data onto target data.
     */
    class MergeVisitor<TData> extends Visitor<any, boolean> implements MergeVisitorContract<TData> {
        _clone: (data: any, typeMetadata: Metadata.Metadata) => any;
        _onDetach: (data: any, typeMetadata: Metadata.Metadata) => void;
        /**
         * Constructs an MergeEntityOnlyVisitor instance.
         *
         * @param options Options used in the construction of the MergeEntityOnlyVisitor.
         */
        constructor(options: MergeVisitorOptions, callbacks: MergeVisitorCallbacks);
        /**
         * See interface.
         */
        merge(source: TData, target: TData, typeMetadata: Metadata.Metadata): void;
        /**
         * See interface.
         */
        visitObject(sourceObject: StringMap<any>, typeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        /**
         * See base class.
         */
        visitObjectPropertyValueDispatch(property: string, sourceObject: StringMap<any>, typeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        /**
         * See interface.
         */
        visitEntityTypedObjectPropertyValue(property: string, sourceObject: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        /**
         * See interface.
         */
        visitNonEntityTypedObjectPropertyValue(property: string, sourceObject: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        /**
         * See interface.
         */
        visitObjectPropertyValue(property: string, sourceObject: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        /**
         * See interface.
         */
        visitArray(sourceArray: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, targetArray: ArrayOrObservableArray): boolean;
        _mergeArray(sourceArray: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, targetArray: ArrayOrObservableArray, workerFunctions?: {
            getEdits?: (unwrappedSourceArray: any[], unwrappedTargetArray: any[]) => KnockoutArrayEdit<any>[];
            getSourceItem?: (targetItem: any, unwrappedSourceArray: any[]) => any;
            handleAdd?: (itemToAdd: any, index: number) => void;
            handleDelete?: (itemToDelete: any, index: number) => void;
        }): boolean;
        private _cloneAndSetProperty(property, sourceObject, typeMetadata, targetObject);
        private _getItemId(item, typeMetadata);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.ObjectCacheTelemetryCollector.d.ts
declare module FxImpl.Data {
    var _setIsDataObjectCacheTelemetryEnabled: (enable: boolean) => void;
    /**
     * Starts the process of submitting pending telemetry entries to the Shell on a regular interval.
     * The method parameters can be used to intercept the submission process for unit testing.
     *
     * @param intervalMilliseconds The interval between submissions. If not specified, a default is used.
     * @param submissionCallback Callback invoked to perform the submission. If not specified, defaults to passing entries to the Shell via RPC.
     * @return An object that, when disposed, terminates the submission cycle.
     */
    function beginTelemetrySubmission(intervalMilliseconds?: number, submissionCallback?: (entries: ObjectCacheTelemetryEntry[]) => void): {
        dispose: () => void;
    };
    /**
     * Sets up the Shell-side counterpart to the ObjectCache telemetry submitter above.
     */
    function registerTelemetrySubmissionHandler(): void;
    /**
     * Describes telemetry information relating to an object cache read event.
     */
    interface ObjectCacheTelemetryEntry {
        /**
         * The timestamp of the entry.
         */
        timestamp: number;
        /**
         * Describes the source of the telemetry event (for example, the blade or part)
         */
        source: string;
        /**
         * The cache key being read.
         */
        key: string;
        /**
         * Indicates whether the cache contained a live entry matching the specified key
         * at the time of the read.
         */
        wasHit: boolean;
        /**
         * For cache misses (i.e., wasHit is false), specifies the time since an earlier
         * matching cache entry (i.e., same cache, key, and session) was evicted, or null
         * if no such earlier entry is on record.
         */
        secondsSinceEviction: number;
    }
    /**
     * Tracks the cache's hit/miss efficiency, and for misses, determines how much longer the eviction delay
     * would have needed to be for it to have been a hit against some earlier entry.
     */
    class ObjectCacheTelemetryCollector {
        /**
         * The number of prior entry keys that will be retained in memory to establish whether subsequent
         * cache misses are warm or cold.
         */
        static maxTrackedEvictedEntries: number;
        private _evictedEntryDateValues;
        private _evictedEntryCircularBuffer;
        /**
         * Call this to report a cache read event.
         *
         * @param key The serialised key being read.
         * @param isHit True if there is a matching entry in the cache; false otherwise.
         */
        recordCacheRead(key: string, isHit: boolean): void;
        /**
         * Call this to report a cache eviction event.
         *
         * @param key The serialised key of the evicted entry.
         */
        recordEviction(key: string): void;
        private static _getCurrentTelemetrySource();
        private _recordCacheHit(key);
        private _recordCacheMiss(key);
        private _ensureEntryNotTrackedAsEvicted(key);
        private _pruneExcessiveEvictedEntries();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.ObjectView.d.ts
import ErrorNotificationTarget = MsPortalFx.Data.ErrorNotificationTarget;
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    interface CancelableRequestInfo<T extends FxPromise> {
        cancelationToken: FxBase.Promises.CancelationToken;
        cancelablePromise: T;
        externalPromise: FxPromise;
    }
    /**
     * Represents a callback that will be invoked when an a fetch operation
     * reports a 'not found' error.
     */
    interface InterceptNotFoundCallback<TParams> {
        (params: TParams): void;
    }
    /**
     * Options for configuring an ObjectView.
     */
    interface ObjectViewConfig<TObject, TParams> {
        /**
         * Indicates whether the ObjectView should intercept any 'not found' (404) errors, and if so,
         * how they should be handled. Defaults to 'true'.
         *
         *  - 'false' means that the ObjectView will not intercept 'not found' errors, which means that
         *    such errors will cause parts/blades to go into generic failure states
         *  - 'true' means that the ObjectView will intercept 'not found' errors, and handle them by
         *    displaying a generic 'not found' message
         *  - callback functions mean that custom 'not found' handling applies, so 404s will trigger
         *    your callback. This is useful for displaying custom 'not found' messages.
         *
         * Regardless of this option, all onInputsSet promise rejections other than 'not found' (404) will
         * continue to trigger generic part/blade failures.
         */
        interceptNotFound?: boolean | InterceptNotFoundCallback<TParams>;
    }
    /**
     * Provides a convenient way to access results from an underlying ViewSource. Whenever you modify
     * the query parameters associated with the ObjectView, it will fetch a corresponding TObject from
     * the underlying ViewSource.
     *
     * This class should not be instantiated directly.  Rather, acquire an instance of a subclass by
     * calling 'createView' on a Cache instance.
     */
    class ObjectView<TObject, TParams> {
        _loadedCacheEntry: KnockoutObservable<TObject>;
        _interceptNotFound: boolean | InterceptNotFoundCallback<TParams>;
        _isDisposed: boolean;
        _dataSource: ViewSource<TParams>;
        _errorNotificationTarget: ErrorNotificationTarget;
        _currentParams: TParams;
        _currentCacheEntryDisposer: FxBase.DisposableLifetimeManager;
        _requestInProgress: KnockoutObservable<CancelableRequestInfo<FxBase.PromiseV<TObject>>>;
        _isLoading: KnockoutComputed<boolean>;
        _lifetime: FxBase.LifetimeManager;
        /**
         * Constructs an instance of ObjectView<TEntity, TParams>.
         *
         * @param dataSource A provider of data for the ObjectView, for example a DataCache instance.
         * @param lifetime The current cache entry referenced by this ObjectView will remain in memory at least until this object notifies that it is disposed.
         * @param errorNotificationTarget An object that represents the minimum lifetime of the current cache entry, and can optionally receive notifications about any errors encountered.
         * @param config Options for configuring the instance.
         */
        constructor(dataSource: ViewSource<TParams>, errorNotificationTarget: ErrorNotificationTarget, config: ObjectViewConfig<TObject, TParams>);
        /**
         * An observable value that indicates whether this ObjectView currently refers to a request that has not yet completed.
         */
        loading: KnockoutComputed<boolean>;
        /**
         * Sets the ObjectView's current query parameters, changing what data it exposes.
         * The data will be fetched from the underlying cache, which may or may not already have it in memory.
         *
         * If you call 'fetch' while an earlier load is still in progress, the older load will be superseded,
         * meaning that its promise will never complete. This is so you do not need manual code to stop
         * superseded promise handlers from performing actions that are now irrelevant.
         *
         * @param params Query parameters describing the data to be fetched. If you supply null/undefined, then the preceding query will be superseded,
         * but no new query will be begun - the ObjectView will therefore become empty.
         * @return A promise that completes when the load has completed.
         */
        fetch(params: TParams): FxPromise;
        private _cancelInProgressRequest();
        private _releaseCurrentContents();
        private _handleFetchRejections(reason);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.RefCountCache.d.ts
declare module FxImpl.Data {
    /**
     * Configures a RefCountCache instance.
     */
    interface RefCountCacheConfig<T> {
        /**
         * Optional. Invoked to notify that the given entry is being ejected from the cache.
         *
         * @param entry The entry being ejected.
         * @param key The entry key.
         */
        onEntryDisposed?(entry: T, key: string): void;
        /**
         * Causes cache entries to remain in memory for a specified period after
         * their last referrer is removed.
         *
         * Do not use this in conjunction with the 'extendEntryLifetimes' setting.
         */
        evictionDelay?: number;
        /**
         * Causes cache entries to remain in memory for a framework-controlled period after
         * their last referrer is removed.
         *
         * Do not use this in conjunction with the 'evictionDelay' setting.
         */
        extendEntryLifetimes?: boolean;
    }
    /**
     * A cache of objects of type T, uniquely identifiable via string keys, in which all
     * accesses to the cache are tracked by referrerId (another string key). The cache tracks
     * which referrers have references to which entries, and automatically ejects cache entries
     * when no referrers have references to them.
     */
    class RefCountCache<T> {
        private _onDisposeEntryCallback;
        private _isDisposed;
        private _evictionDelayMilliseconds;
        private _evictionTimeoutHandlesByKey;
        private _entriesByKey;
        private _entriesByReferrerThenKey;
        /**
         * Constructs an instance of RefCountCache.
         *
         * @param config Configuration for the RefCountCache instance.
         */
        constructor(config?: RefCountCacheConfig<T>);
        /**
         * Gets or creates a cache entry for the given key.
         *
         * @param key The entry key.
         * @param referrerId An arbitrary unique string. The entry will be held in memory until this referrerId disposes its reference. If you pass
         * null/undefined, no referrer will be associated with the entry.
         * @param createCallback A function that supplies a value for the entry. This is called only when creating new entries.
         * @return A new or existing cache entry.
         */
        getEntry(key: string, referrerId: string, createCallback: () => T): T;
        /**
         * Reveals whether or not the RefCountCache currently holds an entry for the given key.
         *
         * @param key The entry key.
         * @return True if the entry exists; false otherwise.
         */
        hasEntry(key: string): boolean;
        /**
         * Disassociates the given entry from the given referrer. If the entry is no longer
         * associated with any referrers, it will be ejected from the cache.
         *
         * @param key The entry key.
         * @param referrerId The ID of the referrer.
         */
        dissociateEntry(key: string, referrerId: string): void;
        /**
         * Dissociates all referrers from the entry and evicts the entry from the cache. Does not wait
         * for any eviction delay.
         *
         * @param key The entry to be evicted.
         */
        immediatelyEvictEntry(key: string): void;
        /**
         * Removes all associations with the given referrer. Any entries that no longer
         * have associations will be ejected from the cache.
         *
         * @param referrerId The ID of the referrer.
         */
        disposeReferrer(referrerId: string): void;
        /**
         * Invokes a callback for each entry currently in the cache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEntry(callback: (key: string, value: T) => void): void;
        /**
         * Disposes the RefCountCache so that onDisposeEntryCallback runs for every entry.
         * Once disposed, the RefCountCache may no longer be used to retrieve entries.
         */
        dispose(): void;
        private _ensureReferenceExists(entry, referrerId);
        private _entryHasDelayedEvictionInProgress(entry);
        private _cancelAnyDelayedEviction(entryKey);
        private _delayedEvictEntryIfNoReferences(entry);
        private _immediateEvictEntryIfNoReferences(entry);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.Shared.d.ts
declare module FxImpl.Data.Shared {
    /**
     * A JavaScript array instance wrapped in an observable wrapper.  Only in some cases will this be a
     * KnockoutObservableArray.
     */
    type ObservableArray = KnockoutObservableBase<any[]>;
    /**
     * A JavaScript array which may or may not be wrapped in an observable wrapper.
     */
    type ArrayOrObservableArray = any[] | ObservableArray;
    /**
     * Deprecated. Use MsPortalFx.isObject instead.
     */
    const isObject: Obsolete;
    /**
     * Deprecated. Use MsPortalFx.isNullOrUndefined instead.
     */
    const isNullOrUndefined: Obsolete;
    /**
     * Deprecated. Use MsPortalFx.areEqual instead.
     */
    const equalDates: Obsolete;
    /**
     * Deprecated. Use MsPortalFx.isObservableArray instead.
     */
    const isObservableArray: Obsolete;
    /**
     * Deprecated. Use MsPortalFx.isArrayOrObservableArray instead.
     */
    const isArrayOrObservableArray: Obsolete;
    /**
     * Unwraps a property value on a given object.
     * Here, we follow a conventional usage of Knockout observables where observability is considered to be an aspect of
     * the (object,key)-pair.  The 'property value' here is the result of unwrapping.
     * The exception here are observable arrays, which are treated themselves as self-standing containers and, hence,
     * not unwrapped by this function.
     *
     * @param obj An object.
     * @param property A property name.
     * @return The unwrapped object property value.
     */
    function unwrapObjectPropertyValue(obj: StringMap<any>, property: string): any;
    /**
     * Returns a boolean reflecting whether a property on a supplied object is observable.
     * Here, we follow a conventional usage of Knockout observables where observability is considered to be an aspect of
     * the (object,key)-pair.  The 'property value' here is the result of unwrapping.
     * The exception here are observable arrays, which are treated themselves as self-standing containers and, hence,
     * not unwrapped by this function.
     *
     * @param obj An object.
     * @param property A property name.
     * @return A boolean reflecting whether the object property value is observable.
     */
    function isObservableObjectPropertyValue(obj: StringMap<any>, property: string): boolean;
    /**
     * Unwraps a value that is assumed/asserted to be of type T[] or of type KnockoutObservableBase<T[]> and its
     * subclasses.
     *
     * @param data The array or observable-wrapped array.
     * @return A JavaScript array.
     */
    function unwrapArrayOrObservableArray(data: ArrayOrObservableArray): any[];
    /**
     * Deprecated. Use MsPortalFx.areEqual instead.
     */
    const equalScalarValues: Obsolete;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.ViewSource.d.ts
declare module FxImpl.Data {
    interface QueryViewSource<T, TParams> extends DataViewSource<T, TParams> {
        /**
         * Any navigation options configured for this QueryCache.
         */
        navigationOptions: MsPortalFx.Data.QueryCacheNavigationOptions<T, TParams>;
    }
    interface DataViewSource<T, TParams> extends RefreshableViewSource<T, TParams> {
        /**
         * Retrieves data matching the specified parameters.
         *
         * @param params Parameters describing the data to be fetched.
         * @param referrer A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @return A promise that completes with the requested data.
         */
        fetch(params: TParams, referrer: MsPortalFx.Base.LifetimeManager): MsPortalFx.Data.DataSetPromise;
    }
    interface RefreshableViewSource<T, TParams> extends ViewSource<TParams> {
        /**
         * Instructs the data source to update the contents of whatever T corresponds to the
         * specified parameters.
         *
         * @param params Parameters describing the data to be updated.
         * @param referrer A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @return A promise that completes when the refresh has completed.
         */
        refresh(params: TParams, referrer: MsPortalFx.Base.LifetimeManager): MsPortalFx.Base.Promise;
    }
    interface ViewSource<TParams> {
        /**
         * Retrieves data matching the specified parameters.
         *
         * @param params Parameters describing the data to be fetched.
         * @param referrer A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @return A promise that completes with the requested data.
         */
        fetch(params: TParams, referrer: MsPortalFx.Base.LifetimeManager): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Internal\Internal.Data.Visitor.d.ts
declare module FxImpl.Data {
    import Fx = MsPortalFx;
    import Metadata = Fx.Data.Metadata;
    import ArrayOrObservableArray = Shared.ArrayOrObservableArray;
    /**
     * An entity is an object whose associated type metadata describes an entity type (with a primary key /
     * unique id).
     */
    type Entity = StringMap<any>;
    /**
     * An array of entity objects.  An entity is an object whose associated type metadata describes an entity type (with
     * a primary key / unique id).
     */
    type EntityArray = ArrayOrObservableArray;
    /**
     * This interface is used to customize a Visitor by supplying mix-in style callbacks.
     */
    interface VisitorCallbacks<TArgs, TResult> {
        /**
         * Visits an entity-typed array (observable or native).
         *
         * @param array An entity-typed array (observable or native).
         * @param typeMetadata Type metadata covering the array and its contained items.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitEntityArray?: (array: EntityArray, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a non-entity-typed array (observable or native).
         *
         * @param array An non-entity-typed array (observable or native).
         * @param typeMetadata Type metadata covering the array and its contained items.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitNonEntityArray?: (array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits an array (observable or native).
         *
         * @param array An array (observable or native).
         * @param typeMetadata Type metadata covering the array and its contained items.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitArray?: (array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits an array item.
         *
         * @param item An item contained in an array.
         * @param index The index for the item in the containing array.
         * @param typeMetadata Type metadata covering item.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitArrayItem?: (item: any, index: number, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits an entity-typed object.
         *
         * @param entity An entity-typed object.
         * @param typeMetadata Type metadata covering the entity.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitEntity?: (entity: Entity, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a non-entity-typed object.
         *
         * @param obj A non-entity-typed object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitNonEntityObject?: (obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a object.
         *
         * @param obj An object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitObject?: (obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Determines whether a given object property should be visited.
         *
         * @param property The property name.
         * @param obj The object.
         * @param typeMetadata Type metadata for the object.
         *
         * @return A boolean reflecting whether the property should be visited.
         */
        shouldVisitObjectProperty?: (property: string, obj: StringMap<any>, typeMetadata: Metadata.Metadata) => boolean;
        /**
         * Visits an entity-typed property on an object.
         *
         * @param property The property name.
         * @param obj The object.
         * @param propertyTypeMetadata Type metadata covering the property on the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitEntityTypedObjectPropertyValue?: (property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a non-entity-typed property on an object.
         *
         * @param property The property name.
         * @param obj The object.
         * @param propertyTypeMetadata Type metadata covering the property on the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitNonEntityTypedObjectPropertyValue?: (property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a property on an object.
         *
         * @param property The property name.
         * @param obj The object.
         * @param propertyTypeMetadata Type metadata covering the property on the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitObjectPropertyValue?: (property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a date value.
         *
         * @param date The date value.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitDate?: (data: Date, args?: TArgs) => TResult;
        /**
         * Visits a scalar (non-Date) value.
         *
         * @param value The scalar value.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitScalar?: (value: number | string, args?: TArgs) => TResult;
        /**
         * Visits a function.
         *
         * @param fn The function.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitFunction?: (fn: Function, args?: TArgs) => TResult;
    }
    /**
     * An interface through which a Visitor is to be used.
     */
    interface VisitorContract<TResult> {
        /**
         * Performs the visitation.
         *
         * @param data The data to be visited.
         * @param typeMetadata Type metadata covering the data.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visit(data: any, typeMetadata: Metadata.Metadata): TResult;
    }
    /**
     * An interface through which a Visitor is to be used.
     */
    interface VisitorWithArgsContract<TArgs, TResult> {
        /**
         * Performs the visitation.
         *
         * @param data The data to be visited.
         * @param typeMetadata Type metadata covering the data.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visit(data: any, typeMetadata: Metadata.Metadata, args: TArgs): TResult;
    }
    /**
     * Options supplied when constructing a Visitor.
     */
    interface VisitorOptions {
    }
    /**
     * A Visitor that can be extended/specialized via inheritance and via mix-in style callbacks.
     */
    class Visitor<TArgs, TResult> implements VisitorWithArgsContract<TArgs, TResult>, VisitorContract<TResult>, VisitorCallbacks<TArgs, TResult> {
        _callbacks: VisitorCallbacks<TArgs, TResult>;
        /**
         * Constructs a Visitor instance.
         *
         * @param options Options used in the construction of the Visitor.
         * @param callbacks Optional, mix-in style callbacks that override default Visitor behavior.
         */
        constructor(options: VisitorOptions, callbacks: VisitorCallbacks<TArgs, TResult>);
        /**
         * See interface.
         */
        visit(data: any, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitEntityArray(array: EntityArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitNonEntityArray(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitArray(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitArrayItem(item: any, index: number, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitEntity(entity: Entity, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitNonEntityObject(obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitObject(obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        shouldVisitObjectProperty(property: string, obj: StringMap<any>, typeMetadata: Metadata.Metadata): boolean;
        /**
         * See interface.
         */
        visitEntityTypedObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitNonEntityTypedObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitDate(date: Date, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitScalar(value: number | string, args?: TArgs): TResult;
        /**
         * See interface.
         */
        visitFunction(fn: Function, args?: TArgs): TResult;
        /**
         * Returns the object properties that should be visited.
         *
         * @param obj An object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return An array of string that are the names of the properties that should be visited.
         */
        getObjectPropertiesToVisit(obj: StringMap<any>, typeMetadata: Metadata.Metadata): string[];
        /**
         * Visits a property on an object, delegating to 'visitEntityTypedObjectPropertyValue' or
         * 'visitNonEntityTypedObjectPropertyValue' based on type metadata.
         *
         * @param property The property name.
         * @param obj The object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         *
         * @return A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitObjectPropertyValueDispatch(property: string, obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        _visit(data: any, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        _visitArrayDispatch(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        _visitObjectDispatch(obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Navigation\Data.DataNavigationMetadata.d.ts
declare module MsPortalFx.Data {
    /**
     * Describes the state of navigable data, for example specifying the
     * total number of items or the token needed to fetch further data.
     *
     * This information is typically extracted from a server response.
     */
    interface DataNavigationMetadata {
        /**
         * If available, provides the total number of items that may be navigated through.
         * Not all data sources make this information available, so this property may be null/undefined.
         */
        totalItemCount?: number;
        /**
         * If applicable, specifies the server-generated continuation token value that may
         * be used to fetch the next range of items. This value may be in any format - for
         * example, it may be an entire URI.
         */
        continuationToken?: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Navigation\Data.DataNavigator.d.ts
declare module MsPortalFx.Data {
    enum SortOrder {
        /**
         * Column is unsorted.
         */
        Unsorted = 0,
        /**
         * Column is sorted ascending.
         */
        Ascending = 1,
        /**
         * Column is sorted descending.
         */
        Descending = 2,
    }
    interface SortBy {
        /**
         * The item key to sort by.
         */
        itemKey: string;
        /**
         * The direction of the sort either ascending or descending.
         */
        sortOrder: SortOrder;
    }
    /**
     * Represents a source of data that supports one or more standard navigation mechanisms,
     * such as skip/take or continuation tokens.
     */
    interface DataNavigator<T> {
        /**
         * The current range of items.
         */
        items: KnockoutObservableBase<T[]>;
        /**
         * Provides metadata about navigation state, such as current page index
         * or the total number of items.
         */
        metadata: KnockoutObservableBase<DataNavigationMetadata>;
        /**
         * Describes errors associated with the current items in the data navigator.
         */
        partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>;
        /**
         * If this data navigator supports loading via skip/take, loads data by that method.
         * This property will be null/undefined if this data navigator does not support skip/take.
         */
        loadBySkipTake?(skip: number, take: number, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
        /**
         * If the data navigator supports loading via continuation tokens, resets its state so that
         * the next load will fetch the first page of data.
         * This property will be null/undefined if this data navigator does not support skip/take.
         */
        resetLoadByContinuationToken?(filter: string, sort?: SortBy[]): void;
        /**
         * If the data navigator supports loading via continuation tokens, loads data by that method.
         * This property will be null/undefined if this data navigator does not support skip/take.
         */
        loadByContinuationToken?(): MsPortalFx.Base.Promise;
        /**
         * Instructs all consumers of this navigator to reset their navigation state
         * and begin at the first page.
         *
         * @return A promise that completes when all consumers of the navigator have finished resetting their navigation state.
         */
        resetNavigation(): MsPortalFx.Base.Promise;
        /**
         * Used by controls that are consuming the navigator to receive notification
         * when the navigation state should be reset. Not intended for use from
         * portal extension code.
         *
         * @param callback Callback to invoke when navigation state should be reset.
         */
        addResetNavigationListener(callback: () => MsPortalFx.Base.Promise): void;
        /**
         * Removes a callback previously registered using addResetListener. Not intended
         * for use from portal extension code.
         *
         * @param callback Callback to be removed. Must be the same function instance that was previously registered.
         */
        removeResetNavigationListener(callback: () => MsPortalFx.Base.Promise): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Navigation\Data.DataNavigatorBase.d.ts
declare module MsPortalFx.Data {
    /**
     * An abstract base class for data navigators.
     */
    class DataNavigatorBase<TEntity> implements DataNavigator<TEntity> {
        /**
         * See interface.
         */
        items: KnockoutObservableBase<TEntity[]>;
        /**
         * See interface.
         */
        metadata: KnockoutObservableBase<DataNavigationMetadata>;
        private _resetListeners;
        private _partialErrors;
        constructor(partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>);
        /**
         * See interface.
         */
        partialErrors: KnockoutReadOnlyObservableArray<PartialError>;
        /**
         * See interface.
         */
        resetNavigation(): MsPortalFx.Base.Promise;
        /**
         * See interface.
         */
        addResetNavigationListener(callback: () => MsPortalFx.Base.Promise): void;
        /**
         * See interface.
         */
        removeResetNavigationListener(callback: () => MsPortalFx.Base.Promise): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Navigation\Data.LocalDataNavigator.d.ts
declare module MsPortalFx.Data {
    /**
     * A DataNavigator that supports skip/take over in-memory data.
     */
    class LocalDataNavigator<T> extends DataNavigatorBase<T> {
        private _allItems;
        private _currentSkipTakeParams;
        private _itemsComputed;
        private _metadataComputed;
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, allItems: KnockoutObservableBase<T[]>, partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>);
        /**
         * See interface.
         */
        loadBySkipTake(skip: number, take: number, filter: string): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Data\Navigation\Data.RemoteDataNavigator.d.ts
declare module MsPortalFx.Data {
    /**
     * Options that describe how a RemoteDataNavigator should perform navigation.
     */
    interface RemoteDataNavigatorOptions<TEntity, TQueryParams> {
        /**
         * If the data source supports skip/take, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         */
        loadBySkipTake?(metadata: DataNavigationMetadata, query: TQueryParams, skip: number, take: number, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
        /**
         * If the data source supports continuation tokens, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         *
         * @param metadata The most recent metadata, if any, fetched previously by this data source.
         * @param query Query parameters to be used.
         * @param reset If true, indicates that the first page of data should be loaded. Otherwise, the continuation token in metadata should be used to
         * fetch the next range of data.
         * @param filter Specifies any filtering value entered by the user.
         * @param sort An array of objects to sort by.
         * @return A promise representing the operation.
         */
        loadByContinuationToken?(metadata: DataNavigationMetadata, query: TQueryParams, reset: boolean, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
    }
    /**
     * A DataNavigator that uses callbacks to read arbitrary external
     * data, such as data loaded on demand from a remote server.
     */
    class RemoteDataNavigator<TEntity, TQueryParams> extends DataNavigatorBase<TEntity> {
        private _options;
        private _continuationTokenFilter;
        private _continuationTokenSort;
        private _continuationTokenResetRequested;
        private _queryParams;
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, items: KnockoutObservableBase<TEntity[]>, metadata: KnockoutObservableBase<DataNavigationMetadata>, options: RemoteDataNavigatorOptions<TEntity, TQueryParams>, partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>);
        /**
         * See interface.
         */
        loadBySkipTake(skip: number, take: number, filter: string, sort?: SortBy[]): MsPortalFx.Base.Promise;
        /**
         * See interface.
         */
        loadByContinuationToken(): MsPortalFx.Base.Promise;
        /**
         * See interface.
         */
        resetLoadByContinuationToken(filter: string, sort?: SortBy[]): void;
        /**
         * Sets query parameters on the navigator, and resets navigation state so that
         * consumers will load the first page of results for the new query. Typically,
         * parts should call this from their onInputsSet methods.
         *
         * Controls that use navigators will not request any data until the first time
         * that navigation state is reset, so you must call this from onInputsSet even
         * if your navigator has no particular query (in this case, just pass 'null' to
         * signal that you are ready for the control to load data).
         *
         * @param query The new query parameters that will be passed to your loadBy... callbacks.
         * @return A promise that completes when all consumers of the navigator have finished resetting their navigation state. Typically, you should return
         * this from your onInputsSet method.
         */
        setQuery(query: TQueryParams): MsPortalFx.Base.Promise;
        private _getClonedQuery();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Decorators.d.ts
declare module MsPortalFx.Composition {
    /**
     * This decorator should only apply to properties.
     *
     * It marks the property ignored by Po. Properties that are marked NotProxied are excluded from
     * observable / view model proxying.  Marking properties with this decorator enables a significant performance
     * optimization for observable / view model proxying.
     *
     * @param target The target object
     * @param key The property key
     * @param descriptor The property descriptor
     */
    function NotProxied(target: any, key: string, descriptor: PropertyDescriptor): void;
    /**
     * This decorator should only apply to class which contains properties.
     *
     * It makes all properties in this clase ignored by Po. All properties in this class are excluded from
     * observable / view model proxying. Marking this decorator enables a significant performance
     * optimization for observable / view model proxying.
     *
     * @param target The target object
     * @param key The property key
     * @param descriptor The property descriptor
     */
    const ProxyCompatibilityMode: (target: any) => void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ErrorMessages.d.ts
declare module FxImpl {
    interface ThrowErrorFunction {
        (...formatArguments: any[]): void;
    }
    /**
     * Returns a map of functions that throw errors with the provided messages.
     */
    function getErrorMap(obj: Object): Object;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Errors\Errors.d.ts
declare module FxImpl {
    /**
     * Alias for native Error type.
     */
    type NativeError = Error;
    /**
     * Alias for native Error object.
     */
    const NativeError: ErrorConstructor;
}
declare module MsPortalFx.Errors {
    import NativeError = FxImpl.NativeError;
    /**
     * Defines the contract of an error within the Framework.
     */
    interface ErrorContract {
        /**
         * Gets the proxyable name of the error.
         */
        type: string;
        /**
         * The error message.
         */
        message?: string;
        /**
         * The error name.
         */
        name?: string;
        /**
         * The error code.
         */
        code?: number;
        /**
         * The default error level for logging the error.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the errorLevel will determine how the unhandled rejection is logged.
         */
        errorLevel?: ErrorLevel;
        /**
         * The error level for logging in the source iframe only.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the _sourceErrorLevel will determine how the unhandled rejection is logged
         * within the source iframe.
         * If undefined the the errorLevel will be used instead.
         * The _sourceErrorLevel property will always be undefined in iframes besides the error source.
         */
        _sourceErrorLevel?: ErrorLevel;
        /**
         * Error source information.
         */
        source?: string;
        /**
         * Inner errors that caused this error.
         */
        innerErrors?: NativeError[];
        /**
         * Indicates if the error has been handled.
         */
        handled?: boolean;
        /**
         * Time error occured.
         */
        timestamp?: number;
        /**
         * Call stack.
         */
        stack?: string;
        /**
         * Information associated with the error that is never proxied.
         */
        errorData?: any;
        /**
         * Information associated with the error that may be proxied.
         */
        data?: any;
    }
    const enum ErrorLevel {
        /**
         * Do not log if unhandled.
         */
        None = 0,
        /**
         * Log as warning if unhandled.
         */
        Warning = 1,
        /**
         * Log as error if unhandled.
         */
        Error = 2,
    }
    interface ErrorType<E extends Error> {
        /**
         * Constructor.
         */
        new (...args: any[]): E;
        /**
         * Provides the unique type name for this error.
         */
        TypeName: string;
    }
    interface ErrorOptions {
        /**
         * The error message.
         */
        message?: string;
        /**
         * The error code.
         */
        code?: number;
        /**
         * The default error level for logging the error.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the errorLevel will determine how the unhandled rejection is logged.
         */
        errorLevel?: ErrorLevel;
        /**
         * The error level for logging in the source iframe only.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the _sourceErrorLevel will determine how the unhandled rejection is logged
         * within the source iframe.
         * If undefined the the errorLevel will be used instead.
         * The _sourceErrorLevel property will always be undefined in iframes besides the error source.
         */
        _sourceErrorLevel?: ErrorLevel;
        /**
         * Error source information.
         */
        source?: string;
        /**
         * Inner errors that caused this error.
         */
        innerErrors?: NativeError | NativeError[];
        /**
         * Indicates if the error has been handled.
         */
        handled?: boolean;
        /**
         * Time error occured.
         */
        timestamp?: number;
        /**
         * Call stack.
         */
        stack?: string;
        /**
         * The error name.
         */
        name?: string;
        /**
         * Information associated with the error.
         * (This error data is shielded from being proxied by a get accessor.)
         */
        errorData?: any;
        /**
         * Information associated with the error.
         * (This error data may be proxied.)
         */
        data?: any;
    }
    /**
     * Checks if the error is an instance of the specified error type.
     * Works across the proxied obserable layer for MsPortalFx.Errors.Error derived errors.
     *
     * @param error The error instance to check.
     * @param errorType The type of error to check for.
     * @return Indicates if the error is an instance of the type.
     */
    function isInstanceOfErrorType<E extends Error>(error: any, errorType: ErrorType<E>): error is E;
    /**
     * Helper to convert various param types to an options object.
     */
    function getErrorOptions<T extends ErrorOptions>(message: string, defaultOptions?: T): T;
    function getErrorOptions<T extends ErrorOptions>(options: T, defaultOptions?: T): T;
    /**
     * Framework Error object that can be thrown or
     * or derived from to make more specific errors.
     */
    class Error extends NativeError implements ErrorContract {
        /**
         * Stores the error type name.
         * Preferably derived errors should specify this to uniquely identify themselves.
         * However, if not provided the contructor name is used to set this at run-time.
         */
        static TypeName: string;
        /**
         * Checks that this error type is a base of the error.
         *
         * @error The error to check.
         * @return True if the error is of this error type.
         */
        static isBaseOf(error: any): error is Error;
        /**
         * The error code.
         */
        code: number;
        /**
         * The error source information.
         */
        source: string;
        /**
         * The name of the extension that created the error.
         */
        extension: string;
        /**
         * The error type name.
         */
        type: string;
        /**
         * The error type names in the prototype chain.
         */
        baseTypes: string[];
        /**
         * The default error level for logging the error.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the errorLevel will determine how the unhandled rejection is logged.
         */
        errorLevel: ErrorLevel;
        /**
         * The error level for logging in the source iframe only.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the _sourceErrorLevel will determine how the unhandled rejection is logged
         * within the source iframe.
         * If undefined the the errorLevel will be used instead.
         * The _sourceErrorLevel property will always be undefined in iframes besides the error source.
         */
        _sourceErrorLevel: ErrorLevel;
        /**
         * Inner error that caused this error.
         */
        innerErrors: NativeError[];
        /**
         * If true, indicates that no further handling is required.
         */
        handled: boolean;
        /**
         * Time error occured.
         */
        timestamp: number;
        /**
         * The error message.
         */
        message: string;
        /**
         * The error name.
         */
        name: string;
        /**
         * The error call stack.
         */
        stack: string;
        /**
         * Information associated with the error that is never proxied.
         */
        private _errorData;
        /**
         * Information associated with the error that can be proxied.
         */
        data: any;
        /**
         * Constructs a generic Error.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a generic Error.
         *
         * @param options The error options.
         */
        constructor(options?: ErrorOptions);
        /**
         * Error specific data.
         */
        errorData: any;
    }
    /**
     * Defines the contract of an error related to Data within the Framework.
     */
    interface DataErrorContract extends ErrorContract {
        /**
         * The name of the data set that was the source of the error.
         */
        dataSetName: string;
        /**
         * Information associated with the error.
         */
        errorData: any;
    }
    /**
     * Represents a generic data error.
     */
    class DataError extends Error implements DataErrorContract {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * The name of the data set that was the source of the error.
         */
        dataSetName: string;
        /**
         * Constructs a DataError.
         *
         * @param options The data error options.
         */
        constructor(dataSetName: string, errorData?: any);
    }
    /**
     * Represents a fetch data error.
     */
    class FetchDataError extends DataError {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a FetchDataError.
         *
         * @param dataSetName The data set name for the error source.
         * @param errorData Error specific data.
         */
        constructor(dataSetName: string, errorData?: any);
    }
    /**
     * Represents an unauthorized data error.
     */
    class UnauthorizedDataError extends DataError {
        /**
          * The unique type name of this error.
          */
        static TypeName: string;
        /**
         * Constructs a UnauthorizedDataError.
         *
         * @param dataSetName The data set name for the error source.
         * @param errorData Error specific data.
         */
        constructor(dataSetName: string, errorData?: any);
    }
    /**
     * Represents a "not found" data error.
     */
    class NotFoundDataError extends DataError {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a NotFoundDataError.
         *
         * @param dataSetName The data set name for the error source.
         * @param errorData Error specific data.
         */
        constructor(dataSetName: string, errorData?: any);
    }
    /**
     * Represents and cancelation error.
     */
    class CanceledError extends Error {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a CanceledError.
         * Thrown to cancel operations.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a CanceledError.
         * Thrown to cancel operations.
         *
         * @param options The error options.
         */
        constructor(options?: ErrorOptions);
    }
    interface DisposedErrorContract extends ErrorContract {
        /**
         * The name of the object being disposed.
         */
        source?: string;
    }
    interface DisposedErrorOptions extends ErrorOptions {
        /**
         * The name of the object being disposed.
         */
        source?: string;
    }
    /**
     * Represents a disposed error.
     */
    class DisposedError extends Error implements DisposedErrorContract {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * The name of the object being disposed.
         */
        source: string;
        /**
         * Construct a DisposedError.
         * Thrown when a instance is accessed after being disposed.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a DisposedError.
         * Thrown when a instance is accessed after being disposed.
         *
         * @param options The error options.
         */
        constructor(options?: DisposedErrorOptions);
    }
}
declare module MsPortalFx.FxError {
    /**
     * Deprecated as of 4/2016.
     * MsPortalFx.FxError nampespace changed to MsPortalFx.Errors
     */
    interface Deprecated {
        /**
         * Deprecated as of 4/2016.
         * MsPortal.FxError nampespace changed to MsPortalFx.Errors
         */
        deprecated: Deprecated;
    }
    /**
     * Deprecated as of 4/2016.
     * Use MsPortalFx.Errors.ErrorContract.
     */
    type ErrorContract = Deprecated;
    /**
     * Deprecated as of 4/2016.
     * Use MsPortalFx.Errors.DataErrorContract.
     */
    type DataErrorContract = Deprecated;
    /**
     * Deprecated as of 4/2016.
     * Use MsPortalFx.Errors.Error.
     */
    var GenericError: Deprecated;
    /**
     * Deprecated as of 4/2016.
     * Use MsPortalFx.Errors.DataError.
     */
    var GenericDataError: Deprecated;
    /**
     * Deprecated as of 4/2016.
     * Use MsPortalFx.Errors.FetchDataError.
     */
    var FetchDataError: Deprecated;
    /**
     * Deprecated as of 4/2016.
     * Use MsPortalFx.Errors.NotFoundDataError.
     */
    var NotFoundDataError: Deprecated;
    /**
     * Deprecated as of 4/2016.
     * Use MsPortalFx.Errors.UnauthorizedDataError.
     */
    var UnauthorizedDataError: Deprecated;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\ActionBarKind.d.ts
declare module MsPortalFx.Extension {
    enum ActionBarKind {
        /**
         * Indicates that no action bar is to be used.
         */
        None = 0,
        /**
         * The type of action bar to use in a form blade.
         */
        Create = 1,
        /**
         * The type of action bar to use in a picker blade.
         */
        Picker = 2,
        /**
         * The type of action bar to use in a form blade.
         */
        Form = 3,
        /**
         * The type of action bar to use in a filter blade.
         */
        Filter = 4,
        /**
         * The type of action bar to use in a delete confirmation blade.
         */
        Delete = 5,
        /**
         * The type of action bar to use in a generic blade.
         */
        Generic = 6,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\AssetIdSourceType.d.ts
declare module MsPortalFx.Extension {
    enum AssetIdSourceType {
        /**
         * Asset ID from a property on the inputs.
         */
        FromInput = 0,
        /**
         * Asset ID from a property on the property provider service on the scope asset type.
         */
        FromProvider = 1,
        /**
         * Asset ID from a property on the property provider service on the permission asset type.
         */
        FromSourceProvider = 2,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\BrowseType.d.ts
declare module MsPortalFx.Extension {
    enum BrowseType {
        /**
         * Use the service view model (browse V1).
         */
        ServiceViewModel = 0,
        /**
         * Use the resource type for browse.
         */
        ResourceType = 1,
        /**
         * Use the asset type blade for browse.
         */
        AssetTypeBlade = 2,
        /**
         * Service link into the classic portal for a service.
         */
        ServiceLink = 3,
        /**
         * Instance link into the classic portal for an instance of a service.
         */
        InstanceLink = 4,
        /**
         * The asset type does not support browse (used only in typescript).
         */
        NoBrowse = -1,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\CloudName.d.ts
declare module FxImpl.Extension.CloudName {
    /**
     * Adds cloud name to detail blade inputs.
     * Both hubs and shell needs this.
     *
     * @param cloudName The cloudName.
     * @param inputs the detail inputs of dynamic selection that needs to be modified.
     * @returns the modified detail inputs.
     */
    function addToModel<T>(cloudName: string, model: T): T;
    /**
     * Adds "all cloud name" cloud name to detail blade inputs.
     *
     * @param cloudName The cloudName.
     * @param inputs the detail inputs of dynamic selection that needs to be modified.
     * @returns the modified detail inputs.
     */
    function addAllCloudsToModel(model?: any): any;
    /**
     * Reads cloud name from detail blade inputs.
     *
     * @param inputs the inputs parameter from onInputsSet.
     * @returns the cloud name.
     */
    function readFromInputs<Ret>(inputs: any): Ret;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\CommandKind.d.ts
declare module MsPortalFx.Extension {
    enum CommandKind {
        /**
         * A standard command invokes execute on the command view model
         */
        Standard = 0,
        /**
         * A Url command opens a new Url in new browser session
         */
        Url = 1,
        /**
         * A blade command kind opens a blade
         */
        Blade = 2,
        /**
         * A FileDownload command kind to download file content.
         */
        FileDownload = 3,
        /**
         * A ListCommand opens a list of items
         */
        List = 4,
        /**
         * A Dynamic command initializes and executes another command.
         */
        Dynamic = 5,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\Extension.d.ts
interface ErrorMessages<T> {
    contextAmd: T;
    contextInit: T;
    protoEnum: T;
    unknownName: T;
    nonIframe: T;
    contentNull: T;
    entryMissMatch: T;
}
declare const placeHolder: string;
declare let errorMessages: ErrorMessages<string>;
declare const _undefinedLog: string;
declare const throwError: ErrorMessages<FxImpl.ThrowErrorFunction>;
declare module FxImpl.Extension {
    import FxBase = MsPortalFx.Base;
    /**
     * Classes which contain a shared data context instance implement this interface
     * This interfaceis used by generated PDL code and not intended to be used directly.
     */
    interface DataContextContainer<TDataContext> {
        /**
         * Sets the data context instance in the container
         *
         * @param dataContext data context to be set in this container
         */
        setDataContext(dataContext: TDataContext): void;
        /**
         * Access the data context held in the container
         */
        dataContext: TDataContext;
        /**
         * Sets a AMD module path and factory to to be called after the module containing the datacontext implementation is downloaded.
         *
         * @param modulePath AMD module to be download
         * @param dataContextFacotry factory that is used to create a new instance of the data context
         * @param localRequire The require dependency of the module. Used to resolve modulePath.
         */
        setDataContextFactory<TModule>(modulePath: string, dataContextFactory: (providerModule: TModule) => TDataContext, localRequire?: LocalRequire): void;
    }
    /**
     * Base class that is used by PDL generated view model factories
     */
    class ViewModelAreaFactoriesBase<TDataContext> implements DataContextContainer<TDataContext> {
        private _context;
        private _factory;
        private _promise;
        /**
         * Initializes the dataContext instance which is shared between view models for this area
         *
         * @param context the data context instance that is to be shared between view models.
         */
        setDataContext(context: TDataContext): void;
        /**
         * Gets the data context instance that is shared between view models in this area
         */
        dataContext: TDataContext;
        /**
         * Sets the data context factory that is used to create a instance of the data context class asyncronously by first downloading
         * the data context module first.
         * This method is intended to support AMD and requires a AMD modulePath to be provided.  The data context factory will not be invoked
         * until the a view model is instantianted.
         *
         * @param modulePath Module to load which contains the viewmodel
         * @param dataContextFactory function to invoke to create a new instance of the data context after the module has been downloaded
         * @param localRequire The require dependency of the module. Used to resolve modulePath.
         */
        setDataContextFactory<TModule>(modulePath: string, dataContextFactory: (providerModule: TModule) => TDataContext, localRequire?: LocalRequire): void;
        /**
         * Utility method to that loads a view model asychronously.
         * This method is invoked by PDL generated code.
         *
         * @param localRequire The require dependency of the module. Used to resolve modulePath.
         * @param modulePath Module to load which contains the viewmodel
         * @param viewModuleFactory function to invoke to create a new instance of the view model
         */
        loadViewModelAsync<TModule, TViewModelItf>(modulePath: string, viewModelFactory: (providerModule: TModule) => TViewModelItf, localRequire?: LocalRequire): FxBase.PromiseV<TViewModelItf>;
    }
    function setRuntime(manifest: MsPortalFx.Extension.Manifest, getCreateEntryPointPromise: () => Q.Promise<MsPortalFx.Extension.EntryPointContract>, bladesModuleBasePath: string, partsModuleBasePath: string, controlsModuleBasePath: string): void;
    function getRuntime(): Runtime;
}
declare module MsPortalFx.Extension {
    interface EntryPointContract {
        /**
         * Initializes the extension.
         */
        initialize(): void;
        /**
         * Disposes the extension.
         */
        dispose(): void;
        /**
         * Gets the definition for the extension.
         *
         * @return The extension definition.
         */
        getDefinition(): Definition;
        /**
         * Gets a view model with the specified name.
         *
         * @param name Name of view model to retrieve.
         * @param initialState Optional initial state for the view model.
         * @return A view model object.
         */
        getViewModel(name: string, container: MsPortalFx.ViewModels.ContainerContract, initialState?: any): any;
        /**
         * Gets a part view model with the specified name.
         *
         * @param name Name of view model to retrieve.
         * @param container The container into which the part is being placed.
         * @param initialState Optional initial state for the view model.
         * @return A view model object.
         */
        getPartViewModel(name: string, container: MsPortalFx.ViewModels.PartContainerContract, initialState?: any): any;
        /**
         * Provides an observable object for other extensions to consume.
         *
         * @param name The name of the observable to provide.
         * @param args Any optional arguments used to obtain the observable.
         * @return The provided observable.
         */
        getObservable?(name: string, args: any[]): any;
    }
    abstract class EntryPointBase<ViewModelFactories> implements EntryPointContract {
        viewModelFactories: ViewModelFactories;
        constructor();
        initialize(): void;
        dispose(): void;
        abstract getDefinition(): Definition;
        getViewModel(name: string, container: MsPortalFx.ViewModels.ContainerContract, initialState?: any): any;
        getPartViewModel(name: string, container: MsPortalFx.ViewModels.PartContainerContract, initialState?: any): MsPortalFx.ViewModels.PartContent;
    }
    interface EntryPointModule {
        create(): MsPortalFx.Extension.EntryPointContract;
    }
    /**
     * Register an extension.
     *
     * @param localRequire The require dependency of the module. Used to resolve modulePath.
     * @param manifest The Extension manifest.
     * @param entryPointModulePath The path to the AMD module.
     */
    function registerAmd<T extends EntryPointModule>(manifest: Manifest, entryPointModulePath: string, localRequire?: LocalRequire, bladesModuleBasePath?: string, partsModuleBasePath?: string, controlsModuleBasePath?: string): void;
    /**
     * OBSOLETE. This API has been deprecated.
     *
     * Gets a service client for a given service from a given extension.
     *
     * @param extensionName The name of the extension to get a service from.
     * @param scope A value that sets the scope the service will operate in (service specific).
     * @return A promise that resolves to the service client and rejects if there is an error obtaining the service.
     */
    var getService: Obsolete;
    /**
     * Composes extension content with a container provided by the runtime.
     *
     * @param contentFactory A callback the creates content given a name and initial state.
     * @param name Name of the content to create and compose.
     * @param viewModelInitialState Initial state of the  of the content.
     * @param createSelectable If true then the framework creates a new selectable automatically
     * @param createHubsInternalCloudNameProperty If true, an internal property should be created for Hubs extension to flow cloud name around.
     * @return A view model composed of extension content and a container.
     * If the content is a promise, returns a promise that resolves to the composed view model.
     */
    function composeViewModel(contentFactory: (name: string, container: MsPortalFx.ViewModels.ContainerContract, initialState: any) => any, name: string, viewModelInitialState?: any, createSelectable?: boolean, createHubsInternalCloudNameProperty?: boolean, onContentCreated?: (content: any) => void): any;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\Extension.Definition.d.ts
declare module MsPortalFx.Extension {
    /**
     * Definition for an extension.
     */
    interface Definition {
        /**
         * Name of the extension.
         */
        name: string;
        /**
         * Version of the extension.
         */
        version?: string;
        /**
         * Arbitrary GUID for the extension.  The compiler will create a unique hash from this.   Remove being optional when extensions are updated with this property
         */
        hash?: string;
        /**
         * Definition schema version.
         */
        schemaVersion?: string;
        /**
         * Which version of the SDK tools were used to generate this defintion.
         * If this field is missing most likly the schema was hand written.
         */
        sdkVersion?: string;
        /**
         * For diagnostics only.
         * This property is to assistant in identfying which build of the extension this is
         * i.e. debug vs retail
         */
        buildDescription?: string;
        /**
         * If this flag is true visual artifacts are displayed in the assets, parts and blades to indicate the functionality is preview
         */
        isPreview?: boolean;
        /**
         * Reusable command types defined within this extension.
         */
        commandsCatalog?: CommandDefinition[];
        /**
         * Parts to show on startboard on startup.
         */
        startBoardParts?: PartInstanceDefinition[];
        /**
         * A list of groups of commands.
         */
        commandGroups?: CommandGroupDefinition[];
        /**
         * List of templates defined by the template
         */
        htmlTemplates?: StringMap<HtmlTemplateDefinition>;
        /**
         * List of style sheet contents defined by the extension.
         */
        styleSheets?: string[];
        /**
         * The gallery service.
         */
        galleryService?: GalleryServiceDefinition;
        /**
         * The dashboard provider.
         */
        dashboardProvider?: DashboardProviderDefinition;
    }
    /**
     * The definition of the dashboard provider.
     */
    interface DashboardProviderDefinition {
        /**
         * The name of the view model.
         */
        viewModel: string;
    }
    /**
     * Definition for an item that can host commands.
     */
    interface CommandContainerDefinition {
        /**
         * Command group associated with this blade.
         */
        commandGroup?: string;
        /**
         * Reference to command group that is associated with this blade.
         * Also included binding overrides for command view model inputs.
         */
        commandGroupReference?: CommandGroupReference;
    }
    const enum BladeAttributes {
        /**
         * Blade has no attributes and will take all defaults
         */
        None = 0,
        /**
         * The blade explicitly does not support rebind
         */
        SuppressRebind = 1,
    }
    /**
     * Definition for a blade.
     */
    interface BladeDefinition extends AssetInstanceDefinition, CommandContainerDefinition {
        /**
         * Name of the blade.
         */
        name: string;
        /**
         * Lenses contained on the blade.
         */
        lenses: LensDefinition[];
        /**
         * Action bar contained on the blade.
         */
        actionBar?: ActionBarDefinition;
        /**
         * Names of inputs that will be supplied by master parts when this blade is invoked.
         */
        inputs?: string[];
        /**
         * Names of  optional inputs that will be supplied by master parts when this blade is invoked.
         */
        optionalInputs?: string[];
        /**
         * Name of inputs that will be used to identify the template of this blade.
         */
        templateKeyInputs?: string[];
        /**
         * Names of outputs that the blade can supply to the master part that invoked it.
         */
        outputs?: string[];
        /**
         * View Model providing a display Title & Icon URI.
         */
        viewModelName?: string;
        /**
         * Internal. Not for use by extensions.
         */
        _internal_viewModelExtensionName?: string;
        /**
         *  Inputs from blade to above View Model providing a display Title & Icon URI.
         */
        viewModelInputs?: InputBinding[];
        /**
         * Bindings between the inner parts and the blade.
         */
        bindings?: InputBinding[];
        /**
         * Width of this blade when displayed.
         */
        width?: MsPortalFx.Blades.BladeWidth;
        /**
         * Initial display state of this blade on first composition.
         * DisplayState.Minimized is ignored.
         */
        initialDisplayState?: MsPortalFx.Blades.DisplayState;
        /**
         * A value indicating whether or not the blade is locked.
         */
        locked?: boolean;
        /**
         * A value indicating whether or not the blade can be pinned to the startboard.
         */
        pinnable?: boolean;
        /**
         * The name of the part defined to represent the pinned blade.
         */
        pinnedPart?: string;
        /**
         * The type of edit scope to created for the when the blade is opened. The id of the created
         * edit scope will be passed to the blade as an input parameter named 'editScopeId'.
         */
        editScopeType?: string;
        /**
         * The style of the blade.
         */
        style?: Blades.BladeStyle;
        /**
         * If true, disposes the edit scope when blade would be implicitly closed by shell due to a selection change; else prompts for confirmation.
         */
        discardEditsOnSelectionChange?: boolean;
        /**
         * The orientation of lenses within the blade.
         */
        orientation?: FxImpl.Widgets.Orientation;
        /**
         * The permissions for the blade.
         */
        permissions?: Array<Permission | PermissionSet>;
        /**
         * The toolbar for the blade.
         */
        toolbar?: ToolbarDefinition;
        /**
         * The info for the master blade of the blade pair.
         */
        pairMasterInfo?: PairMasterInfo;
        /**
         * If this is a menu blade, describes its configuration options. If this is not a menu blade, this property is not set.
         */
        menuBlade?: MenuBladeConfig;
        /**
         * If this is a template blade, describes its configuration options. If this is not a template blade, this property is not set.
         */
        templateBlade?: TemplateBladeConfig;
        /**
         * If this is a frame blade, describes its configuration options. If this is not a frame blade, this property is not set.
         */
        frameBlade?: FrameBladeConfig;
        /**
         * Delays composing blade content till inputs are set.
         */
        waitForInputsSet?: boolean;
        /**
         * Gets or sets the activation style.
         */
        activationStyle?: ActivationStyle;
        /**
         * blade attributes, a collection of bitwise flags
         * Eventually the other boolean properties should be migrated to this member
         */
        attributes?: BladeAttributes;
    }
    /**
     * Describes configuration options for a menu blade.
     */
    interface MenuBladeConfig {
        /**
         * Indicates whether this is a no-PDL MenuBlade.
         */
        isV2?: boolean;
    }
    /**
     * Describes configuration options for a template blade.
     */
    interface TemplateBladeConfig extends ItemWithTemplate {
        /**
         * Specifies whether the blade is a parameter provider.
         */
        parameterProvider?: boolean;
        /**
         * Specifies whether the blade has custom controls.
         */
        hasCustomControls?: boolean;
        /**
         * Defines the detail blade(s) that will be created based on this part.
         */
        details?: DetailsDefinition[];
        /**
         * The size of the part.  Only FullWidthFitHeight and FitToContainer are valid.
         */
        partSize?: MsPortalFx.Parts.PartSize;
        /**
         * Part settings to be applied to the virtual part
         */
        partState?: PartStateDefinition;
        /**
         * List of style sheet contents defined by the extension.
         */
        styleSheets?: StyleSheetDefinition[];
    }
    /**
     * Describes configuration options for a frame blade.
     */
    interface FrameBladeConfig {
        /**
         * Part settings to be applied to the virtual part
         */
        partState?: PartStateDefinition;
    }
    /**
     * Defines the attributes for a toolbar.
     */
    interface ToolbarDefinition {
        /**
         * The source for the toolbar view model.
         */
        source: InputBinding;
    }
    /**
     * Definition of a action bar instance.
     */
    interface ActionBarDefinition {
        /**
         * Name of this action bar instance.
         */
        name?: string;
        /**
         * The kind of action bar.
         */
        actionBarKind?: MsPortalFx.Extension.ActionBarKind;
        /**
         * If given, specifies the view model associated with the action bar.
         * This is used when referencing the view model as a property on some other view model.
         */
        source?: InputBinding;
        /**
         * If given, specifies the view model associated with the action bar.
         * This is used when referencing the view model as a standalone item (not a property on some other view model).
         */
        viewModel?: string;
        /**
         * Input bindings for the view model of the action bar.
         */
        bindings?: InputBinding[];
    }
    /**
     * Definition for a lens.
     */
    interface LensDefinition {
        /**
         * Name of the lens.
         */
        name?: string;
        /**
         * Optional title to be displayed in the lens.
         */
        title?: string;
        /**
         * Part instances contained on the lens.
         */
        partInstances?: PartInstanceDefinition[];
        /**
         * Checks if it is a summary lens.
         */
        isSummary?: boolean;
    }
    /**
     * The mode of the redirect part.
     */
    const enum RedirectMode {
        /**
         * It is not a redirect part.
         */
        None = 0,
        /**
         * The redirect part preserves the pinning.
         */
        Preserve = 1,
        /**
         * The part is completed deprecated.
         */
        Deprecate = 2,
    }
    /**
     * Definition of a part instance.
     */
    interface PartInstanceDefinition {
        /**
         * Name of this part instance.
         */
        name?: string;
        /**
         * Reference to part type to instantiate. Either reference or inline must be declared.
         */
        reference?: PartReferenceDefinition;
        /**
         * Part definition to instantiate. Either reference or inline must be declared.
         */
        inline?: PartDefinition;
        /**
         * Specifies whether or not the part acts as a parameter provider. This information is provided here
         * so that we know whether references to external parts are parameter providers.
         */
        parameterProvider?: boolean;
        /**
         * Indicates if the part is retired.
         */
        redirectMode?: RedirectMode;
        /**
         * Some configuration options that are part type sepecific
         * This is for parts which have better perf when they can be initialized early.
         */
        options?: StringMap<any>;
    }
    /**
     * Definition of a part reference instance.
     */
    interface PartReferenceDefinition {
        /**
         * Name of the part type.
         */
        partTypeName: string;
        /**
         * Extension where part type is defined. Defaults to same extension where reference is used.
         */
        extension?: string;
        /**
         * Version of the extension.
         */
        version?: string;
        /**
         * Input bindings for the view model of the part.
         */
        bindings?: InputBinding[];
        /**
         * Initial size of this part newly instantiated. Defaults to 'defaultInitialSize' defined on part type.
         */
        initialSize?: Parts.PartSize;
        /**
         * The part initial width in grid steps if the initialSize is PartSize.Custom.
         */
        initialWidth?: number;
        /**
         * The part initial height in grid steps if the initialSize is PartSize.Custom.
         */
        initialHeight?: number;
        /**
         * Optional. Initial size of this part when rendered in a larger context.
         * This size is applied when the larger context is first rendered. If no large size is provided, then conserve the initial size.
         */
        largeInitialSize?: Parts.PartSize;
        /**
         * Type of asset that this instance is bound to.
         * This is used as an override for the assetType that is used in the referenced part type.
         * The assetPropertyId cannot be overridden because that is a part implementation
         * detail.
         */
        assetType?: string;
        /**
         * Name of view model to inject as a property of the referenced part view model in order to extend it.
         */
        extenderViewModel?: string;
    }
    /**
     * The definition of the part gallery info
     */
    interface PartGalleryInfoDefinition {
        /**
         * The text of the part on the part gallery.
         */
        title: string;
        /**
         * The category that the part belongs to.
         */
        category?: string;
        /**
         * Part description
         */
        description?: string;
        /**
         * The thumbnail for the part on the part gallery.
         */
        thumbnail?: Base.Image;
        /**
         * Gets the thumbanil stretch.
         */
        thumbnailStretch?: MsPortalFx.Widgets.PartGallery.ThumbnailStretch;
        /**
         * Gets the pivot kind.
         */
        pivotKind?: PartGalleryPivotKind;
        /**
         * Gets the selectable path to trigger auto configuration.
         */
        autoConfigSelectablePath?: string;
        /**
         * The feature values used to conditionally show the part in the gallery.
         */
        feature?: string;
    }
    /**
     * The definition of the part input.
     */
    interface InputDefinition {
        /**
         * The name of the input.
         */
        name: string;
        /**
         * The type of the input.
         */
        type?: string;
        /**
         * Indicates if the input is optional.
         */
        optional?: boolean;
        /**
         * Indicates if the input is the asset id.
         */
        isAssetId?: boolean;
    }
    /**
     * Definition of a part type.
     */
    interface PartTypeDefinition extends PartDefinition {
        /**
         * Name of the part type.
         */
        name?: string;
        /**
         * The info of the part shown in the part gallery.
         */
        partGalleryInfo?: PartGalleryInfoDefinition;
        /**
         * The definitions of the inputs to the part.
         */
        inputDefinitions?: InputDefinition[];
        /**
         * Reference to part type to instantiate.
         */
        reference?: PartReferenceDefinition;
        /**
         * Specifies whether or not the part acts as a parameter provider.
         */
        parameterProvider?: boolean;
    }
    interface ItemWithTemplate {
        /**
         * Key to the HTML template used by the item.
         */
        htmlTemplate?: string;
        /**
         * The HTML template used by the item. This is preferred. If not specified,
         * the htmlTemplate key is used to get it from the global list of templates.
         */
        htmlTemplateInline?: HtmlTemplateDefinition;
    }
    /**
     * Definition for a part.
     */
    interface PartDefinition extends AssetInstanceDefinition, CommandContainerDefinition, ItemWithTemplate {
        /**
         * Name of the viewmodel to use.
         */
        viewModel?: string;
        /**
         * Default template for this part.
         */
        partKind?: Parts.PartKind;
        /**
         * View model properties that part can declare input bindings for.
         */
        inputs?: string[];
        /**
         * Input bindings for the view model of the part.
         */
        bindings?: InputBinding[];
        /**
         * Defines the detail blade(s) that will be created based on this part.
         */
        details?: DetailsDefinition[];
        /**
         * Default initial size of this part when instantiated. Defaults to PartSize.Normal.
         */
        initialSize?: Parts.PartSize;
        /**
         * The part initial width in grid steps if the initialSize is PartSize.Custom.
         */
        initialWidth?: number;
        /**
         * The part initial height in grid steps if the initialSize is PartSize.Custom.
         */
        initialHeight?: number;
        /**
         * Optional. Initial size of this part when rendered in a larger context.
         * This size is applied when the larger context is first rendered. If no large size is provided, then conserve the initial size.
         */
        largeInitialSize?: Parts.PartSize;
        /**
         * Sizes supported by a custom part.  Ignored for parts that are not PartKind.Custom.
         */
        supportedSizes?: Parts.PartSize[];
        /**
         * The resize mode for this this part. Ignored for parts that are not PartKind.Custom.
         */
        resizeMode?: Parts.ResizeMode;
        /**
         * Properties in viewmodel to save in viewstate.
         */
        viewStateProperties?: string[];
        /**
         * The type of edit scope to created for the when the tile is put on the start board. The id of the created
         * edit scope will be passed to the part as a property named 'editScopeId'.
         */
        editScopeType?: string;
        /**
         * Strategies to save view model properties in user settings.
         */
        partState?: PartStateDefinition;
        /**
         * Optional. Whether the part can use old versions of inputs. Default is false.
         *
         * Old versions of inputs might be present if the part was pinned/cloned and the input properties changed in PDL.
         */
        canUseOldInputVersions?: boolean;
        /**
         * The permissions for the part.
         */
        permissions?: Array<Permission | PermissionSet>;
        /**
         * Specifies whether this part and its parent blade share the same view model.
         */
        shareVmWithParentBlade?: boolean;
        /**
         * Optional part options.
         */
        options?: StringMap<any>;
        /**
         * List of style sheet contents defined by the extension.
         */
        styleSheets?: StyleSheetDefinition[];
    }
    /**
     * Definition for strategies to save view model properties in user settings.
     */
    interface PartStateDefinition {
        /**
         * Property names whose values are saved for each inputs identity.
         */
        inputIdentityProperties?: string[];
        /**
         * Properties whose values are saved to a user defined key.
         */
        sharedProperties?: PartSharedStateDefinition[];
    }
    /**
     * Definition for part properties that get saved to settings with a user defined key.
     */
    interface PartSharedStateDefinition {
        /**
         * Property name to save.
         */
        property: string;
        /**
         * User setting key to use when saving value.
         */
        key: string;
    }
    /**
     * The definition of the default blade action.
     */
    interface DefaultBladeAction {
        /**
         * The name of the part that owns default blade action.
         */
        partName: string;
        /**
         * The name of the default action
         */
        actionName: string;
    }
    /**
     * The info of the commands to navigate the master blade of a blade pair.
     */
    interface NavigateMasterCommands {
        /**
         * The display text of the command to navigate to the next item.
         */
        nextText?: string;
        /**
         * The display text of the command to navigate to the previous item.
         */
        previousText?: string;
    }
    /**
     * The info of the commands to toggle master blade of a blade pair.
     */
    interface ToggleMasterCommand {
        /**
         * The display text of the command to show the master blade.
         */
        showText?: string;
        /**
         * The display text of the command to hide the master blade.
         */
        hideText?: string;
    }
    /**
     * The info for the details blade of the blade pair.
     */
    interface PairDetailsInfo {
        /**
         * Gets if the master blade should be hidden by default.
         */
        shouldHideMasterBlade?: boolean;
        /**
         * Gets the info of the commands of master blade navigation.
         */
        navigateMasterCommands?: NavigateMasterCommands;
        /**
         * Gets if the blades should be paired in windowed mode.
         */
        windowed?: boolean;
    }
    /**
     * The info for the master blade of the blade pair
     */
    interface PairMasterInfo {
        /**
         * The default blade action of the master blade of the blade pair.
         */
        defaultBladeAction?: DefaultBladeAction;
        /**
         * Gets the info of the command to toggle the master blade.
         */
        toggleMasterCommand?: ToggleMasterCommand;
        /**
         *
         */
        width?: MsPortalFx.Blades.PairParentWidth;
    }
    /**
     * Definition for how detail blades should be open.
     */
    interface DetailsDefinition {
        /**
         * The name of the details definition.
         */
        name?: string;
        /**
         * Name of details blade to open. Undefined if selection implements DynamicSelection.
         */
        blade?: string;
        /**
         * Name of extension of the details blade to open. Undefined if selection implements DynamicSelection.
         */
        bladeExtension?: string;
        /**
         * Whether multiple blades should be open.
         */
        isMultiple?: boolean;
        /**
         * Input bindings that trigger the opening of detail blade.
         */
        invocationInputArguments?: InputBinding[];
        /**
         * location of selectable or selectable set in the view model that will trigger
         * opening the blade.   If this is omitted then container.selectable is used.
         */
        selectablePath?: string;
        /**
         * Bindings to populate the selection value that is passed to the blade.
         * This is only applicable to the invocationInputArguments generated by the shell.
         * This feature is used when explicit invocation input arguments are not provided.
         */
        selectableBindings?: InputBinding[];
        /**
         * Additional input bindings for the view model of the details blade.
         */
        additionalInputArguments?: InputBinding[];
        /**
         * Output bindings between the detail blade and the part's view model.
         */
        outputArguments?: InputBinding[];
        /**
         * The parameter collector model associated with the blade action, if any.
         */
        parameterCollector?: string;
        /**
         * Flag indicating if this blade action starts a sub journey.
         */
        asSubJourney?: boolean;
        /**
         * Gets or sets the info for the details blade of the blade pair.
         */
        pairInfo?: PairDetailsInfo;
        /**
         * Gets or sets if the blade will be opened in the context pane.
         */
        openInContextPane?: boolean;
        /**
         * if the blade will be opened in the context pane, true open as context, false open as detail blade
         */
        persistentContextPane?: boolean;
    }
    interface ActivationStyle {
        /**
         * The width of the curent blade when it activates a detail blade.
         */
        width?: MsPortalFx.Blades.BladeWidth;
    }
    /**
     * Definition for an input of a part/blade/command.
     */
    interface InputBinding {
        /**
         * Name of part's view model property.
         */
        property?: string;
        /**
         * Specifies from where to acquire individual values for the array-typed input property on the part's view
         * model.
         */
        valuesFrom: Reference[];
        /**
         * In binding scenarios that distinguish between required and optional parameters,
         * such as part binding, indicates whether this binding parameter is optional. In
         * other scenarios it should not be true.
         */
        optional?: boolean;
        /**
         * Whether this input is part of a set that uniquely identifies the values.
         */
        isIdentityInput?: boolean;
    }
    /**
     * Describes a reference to property on a part or a blade's model.
     */
    interface Reference {
        /**
         * Specifies the type of the reference.
         */
        referenceType: ReferenceType;
        /**
         * Refers to the property on the source's model.
         */
        property: string;
        /**
         * When "referenceType" is "Part", names the part that is being referenced.  If not supplied, the part is
         * determined implicitly from part context in which the reference is used.
         */
        part?: string;
        /**
         * When "referenceType" is "Command", names the blade command that is being referenced.
         */
        bladeCommand?: string;
        /**
         * When "referenceType" is "Command", names the part command that is being referenced.
         */
        partCommand?: string;
        /**
         * When "referenceType" is "Constant", the value to use as the source value of binding.
         */
        constantValue?: any;
    }
    interface CommandExternalReference {
        /**
            * Command type defined in the commands catalog.
            */
        commandType: string;
        /**
            * Name of the extension that defines the commands catalog.
            *   Undefined to assume the same extension.
            */
        extension?: string;
    }
    interface CommandDefinition extends AssetInstanceDefinition {
        /**
         * Identifier for the command.
         */
        name?: string;
        /**
         * The command text.
         */
        text?: string;
        /**
         * View model for the command.
         */
        viewModel?: string;
        /**
         * Input bindings for the view model of the command.
         */
        bindings?: InputBinding[];
        /**
         * Defines the detail blade that can be opened by this command
         */
        details?: DetailsDefinition;
        /**
         * The permissions for the command.
         */
        permissions?: Array<Permission | PermissionSet>;
        /**
         * The kind of the command.
         */
        commandKind?: CommandKind;
        /**
         * Reference to a command defined in the commands catalog of an extension.
         */
        reference?: CommandExternalReference;
    }
    /**
     * The server event that maps to this notification.
     */
    interface ServerEvent {
        /**
         * The event source.
         */
        source: string;
        /**
         * The event operation.
         */
        operation: string;
    }
    /**
     * The notification message.
     */
    interface NotificationMessage {
        /**
         * The message type.
         */
        type: NotificationMessageType;
        /**
         * The notification status.
         */
        status: string;
        /**
         * The notification substatus.
         */
        subStatus?: string;
        /**
         * The title to show for the notification.
         */
        title: string;
        /**
         * The descriptive message to show for the notification.
         */
        message: string;
        /**
         * The optional asset type associated with the notification message.
         */
        assetType?: string;
    }
    /**
     * Definition for the instance of an asset.
     */
    interface AssetInstanceDefinition {
        /**
         * Type of asset that this instance is bound to.
         */
        assetType?: string;
        /**
         * Name of the input property that maps to the identifier of this asset.
         * Required if 'assetType' is defined.
         */
        assetIdInputProperty?: string;
    }
    interface CommandGroupDefinition {
        /**
         * Name for the command group.
         */
        name: string;
        /**
         * Commands in the command group.
         */
        commands: CommandDefinition[];
    }
    interface CommandReference {
        /**
         * Name for the command group.
         */
        name: string;
        /**
         * Input bindings for the view model of the command.
         */
        bindings?: InputBinding[];
    }
    interface CommandGroupReference {
        /**
         * Name for the command group.
         */
        name: string;
        /**
         * Commands in the command group.
         * These references exist to override command bindings.
         */
        commands: CommandReference[];
    }
    /**
     * Definition of a gallery service.
     */
    interface GalleryServiceDefinition {
        /**
         * Service view model name.
         */
        serviceViewModel: string;
    }
    /**
     * The permission base for the permission and permission set classes.
     */
    interface PermissionBase {
        /**
         * The type of the permission.
         */
        permissionType: PermissionType;
    }
    /**
     * Defines the permission type used by the permission base to describe the type of permission.
     */
    const enum PermissionType {
        /**
         * The permission is a permission object.
         */
        Permission = 0,
        /**
         * The permission is a permission set (collection of permissions).
         */
        PermissionSet = 1,
    }
    /**
     * Permission used on part, command and blade.
     */
    interface Permission extends PermissionBase {
        /**
         * The optional extension name for the asset type for the action.
         */
        extensionName?: string;
        /**
         * The the asset type for the action.
         */
        assetType: string;
        /**
         * The reference for the asset id for the action.
         */
        assetId: AssetIdSource;
        /**
         * The action required for the permission.
         */
        action: string;
    }
    /**
     * Permission set used on part, command and blade.
     */
    interface PermissionSet extends PermissionBase {
        /**
         * The set requirement for the set.
         */
        requirement: SetRequirement;
        /**
         * The permissions for the set.
         */
        permissions: Array<Permission | PermissionSet>;
    }
    /**
     * Describes a asset ID source reference for a permission.
     */
    interface AssetIdSource {
        /**
         * Specifies the type of the reference.
         */
        sourceType: AssetIdSourceType;
        /**
         * The name of the property for the asset ID.
         */
        property: string;
        /**
         * When the source type is "FromProvider" or "FromSourceProvider", this is the key to pass to the property
         * provider along with the inputs.
         */
        providerKey?: string;
    }
    /**
     * Points to a knockout HTML fragment which functions as a extension html template.
     */
    interface HtmlTemplateDefinition {
        /**
         * The file path/name which this template was defined in
         */
        file: string;
        /**
         * The template content
         */
        content: string;
    }
    /**
     * Points to a set of CSS styles.
     */
    interface StyleSheetDefinition {
        /**
         * The file path/name which this style sheet was defined in.
         */
        file: string;
        /**
         * The style sheet content.
         */
        content: string;
    }
    interface ControlDefinition {
        /**
         * The name of the control.
         */
        name: string;
        /**
         * The root module ID of the control.
         */
        moduleId: string;
        /**
         * List of style sheet contents defined by the extension.
         */
        styleSheets?: StyleSheetDefinition[];
        /**
         * A flag to indicate if the control is a form field or not.
         */
        isFormField?: boolean;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\Extension.Manifest.d.ts
declare module MsPortalFx.Extension {
    const enum NotificationMessageType {
        /**
         * Indicates an error message.
         */
        Error = 0,
        /**
         * Indicates a warning message.
         */
        Warning = 1,
        /**
         * Indicates a success message.
         */
        Success = 2,
        /**
         * Indicates a progress message.
         */
        Progress = 3,
        /**
         * Indicates an info message.
         */
        Info = 4,
    }
    /**
     * Manifest for an extension.
     */
    interface Manifest {
        /**
         * Name of the extension.
         */
        name: string;
        /**
         * Page version of the extension.
         */
        pageVersion?: string;
        /**
         * Obsolete. Version of the extension. This is superceded by Extension.getVersion and Manifest.pageVersion.
         */
        version?: Obsolete;
        /**
         * Arbitrary GUID for the extension. The compiler will create a unique hash from this.
         * Remove being optional when extensions are updated with this property
         */
        hash?: string;
        /**
         * Definition schema version.
         */
        schemaVersion?: string;
        /**
         * Which version of the SDK tools were used to generate this manifest.
         */
        sdkVersion?: string;
        /**
         * If this flag is true visual artifacts are displayed in the assets, parts and blades to indicate the functionality is preview
         */
        isPreview?: boolean;
        /**
         * List of asset types supported by this extension.
         */
        assetTypes?: AssetTypeManifest[];
        /**
         * List of notifications supported by this extension
         */
        notifications?: NotificationDefinition[];
        /**
         * List of notifications in the new schema supported by this extension
         */
        notifications2?: Notification[];
        /**
         * A value indicating whether or not the extension has start board parts.
         */
        startBoardParts?: PartInstanceManifest[];
        /**
         * The hubs in the extension.
         */
        hubs?: HubInstanceManifest[];
        /**
         * The gallery service in the extension.
         */
        galleryService?: GalleryServiceDefinition;
        /**
         * The list of gallery parts.
         */
        galleryParts?: GalleryPartManifest[];
        /**
         * The list of redirects.
         */
        redirects?: RedirectDefinition[];
    }
    interface RedirectDefinition {
        /**
         * The type of redirect.
         */
        type: RedirectType;
        /**
         * The name of the blade to redirect.
         */
        fromBlade: string;
        /**
         * The name of the blade to redirect to.
         */
        toBlade?: string;
        /**
         * The extension of the blade to redirect to.
         */
        toExtension?: string;
    }
    /**
     * Asset type manifest for an extension.
     */
    interface AssetTypeManifest {
        /**
         * The name of the asset type.
         */
        name?: string;
        /**
         * The singular display name of the asset type.
         */
        singularDisplayName?: string;
        /**
         * The plural display name of the asset type.
         */
        pluralDisplayName?: string;
        /**
         * The lowercase singular display name of the asset type.
         */
        lowerSingularDisplayName?: string;
        /**
         * The lowercase plural display name of the asset type.
         */
        lowerPluralDisplayName?: string;
        /**
         * The service display name of the asset type.
         */
        serviceDisplayName?: string;
        /**
         * The contracts flag for which contracts the asset view model supports.
         */
        contracts?: number;
        /**
         * The name of the asset type view model associated with this asset type.
         */
        viewModel?: string;
        /**
         * The icon of the asset type.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * The part associated with this asset.
         */
        partName?: string;
        /**
         * If this flag is true visual artifacts are displayed in the asset's parts and blades to indicate the functionality is preview
         */
        isPreview?: boolean;
        /**
         * The blade associated with the asset.
         */
        bladeName?: string;
        /**
         * The blade extension associated with the asset.
         */
        bladeExtensionName?: string;
        /**
         * Optional browse type which indicates the type of browse for the asset type.
         */
        browseType?: BrowseType;
        /**
         * Optional service name for the browse service associated with the asset.
         */
        browseServiceViewModel?: string;
        /**
         * Optional 'private' browse flag which indicates to exclude this asset from the browse UX.
         */
        privateBrowse?: boolean;
        /**
         * Optional link URI for browse associated with the asset using a link to an external source.
         */
        browseLinkUri?: string;
        /**
         * Optional browse flag which indicates that if RDFE access is not available to not show this asset fromt he browse UX.
         */
        browseRequiresRdfe?: boolean;
        /**
         * Optional browse flag which are the browse requirements.
         */
        browseRequirements?: number;
        /**
         * The service name for the grid columns service associated with the asset.
         */
        gridColumnsServiceViewModel?: string;
        /**
         * The service name for the dynamic blade service associated with the asset.
         */
        dynamicBladeServiceViewModel?: string;
        /**
         * Optional resource type definition associated with the asset.
         */
        resourceType?: ResourceTypeDefinition;
        /**
         * The service name for the property provider service associated with the asset.
         */
        propertyProviderServiceViewModel?: string;
        /**
         * The type of the asset id.
         */
        assetIdType?: string;
        /**
         * The market place item.
         */
        marketplaceItemId?: string;
        /**
         * The market place category.
         */
        marketplaceMenuItemId?: string;
        /**
         * The static overview menu item for the asset type.
         */
        staticOverview?: StaticOverviewDefinition;
        keywords?: string;
    }
    /**
     * The resource type definition defines the resource type information for an asset type.
     */
    interface ResourceTypeDefinition {
        /**
         * The name of the resource type.
         */
        resourceTypeName: string;
        /**
         * The mapping view model for this resource type.
         */
        mappingViewModel?: string;
        /**
         * The ARM API version to use for this resource type.
         * If this is not specified, the latest API version will be used from the ARM manifest file.
         */
        apiVersion?: string;
        /**
         * The routing type for the resource type.
         * If this is not specified, the 'Default' routing type will be used.
         */
        routingType?: ResourceRoutingType;
        /**
         * The optional array of kinds for this resource type.
         */
        kinds?: ResourceKindDefinition[];
    }
    /**
     * The resource kind definition defines the resource kind information for a resource type.
     */
    interface ResourceKindDefinition {
        /**
         * The name of the resource type kind.
         */
        name: string;
        /**
         * The is default flag of the resource type kind.
         */
        isDefault?: boolean;
        /**
         * The visibility of the resource type kind.
         */
        visibility?: KindVisibility;
        /**
         * The singular display name of the resource type kind.
         */
        singularDisplayName?: string;
        /**
         * The plural display name of the resource type kind.
         */
        pluralDisplayName?: string;
        /**
         * The lowercase singular display name of the resource type kind.
         */
        lowerSingularDisplayName?: string;
        /**
         * The lowercase plural display name of the resource type kind.
         */
        lowerPluralDisplayName?: string;
        /**
 * The service display name of the resource type kind.
 */
        serviceDisplayName?: string;
        /**
         * The blade associated with the resource type kind.
         */
        bladeName?: string;
        /**
         * The blade extension associated with the resource type kind.
         */
        bladeExtensionName?: string;
        /**
         * The icon of the resource type kind.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * If this flag is true visual artifacts are displayed in the asset's parts and blades to indicate the functionality is preview.
         */
        isPreview?: boolean;
        /**
         * The is use resource menu flag of the resource type kind.
         */
        useResourceMenu?: boolean;
        /**
         * The static overview menu item of the resource type kind.
         */
        staticOverview?: StaticOverviewDefinition;
        /**
         * The market place item.
         */
        marketplaceItemId?: string;
        /**
         * The market place category.
         */
        marketplaceMenuItemId?: string;
        /**
         * The list of keywords.
         * NOTE: comma seperated list.
         */
        keywords?: string;
    }
    /**
     * The static overview definition defines the static overview menu item for an asset type or resource type kind.
     */
    interface StaticOverviewDefinition {
        /**
         * The optional ID for the static overview menu item.
         */
        id?: string;
        /**
         * The optional display name of the static overview menu item.
         */
        displayName?: string;
        /**
         * The optional icon of the static overview menu item.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * The optional keywords .
         */
        keywords?: string;
    }
    /**
     * Manifest for a notification that will be used to format notifications.
     */
    interface NotificationDefinition {
        /**
         * The notification event source for this notification.
         */
        eventSource: string;
        /**
         * The notification event type of this notification.
         */
        eventType: string;
        /**
         * The notification label for this notification.
         */
        label: string;
        /**
         * The notification message for this notification.
         * Note that this message can support format items. The notification arguments received by the server will be plugged into these items
         * Example: This is a {0} message written by {1}.
         */
        message: string;
        /**
         * The notification asset type of this notification.
         */
        assetType?: string;
    }
    /**
     * Manifest for a notification in the new schema.
     */
    interface Notification {
        /**
         * The notification name.
         */
        name: string;
        /**
         * The notification asset type of this notification.
         */
        assetType?: string;
        /**
         * The server event that this notification maps to.
         */
        serverEvent?: ServerEvent;
        /**
         * The messages for this notification.
         */
        messages: NotificationMessage[];
    }
    /**
     * Manifest for a part instance.
     */
    interface PartInstanceManifest {
        /**
         * The name of the part instance.
         */
        name: string;
        /**
         * Default initial size of this part when instantiated. Defaults to PartSize.Normal.
         */
        initialSize?: Parts.PartSize;
    }
    /**
     * Manifest for a blade.
     */
    interface BladeManifest {
        /**
         * Name of the blade.
         */
        name: string;
        /**
         * Width of this blade when displayed.
         */
        width?: MsPortalFx.Blades.BladeWidth;
        /**
         * A list of extension name hints that are likely to be required by the blade.
         */
        extensionHints?: string[];
    }
    /**
     * Manifest for a hub.
     */
    interface HubInstanceManifest {
        /**
         * Name of the hub.
         */
        name: string;
        /**
         * Title of the hub.
         */
        title: string;
        /**
         * The icon of the hub.
         */
        icon: MsPortalFx.Base.Image;
        /**
         * The view model for the hub.
         */
        viewModel: string;
        /**
         * Knockout Template used by the hub.
         */
        htmlTemplate?: string;
        /**
         * Defines the detail blade(s) that will be created based on this hub.
         */
        details?: DetailsDefinition[];
    }
    interface GalleryPartManifest {
        /**
         * Name of the part type.
         */
        name?: string;
        /**
         * Initial size for the part.
         */
        initialSize?: Parts.PartSize;
        /**
         * Initial width for the custom size part.
         */
        initialWidth?: number;
        /**
         * Initial height for the custom size part.
         */
        initialHeight?: number;
        /**
         * The info of the part shown in the part gallery.
         */
        partGalleryInfo?: PartGalleryInfoDefinition;
        /**
         * Type of asset that this instance is bound to.
         */
        assetType?: string;
        /**
         * The definitions of the inputs to the part.
         */
        inputDefinitions?: InputDefinition[];
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\ExtensionDescriptor.d.ts
declare module FxImpl.Extension {
    let selfCloudName: string;
    let multiCloudEnabled: boolean;
    /**
     * Determine whether two cloud names are the same.
     *
     * @param name1 the first name.
     * @param name2 the second name.
     * @returns true if two cloud names are equal(case insensitive). Always return true under single cloud mode.
     */
    function isEqualCloudName(name1: string, name2: string): boolean;
    /**
     * The descriptor for an extension window.
     */
    interface ExtensionDescriptor {
        /**
         * The name of the cloud.
         */
        cloudName: string;
        /**
         * The name of the extension.
         */
        name: string;
    }
    /**
     * The cloud wrapper.
     */
    interface CloudWrapper<T> {
        /**
         * The name of the cloud.
         */
        cloudName: string;
        /**
         * The data.
         */
        data: T;
    }
    /**
      * Generates the self cloud name of the extension. (Internal use only)
      */
    function generateSelfCloudName(queryString: string): string;
    /**
     * Generates the multi cloud enabled flag. (Internal use only)
     */
    function generateMultiCloudEnabled(): boolean;
    /**
     * Gets the ID for an extension window.
     *
     * @param descriptor The descriptor.
     * @param options The Options.
     * @returns The ID for the extension window.
     */
    function getWindowId(descriptor: ExtensionDescriptor, options?: {
        addSelfCloudNameIfMissing?: boolean;
        forceCloudName?: boolean;
    }): string;
    /**
     * Gets the descriptor for an extension window.
     *
     * @param windowId The ID for the extension window.
     * @returns The descriptor.
     */
    function getDescriptor(windowId: string, options?: {
        addSelfCloudNameIfMissing?: boolean;
    }): ExtensionDescriptor;
    /**
     * Determine whether two descriptors are referencing to the same extension/window.
     *
     * @param descriptor1 the first descriptor.
     * @param descriptor2 the second descriptor.
     * @returns true if two descriptors reference to the same extension/window. Always return true under single cloud mode.
     */
    function isEqualDescriptor(descriptor1: ExtensionDescriptor, descriptor2: ExtensionDescriptor): boolean;
    /**
     * Manipulate depend on multiCloudEnabled. (for hubs extension only)
     * In Hubs extension, everything is driven by a cloud name indexed map.
     * This helper decouple hubs extension from internal details like multiCloudEnabled and defaultCloudName.
     *
     * @param cloudName the cloud name to be normalized.
     * @returns defaultCloudName in single cloud mode, pass through the cloudName in multiple cloud mode.
     */
    const normalizeCloudName: (cloudName: string, makeLowerCase?: boolean) => string;
    /**
     * Helper to create a cloud name based map.
     * When in single cloud mode cloud name is normalized to be always the default cloud name.
     */
    class CloudMap<T> {
        private _map;
        /**
         * Gets the value based on cloud name.
         *
         * @param cloudName The cloudName.
         * @returns the value in the map.
         */
        get(cloudName: string): T;
        /**
         * Gets or sets the value based on cloud name.
         *
         * @param cloudName The cloudName.
         * @returns the value in the map.
         */
        getOrSet(cloudName: string, defaultValue: T): T;
        /**
         * Sets the value based on cloud name.
         *
         * @param cloudName The cloudName.
         * @param value the cloud name to be normalized.
         * @returns the value in the map.
         */
        set(cloudName: string, value: T): void;
        /**
         * Gets a list of all the values.
         *
         * @returns the list of all the values in the map.
         */
        all(): T[];
        disposeAll(): void;
    }
    /**
     * Gets the window ID for hubs extension.
     */
    function getHubsWindowId(): string;
    /**
     * Gets the cloud name for hubs extension.
     */
    function getHubsCloudName(): string;
    /**
     * add cloud name to id. if cloudname is default cloud name, do nothing
     *
     * @id The id
     * @cloudName The cloud name
     * @startingSlash add starting slash or not
     */
    function addCloudNameToId(id: string, cloudName: string, startingSlash?: boolean): string;
    /**
     * Remove cloud name from id. if cloudname is not in the id, do nothing
     *
     * @id The id
     */
    function removeCloudNameFromId(id: string): string;
    /**
     * Gets cloud name from id. if cloudname is not in the id, use default cloud name
     *
     * @id The id
     */
    function getCloudNameFromId(id: string): string;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\KindVisibility.d.ts
declare module MsPortalFx.Extension {
    enum KindVisibility {
        /**
         * Normal visibility.
         */
        Normal = 0,
        /**
         * Hidden visibility.
         */
        Hidden = 1,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\PartGalleryPivotKind.d.ts
declare module MsPortalFx.Extension {
    enum PartGalleryPivotKind {
        /**
         * No kind defined.
         */
        None = 0,
        /**
         * Indicates that the part is under the general pivot.
         */
        General = 1,
        /**
         * Indicates that the part is associated to an asset and must be pivoted accordingly.
         */
        AssetType = 2,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\RedirectType.d.ts
declare module MsPortalFx.Extension {
    enum RedirectType {
        /**
         * No redirect.
         */
        None = 0,
        /**
         * Defines a redirect to a menu blade.
         */
        MenuBlade = 2,
        /**
         * Defines a redirect to the resource menu blade.
         */
        ResourceMenuBlade = 3,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\ReferenceType.d.ts
declare module MsPortalFx.Extension {
    enum ReferenceType {
        /**
         * The reference is to a view model property on a part.
         */
        Part = 0,
        /**
         * The reference is to an input belonging to the enclosing blade.
         */
        BladeInput = 1,
        /**
         * The reference is to a view model property on a blade's action bar.
         */
        BladeActionBar = 2,
        /**
         * The reference is to a property on a blade's extension view model.
         */
        BladeProperty = 3,
        /**
         * The reference is to a view model property on a command.
         */
        Command = 4,
        /**
         * The reference is a constant value.
         */
        Constant = 5,
        /**
         * The reference is to a property on a a item that is currently selected
         */
        SelectedItem = 6,
        /**
         * The reference is to a view model property on the part adapter.
         */
        Adapter = 7,
        /**
         * The reference is to a property on the containing Dashboard.
         */
        Dashboard = 8,
        /**
         * The reference is to an input of the part adapter.
         */
        AdapterInput = 9,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\ResourceRoutingType.d.ts
declare module MsPortalFx.Extension {
    enum ResourceRoutingType {
        /**
         * Default routing type, resource-group level resources.
         */
        Default = 0,
        /**
         * Tenant based resources.
         */
        Tenant = 1,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\Runtime.d.ts
declare module FxImpl.Extension {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import Rpc = FxBase.Rpc.Internal;
    import FxAssets = Fx.Assets;
    import FxExtension = Fx.Extension;
    import FxViewModels = Fx.ViewModels;
    import ActionEndPointDefinition = Rpc.ActionEndPointDefinition;
    import FuncEndPointDefinition = Rpc.FuncEndPointDefinition;
    import Context = FxImpl.TelemetryContext;
    import ProxiedObjectTypeDefinition = Rpc.ProxiedObjectTypeDefinition;
    import Security = FxBase.Security;
    import Settings = Fx.Settings;
    import HubsAzure = HubsExtension.Azure;
    var registerManifestDefinition: ActionEndPointDefinition<FxExtension.Manifest>;
    var getViewModelsDefinition: ProxiedObjectTypeDefinition<GetViewModelOptions, any>;
    var getExtensionGalleryService: ProxiedObjectTypeDefinition<void, any>;
    var initializeEndPoint: FuncEndPointDefinition<void, BootstrapTelemetry>;
    var disposeEndPoint: ActionEndPointDefinition<{}>;
    var getDefinitionEndPoint: FuncEndPointDefinition<void, FxExtension.Definition>;
    var getBladeDefinitionEndPoint: FuncEndPointDefinition<string, FxExtension.BladeDefinition>;
    var getPartDefinitionEndPoint: FuncEndPointDefinition<string, FxExtension.PartTypeDefinition>;
    var getControlDefinitionEndPoint: FuncEndPointDefinition<string, FxExtension.ControlDefinition>;
    var pingEndPoint: FuncEndPointDefinition<void, boolean>;
    interface GetAuthorizationTokenOptions {
        resourceName?: string;
        cloudName?: string;
    }
    interface GetAuthorizationTokenOptionsExtended extends GetAuthorizationTokenOptions {
        isBackground: boolean;
    }
    var getAuthorizationTokenEndPoint: FuncEndPointDefinition<GetAuthorizationTokenOptionsExtended, Security.GetAuthorizationTokenResponse>;
    var getUserInfoEndPoint: FuncEndPointDefinition<any, Security.UserInfo>;
    var getSharedSettingsEndPoint: FuncEndPointDefinition<any, Settings.SharedSettings>;
    var getLocalGalleryPackagesEndpointsDefinition: FuncEndPointDefinition<any, string[]>;
    var registerLocalGalleryPackagesEndpointDefinition: FuncEndPointDefinition<string, any>;
    var submitObjectCacheTelemetryEndpoint: FuncEndPointDefinition<Data.ObjectCacheTelemetryEntry[], void>;
    var sharedObservablesEndPoint: ProxiedObjectTypeDefinition<string, any>;
    interface HasPermissionsToShellArgs {
        entityId: string;
        requestedActions: string[];
        cloudName?: string;
    }
    var hasPermissionsToShell: FuncEndPointDefinition<HasPermissionsToShellArgs, boolean>;
    var mapAssetIdToResourceIdEndPoint: FuncEndPointDefinition<FxAssets.AssetTriplet, string>;
    var mapResourceIdToAssetIdEndPoint: FuncEndPointDefinition<string, FxAssets.AssetTriplet>;
    interface MapAssetIdToDynamicSelectionArgs {
        assetId: FxAssets.AssetTriplet;
        forceBladeSelection: boolean;
    }
    var mapAssetIdToDynamicSelectionAndIconEndPoint: FuncEndPointDefinition<MapAssetIdToDynamicSelectionArgs, FxAssets.DynamicSelectionAndIcon>;
    interface MapResourceIdToDynamicSelectionArgs {
        resourceId: string;
        forceBladeSelection: boolean;
    }
    var mapResourceIdToDynamicSelectionAndIconEndPoint: FuncEndPointDefinition<MapResourceIdToDynamicSelectionArgs, FxAssets.DynamicSelectionAndIcon>;
    interface GetAssetTypeInformationEndPointArgs {
        extensionName: string;
        assetType: string;
    }
    var getAssetTypeInformationEndPoint: FuncEndPointDefinition<GetAssetTypeInformationEndPointArgs, FxAssets.AssetTypeInformation>;
    var getResourceTypeAssetTypeInformationEndPoint: FuncEndPointDefinition<string[], FxAssets.ResourceTypeAssetTypeInformation[]>;
    var getResourceAssetInformationEndPoint: FuncEndPointDefinition<string[], FxAssets.ResourceAssetInformation[]>;
    interface GetResourceEndPointArgs {
        resourceId: string;
        caller: string;
    }
    var getResourceEndPoint: FuncEndPointDefinition<GetResourceEndPointArgs, HubsAzure.ResourceWithStrings>;
    var signalResourcesChangedEndPoint: FuncEndPointDefinition<string[], void>;
    var getArmEndpointEndPoint: FuncEndPointDefinition<void, string>;
    /**
     * Enumeration of types of containers that can be created when a view model is being created
     */
    const enum ContainerType {
        /**
         * Use the default container for the
         */
        Default = 0,
        /**
         * Template blade view models are shared between the blade and part.  Their container has different
         * behaviors then a "old style" part and blade containers.
         */
        TemplateBlade = 1,
    }
    interface Definition extends FxExtension.Definition {
        requireConfig?: RequireConfig;
    }
    /**
           * Enumeration of types of ealyTaskReturn
           */
    const enum EarlyTaskExecuteType {
        /**
         * use array.reduce with Q() to sequencail tasks.  Eg. tasks.reduce((prev, task) => prev.then(() => model[task.method].apply(model, task.args)), Q());
         * return 1 promise back of daisy chain promise.  Each task wait on previous task's resolution.
         */
        Sequential = 0,
        /**
         * use array.map with Q.fcall() to concurrent schedule tasks.  Eg. tasks.map((task) =>Q.fcall(() => model[task.method].apply(model, task.args)));
         * return array of promises. the later one doesn't wait for previous task executeion's resolution.
         */
        Concurrent = 1,
    }
    /**
     * EalyExecTasks Options passed to getViewModel and getPartViewModel from the shell such that before it return the content of the viewModel, it will execute the following tasks by
     * tasks.map( (v) => Q.fcall( content[v.method].apply(content, v.args);));  for concurrent execute or sequencial call by task.reduce().
     */
    interface EarlyExecuteTasks {
        /**
         * options to keep the task output promises  the "_msPortalFx_earlyExec" + keepReturns
         */
        keepReturnsIn?: string;
        /**
         * list of tasks to execute on the ViewModel.
         */
        tasks: {
            method: string;
            args?: any[];
        }[];
        /**
         * options to execute tasks in sequential (by array.reduce) or Concurrent (by array.map)
         */
        taskExecType?: EarlyTaskExecuteType;
    }
    /**
     * Options passed to getViewModel and getPartViewModel from the shell
     */
    interface GetViewModelOptions {
        /**
         * The type of the view model.
         */
        type: string;
        /**
         * The type of container to use.   The container is the API which the view model
         * uses interact with various shell features.
         */
        containerType?: ContainerType;
        /**
         * The view model name.
         */
        name: string;
        /**
         * Initial state that was restored user settings
         */
        initialState?: any;
        /**
         * If true the selectable container should be initialized
         */
        createSelectable?: boolean;
        /**
         * Creation context of the view model
         */
        telemetryContext?: Context.State;
        /**
         * A Part's size, if requesting a Part's view model.
         */
        partSize?: MsPortalFx.Parts.PartSize;
        /**
         * A Part's location, if requesting a Part's view model.
         */
        partLocation?: FxViewModels.PartLocation;
        /**
         * onInputsSet parameters
         */
        onInputsSetParameters?: OnInputsSetParameters;
        /**
        * Part collapsed state
        */
        collapsed?: boolean;
        /**
         * If true, an internal property should be created for Hubs extension to flow cloud name around.
         */
        createHubsInternalCloudNameProperty?: boolean;
        /**
        * If set, start execute these tasks on the ViewModel before it proxied back the result
        */
        earlyExecTasks?: EarlyExecuteTasks;
        /**
         * various view model flags used to configure SDK options
         */
        flags?: MsPortalFx.ViewModels.Internal.ViewModelFlags;
    }
    /**
     * Parameters to onInputsSet
     */
    interface OnInputsSetParameters {
        /**
         * Actual inputs.
         */
        inputs: any;
        /**
         * Settings.
         */
        settings: any;
        /**
         * Trace options.
         */
        traceOptions: FxImpl.ViewModels.CompositionViewModelTraceOptions;
        /**
         * An identifier for the composition item that can be used in diagnostic traces.
         */
        viewModelName: string;
        /**
         * Inputs metadata (currently only for Parts).
         */
        inputsMetadata: InputsMetadata;
    }
    /**
     * View model wrapper for API V2
     */
    interface ViewModelWrapper<T> {
        _msPortalFx_viewModelApiV2_wrapper: boolean;
        chrome: StringMap<KnockoutObservable<any>>;
        viewModel: KnockoutObservable<T>;
    }
    /**
     * Metadata describing how inputs can be bound to properties on the Part's container (its enclosing Dashboard and, later, enclosing
     * Blade).
     */
    type InputsMetadata = StringMap<InputMetadata>;
    /**
     * Metadata describing how an input can be bound to a property from its container (its enclosing Dashboard and, later, enclosing Blade).
     */
    interface InputMetadata {
        /**
         * Those sources available at the container level.  The user will select 0 or 1 of these via configuration UI.
         */
        bindingSources: InputBindingSource[];
        /**
         * The currently selected source or null/undefined if the user has elected to override this input with an explicitly specified
         * value.
         */
        activeBindingSourceName: string;
    }
    /**
     * Metadata describing a container property to which a Part input can be bound.  For a given Part input, the user will select 0 or 1
     * of these via configuration UI.
     */
    interface InputBindingSource {
        /**
         * The runtime-level name of the property at the container level (the Dashboard or, later, the enclosing Blade).
         */
        name: string;
        /**
         * Indicates whether this Dashboard-level property accepts value updates.
         */
        acceptsValueUpdates: boolean;
    }
    interface Runtime extends FxBase.Disposable {
        /**
         * Register an extension.
         */
        register(): void;
        /**
         * Gets the security token an extension uses to make calls against
         * secured back end services.
         * This is the internal implementation of get authorization token, which is cloud aware.
         *
         * @param options Optional options containing the resource name and the cloud name of the extension wants access to.
         * @param rpcEndpoint The rpc end point that actually gets auth token from server side.
         * @return A security token for the named service or if no such token is available undefined.
         */
        getAuthorizationToken(options?: GetAuthorizationTokenOptions): FxBase.PromiseV<Security.AuthorizationToken>;
        /**
         * Gets the signed in user and directory info.
         *
         * @return The info for the currently signed in user and directory.
         */
        getUserInfo(): FxBase.PromiseV<Security.UserInfo>;
        /**
         * Gets the shaerd settings for the extensions to use.
         *
         * @return The shared settings properties.
         */
        getSharedSettings(): FxBase.PromiseV<Settings.SharedSettings>;
        /**
         * Checks to see if the current user has permissions to perform a set of actions against an entity.
         * secured back end services.
         *
         * @param entityId The entity to check for permissions. The entity ID MUST be a resource ID, a subscription ID or a resource group ID.
         * @param actions The actions being to checked.
         * @param cloudName The cloud name.
         * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
         */
        hasPermission(entityId: string, actions: string[], cloudName: string): FxBase.PromiseV<boolean>;
        /**
         * Checks to see if the current user has permissions to perform a set of actions against an asset.
         * secured back end services.
         *
         * @param assetId The asset to check for permissions. The asset MUST have an associated resource type.
         * @param actions The actions being to checked.
         * @param cloudName The cloud name.
         * @return A promise that resolves to true if the current user can perform all the provided actions against the provided asset.
         */
        assetHasPermission(assetId: FxAssets.AssetTriplet, actions: string[], cloudName: string): FxBase.PromiseV<boolean>;
        /**
         * Maps an asset ID to a resource ID using the asset type system.
         * Note that this will reject if the asset type does not support mapping to resource ID.
         *
         * @param assetId The fully qualified asset ID.
         * @return A promise that resolves to the resource ID string for the fully qualified asset ID.
         */
        mapAssetIdToResourceId(assetId: FxAssets.AssetTriplet): FxBase.PromiseV<string>;
        /**
         * Maps a resource ID to an asset ID using the asset type system.
         * Note that this will reject if an asset type is not found for the resource type.
         *
         * @param resourceId The resource ID string.
         * @return A promise that resolves to the fully qualified asset ID for the resource ID.
         */
        mapResourceIdToAssetId(resourceId: string): FxBase.PromiseV<FxAssets.AssetTriplet>;
        /**
         * Maps an asset triplet to a dynamic selection and an icon using the asset type system.
         * Note that this will reject if an asset type is not found.
         *
         * @param assetId The fully qualified asset ID.
         * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
         * @return A promise that resolves to the fully qualified dynamic selection and the icon for the asset ID.
         */
        mapAssetIdToDynamicSelectionAndIcon(assetId: FxAssets.AssetTriplet, forceBladeSelection: boolean): FxBase.PromiseV<FxAssets.DynamicSelectionAndIcon>;
        /**
         * Maps a resource ID to a dynamic selection and an icon using the asset type system.
         * Note that this will reject if an asset type is not found for the resource type.
         *
         * @param resourceId The resource ID string.
         * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
         * @return A promise that resolves to the fully qualified dynamic selection and the icon for the resource ID.
         */
        mapResourceIdToDynamicSelectionAndIcon(resourceId: string, forceBladeSelection: boolean): FxBase.PromiseV<FxAssets.DynamicSelectionAndIcon>;
        /**
         * Gets an asset type's information for a given asset type using the asset type system.
         * Note that this will reject if the asset type is not found.
         *
         * @param extensionName The name of the extension that owns the asset type.
         * @param assetType The name of the asset type.
         * @return A promise that resolves to the asset type information structure for the asset type.
         */
        getAssetTypeInformation(extensionName: string, assetType: string): FxBase.PromiseV<FxAssets.AssetTypeInformation>;
        /**
         * Gets an asset type information for an array of resource types using the asset type system.
         * Note that this will not reject if an asset type is not found for the resource type, but the
         * assetTypeInformation will be null for that resource type.
         *
         * @param resourceTypes The array of names of the resource types.
         * @return A promise that resolves to the asset type information structure for the resource type.
         */
        getResourceTypeAssetTypeInformation(resourceTypes: string[]): FxBase.PromiseV<FxAssets.ResourceTypeAssetTypeInformation[]>;
        /**
         * Gets the asset information for an array of resource IDs using the asset type system.
         * Note that this will not reject if an asset type is not found for the resource type, but the assetId and
         * assetTypeInformation will be null for that resource ID.
         *
         * @param resourceIds An array of resource IDs.
         * @return A promise that resolves to an array of asset information packets, one for each source resource ID.
         */
        getResourceAssetInformation(resourceIds: string[]): FxBase.PromiseV<FxAssets.ResourceAssetInformation[]>;
        /**
         * Gets the resource identified by a supplied resource ID.
         *
         * @param resourceId A resource ID.
         * @param caller A string identifying the caller (for telemetry).
         * @return A promise that resolves with a resource object.
         */
        getResource(resourceId: string, caller: string): FxBase.PromiseV<HubsAzure.ResourceWithStrings>;
        /**
         * Signals that resources of the specified type have changed and cache for these resources should be updated.
         *
         * @param resourceIds The array of resource IDs.
         * @return The promise that resolves when the operation has completed.
         */
        signalResourcesChanged(resourceIds: string[]): FxBase.Promise;
        /**
         * Gets the URIs of endpoints that can be invoked to return gallery package information.
         *
         * @return A promise that resolves to an array of URI strings.
         */
        getLocalGalleryPackagesEndpoints(): FxBase.PromiseV<string[]>;
        /**
         *  Extensions can opt out of the automatic ajax version check if their data APIs are not
         *  compatible for some reason.
         */
        disableAjaxServerVersionCheck(): void;
        /**
         * Gets an observable object.
         *
         * @param type The type of observable object to get.
         * @param name Name of the observable object to get.
         * @param parameters Custom parameters passed to the extension.
         * @return A view model composed of extension content and a container. If the content is a promise, returns a promise that resolves to the composed view model.
         */
        getObservable(options: GetViewModelOptions): Q.Promise<any>;
        /**
         * Gets the gallery service view model from the extension.
         *
         * @return A promise resolved with the gallery service view model.
         */
        getGalleryServiceViewModel(): FxBase.PromiseV<any>;
    }
    class RuntimeImpl implements Runtime {
        private _extensionId;
        private _manifest;
        private _disableAjaxVersionCheck;
        private _registered;
        private _initialized;
        private _disposed;
        _entryPoint: FxExtension.EntryPointContract;
        private _entryPointDeferred;
        private _hubsWindowsId;
        private _tokenCache;
        constructor(manifest: FxExtension.Manifest, createEntryPoint: () => FxBase.PromiseV<FxExtension.EntryPointContract>, bladesModuleBasePath: string, partsModuleBasePath: string, controlsModuleBasePath: string);
        /**
         * Public for testing.
         */
        initializeEntryPoint(createEntryPoint: () => FxBase.PromiseV<FxExtension.EntryPointContract>): FxBase.PromiseV<BootstrapTelemetry>;
        /**
         * See interface.
         */
        register(): void;
        private _initialize();
        /**
         * See interface.
         */
        getAuthorizationToken(options?: GetAuthorizationTokenOptions): FxBase.PromiseV<Security.AuthorizationToken>;
        /**
         * See interface.
         */
        getSharedSettings(): FxBase.PromiseV<Settings.SharedSettings>;
        /**
         * See interface.
         */
        getUserInfo(): FxBase.PromiseV<Security.UserInfo>;
        /**
         * See interface.
         */
        getLocalGalleryPackagesEndpoints(): FxBase.PromiseV<string[]>;
        /**
         * See interface.
         */
        hasPermission(entityId: string, actions: string[], cloudName: string): FxBase.PromiseV<boolean>;
        /**
         * See interface.
         */
        assetHasPermission(assetId: FxAssets.AssetTriplet, actions: string[], cloudName: string): FxBase.PromiseV<boolean>;
        /**
         * See interface.
         */
        mapAssetIdToResourceId(assetId: FxAssets.AssetTriplet): FxBase.PromiseV<string>;
        /**
         * See interface.
         */
        mapResourceIdToAssetId(resourceId: string): FxBase.PromiseV<FxAssets.AssetTriplet>;
        /**
         * See interface.
         */
        mapAssetIdToDynamicSelectionAndIcon(assetId: FxAssets.AssetTriplet, forceBladeSelection: boolean): FxBase.PromiseV<FxAssets.DynamicSelectionAndIcon>;
        /**
         * See interface.
         */
        mapResourceIdToDynamicSelectionAndIcon(resourceId: string, forceBladeSelection: boolean): FxBase.PromiseV<FxAssets.DynamicSelectionAndIcon>;
        /**
         * See interface.
         */
        getAssetTypeInformation(extensionName: string, assetType: string): FxBase.PromiseV<FxAssets.AssetTypeInformation>;
        /**
         * See interface.
         */
        getResourceTypeAssetTypeInformation(resourceTypes: string[]): FxBase.PromiseV<FxAssets.ResourceTypeAssetTypeInformation[]>;
        /**
         * See interface.
         */
        getResourceAssetInformation(resourceIds: string[]): FxBase.PromiseV<FxAssets.ResourceAssetInformation[]>;
        /**
         * See interface.
         */
        getResource(resourceId: string, caller: string): FxBase.PromiseV<HubsAzure.ResourceWithStrings>;
        /**
         * See interface.
         */
        signalResourcesChanged(resourceIds: string[]): FxBase.Promise;
        /**
         * See interface.
         */
        disableAjaxServerVersionCheck(): void;
        /**
         * See interface.
         */
        getObservable(options: GetViewModelOptions): Q.Promise<any>;
        /**
         * Gets the gallery service view model from the extension.
         *
         * @return A promise resolved with the gallery service view model.
         */
        getGalleryServiceViewModel(): FxBase.PromiseV<any>;
        /**
         * See interface.
         */
        dispose(): void;
        private getViewModel(options);
        private getPartViewModel(getOptions);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\ServiceClient.d.ts
declare module MsPortalFx.Extension {
    /**
     * Interface for services exposed by extensions.
     */
    interface ServiceClient {
        /**
         * Disposes the client's resources.
         */
        dispose(): void;
    }
    /**
     * Enumerates the type of services an extension exposes.
     */
    enum ServiceType {
        /**
         * An observable service type.
         * When passed to getService the scope parameter is interpreted as the name of the observable to return
         */
        Observable = 0,
    }
    /**
     * Interface for the observables service.
     */
    interface ObservableServiceClient<T> extends ServiceClient {
        /**
         * Gets an observable object from the service provider extension.
         * The observables name is the scope parameter passed to getService.
         *
         * @param args The set of arguments passed to the extension providing the observable service.
         * @return An observable from the service provider extension.
         */
        getObservable(...args: any[]): MsPortalFx.Base.PromiseV<T>;
        /**
         * Releases an observable object obtained from the service provider extension.
         *
         * @param observable The observable to release.
         */
        releaseObservable(observable: T): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Extension\SetRequirement.d.ts
declare module MsPortalFx.Extension {
    enum SetRequirement {
        /**
         * All items in the set must be satisfied (operator AND).
         */
        All = 0,
        /**
         * Any items in the set must be satisfied (operator OR).
         */
        Any = 1,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Globalization.d.ts
declare module FxImpl {
    import Fx = MsPortalFx;
    interface Format<T> {
        format(value: T): string;
    }
    interface FormatCache<TOptions, TValue> {
        get(options?: TOptions): Format<TValue>;
    }
    class IntlContext {
        private _intl;
        displayLanguage: string;
        formatCulture: string;
        numberFormatCache: FormatCache<Fx.Intl.NumberFormatOptions, number>;
        dateTimeFormatCache: FormatCache<Fx.Intl.DateTimeFormatOptions, Date>;
        constructor(effectiveLocaleStr: string, intl?: any);
        static createWithBrowserIntl(effectiveLocaleStr?: string): IntlContext;
        supportedLocalesOf(locales: string[]): string[];
    }
    module Intl {
        var displayLanguage: string;
        var formatCulture: string;
        interface NumberFormat {
            /**
             * Returns the format of the number according to the formatting options of this NumberFormat object.
             */
            format(value: number): string;
        }
        /**
         * An object that can provide language sensitive number formatting.
         */
        module NumberFormat {
            /**
             * Creates a new instance of an object that can provide language sensitive number formatting.
             */
            function create(options?: Fx.Intl.NumberFormatOptions): NumberFormat;
            /**
             * Returns the format of the number default formatting options for the current locale.
             */
            function format(value: number): string;
        }
        interface DateTimeFormat {
            /**
             * Returns the format of the number according to the formatting options of this DateTimeObject object.
             */
            format(value: Date): string;
        }
        /**
         * An object that can provide language sensitive date and time formatting.
         */
        module DateTimeFormat {
            /**
             * The format options that returns strings similar to 11/30/2011.
             */
            var shortDatePattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to Wednesday, November 30, 2011.
             */
            var longDatePattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to Wednesday, November 30, 2011, 5:25:30 AM.
             */
            var fullDateTimePattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to November 30.
             */
            var monthDayPattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to 5:25 AM.
             */
            var shortTimePattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to 5:25:30 AM.
             */
            var longTimePattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to November 2011.
             */
            var yearMonthPattern: Fx.Intl.DateTimeFormatOptions;
            /**
             * Creates a new instance of an object that can provide language sensitive date and time formatting.
             */
            function create(options?: Fx.Intl.DateTimeFormatOptions): DateTimeFormat;
        }
        module Internal {
            function supportedLocalesOf(locales: string[]): string[];
        }
    }
}
declare module "MsPortalFx/Globalization" {
    var Intl: typeof FxImpl.Intl;
    export = Intl;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\GlobalStateManager.d.ts
declare module FxImpl.GlobalStateManager {
    interface Resettable {
        reset(): void;
    }
    function register(resettable: Resettable): void;
    function resetGlobalState(): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Hubs\InternalCommands.d.ts
declare module FxImpl {
    /**
     * Interface is in Framework but implementation is in Framework.Client under Internal/ListCommand.
     * Declaring the interface here allows the shell to avoid referencing the Framework.Client module.
     * This is a internal command type that exists only for hubs.
     */
    interface ListCommand2Contract extends MsPortalFx.ViewModels.ListCommandContract {
        /**
         * Shell tests for the existance of this property.
         * Name is short intentionally to keep the size small.
         */
        lc2: boolean;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Hubs\Notifications.d.ts
declare module MsPortalFx.Hubs.Notifications {
    import FxAssets = MsPortalFx.Assets;
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * The notification status.
     */
    enum NotificationStatus {
        /**
         * An information notification
         */
        Information = 0,
        /**
         * A warning notification
         */
        Warning = 1,
        /**
         * An error notification
         */
        Error = 2,
        /**
         * An in progress notification
         */
        InProgress = 3,
        /**
         * A success notification
         */
        Success = 4,
    }
    /**
     * Interface that represents data required to create a client notification.
     */
    interface ClientNotificationParameters {
        /**
        * The notification status - Information, Warning, Error, InProgress, Success.
        */
        status: NotificationStatus;
        /**
         * The notification title.
         */
        title: string;
        /**
         * The notification description.
         */
        description: string;
        /**
         * Optionally, render the notification description as HTML.
         */
        descriptionAsHtml?: boolean;
        /**
         * The event correlation ids associated with the notification.
         */
        correlationIds?: string[];
        /**
         * The percentage of operation completed. If this value exists, a deterministic progress bar is shown.
         * If not, a non-deterministic progress icon is shown with a description.
         */
        percentComplete?: number;
        /**
         * The asset associated with the notification.
         * Either the asset or the linked blade can be specified but not both.
         */
        asset?: FxAssets.AssetTriplet;
        /**
         * A URI that the notification links to.
         */
        uri?: string;
        /**
         * The blade linked to this notification.
         * Either the asset or the linked blade can be specified but not both.
         */
        linkedBlade?: FxViewModels.DynamicBladeSelection;
        /**
         * Any additional properties associated with the notification.
         */
        additionalProperties?: any;
    }
    /**
     * Interface that represents data representing a client notification.
     * This interface cannot be used to create a new notification.
     */
    interface ClientNotificationData extends ClientNotificationParameters {
        /**
         * The notification timestamp.
         */
        timestamp: Date;
        /**
         * Boolean indicating if this is a recommendation notification.
         */
        isRecommendation?: boolean;
    }
    /**
     * Client notification class
     */
    class ClientNotification implements ClientNotificationParameters {
        /**
         * The notification status - Information, Warning, Error, InProgress, Success.
         */
        status: NotificationStatus;
        /**
         * The notification title.
         */
        title: string;
        /**
         * The notification description.
         */
        description: string;
        /**
         * Render the notification description as HTML.
         */
        descriptionAsHtml: boolean;
        /**
         * The event correlation ids associated with the notification.
         */
        correlationIds: string[];
        /**
         * The percentage of operation completed. Used only when notification status is InProgress.
         * If a value is specified, a deterministic progress bar is shown. If not, a non-deterministic progress bar is shown.
         */
        percentComplete: number;
        /**
         * The asset associated with the notification.
         */
        asset: FxAssets.AssetTriplet;
        /**
         * A URI that the notification links to.
         */
        uri: string;
        /**
         * The blade linked to this notification.
         * Either the asset or the linked blade can be specified but not both.
         */
        linkedBlade: FxViewModels.DynamicBladeSelection;
        /**
         * Constructs a notification object that can be published.
         *
         * @param clientNotificationData The client notification data.
         */
        constructor(params: ClientNotificationParameters);
        validate(): boolean;
        package(cloudName?: string): FxImpl.Hubs.Notifications.InternalClientNotificationData;
        /**
         * Publishes this notification to the portal using the properties specified.
         */
        publish(): void;
        /**
         * Publishes a one time notification.
         *
         * @param clientNotificationData The client notification data.
         */
        static publish(params: ClientNotificationParameters): ClientNotification;
    }
}
declare module FxImpl.Hubs.Notifications {
    import FxBase = MsPortalFx.Base;
    import Rpc = FxBase.Rpc.Internal;
    import Notifications = MsPortalFx.Hubs.Notifications;
    var addClientNotficationDefinition: Rpc.FuncEndPointDefinition<InternalClientNotificationData, void>;
    var addClientNotficationsDefinition: Rpc.FuncEndPointDefinition<InternalClientNotificationData[], void>;
    /**
     * The action performed when the modal notification buttons are clicked.
     */
    const enum ModalNotificationClickAction {
        /**
         * Execute a click on the notification
         */
        NotificationClick = 1,
        /**
         * Refresh the portal
         */
        RefreshPortal = 2,
    }
    /**
     * Action to take for the client notification URI.
     */
    enum ClientNotificationUriAction {
        /**
         * Navigates within the portal (ex: route to deep link).
         */
        NavigatePortal = 0,
        /**
         * Opens the URI in a new browser tab.
         */
        OpenInNewTab = 1,
        /**
         * Opens the URI in the current browser tab (replacing the portal).
         */
        OpenInCurrentTab = 2,
    }
    /**
    * The parameters for the modal dialog.
    */
    interface ModalNotificationParams {
        /**
         * The notification that is shown in the menu and in the dialog.
         * The asset specified in the notification will be launched on the primary click.
         */
        notification: InternalClientNotificationData;
        /**
         * The primary button text. Optional, if not specified will default to OK.
         */
        primaryButtonText?: string;
        /**
         * The secondary button text. Optional, if not specified will default to Cancel.
         */
        secondaryButtonText?: string;
        /**
         * The action performed when the primary button is clicked. Defaults to no action.
         */
        primaryButtonClickAction?: ModalNotificationClickAction;
        /**
         * The action performed when the secondary button is clicked. Defaults to no action.
         */
        secondaryButtonClickAction?: ModalNotificationClickAction;
    }
    /**
     * The RPC method that hubs calls to add a modal notification.
     */
    var showModalNotification: Rpc.FuncEndPointDefinition<ModalNotificationParams, MsPortalFx.ViewModels.Dialogs.DialogResult>;
    /**
     * Interface that represents data representing a client notification with cloud name.
     */
    interface InternalClientNotificationData extends Notifications.ClientNotificationData {
        /**
         * The cloud name.
         */
        cloudName: string;
        /**
         * Flag indicating if this is a server event.
         */
        isServerEvent?: boolean;
        /**
         * Action to take for the notification URI.
         */
        uriAction?: ClientNotificationUriAction;
    }
    /**
     * Cloud client notification class
     */
    class InternalClientNotification extends Notifications.ClientNotification {
        /**
         * The cloud name.
         */
        cloudName: string;
        /**
         * Constructs a notification object that can be published.
         *
         * @param The client notification data.
         * @cloudName The cloud name.
         */
        constructor(params: Notifications.ClientNotificationParameters, cloudName: string);
        /**
         * Publishes this notification to the portal using the properties specified.
         *
         * @returns The timestamp at which the notification was published.
         */
        publish(): Date;
        /**
         * Publishes a one time notification.
         *
         * @param clientNotificationData The client notification data.
         */
        static internalPublish(params: Notifications.ClientNotificationParameters, cloudName: string): InternalClientNotification;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Internal\Data\Interfaces.Data.Expressions.d.ts
declare module FxImpl.Data.Expressions {
    interface AllowedExpressions extends StringMap<boolean> {
        Identifier?: boolean;
        And?: boolean;
        Or?: boolean;
        Not?: boolean;
        Group?: boolean;
        Equals?: boolean;
        NotEquals?: boolean;
        GreaterThan?: boolean;
        GreaterThanOrEquals?: boolean;
        LessThan?: boolean;
        LessThanOrEquals?: boolean;
        Boolean?: boolean;
        Guid?: boolean;
        Decimal?: boolean;
        Double?: boolean;
        Integer?: boolean;
        String?: boolean;
        Null?: boolean;
        Add?: boolean;
        Subtract?: boolean;
        Multiply?: boolean;
        Divide?: boolean;
        Modulo?: boolean;
        Negate?: boolean;
        Round?: boolean;
        Floor?: boolean;
        Ceiling?: boolean;
        StartsWith?: boolean;
        EndsWith?: boolean;
        Contains?: boolean;
        Trim?: boolean;
        ToUpper?: boolean;
        ToLower?: boolean;
        IndexOf?: boolean;
        SubString?: boolean;
        Concat?: boolean;
        Month?: boolean;
        Year?: boolean;
        Day?: boolean;
        Hour?: boolean;
        Minute?: boolean;
        Second?: boolean;
        Now?: boolean;
    }
    interface Expression {
        type: string;
    }
    interface UnaryExpression extends Expression {
        expression: Expression;
    }
    interface BinaryExpression extends Expression {
        left: Expression;
        right: Expression;
    }
    interface SetExpression extends Expression {
        expressions: Expression[];
    }
    interface EqualsExpression extends BinaryExpression {
    }
    interface NotEqualsExpression extends BinaryExpression {
    }
    interface GreaterThanExpression extends BinaryExpression {
    }
    interface GreaterThanOrEqualsExpression extends BinaryExpression {
    }
    interface LessThanExpression extends BinaryExpression {
    }
    interface LessThanOrEqualsExpression extends BinaryExpression {
    }
    interface AndExpression extends SetExpression {
    }
    interface OrExpression extends SetExpression {
    }
    interface NotExpression extends UnaryExpression {
    }
    interface AddExpression extends SetExpression {
    }
    interface SubtractExpression extends SetExpression {
    }
    interface MultiplyExpression extends SetExpression {
    }
    interface DivideExpression extends SetExpression {
    }
    interface ModuloExpression extends SetExpression {
    }
    interface NegateExpression extends UnaryExpression {
    }
    interface GroupExpression extends UnaryExpression {
    }
    interface BooleanExpression extends Expression {
        value: boolean;
    }
    interface GuidExpression extends Expression {
        value: string;
    }
    interface DecimalExpression extends Expression {
        value: string;
    }
    interface DoubleExpression extends Expression {
        value: number;
    }
    interface IntegerExpression extends Expression {
        value: number;
    }
    interface StringExpression extends Expression {
        value: string;
    }
    interface NullExpression extends Expression {
    }
    interface IdentifierExpression extends Expression {
        name: string;
    }
    interface RoundExpression extends UnaryExpression {
    }
    interface FloorExpression extends UnaryExpression {
    }
    interface CeilingExpression extends UnaryExpression {
    }
    interface StartsWithExpression extends Expression {
        expression: Expression;
        start: Expression;
    }
    interface EndsWithExpression extends Expression {
        expression: Expression;
        end: Expression;
    }
    interface ContainsExpression extends Expression {
        expression: Expression;
        value: Expression;
    }
    interface TrimExpression extends UnaryExpression {
    }
    interface ToUpperExpression extends UnaryExpression {
    }
    interface ToLowerExpression extends UnaryExpression {
    }
    interface IndexOfExpression extends Expression {
        expression: Expression;
        value: Expression;
    }
    interface SubStringExpression extends Expression {
        expression: Expression;
        start: Expression;
        count?: Expression;
    }
    interface ConcatExpression extends Expression {
        expression: Expression;
        value: Expression;
    }
    interface MonthExpression extends UnaryExpression {
    }
    interface YearExpression extends UnaryExpression {
    }
    interface DayExpression extends UnaryExpression {
    }
    interface HourExpression extends UnaryExpression {
    }
    interface MinuteExpression extends UnaryExpression {
    }
    interface SecondExpression extends UnaryExpression {
    }
    interface NowExpression extends Expression {
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Internal\Data\Interfaces.Data.Navigator.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    const enum LoadState {
        Pending = 0,
        Loading = 1,
        Loaded = 2,
        Error = 3,
    }
    interface NavigatorItem<T, TId> {
        id: TId;
        data: KnockoutObservableBase<T>;
    }
    interface HierarchicalNavigatorItem<T, TId> extends NavigatorItem<T, TId> {
        depth: KnockoutObservableBase<number>;
        canExpand: KnockoutObservableBase<boolean>;
        isExpanded: KnockoutObservableBase<boolean>;
    }
    interface Navigator<T, TData, TId> {
        properties: Property[];
        allowedFilterExpressions: Expressions.AllowedExpressions;
        initialized: FxPromise;
        filterExpression: KnockoutObservable<Expressions.Expression>;
        searchText: KnockoutObservable<string>;
        sortOrder: KnockoutObservable<SortOrder[]>;
        selectedProperties: KnockoutObservable<Property[]>;
    }
    interface AllNavigation<TItem extends NavigatorItem<any, any>> {
        items: KnockoutReadOnlyObservableArray<TItem>;
        totalItems: KnockoutReadOnlyObservableBase<number>;
        loadAll(): FxPromise;
        refresh(): FxPromise;
    }
    interface PageNavigation<TItem extends NavigatorItem<any, any>> {
        items: KnockoutReadOnlyObservableArray<TItem>;
        totalItems: KnockoutReadOnlyObservableBase<number>;
        startIndex: KnockoutReadOnlyObservableBase<number>;
        canLoadMore: KnockoutReadOnlyObservableBase<boolean>;
        loadPage(startIndex: number, pageSize: number): FxPromise;
        refresh(): FxPromise;
    }
    interface DemandNavigation<TItem extends NavigatorItem<any, any>> {
        items: KnockoutReadOnlyObservableArray<TItem>;
        totalItems: KnockoutReadOnlyObservableBase<number>;
        canLoadMore: KnockoutReadOnlyObservableBase<boolean>;
        loadMore(count: number): FxPromise;
        refresh(): FxPromise;
    }
    interface ListNavigator<T, TData, TId> extends Navigator<T, TData, TId>, AllNavigation<NavigatorItem<T, TId>> {
    }
    interface PageNavigator<T, TData, TId> extends Navigator<T, TData, TId>, PageNavigation<NavigatorItem<T, TId>> {
    }
    interface PagedListNavigator<T, TData, TId> extends Navigator<T, TData, TId>, AllNavigation<NavigatorItem<T, TId>>, PageNavigation<NavigatorItem<T, TId>> {
    }
    interface DemandLoadNavigator<T, TData, TId> extends Navigator<T, TData, TId>, DemandNavigation<NavigatorItem<T, TId>> {
    }
    interface PagedDemandLoadNavigator<T, TData, TId> extends Navigator<T, TData, TId>, DemandNavigation<NavigatorItem<T, TId>>, PageNavigation<NavigatorItem<T, TId>> {
    }
    interface HierarchicalListNavigator<T, TData, TId> extends Navigator<T, TData, TId>, AllNavigation<HierarchicalNavigatorItem<T, TId>> {
    }
    interface PagedHierarchicalNavigator<T, TData, TId> extends Navigator<T, TData, TId>, PageNavigation<HierarchicalNavigatorItem<T, TId>> {
    }
    interface NavigatorOptions<T, TData, TId> {
        inputParams?: QueryParams | FxPromiseV<QueryParams>;
        getId?: (data: TData) => TId;
        getModel?: (data: TData[]) => T[] | FxPromiseV<T[]>;
        searchText?: KnockoutObservable<string>;
        filterExpression?: KnockoutObservable<Expressions.Expression>;
        sortOrder?: KnockoutObservableArray<SortOrder>;
        selectedProperties?: KnockoutObservableArray<Property>;
    }
    interface ListNavigatorOptions<T, TData, TId> extends NavigatorOptions<T, TData, TId> {
    }
    interface DemandLoadNavigatorOptions<T, TData, TId> extends NavigatorOptions<T, TData, TId> {
    }
    interface HierarchicalListNavigatorOptions<T, TData, TId> extends NavigatorOptions<T, TData, TId> {
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Internal\Data\Interfaces.Data.QueryParams.d.ts
declare module FxImpl.Data {
    const enum SortDirection {
        Descending = 0,
        Ascending = 1,
    }
    interface Property {
        name: string;
    }
    interface SortOrder {
        property: Property;
        direction: SortDirection;
    }
    interface QueryParams {
        searchText?: string;
        filterExpression?: Expressions.Expression;
        sortOrder?: SortOrder[];
        selectedProperties?: Property[];
        totalCount?: boolean;
        continuationToken?: string;
        skip?: number;
        take?: number;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Internal\Internal.Constants.d.ts
declare module FxImpl.Constants {
    module CloudName {
        const inputBindingKey: string;
        const allClouds: string;
    }
    module RpcMethods {
        const brokerExtensionService: string;
        const forwardEvent: string;
        const getAuthToken: string;
        const getUserInfo: string;
        const getSharedSettings: string;
        const entryPointDispose: string;
        const entryPointGetDefinition: string;
        const entryPointGetBladeDefinition: string;
        const entryPointGetControlDefinition: string;
        const entryPointGetPartDefinition: string;
        const entryPointInitialize: string;
        const hasPermission: string;
        const mapAssetIdToResourceId: string;
        const mapResourceIdToAssetId: string;
        const mapAssetIdToDynamicSelectionAndIcon: string;
        const mapResourceIdToDynamicSelectionAndIcon: string;
        const getAssetTypeInformation: string;
        const getResourceTypeAssetTypeInformation: string;
        const getResourceAssetInformation: string;
        const getResource: string;
        const notifyExtensionStatus: string;
        const ping: string;
        const provideExtensionService: string;
        const registration: string;
        const updateSubscriptionInfo: string;
        const updateTenantInfo: string;
        const getRegisteredResourceProviderInfo: string;
        const viewModels: string;
        const getClientNotifications: string;
        const shellReadUserSettings: string;
        const shellWriteUserSettings: string;
        const signalResourcesChanged: string;
        const getSubscriptionInfo: string;
        const getAllSubscriptions: string;
        const getSelectedSubscriptions: string;
        const getLocationDisplayNames: string;
        const submitObjectCacheTelemetry: string;
        const networkTelemetry: string;
        const addClientNotification: string;
        const addClientNotifications: string;
        const getArmEndpoint: string;
        const getSettings: string;
        const logFeatureAdoptionTelemetry: string;
        const pinParts: string;
        const hubsGetResourceGroupsFromSubscription: string;
        const getSasUriForQueue: string;
        const getHmacSha256: string;
        const azureResourceManagerDeployTemplate: string;
        const azureResourceManagerPollForDeployment: string;
        const validateArmTemplate: string;
        const getExtensionGalleryServiceViewModel: string;
        const getLocalGalleryPackagesEndpoints: string;
        const getLocationsForCreate: string;
        const getProvisioningOperation: string;
        const getProvisioningRequest: string;
        const initiateProvisioningRequest: string;
        const registerLocalGalleryPackagesEndpoint: string;
        const submitProvisionerTelemetry: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Internal\Internal.DefinitionBuilder.d.ts
declare module FxImpl.DefinitionBuilder {
    import FxExtension = MsPortalFx.Extension;
    const createMenuBladeConfig: () => FxExtension.MenuBladeConfig;
    const createTemplateBladeConfig4: (htmlTemplate?: string, parameterProvider?: boolean, details?: FxExtension.DetailsDefinition[], partSize?: MsPortalFx.Parts.PartSize, htmlTemplateInline?: FxExtension.HtmlTemplateDefinition, partState?: FxExtension.PartStateDefinition) => FxExtension.TemplateBladeConfig;
    const createCommandExternalReference: (commandType?: string, extension?: string) => FxExtension.CommandExternalReference;
    const createDefaultBladeAction: (partName?: string, actionName?: string) => FxExtension.DefaultBladeAction;
    const createHtmlTemplateDefinition: (file?: string, content?: string) => FxExtension.HtmlTemplateDefinition;
    const createAssetIdSource: (ourceType?: FxExtension.AssetIdSourceType, property?: string, providerKey?: string) => FxExtension.AssetIdSource;
    const createPairMasterInfo: (width?: MsPortalFx.Blades.PairParentWidth, defaultBladeAction?: FxExtension.DefaultBladeAction, toggleMasterCommand?: FxExtension.ToggleMasterCommand) => FxExtension.PairMasterInfo;
    const createPairDetailsInfo: (shouldHideMasterBlade?: boolean, windowed?: boolean, navigateMasterCommands?: FxExtension.NavigateMasterCommands) => FxExtension.PairDetailsInfo;
    const createPermissionBase: (permissionType?: FxExtension.PermissionType) => FxExtension.PermissionBase;
    const createPartSharedStateDefinition: (property?: string, key?: string) => FxExtension.PartSharedStateDefinition;
    const createPartStateDefinition: (inputIdentityProperties?: string[], sharedProperties?: FxExtension.PartSharedStateDefinition[]) => FxExtension.PartStateDefinition;
    const createInputDefinition: (name: string, type?: string, optional?: boolean, isAssetId?: boolean) => FxExtension.InputDefinition;
    const createNotificationMessage: (type?: FxExtension.NotificationMessageType, status?: string, subStatus?: string, title?: string, message?: string, assetType?: string) => FxExtension.NotificationMessage;
    const createServerEvent: (source?: string, operation?: string) => FxExtension.ServerEvent;
    const createPartGalleryInfoDefinition: (title?: string, description?: string, category?: string, thumbnail?: any, thumbnailStretch?: MsPortalFx.Widgets.PartGallery.ThumbnailStretch) => FxExtension.PartGalleryInfoDefinition;
    const createPartGalleryInfoDefinition2: (title?: string, description?: string, category?: string, thumbnail?: any, thumbnailStretch?: MsPortalFx.Widgets.PartGallery.ThumbnailStretch, pivotKind?: MsPortalFx.Extension.PartGalleryPivotKind, autoConfigSelectablePath?: string, feature?: string) => FxExtension.PartGalleryInfoDefinition;
    const createPermissionSet: (requirement?: FxExtension.SetRequirement, permissions?: Array<FxExtension.Permission | FxExtension.PermissionSet>, permissionType?: FxExtension.PermissionType) => FxExtension.PermissionSet;
    const createPermission: (extensionName?: string, assetType?: string, assetId?: FxExtension.AssetIdSource, action?: string, permissionType?: FxExtension.PermissionType) => FxExtension.Permission;
    const createReference: (referenceType?: FxExtension.ReferenceType, property?: string, part?: string, bladeCommand?: string, partCommand?: string, constantValue?: any) => FxExtension.Reference;
    const createToolbarDefinition: (source?: FxExtension.InputBinding) => FxExtension.ToolbarDefinition;
    const createNavigateMasterCommands: (nextText?: string, previousText?: string) => FxExtension.NavigateMasterCommands;
    const createToggleMasterCommand: (showText?: string, hideText?: string) => FxExtension.ToggleMasterCommand;
    const createActionBarDefinition: (name: string, actionBarKind?: FxExtension.ActionBarKind, source?: FxExtension.InputBinding, viewModel?: string, bindings?: FxExtension.InputBinding[]) => FxExtension.ActionBarDefinition;
    const createBladeDefinition: (name: string, inputs?: string[], optionalInputs?: string[], templateKeyInputs?: string[], outputs?: string[], commandGroup?: string, viewModelName?: string, _internal_viewModelExtensionName?: string, lenses?: FxExtension.LensDefinition[], commandGroupReference?: FxExtension.CommandGroupReference, viewModelInputs?: FxExtension.InputBinding[], bindings?: FxExtension.InputBinding[], width?: MsPortalFx.Blades.BladeWidth, locked?: boolean, editScopeType?: string, assetType?: string, assetIdInputProperty?: string, pinnedPart?: string, pinnable?: boolean, initialDisplayState?: MsPortalFx.Blades.DisplayState, style?: MsPortalFx.Blades.BladeStyle, actionBar?: FxExtension.ActionBarDefinition, discardEditsOnSelectionChange?: boolean, orientation?: FxImpl.Widgets.Orientation, permissions?: FxExtension.PermissionBase[], pairMasterInfo?: FxExtension.PairMasterInfo, toolbar?: FxExtension.ToolbarDefinition, templateBlade?: FxExtension.TemplateBladeConfig, waitForInputsSet?: boolean) => FxExtension.BladeDefinition;
    const createBladeDefinition2: (name: string, inputs?: string[], optionalInputs?: string[], templateKeyInputs?: string[], outputs?: string[], commandGroup?: string, viewModelName?: string, _internal_viewModelExtensionName?: string, lenses?: FxExtension.LensDefinition[], commandGroupReference?: FxExtension.CommandGroupReference, viewModelInputs?: FxExtension.InputBinding[], bindings?: FxExtension.InputBinding[], width?: MsPortalFx.Blades.BladeWidth, locked?: boolean, editScopeType?: string, assetType?: string, assetIdInputProperty?: string, pinnedPart?: string, pinnable?: boolean, initialDisplayState?: MsPortalFx.Blades.DisplayState, style?: MsPortalFx.Blades.BladeStyle, actionBar?: FxExtension.ActionBarDefinition, discardEditsOnSelectionChange?: boolean, orientation?: FxImpl.Widgets.Orientation, permissions?: FxExtension.PermissionBase[], pairMasterInfo?: FxExtension.PairMasterInfo, toolbar?: FxExtension.ToolbarDefinition, templateBlade?: FxExtension.TemplateBladeConfig, waitForInputsSet?: boolean, menuBlade?: FxExtension.MenuBladeConfig, attributes?: FxExtension.BladeAttributes) => FxExtension.BladeDefinition;
    const createCommandDefinition: (name: string, text?: string, viewModel?: string, bindings?: FxExtension.InputBinding[], details?: FxExtension.DetailsDefinition, assetType?: string, assetIdInputProperty?: string, permissions?: FxExtension.PermissionBase[], commandKind?: FxExtension.CommandKind, reference?: FxExtension.CommandExternalReference) => FxExtension.CommandDefinition;
    const createCommandGroupDefinition: (name: string, commands?: FxExtension.CommandDefinition[]) => FxExtension.CommandGroupDefinition;
    const createCommandGroupReference: (name: string, commands?: FxExtension.CommandReference[]) => FxExtension.CommandGroupReference;
    const createCommandReference: (name: string, bindings?: FxExtension.InputBinding[]) => FxExtension.CommandReference;
    const createGalleryServiceDefinition: (serviceViewModel?: string) => FxExtension.GalleryServiceDefinition;
    const createDashboardProviderDefinition: (viewModel?: string) => FxExtension.DashboardProviderDefinition;
    const createLensDefinition: (name: string, title?: string, partInstances?: FxExtension.PartInstanceDefinition[], isSummary?: boolean) => FxExtension.LensDefinition;
    const createPartDefinition4: (viewModel?: string, partKind?: MsPortalFx.Parts.PartKind, canUseOldInputVersions?: boolean, inputs?: string[], bindings?: FxExtension.InputBinding[], htmlTemplate?: string, details?: FxExtension.DetailsDefinition[], initialSize?: MsPortalFx.Parts.PartSize, initialWidth?: number, initialHeight?: number, largeInitialSize?: MsPortalFx.Parts.PartSize, supportedSizes?: MsPortalFx.Parts.PartSize[], resizeMode?: MsPortalFx.Parts.ResizeMode, commandGroup?: string, commandGroupReference?: FxExtension.CommandGroupReference, editScopeType?: string, viewStateProperties?: string[], partState?: FxExtension.PartStateDefinition, assetType?: string, assetIdInputProperty?: string, permissions?: FxExtension.PermissionBase[], options?: StringMap<any>, htmlTemplateInline?: FxExtension.HtmlTemplateDefinition) => FxExtension.PartDefinition;
    const createPartDefinition5: (viewModel?: string, partKind?: MsPortalFx.Parts.PartKind, canUseOldInputVersions?: boolean, inputs?: string[], bindings?: FxExtension.InputBinding[], htmlTemplate?: string, details?: FxExtension.DetailsDefinition[], initialSize?: MsPortalFx.Parts.PartSize, initialWidth?: number, initialHeight?: number, supportedSizes?: MsPortalFx.Parts.PartSize[], resizeMode?: MsPortalFx.Parts.ResizeMode, commandGroup?: string, commandGroupReference?: FxExtension.CommandGroupReference, editScopeType?: string, viewStateProperties?: string[], partState?: FxExtension.PartStateDefinition, assetType?: string, assetIdInputProperty?: string, permissions?: FxExtension.PermissionBase[], options?: StringMap<any>, htmlTemplateInline?: FxExtension.HtmlTemplateDefinition) => FxExtension.PartDefinition;
    const createPartReferenceDefinition: (partTypeName?: string, extension?: string, version?: string, bindings?: FxExtension.InputBinding[], initialSize?: MsPortalFx.Parts.PartSize, largeInitialSize?: MsPortalFx.Parts.PartSize, assetType?: string, extenderViewModel?: string) => FxExtension.PartReferenceDefinition;
    const createPartReferenceDefinition2: (partTypeName?: string, extension?: string, version?: string, bindings?: FxExtension.InputBinding[], initialSize?: MsPortalFx.Parts.PartSize, initialWidth?: number, initialHeight?: number, largeInitialSize?: MsPortalFx.Parts.PartSize, assetType?: string, extenderViewModel?: string) => FxExtension.PartReferenceDefinition;
    const createPartReferenceDefinition3: (partTypeName?: string, extension?: string, version?: string, bindings?: FxExtension.InputBinding[], initialSize?: MsPortalFx.Parts.PartSize, initialWidth?: number, initialHeight?: number, assetType?: string, extenderViewModel?: string) => FxExtension.PartReferenceDefinition;
    const createPartInstanceDefinition: (name: string, reference?: FxExtension.PartReferenceDefinition, inline?: FxExtension.PartDefinition, parameterProvider?: boolean, options?: StringMap<any>, redirectMode?: any) => FxExtension.PartInstanceDefinition;
    const createPartTypeDefinition4: (name: string, partGalleryInfo?: FxExtension.PartGalleryInfoDefinition, inputDefinitions?: FxExtension.InputDefinition[], reference?: FxExtension.PartReferenceDefinition, parameterProvider?: boolean, viewModel?: string, partKind?: MsPortalFx.Parts.PartKind, canUseOldInputVersions?: boolean, inputs?: string[], bindings?: FxExtension.InputBinding[], htmlTemplate?: string, details?: FxExtension.DetailsDefinition[], initialSize?: MsPortalFx.Parts.PartSize, initialWidth?: number, initialHeight?: number, largeInitialSize?: MsPortalFx.Parts.PartSize, supportedSizes?: MsPortalFx.Parts.PartSize[], resizeMode?: MsPortalFx.Parts.ResizeMode, commandGroup?: string, commandGroupReference?: FxExtension.CommandGroupReference, editScopeType?: string, viewStateProperties?: string[], partState?: FxExtension.PartStateDefinition, assetType?: string, assetIdInputProperty?: string, permissions?: FxExtension.PermissionBase[], options?: StringMap<any>, htmlTemplateInline?: FxExtension.HtmlTemplateDefinition) => FxExtension.PartTypeDefinition;
    const createPartTypeDefinition5: (name: string, inputDefinitions?: FxExtension.InputDefinition[], reference?: FxExtension.PartReferenceDefinition, parameterProvider?: boolean, viewModel?: string, partKind?: MsPortalFx.Parts.PartKind, canUseOldInputVersions?: boolean, inputs?: string[], bindings?: FxExtension.InputBinding[], htmlTemplate?: string, details?: FxExtension.DetailsDefinition[], initialSize?: MsPortalFx.Parts.PartSize, initialWidth?: number, initialHeight?: number, largeInitialSize?: MsPortalFx.Parts.PartSize, supportedSizes?: MsPortalFx.Parts.PartSize[], resizeMode?: MsPortalFx.Parts.ResizeMode, commandGroup?: string, commandGroupReference?: FxExtension.CommandGroupReference, editScopeType?: string, viewStateProperties?: string[], partState?: FxExtension.PartStateDefinition, assetType?: string, assetIdInputProperty?: string, permissions?: FxExtension.PermissionBase[], options?: StringMap<any>, htmlTemplateInline?: FxExtension.HtmlTemplateDefinition) => FxExtension.PartTypeDefinition;
    const createPartTypeDefinition6: (name: string, inputDefinitions?: FxExtension.InputDefinition[], reference?: FxExtension.PartReferenceDefinition, parameterProvider?: boolean, viewModel?: string, partKind?: MsPortalFx.Parts.PartKind, canUseOldInputVersions?: boolean, inputs?: string[], bindings?: FxExtension.InputBinding[], htmlTemplate?: string, details?: FxExtension.DetailsDefinition[], initialSize?: MsPortalFx.Parts.PartSize, initialWidth?: number, initialHeight?: number, supportedSizes?: MsPortalFx.Parts.PartSize[], resizeMode?: MsPortalFx.Parts.ResizeMode, commandGroup?: string, commandGroupReference?: FxExtension.CommandGroupReference, editScopeType?: string, viewStateProperties?: string[], partState?: FxExtension.PartStateDefinition, assetType?: string, assetIdInputProperty?: string, permissions?: FxExtension.PermissionBase[], options?: StringMap<any>, htmlTemplateInline?: FxExtension.HtmlTemplateDefinition) => FxExtension.PartTypeDefinition;
    const createDefinition: (partsCatalog?: FxExtension.PartTypeDefinition[], commandsCatalog?: FxExtension.CommandDefinition[], blades?: FxExtension.BladeDefinition[], startBoardParts?: FxExtension.PartInstanceDefinition[], commandGroups?: FxExtension.CommandGroupDefinition[], htmlTemplates?: StringMap<FxExtension.HtmlTemplateDefinition>, styleSheets?: string[], galleryService?: FxExtension.GalleryServiceDefinition, name?: string, version?: string, hash?: string, schemaVersion?: string, sdkVersion?: string, buildDescription?: string, isPreview?: boolean) => FxExtension.Definition;
    const createDefinition2: (partsCatalog?: FxExtension.PartTypeDefinition[], commandsCatalog?: FxExtension.CommandDefinition[], startBoardParts?: FxExtension.PartInstanceDefinition[], commandGroups?: FxExtension.CommandGroupDefinition[], htmlTemplates?: StringMap<FxExtension.HtmlTemplateDefinition>, styleSheets?: string[], galleryService?: FxExtension.GalleryServiceDefinition, name?: string, version?: string, hash?: string, schemaVersion?: string, sdkVersion?: string, buildDescription?: string, isPreview?: boolean) => FxExtension.Definition;
    const createDefinition3: (partsCatalog?: FxExtension.PartTypeDefinition[], commandsCatalog?: FxExtension.CommandDefinition[], startBoardParts?: FxExtension.PartInstanceDefinition[], commandGroups?: FxExtension.CommandGroupDefinition[], htmlTemplates?: StringMap<FxExtension.HtmlTemplateDefinition>, styleSheets?: string[], galleryService?: FxExtension.GalleryServiceDefinition, dashboardProvider?: FxExtension.DashboardProviderDefinition, name?: string, version?: string, hash?: string, schemaVersion?: string, sdkVersion?: string, buildDescription?: string, isPreview?: boolean) => FxExtension.Definition;
    const createDetailsDefinition: (blade?: string, bladeExtension?: string, isMultiple?: boolean, invocationInputArguments?: FxExtension.InputBinding[], selectablePath?: string, selectableBindings?: FxExtension.InputBinding[], additionalInputArguments?: FxExtension.InputBinding[], outputArguments?: FxExtension.InputBinding[], parameterCollector?: string, name?: string, asSubJourney?: boolean, pairInfo?: FxExtension.PairDetailsInfo, openInContextPane?: boolean, persistentContextPane?: boolean) => FxExtension.DetailsDefinition;
    const createInputBinding: (property?: string, valuesFrom?: FxExtension.Reference[], optional?: boolean, isIdentityInput?: boolean) => FxExtension.InputBinding;
    function createSvgImage(data?: string, isLogo?: boolean): MsPortalFx.Base.Image;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Internal\Internal.Widgets.d.ts
declare module FxImpl.Widgets {
    enum Orientation {
        /**
        * Indicates a layout that expands horizontally.
        */
        Horizontal = 0,
        /**
        * Indicates a layout that expands vertically.
        */
        Vertical = 1,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\MsPortalFxBegin.d.ts
declare var executeInDevelopmentModeOnly: Action1<Action>;
declare module FxImpl {
    /**
     * Deprecated. Use FxImpl namespace instead.
     */
    const Base: Obsolete;
}
declare module MsPortalFx {
    /**
     * Deprecated. Use FxImpl namespace instead.
     */
    const Internal: Obsolete;
    const isIFrame: boolean;
    /**
     * Gets the value of the specified feature.
     * NOTE: The feature must be specified without the <Extension>_ prefix.
     *
     * @param feature The name of the feature.
     * @returns The value of the feature.
     */
    function getFeatureValue(feature: string): string;
    /**
     * Gets a value indicating whether or not the specified feature is enabled.
     * NOTE: The feature must be specified without the <Extension>_ prefix.
     *
     * @param feature The name of the feature.
     * @returns True if the feature is enabled; else false.
     */
    function isFeatureEnabled(feature: string): boolean;
    /**
     * The original Object.defineProperty() method. This method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.
     * NOTE: 1. The Object.defineProperty() might be overridden to only defines non enumeration property. So, the MsPortalFx.defineProperty is the recommended way to define enumeration property.
     *       2. Set "MsPortalFx.defineProperty" to "MsPortalFx.defineProperty || Object.defineProperty" to avoid potential recursive loop.
     *
     * @param obj The object on which to define the property.
     * @param property name The property name.
     * @param descriptor The descriptor for the property.
     */
    var defineProperty: Action3<any, string, PropertyDescriptor>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\MsPortalFxEnd.d.ts
declare module MsPortalFx {
    module ViewModels.Controls.HotSpot {
        const ViewModel2: Obsolete;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Observables\AzureObservables.d.ts
declare module HubsExtension.Internal.Azure {
    import FxBase = MsPortalFx.Base;
    import FxPromiseV = FxBase.PromiseV;
    import Rpc = FxBase.Rpc.Internal;
    import ResourceBase = HubsExtension.Azure.ResourceBase;
    import ActionEndPointDefinition = Rpc.ActionEndPointDefinition;
    /**
     * Interface for the parameters used when calling the updateTenantInfoEndPoint.
     */
    interface UpdateTenantInfoParameters {
        tenantList: HubsExtension.Azure.Tenant[];
    }
    /**
     * Endpoint for the hubsextension to communicate tenant changes to the shell.
     */
    var updateTenantInfoEndPoint: ActionEndPointDefinition<UpdateTenantInfoParameters>;
    /**
     * Endpoint for the hubsextension to communicate subscription changes to the shell.
     */
    var updateSubscriptionInfoEndPoint: ActionEndPointDefinition<HubsExtension.Azure.SubscriptionList>;
    /**
     * Endpoint for the hubsextension to send resource provider information to the shell.
     */
    var getRegisteredResourceProviderInfoEndPoint: ActionEndPointDefinition<string[]>;
    /**
     * The interfaces of part gallery.
     */
    module PartGallery {
        /**
         * The subscription used resource groups in part gallery.
         */
        interface Subscription {
            /**
             * The id of the subscription.
             */
            id: string;
            /**
             * The display name of the subscription.
             */
            name: string;
            /**
             * Gets or sets if the subscription name is unique among the ones of the resource groups.
             */
            isNameUnique: boolean;
        }
        /**
         * The resource groups used by part gallery.
         */
        interface ResourceGroup {
            /**
             * The id of the resource group.
             */
            id: string;
            /**
             * The display name of the resource group.
             */
            name: string;
            /**
             * The subscription of the resource group.
             */
            subscription: Subscription;
        }
        /**
         * The resource information for the part gallery.
         */
        interface Resource {
            /**
             * The id of the resource.
             */
            id: string;
            /**
             * The name of the resource.
             */
            name: string;
            /**
             * The name of the cloud of the extension where the resource is.
             */
            cloudName: string;
            /**
             * The name of the extension where the resource is.
             */
            extensionName: string;
            /**
             * The type of the asset.
             */
            assetType: string;
            /**
             * The type of the resource.
             */
            type: string;
            /**
             * The display name of the asset type.
             */
            assetTypeDisplayName?: string;
        }
        /**
         * The tag used in part gallery.
         */
        interface Tag {
            /**
             * The key of the tag.
             */
            key: string;
            /**
             * The value of the tag.
             */
            value: string;
        }
        /**
         * The data provider for the part gallery.
         */
        interface DataProvider {
            /**
             * Loads the subscriptions.
             */
            loadSubscriptions(cloudName: string): FxPromiseV<MsPortalFx.Azure.Subscription[]>;
            /**
             * Loads the resource groups for the specified subscription up to a number of items specified.
             */
            loadResourceGroupsForSubId(cloudName: string, subscriptionId: string, numberOfItems: number): FxPromiseV<HubsExtension.Azure.ResourceGroupWithStrings[]>;
            /**
             * Loads the resource groups.
             */
            loadResourceGroups(cloudName: string): FxPromiseV<ResourceGroup[]>;
            /**
             * Loads the resources for the given resource type.
             */
            loadResourcesForType(resourceType: string, cloudName: string): FxPromiseV<Resource[]>;
            /**
             * Loads the resources for the given filter.
             */
            loadResourcesByFilter(filter: string, cloudName: string): FxPromiseV<Resource[]>;
            /**
             * Loads all the tags.
             */
            loadTags(cloudName: string): FxPromiseV<Tag[]>;
            /**
             * Loads all the resource ids for given tag.
             */
            loadResourceIdsForTag(key: string, value: string, cloudName: string): FxPromiseV<string[]>;
            /**
             * Loads the resources in the resource group for a given resource group id.
             */
            loadResourcesInResourceGroup(resourceGroupId: string, cloudName: string): FxPromiseV<Resource[]>;
            /**
             * Loads the related resource ids for a given resource (group) id.
             */
            loadRelatedResourceIds(resourceId: string, cloudName: string): FxPromiseV<string[]>;
            /**
             * Loads a resource group.
             */
            loadResourceGroup(subscriptionId: string, resourceGroupName: string, cloudName: string): FxPromiseV<ResourceBase>;
            /**
             * Creates a resource group.
             */
            createResourceGroup(subscriptionId: string, resourceGroupName: string, resourceGroupLocation: string, cloudName: string): FxPromiseV<ResourceBase>;
            /**
             * Gets locations available for dashboards.
             */
            getDashboardLocations(subscriptionId: string, cloudName: string): FxPromiseV<string[]>;
        }
    }
}
declare module HubsExtension.Azure {
    import FxBase = MsPortalFx.Base;
    import FxPromiseV = FxBase.PromiseV;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxImage = FxBase.Image;
    /**
     * Data contract for a list of Azure values.
     */
    interface CollectionResponse<T> {
        /**
         * The list of objects of type T.
         */
        value: T[];
    }
    /**
     * Data contract for a list of Azure values with a continuation token.
     */
    interface ContinuationCollectionResponse<T> {
        /**
         * The list of objects of type T.
         */
        value: T[];
        /**
         * The optional continuation token.
         */
        token?: string;
    }
    /**
     * Data contract for a single Azure subscription.
     */
    interface SubscriptionContract {
        /**
         * Friendly name of the azure subscription.
         */
        subscriptionName: string;
        /**
         * Id of the azure subscription.
         */
        subscriptionID: string;
        /**
         * Id of the Active Directory tenant containg this subscription.
         */
        tenantID: string;
        /**
         * The subscription status.
         */
        status: string;
        /**
         * The subscription policies. May be null.
         */
        subscriptionPolicies: SubscriptionPolicies;
        /**
         * The subscriptions requires rdfe.
         */
        requireRdfe: boolean;
        /**
         * The users authorization type for the subscriptions. Values are "Legacy", "RoleBased", "Legacy, RoleBased".
         */
        authorizationSource: string;
    }
    /**
     * Data contract for a single Azure subscription.
     */
    class Subscription implements SubscriptionContract {
        /**
         * Friendly name of the azure subscription.
         */
        subscriptionName: string;
        /**
         * Id of the azure subscription.
         */
        subscriptionID: string;
        /**
         * Id of the Active Directory tenant containg this subscription.
         */
        tenantID: string;
        /**
         * The subscription status.
         */
        status: string;
        /**
         * The subscription policies.
         */
        subscriptionPolicies: SubscriptionPolicies;
        /**
         * The subscriptions requires rdfe.
         */
        requireRdfe: boolean;
        /**
         * The users authorization type for the subscriptions. Values are "Legacy", "RoleBased", "Legacy, RoleBased".
         */
        authorizationSource: string;
    }
    /**
     * Data contract for Azure subscription policies.
     */
    class SubscriptionPolicies {
        /**
         * The subscription location placement id.
         */
        locationPlacementId: string;
        /**
         * The subscription quota id.
         */
        quotaId: string;
    }
    /**
     * Data contract for a list of Azure subscriptions.
     */
    class SubscriptionList {
        /**
         * The list of sucscriptions.
         */
        subscriptions: Subscription[];
    }
    /**
     * Data model for tenant info.
     */
    class TenantInfo {
        /**
         * List of all tenants for the user.
         */
        tenants: Tenant[];
    }
    /**
     * Data model for a tenant.
     */
    class Tenant {
        /**
         * Tenant id.
         */
        id: string;
        /**
         * The tenant domain name.
         */
        domainName: string;
        /**
         * The tenant display name.
         */
        displayName: string;
        /**
         * True if signed in tenant.
         */
        isSignedInTenant: boolean;
    }
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBase {
        /**
         * The resource entity id of the resource entity.
         */
        id: string;
        /**
         * The name of the resource entity.
         */
        name: string;
        /**
         * The location of the resource entity.
         */
        location: string;
        /**
         * The tags of the resource entity.
         */
        tags: StringMap<string>;
        /**
         * The properties of the resource entity.
         */
        properties: StringMap<any>;
    }
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBaseObservable {
        /**
         * The resource entity id of the resource entity.
         */
        id: KnockoutObservableBase<string>;
        /**
         * The name of the resource entity.
         */
        name: KnockoutObservableBase<string>;
        /**
         * The location of the resource entity.
         */
        location: KnockoutObservableBase<string>;
        /**
         * The tags of the resource entity.
         */
        tags: KnockoutObservableBase<StringMap<string>>;
        /**
         * The properties of the resource entity.
         */
        properties: KnockoutObservableBase<StringMap<any>>;
    }
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBaseWithStrings extends ResourceBase {
        /**
         * The location string for the resource group's location.
         */
        locationString: string;
    }
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBaseObservableWithStrings extends ResourceBaseObservable {
        /**
         * The location string for the resource group's location.
         */
        locationString: KnockoutObservableBase<string>;
    }
    /**
     * The locked states enumeration provides named constants for the resource group.
     */
    const enum ResourceLockState {
        /**
         * Locked resource group.
         */
        Locked = 0,
        /**
         * Unlocked resource group.
         */
        Unlocked = 1,
    }
    /**
     * Data model for a single resource group.
     */
    interface ResourceGroup extends ResourceBase {
        /**
         * The lock state of the resource group.
         */
        lockState: ResourceLockState;
        /**
         * The provisioning state of the resource group.
         */
        provisioningState: string;
    }
    /**
     * Data model for a single resource group with the display strings.
     */
    interface ResourceGroupWithStrings extends ResourceGroup, ResourceBaseWithStrings {
    }
    /**
     * Data model for a single resource group.
     */
    interface ResourceGroupObservable extends ResourceBaseObservable {
        /**
         * The lock state of the resource group.
         */
        lockState: KnockoutObservableBase<ResourceLockState>;
        /**
         * The provisioning state of the resource group.
         */
        provisioningState: KnockoutObservableBase<string>;
    }
    /**
     * Data model for a single resource group with the display strings.
     */
    interface ResourceGroupObservableWithStrings extends ResourceGroupObservable, ResourceBaseObservableWithStrings {
    }
    /**
     * Data contract for a list of Azure resource groups.
     */
    interface ResourceGroupList {
        /**
         * The list of resource groups.
         */
        resourceGroups: ResourceGroup[];
    }
    /**
     * Data model for a single resource.
     */
    interface Resource extends ResourceBase {
        /**
         * The resource group ID of the resource.
         */
        resourceGroup: string;
        /**
         * The type of the resource.
         */
        type: string;
        /**
         * The resource type kind of the resource.
         */
        kind?: string;
        /**
         * The self link URI of the resource.
         */
        selfLinkUri: string;
    }
    /**
     * Data model for a single resource.
     */
    interface ResourceObservable extends ResourceBaseObservable {
        /**
         * The resource group ID of the resource.
         */
        resourceGroup: KnockoutObservableBase<string>;
        /**
         * The type of the resource.
         */
        type: KnockoutObservableBase<string>;
        /**
         * The resource type kind of the resource.
         */
        kind?: KnockoutObservableBase<string>;
        /**
         * The self link URI of the resource.
         */
        selfLinkUri: KnockoutObservableBase<string>;
    }
    /**
     * Data model for a single resource with the display strings.
     */
    interface ResourceWithStrings extends Resource, ResourceBaseWithStrings {
        /**
         * The resource name without the parent resource if it's a nested resource.
         */
        trimmedName: string;
    }
    /**
     * Data model for a single resource with the display strings.
     */
    interface ResourceObservableWithStrings extends ResourceObservable, ResourceBaseObservableWithStrings {
        /**
         * The resource name without the parent resource if it's a nested resource.
         */
        trimmedName: KnockoutObservableBase<string>;
    }
    /**
     * Data contract for a list of Azure resources.
     */
    interface ResourceList {
        /**
         * The list of resources.
         */
        resources: Resource[];
    }
    /**
     * The data model used by the region picker.
     */
    class RegionPickerDataModel {
        /**
         * The default parameter set.
         */
        regionPicker: {
            regionId: KnockoutObservable<string>;
        };
    }
    /**
     * The data model used by the subscription picker.
     */
    class SubscriptionPickerDataModel {
        /**
         * The default parameter set.
         */
        subscriptionPicker: {
            subscriptionId: KnockoutObservable<string>;
            subscriptionName: KnockoutObservable<string>;
        };
    }
    /**
     * The data model used by the create new resource group.
     */
    class ResourceGroupDataModel {
        /**
         * The default parameter set.
         */
        resourceGroup: {
            resourceGroupName: KnockoutObservable<string>;
            subscriptionId: KnockoutObservable<string>;
        };
    }
    /**
     * The data model used by the resource group picker.
     */
    class ResourceGroupPickerDataModel {
        /**
         * The default parameter set.
         */
        resourceGroupPicker: {
            resourceGroupName: KnockoutObservable<string>;
            resourceGroupLocation: KnockoutObservable<string>;
            subscriptionId: KnockoutObservable<string>;
            isNewResourceGroup: KnockoutObservable<string>;
        };
    }
    module SpecPicker {
        import Forms = FxViewModels.Forms;
        import SpecPicker = HubsExtension.Azure.SpecPicker;
        const enum OriginControl {
            Unknown = 0,
            DropDown = 1,
            Selector = 2,
            InfoBox = 3,
        }
        type ColorScheme = "" | "mediumBlue" | "darkOrchid" | "yellowGreen" | "orange";
        /**
         * Data contract for a spec.
         */
        interface Spec {
            /**
             * The id.
             */
            id: string;
            /**
             * The spec code.
             */
            specCode: string;
            /**
             * The color scheme.
             */
            colorScheme: ColorScheme;
            /**
             * The title.
             */
            title: string;
            /**
             * The sub title.
             * This value will be displayed if there is not enough space for title in some container. e.g spec title in recommendation blade
             */
            shortTitle?: string;
            /**
             * The features.
             */
            features: Array<SpecPicker.Feature>;
            /**
             * The promoted features.
             */
            promotedFeatures: Array<SpecPicker.PromotedFeature>;
            /**
             * The spec cost.
             */
            cost: SpecPicker.SpecCost;
        }
        /**
         * Data contract for a Feature.
         */
        interface Feature {
            /**
             * The id.
             */
            id: string;
            /**
             * The display name.
             */
            displayName?: string;
            /**
             * The display value.
             */
            displayValue?: string;
            /**
             * The icon name.
             */
            iconName?: string;
            /**
             * The icon Svg Data.
             */
            iconSvgData?: string;
            /**
             * The icon image.
             */
            iconImage?: FxImage;
        }
        /**
         * Data contract for a Promoted Feature.
         */
        interface PromotedFeature {
            /**
             * The id.
             *
             * It can be set to lookup the promoted feature in partner extensions.
             * This id is optional. Since it isn't required by spec picker control.
             */
            id?: string;
            /**
             * The value.
             */
            value: string;
            /**
             * The unit description.
             */
            unitDescription: string;
        }
        /**
         * Data contract for a spec data.
         */
        interface SpecData {
            /**
             * The features.
             */
            features: SpecPicker.Feature[];
            /**
             * The specs.
             */
            specs: Array<SpecPicker.Spec>;
            /**
             * The resource map used for spec cost computation.
             * It's a mapping from regionId to array of resource quota set.
             */
            resourceMap?: StringMap<Pricing.SpecResourceSet[]>;
            /**
             * The list spec ids to allow zero cost.
             * This is a pre-defined list of specs that are allowed zero cost, to avoid displaying misleading billing information in UI. Make it required is to
             * enforce awareness of this parameter.
             *
             * 1) Sometimes a zero cost is computed by the billing backend for various reasons, either legitimate or not, for any spec card.
             * 2) There is a very strong design requirement that the spec picker should never show a zero unexpected.
             */
            specsToAllowZeroCost: string[];
            /**
             * The spec type. e.g. "Website", "VirtualMachine"
             * this value will be log to telemetry log
             */
            specType: string;
            /**
             * The message will be displayed on the top of specPickerPart.
             */
            message?: string;
            /**
             * The message will be displayed on top of specPickerPart for Direct EA user.
             * If this message is not set, the default message is "Prices presented below are estimated retail prices and do not reflect applicable discounts
             * for your subscription. If you have purchased Azure services through a reseller, contact your reseller for applicable pricing."
             */
            messageForEA?: string;
            /**
             * The message will be displayed on top of specPickerPart for Indirect EA user.
             * If this message is not set, no message will be shown by default on top of specPickerPart.
             */
            messageForIndirectEA?: string;
            /**
             * The message will be displayed on the top of specPickerPart for Reseller user.
             * If this message is not set, no message will be shown by default on top of specPickerPart.
             */
            messageForReseller?: string;
        }
        /**
         * Data contract for spec picker blade parameter.
         * This contract defined all required properties to open spec picker blade.
         */
        interface SpecPickerBladeParameter {
            /**
             * The blade to open.
             */
            detailBlade: string;
            /**
             * The extension to open.
             */
            extension: string;
            /**
             * The selected spec id.
             * This parameter will be set to ProviderInputs.inputParameters.
             */
            selectedSpecId?: string;
            /**
             * The selected specs ids.
             * This parameter will be set to ProviderInputs.inputParameters.
             */
            selectedSpecIds?: string[];
            /**
             * If this property is set to true, it will show the recommended view by default.
             * If don't set this property, the default view is "View All spec"
             */
            selectRecommendedView?: boolean;
            /**
             * The subscription id.
             * This parameter will be set to ProviderInputs.options.
             */
            subscriptionId: string;
            /**
             * The region id.
             * This parameter will be set to ProviderInputs.options.
             */
            regionId: string;
            /**
             * The disabled specs. Will be used by spec picker part.
             * This parameter will be set to ProviderInputs.options.
             * If you don't provide a value, spec picker will try to get "disabledSpecs" from extender view model.
             * If you don't provide a value and there is no "disabledSpecs" in extender view model, spec picker won't show disabled spec.
             */
            disabledSpecs?: DisabledSpec[];
            /**
             * The recommended spec ids.
             * This parameter will be set to ProviderInputs.options.
             * If you don't provide a value, spec picker will try to get "recommendedSpecIds" from extender view model.
             * If you don't provide a value and there is no "recommendedSpecIds" in extender view model, spec picker won't show recommended specs.
             */
            recommendedSpecIds?: string[];
            /**
             * The recent spec ids. (future api)
             * This parameter will be set to ProviderInputs.options.
             * If you don't provide a value, spec picker will try to get "recentSpecIds" from extender view model.
             * If you don't provide a value and there is no "recentSpecIds" in extender view model, spec picker won't show recent specs.
             * Currently not used for the spec picker, but used for the dropdown
             */
            recentSpecIds?: string[];
            /**
             * The options.
             * This parameter will be merge to ProviderInputs.options and this value will be passed to extender.
             */
            options?: any;
        }
        /**
         * Data contract for disabled spec.
         */
        interface DisabledSpec {
            /**
             * The disabled spec id.
             */
            specId: string;
            /**
             * The disabled message.
             * If you don't provide a value, the default message is "Not available".
             */
            message?: string;
            /**
             * The help balloon message.
             * If you don't provide a value, the help balloon won't display.
             */
            helpBalloonMessage?: string;
            /**
             * The help balloon link text.
             */
            helpBalloonLinkText?: string;
            /**
             * The help balloon link URI.
             */
            helpBalloonLinkUri?: string;
        }
        /**
         * Data contract for pricing tier display.
         */
        interface PricingTierDisplay extends PricingTierSpecDisplay {
            /**
             * The asset name.
             */
            assetName: string;
            /**
             * The part title.
             * If you don't provide a value, the default value is "Pricing tier".
             */
            partTitle?: string;
            /**
             * The feature icons.
             */
            featureIcons?: KnockoutObservableBase<any[]>;
            /**
             * The multi specs display object
             */
            specs?: KnockoutObservableBase<PricingTierSpecsDisplay[]>;
        }
        interface PricingTierSpecDisplay {
            /**
             * The spec code.
             * If you don't provide a value, the default value will get from spec card.
             */
            specCode?: string;
            /**
             * The first number.
             */
            firstNumber?: KnockoutObservableBase<any>;
            /**
             * The first text.
             */
            firstText?: KnockoutObservableBase<string>;
            /**
             * The second number.
             */
            secondNumber?: KnockoutObservableBase<any>;
            /**
             * The second text.
             */
            secondText?: KnockoutObservableBase<string>;
        }
        interface PricingTierSpecsDisplay extends PricingTierSpecDisplay {
            /**
             * The corresponding spec id
             * Must be provided to corrolate spec display info
             */
            specId: string;
        }
        /**
         * Data contract for pricing tier launcher extender input.
         */
        interface PricingTierLauncherExtenderInput {
            /**
             * The entity id.
             */
            entityId?: any;
        }
        /**
         * Data contract for pricing tier launcher spec data.
         */
        interface PricingTierLauncherSpecData {
            /**
             * The features.
             */
            features: SpecPicker.Feature[];
            /**
             * The spec.
             */
            spec?: SpecPicker.Spec;
            /**
             * The specs.
             */
            specs?: SpecPicker.Spec[];
        }
        /**
         * Data contract for pricing tier launcher extender output.
         */
        interface PricingTierLauncherExtenderOutput {
            /**
             * The pricing tier display data
             */
            pricingTierDisplay: PricingTierDisplay;
            /**
             * The spec picker blade parameter.
             */
            specPickerBladeParameter: SpecPickerBladeParameter;
            /**
             * The spec data.
             */
            specData: SpecPicker.PricingTierLauncherSpecData;
            /**
            * The error message displayed by the Part when it has failed.
            */
            failureMessage?: string;
        }
        /**
         * Data contract or a pricing tier launcher extender.
         */
        interface PricingTierLauncherExtender {
            /**
             * The input from part view model to extender.
             */
            input: KnockoutObservableBase<PricingTierLauncherExtenderInput>;
            /**
             * The output from extender to part view model.
             */
            output: KnockoutObservableBase<PricingTierLauncherExtenderOutput>;
            /**
             * Save selected spec async.
             *
             * @param selected spec id.
             * @return A promise representing the completion of the operation.
             */
            saveSelectedSpecAsync?(selectedSpecId: string): FxBase.Promise;
            /**
             * Save selected specs async.
             *
             * @param selected specs ids.
             * @return A promise representing the completion of the operation.
             */
            saveSelectedSpecsAsync?(selectedSpecsIds: string[]): FxBase.Promise;
            /**
             * Checks to see if the current user has read permission to access pricing tier launcher part.
             *
             * @param entityId The entity to check for permissions. It will be null during creation.
             * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
             */
            hasReadPermision?(entityId: any): FxPromiseV<boolean>;
        }
        /**
         * Data contract for spec picker extender input.
         */
        interface SpecPickerExtenderInput {
            /**
             * The selected spec id.
             */
            selectedSpecId?: string;
            /**
             * The selected spec id.
             */
            selectedSpecIds?: string[];
            /**
             * The options.
             * This value will be passed from collector to provider part. And passed from provider part to extender.
             */
            options: any;
            /**
             * The specs made available to the spec picker extender
             */
            availableSpecData: KnockoutObservableBase<Spec[]>;
        }
        /**
         * Data contract for pricing tier launcher extender output.
         */
        interface SpecPickerExtenderOutput {
            /**
             * The spec data.
             */
            specData?: SpecPicker.SpecData;
            /**
             * The disabled specs.
             * If you don't provide a value, spec picker will try to get "disabledSpecs" from provider parameter.
             */
            disabledSpecs?: DisabledSpec[];
            /**
             * The recommended spec ids.
             */
            recommendedSpecIds?: string[];
            /**
             * The recent spec ids.
             */
            recentSpecIds?: string[];
            /**
            * The error message displayed by the Part when it has failed.
            */
            failureMessage?: string;
            /**
             * The specs passed through a filter
             */
            filteredSpecIds?: KnockoutComputed<string[]>;
        }
        /**
         * Data contract for spec picker extender.
         */
        interface SpecPickerExtender {
            /**
             * The input from part view model to extender.
             */
            input: KnockoutObservableBase<SpecPickerExtenderInput>;
            /**
             * The output from extender to part view model.
             */
            output: KnockoutObservableBase<SpecPickerExtenderOutput>;
            /**
             * Checks to see if the current user has permissions to access pricing tier launcher part.
             *
             * @param entityId The entity to check for permissions. It will be null during creation.
             * @param options The options from provider.
             * @return A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
             */
            hasEditPermision?(entityId: any, options: any): FxPromiseV<boolean>;
            /**
             * The controls to be placed on the filter form
             */
            filterControls?: KnockoutObservableArray<FilterControl>;
            /**
             * The selection mode for the specPicker
             */
            selectionMode?: FxViewModels.Controls.Lists.ListView.SelectionMode;
            /**
             * The message shown when there are no specs.
             */
            noSpecsMsg?: KnockoutObservableBase<string>;
        }
        type FilterControl = Forms.Base.Slider.ViewModel<any> | Forms.TextBox.ViewModel | Forms.TokenComboBox.ViewModel<any> | FxViewModels.Controls.SearchBox.ViewModel | Forms.NumericTextBox.ViewModel | Forms.CheckBox.ViewModel | Forms.Base.EditableComboBox.ViewModel<any> | Forms.MultiSelectDropDown.ViewModel<any> | Forms.DropDown.ViewModel<any>;
        /**
         * Data contract for spec picker launcher part view model.
         */
        interface SpecPickerLauncherPartViewModel {
            /**
             * Get provider input.
             *
             * @param providerId The provider id.
             * @return A spec picker blade parameter.
             */
            getProviderInput(providerId: string): SpecPickerBladeParameter;
            /**
             * Update selected spec async.
             *
             * @param selectedSpecId The selected spec id.
             * @param selectedRecommendedView Shows if the recommended view was selected or not.
             * @return A promise representing the update selected spec request which will complete asynchronously.
             */
            updateSelectedSpecAsync?(selectedSpecId: string, selectedRecommendedView?: boolean): FxBase.Promise;
            /**
             * Update selected spec async.
             *
             * @param selectedSpecIds The selected specs ids.
             * @param selectedRecommendedView Shows if the recommended view was selected or not.
             * @return A promise representing the update selected spec request which will complete asynchronously.
             */
            updateSelectedSpecsAsync?(selectedSpecIds: string[], selectedRecommendedView?: boolean): FxBase.Promise;
        }
        /**
         * Data contract for a spec cost.
         * This cost is hard coded in spec data. Doesn't return from Billing API
         */
        interface SpecCost {
            /**
             * The amount.
             */
            amount?: number;
            /**
             * The currency code.
             */
            currencyCode?: string;
            /**
             * The caption.
             */
            caption: string;
            /**
             * The decimal precision of the price. Defaults to 2.
             */
            decimalPrecision?: number;
        }
        /**
         * Spec picker V3 data used in ParameterCollection flow
         */
        module ParameterCollectionV3 {
            /**
             * Spec picker V3 data sent from Collector to Provider and back from Provider to Collector.
             */
            interface SpecPickerProviderCollectorParameter {
                fromProviderToCollector: SpecPickerProviderCollectorParameterFromProvider;
                fromCollectorToProvider: SpecPickerProviderCollectorParameterFromCollector;
            }
            interface SpecPickerProviderCollectorParameterFromProvider {
                /**
                 * The selected spec id.
                 */
                selectedSpecId?: string;
                /**
                * The selected specs ids.
                */
                selectedSpecIds?: string[];
                /**
                 * Check if the recommended view should be shown by default.
                 */
                selectedRecommendedView: boolean;
            }
            interface SpecPickerProviderCollectorParameterFromCollector {
                /**
                 * The entity id.
                 */
                entityId: any;
                /**
                * The selected spec id.
                */
                selectedSpecId?: string;
                /**
                * The selected specs ids.
                */
                selectedSpecIds?: string[];
                /**
                 * The subscription id.
                 */
                subscriptionId: string;
                /**
                 * The region id.
                 */
                regionId: string;
                disabledSpecs: SpecPicker.DisabledSpec[];
                recommendedSpecIds: string[];
                recentSpecIds?: string[];
                selectRecommendedView: boolean;
                options: StringMapPrimitive;
                /**
                 * A telemetry flag to determine which control or part was responsible for launching the spec picker.
                 */
                originControl?: SpecPicker.OriginControl;
            }
        }
    }
    module Lock {
        /**
         * The data contract for all information needed to check a lock on a resource
         */
        interface LockCheck {
            /**
             * The resource id to check
             */
            resourceId: string;
            /**
             * The level of the lock
             */
            lockLevel: LockType;
            /**
             * The cloud for this to be checked against
             */
            cloudName?: string;
        }
        type LockType = "ReadOnly" | "CanNotDelete" | "";
    }
    module Pricing {
        import ResourceManager = MsPortalFx.Azure.ResourceManager;
        /**
         * Data contract for spec cost query input.
         */
        interface SpecCostQueryInput {
            /**
             * The subscription Id.
             */
            subscriptionId: string;
            /**
             * The list of spec resource sets.
             */
            specResourceSets: SpecResourceSet[];
            /**
             * The list spec ids to allow zero cost.
             * This is a pre-defined list of specs that are allowed zero cost, to avoid displaying misleading billing information in UI. Make it required is to
             * enforce awareness of this parameter.
             *
             * 1) Sometimes a zero cost is computed by the billing backend for various reasons, either legitimate or not, for any spec card.
             * 2) There is a very strong design requirement that the spec picker should never show a zero unexpected.
             */
            specsToAllowZeroCost: string[];
            /**
             * The spec type. e.g. "Website", "VirtualMachine"
             */
            specType?: string;
        }
        /**
         * Data contract for a first party resource quota.
         */
        interface FirstPartyResource {
            /**
             * The round-tripped Id.
             */
            id?: string;
            /**
             * The MINT Resource Id (referred to as Resource GUID in some documentation).
             */
            resourceId: string;
            /**
             * The quantity of the resource.
             */
            quantity: number;
        }
        /**
         * Data contract for a resource quota set.
         */
        interface SpecResourceSet {
            /**
             * The spec id.
             */
            id: string;
            /**
             * This property is obsolete. Please use firstParty.
             */
            quotas?: FirstPartyResource[];
            /**
             * The first party quotas.
             */
            firstParty?: FirstPartyResource[];
            /**
             * The third party quotas.
             */
            thirdParty?: ThirdPartyResource[];
        }
        /**
         * Data contract for a third party resource.
         */
        interface ThirdPartyResource {
            /**
             * The round-tripped Id.
             */
            id?: string;
            /**
             * The resource publisher Id.
             */
            publisherId: string;
            /**
             * The resource offer Id.
             */
            offerId: string;
            /**
             * The resource plan Id.
             */
            planId: string;
            /**
             * The promotion code.
             */
            promotionCode: string;
            /**
             * The third party meters.
             */
            meters: ThirdPartyMeter[];
        }
        /**
         * Data contract for a third party meter.
         */
        interface ThirdPartyMeter {
            /**
             * The meter ID
             */
            meterId: string;
            /**
             * The meter quantity
             */
            quantity: number;
        }
        /**
         * Data contract for a third party resource and the quantity of that resource
         */
        interface CostEstimate {
            /**
             * The round-tripped Id
             */
            id: string;
            /**
             * The total monetarty amount for this estimate
             * FirstParty + ThirdParty, but single currency
             */
            amount: number;
            /**
             * The billing currency code (e.g. USD)
             */
            currencyCode: string;
            /**
             * The status code for the individual spec cost
             */
            statusCode: SpecCostQueryResultSpecStatusCode;
            /**
             * The cost the first party resources
             */
            firstParty: CostEstimateResource[];
            /**
             * The cost the third party resources
             */
            thirdParty: CostEstimateResource[];
        }
        /**
         * Data contract for a cost estimate resource.
         */
        interface CostEstimateResource {
            /**
             * The round-tripped Id
             */
            id: string;
            /**
             * The line level cost breakdown for the resource.
             **/
            meters: CostEstimateMeter[];
            /**
             * Additional info about the third party plan / SKU. Null for 1st party resources and comes from the Ratings API
             * for 3rd party resources. Marked optional to avoid breaking older unit tests.
             */
            features?: ProductFeatures;
            /**
             * The per-term cost of purchasing this resource. Null for 1st party resources, and comes from the Ratings API
             * for 3rd party resources. Marked optional to avoid breaking older unit tests.
             */
            costPerTerm?: number;
            /**
             * A string indicating the length of the subscription period for this 3rd party resource.
             * An empty string for 1st party resources, and comes from the Ratings API for 3rd party resources.
             * This value is not localized (it is set from a list of constant values hard coded in the data-market feed).
             * Marked optional to avoid breaking older unit tests.
             */
            term?: string;
        }
        /**
         * Describes whether the third party product has a free trial or is a bring-your-own-license offer.
         */
        interface ProductFeatures {
            /**
             * Indicates whether a 3rd party plan/SKU includes a free trial period.
             */
            hasFreeTrial: boolean;
            /**
             * Indicates whether a third party plan / SKU requires the user to buy a license externally.
             */
            bringYourOwnLicense: boolean;
        }
        /**
         * Data contract for a cost estimate meter.
         */
        interface CostEstimateMeter {
            /**
             * The round-tripped Id
             */
            id: string;
            /**
             * The monetary amount for this estimate
             * This is in the billing currency code, which is specified in the parent object.
             */
            amount: number;
            /**
             * The monetary amount per unit
             * This value is prorated for 1st party resources, and comes from the Ratings API for 3rd party resources
             */
            perUnitAmount: number;
            /**
             * The Per Unit currency code (e.g. USD)
             * This is the same as the billing currency code for 1st party resources, and comes from the Ratings API for 3rd party resources
             */
            perUnitCurrencyCode: string;
            /**
             * The localized unit. It's empty string for 1st party resources, and comes from the Ratings API for 3rd party resources.
             */
            unit: string;
            /**
             * The name of the meter. Empty string for 1st party resources, and comes from the Ratings API for 3rd party resources.
             * Marked optional to avoid breaking older unit tests.
             */
            name?: string;
            /**
             * Price rules describing the progressive pricing scheme for this meter. Meters which have one flat rate will have a single rule
             * with no upper/lower bound. Marked optional to avoid breaking older unit tests.
             */
            priceRules?: PriceRule[];
        }
        /**
         * An interval in a progressing pricing scheme.
         */
        interface PriceRule {
            /**
             * The lower bound for this interval. If this value is null, then there is no lower bound.
             */
            from: number;
            /**
             * The upper bound for this interval. If this value is null, then there is no upper bound.
             */
            to: number;
            /**
             * The cost for each unit of usage between from and to.
             * This is expressed in the PerUnitCurrencyCode currency code given by the parent CostEstimateMeter.
             */
            amount: number;
        }
        /**
         * Data contract for the spec cost query result.
         */
        interface SpecCostQueryResult {
            /**
             * Gets or sets a flag that indicates whether the costs were successfully returned.
             * Otherwise, a failure statusCode is returned.
             */
            isSuccess: boolean;
            /**
             * DEPRECATED: For backwards compatibility, this will be set to true for chanel === DirectEA and false for all other channels.
             * Please use "channel" property instead of this.
             *
             * Gets or sets a flag that indicates whether the cost is of enterprise agreement type.
             */
            isEASubscription: boolean;
            /**
             * Gets or sets the channel.
             */
            channel: string;
            /**
             * Gets or sets the list of the list of cost estimates.
             */
            costs: CostEstimate[];
            /**
             * Gets or sets the status code.
             */
            statusCode: Pricing.SpecCostQueryResultStatusCode;
            /**
             * Gets or sets the SpecCostQueryResult version.
             */
            version: string;
        }
        /**
         * Constants for gallery pricing.
         */
        module Constants {
            /**
             * Constants for the gallery pricing summary blade.
             */
            var PricingSummaryBlade: {
                displayText: string;
                bladeName: string;
                bladeExtension: string;
            };
            /**
             * Constants for the gallery legal terms blade.
             */
            var LegalTermsBlade: {
                bladeName: string;
                bladeExtension: string;
            };
            /**
             * Constants for the channel type.
             */
            var ChannelType: {
                directEA: string;
                indirectEA: string;
                direct: string;
                csp: string;
            };
        }
        /**
         * Gallery create pricing information model.
         */
        interface PricingInfo {
            /**
             * The subscription id.
             */
            subscriptionId: string;
            /**
             * The pricing tier selections made by the user.
             */
            pricingTierSelections: PricingTierSelection[];
            /**
             * The usage-based resources selected by the user.
             */
            usageBasedResources: UsageBasedResource[];
            /**
             * Gallery item products with pricing information.
             */
            products?: ResourceManager.GalleryItemProduct[];
            /**
             * Gallery item products with no pricing information.
             */
            productsWithNoPricing?: ResourceManager.GalleryItemProduct[];
            /**
             * Optional. Shows the "Pin to Startboard" checkbox on the legal terms blade.
             */
            showPinToStartboardCheckbox?: boolean;
        }
        /**
         * Pricing tier selection model.
         */
        interface PricingTierSelection {
            /**
             * The pricing tier id.
             */
            pricingTierId: string;
            /**
             * The pricing tier display name.
             */
            pricingTierDisplayName: string;
            /**
             * The number of instances.
             */
            instanceCount: number;
            /**
             * The calculated unit display name.
             */
            unitDisplayName: string;
            /**
             * The spec resource set.
             */
            specResourceSet: SpecResourceSet;
            /**
             * The specs allowed to have zero as a possible cost amount.
             */
            specsToAllowZeroCost: string[];
        }
        /**
         * Usage-based resource model.
         */
        interface UsageBasedResource {
            /**
             * The resource display name.
             */
            resourceDisplayName: string;
            /**
             * The resource type display name.
             */
            resourceTypeDisplayName: string;
            /**
             * The number of instances.
             */
            instanceCount: number;
        }
        /**
         * Status code for the GetSpecsCosts result
         * The corresponding C# enum is CostEstimateOverallStatusCode
         */
        const enum SpecCostQueryResultStatusCode {
            /**
             * Costing data was successfully returned.
             */
            Success = 0,
            /**
             * Costing data is not available.
             */
            CostDataNotAvailable = 1,
            /**
             * Batch mode request error-ed for some items.
             */
            Partial = 2,
            /**
             * Batch mode request error-ed for all items.
             */
            BatchFailed = 3,
            /**
             * Auth failure.
             */
            AuthFailure = 4,
            /**
             * An unexpected exception was thrown by the subscription provider component. Check logs for details.
             */
            SubscriptionException = 5,
            /**
             * User&apos; subscription was not found.
             */
            SubscriptionNotFound = 6,
            /**
             * User&apos; subscription is not active.
             */
            SubscriptionNotActive = 7,
            /**
             * Subscription data is invalid.
             */
            SubscriptionIsInvalid = 8,
            /**
             * Not supported in billing region.
             */
            NotSupportedInBillingRegion = 9,
            /**
             * Pricing is not available for this subscription.
             */
            SubscriptionPricingUnavailable = 10,
            /**
             * Pricing is available as retail when EA is requested
             */
            SuccessAsRetailForEa = 12,
            /**
             * Spec is not supported in the current environment, e.g. Mooncake, Blackforest
             */
            NotSupportedInCurrentEnvironment = 13,
        }
        /**
         * Status code for the GetSpecsCosts result
         * The corresponding C# enum is CostEstimateOverallStatusCode
         */
        const enum SpecCostQueryResultSpecStatusCode {
            /**
             * Costing data was successfully returned.
             */
            Success = 0,
            /**
             * Error retrieving price
             */
            PricingException = 1,
            /**
             * Spec not supported in region
             */
            NotSupportedInBillingRegion = 2,
            /**
             * Spec not available for subscription
             */
            NotAvailableForSubscription = 3,
            /**
             * Spec returns for retail but not ea
             */
            SuccessAsRetailForEa = 4,
            /**
             * Meter doesn't exist, do not display
             */
            MeterNotFound = 5,
        }
    }
    /**
     * The resource type cache type.
     */
    type ResourceTypeCache = StringMap<ResourceTypeMetadata>;
    /**
     * The resource type kind cache type.
     */
    type ResourceTypeKindCache = StringMap<ResourceTypeKindMetadata>;
    /**
     * The resource type metadata from the server.
     */
    interface ResourceTypeMetadata {
        /**
         * The name of the resource type.
         */
        resourceType: string;
        /**
         * The icon override for the type.
         */
        icon: string;
        /**
         * The dictionary of resource type kind metadata.
         */
        kinds: ResourceTypeKindCache;
        /**
         * The dynamic kinds endpoint format.
         */
        dynamicKindsEndpoint: string;
        /**
         * The list of capabilities supported by the type.
         * Note: This is a comma separated list of capabilities
         * Example: "CrossResourceGroupResourceMove, CrossSubscriptionResourceMove"
         */
        capabilities: string;
    }
    /**
     * The resource type kind metadata from the server.
     */
    interface ResourceTypeKindMetadata {
        /**
         * The name of the kind.
         */
        kind: string;
        /**
         * The icon override for the kind.
         */
        icon: string;
        /**
         * The blade override for the kind.
         */
        blade: ResourceBladeReference;
        /**
         * The visibility for the kind.
         */
        visibility: string;
    }
    /**
     * Kind metadata visibility constants.
     */
    module KindMetadataVisibility {
        /**
         * Default visibility (shown in browse).
         */
        var defaultVisibility: string;
        /**
         * Hidden visibility (not shown in browse).
         */
        var hiddenVisibility: string;
    }
    /**
     * The resource blade reference from the server.
     */
    interface ResourceBladeReference {
        /**
         * The name of the blade.
         */
        name: string;
        /**
         * The name of the extension.
         */
        extension: string;
    }
    /**
     * Searches the given resource type cache and when it finds a resource type match, calls the provided callback.
     *
     * @param resourceTypeCache The resource type cache.
     * @param resourceType The resource type to find.
     * @param callback The callback called if the type was found.
     * @return Boolean true if the resource type was found and the callback called, else false.
     */
    function withResourceType(resourceTypeCache: ResourceTypeCache, resourceType: string, callback: (typeMetaData: ResourceTypeMetadata) => void): boolean;
    /**
     * Searches the given resource type cache and when it finds a resource type and kind match, calls the provided
     * callback.
     *
     * @param resourceTypeCache The resource type cache.
     * @param resourceType The resource type to find.
     * @param resourceTypeKind The resource type kind to find.
     * @param callback The callback called if the kind was found.
     * dynamic kind endpoint.
     * @return Boolean true if the resource kind was found and the callback called, else false.
     */
    function withResourceTypeKind(resourceTypeCache: ResourceTypeCache, resourceType: string, resourceTypeKind: string, callback: (typeMetaData: ResourceTypeMetadata, typeKindMetaData: ResourceTypeKindMetadata) => void): boolean;
    /**
     * Gets the resource kind icon as an image from the given resource type cache and the resource type and kind.
     *
     * @param resourceTypeMetadata The resource type metadata.
     * @param resourceTypeKindMetadata The resource type kind metadata.
     * @param forceSecureUriOnly Optional flag to force using secure URI only.
     * @return The icon image for the resource kind if found and valid, otherwise null.
     */
    function getResourceKindIconAsImage(resourceTypeMetadata: ResourceTypeMetadata, resourceTypeKindMetadata: ResourceTypeKindMetadata, forceSecureUriOnly?: boolean): FxImage;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\OptimizableFragments.d.ts
declare const __extends: (d: any, b: any) => void;
declare const __decorate: (decorators: any, target: any, key: any, desc: any) => any;
declare const __metadata: (k: any, v: any) => any;
declare const __param: (paramIndex: any, decorator: any) => (target: any, key: any) => void;
declare const __awaiter: (thisArg: any, _arguments: any, Promise: any, generator: any) => any;

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Parts\PartColor.d.ts
declare module MsPortalFx.Parts {
    enum PartColor {
        /**
         * The default theme color.
         */
        Theme = 0,
        /**
         * Blue.
         */
        Blue = 1,
        /**
         * Green.
         */
        Green = 2,
        /**
         * Orange.
         */
        Orange = 3,
        /**
         * Pink.
         */
        Pink = 4,
        /**
         * Purple.
         */
        Purple = 5,
        /**
         * Azure.
         */
        Azure = 6,
        /**
         * Dark.
         */
        Dark = 7,
        /**
         * Red.
         */
        Red = 8,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Parts\PartKind.d.ts
declare module MsPortalFx.Parts {
    enum PartKind {
        /**
         * Custom part that requires a provided template
         */
        Custom = 0,
        /**
         * Part to show the summary of a collection.
         */
        CollectionSummary = 1,
        /**
         * Part that displays an extension error.
         */
        Error = 3,
        /**
         * Part to show the summary of an item.
         */
        ItemSummary = 4,
        /**
         * Part to display a Settings control.
         */
        Settings = 7,
        /**
         * Part to display a SingleSetting control.
         */
        SingleSetting = 8,
        /**
         * Part to display a LogStream control.
         */
        LogStream = 11,
        /**
         * Part to display a Grid control.
         */
        Grid = 14,
        /**
         * Part to display a document Editor.
         */
        Editor = 15,
        /**
         * Part to display a document DiffEditor.
         */
        DiffEditor = 16,
        /**
         * Part used for provisioning an asset.
         */
        Provisioning = 17,
        /**
         * Built-in part that displays unavailable UI.
         */
        Unavailable = 18,
        /**
         * Part used to initiate Create flow for an asset.
         */
        Create = 19,
        /**
         * Part to show the summary of a collection.
         */
        Button = 20,
        /**
         * Part used to launch a quick start blade.
         */
        QuickStart = 21,
        /**
         * Part used to represent an asset.
         */
        Asset = 22,
        /**
         * Part used to show documentation or getting started information.
         */
        InfoList = 23,
        /**
         * Part used to show a list of properties.
         */
        Properties = 24,
        /**
         * Part used to display a collection of records with an optional rollup.
         */
        Collection = 25,
        /**
         * Part used to display a Chart control.
         */
        Chart = 26,
        /**
         * Part used to display a single value gauge with optional metrics.
         */
        SingleValueGauge = 27,
        /**
         * Part used to display a Donut control.
         */
        Donut = 28,
        /**
         * Part used to display a quota gauge with optional metrics.
         */
        QuotaGauge = 29,
        /**
         * Part used to show the resource summary.
         */
        ResourceSummary = 30,
        /**
         * Part used to render a web page inside an iframe.
         */
        Frame = 31,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Parts\PartSize.d.ts
declare module MsPortalFx.Parts {
    enum PartSize {
        /**
         * A tile that is 1 column x 1 row.
         */
        Mini = 0,
        /**
         * A tile that is 2 columns x 1 row.
         */
        Small = 1,
        /**
         * A tile that is 2 columns x 2 rows.
         */
        Normal = 2,
        /**
         * A tile that is 4 columns x 2 rows.
         */
        Wide = 3,
        /**
         * A tile that is 2 columns x 4 rows.
         */
        Tall = 4,
        /**
         * A tile that is 6 columns x 4 rows.
         */
        HeroWide = 5,
        /**
         * A tile that is 4 columns x 6 rows.
         */
        HeroTall = 6,
        /**
         * A tile that is 6 columns by unbounded rows that fits the content.
         */
        HeroWideFitHeight = 7,
        /**
         * A tile that expands all the available columns by unbounded rows that fits the content.
         */
        FullWidthFitHeight = 8,
        /**
         * A tile that fits all the available space of the content area it occupies.
         */
        FitToContainer = 9,
        /**
         * A tile that is 4 columns x 4 rows.
         */
        Large = 10,
        /**
         * A tile that is 6 columns x 6 rows.
         */
        Hero = 11,
        /**
         * A tile with a custom size.
         */
        Custom = 99,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Parts\PartSizeHelper.d.ts
declare module MsPortalFx.Parts {
    import PartSize = MsPortalFx.Parts.PartSize;
    module PartSizeHelper {
        /**
         * The collection of all the standard sizes supported by tile with associated properties.
         * Variable part size dimensions are flagged as follow:
         * 0 indicate to use content aware fit. The dimension will grow as the content inside grows.
         * -1 indicate to use container aware fit. The dimension will be as large as the container it is in.
         */
        const AllSizes: TileSize[];
        /**
         * The collection of all the CSS class names representing tile sizes.
         */
        const AllCssClasses: string[];
        /**
         * Gets the pixel dimensions based on grid column span and row span.
         * The value will be clamped between 1 to 25 in span in either dimensions.
         *
         * @param colSpan The column span.
         * @param rowSpan The row span.
         * @return An object with the pixels width and height.
         */
        function getGridPixelSize(colSpan: number, rowSpan: number): {
            width: number;
            height: number;
        };
        /**
         * Gets the standard size that correspond to the pixel width and height requested.
         * If the size is not matching, than a custom size will be produced.
         *
         * @param width The width in pixel.
         * @param rowSpan The height in pixel.
         * @return An object with the standard size properties.
         */
        function getCorrespondingStandardSize(width: number, height: number): TileSize;
        /**
         * Gets the default size for a tile.
         *
         * @return An object with the standard size properties.
         */
        function getDefaultSize(): TileSize;
        /**
         * Gets the size that corresponds to the requested standard tile size.
         *
         * @param tileSize The standard tile size requested.
         * @return An object with the standard size properties.
         */
        function getSize(tileSize: PartSize): TileSize;
        /**
         * Checks if the specified size is a fixed dimension part size.
         *
         * @param size The size to check.
         * @return True if the size is of fixed dimensions.
         */
        function isFixedSize(size: PartSize): boolean;
        /**
         * Checks if the specified size is a variable dimension part size.
         *
         * @param size The size to check.
         * @return True if the size is of variable dimensions.
         */
        function isVariableSize(size: PartSize): boolean;
        /**
         * Checks if the specified size has an adaptive width.
         *
         * @param size The size to check.
         * @return True if the size has an adaptive width.
         */
        function isAdaptiveWidth(size: PartSize): boolean;
    }
    interface TileSize {
        /**
         * Part name.
         */
        name: PartSize;
        /**
         * Part CSS.
         */
        css: string;
        /**
         * Part size.
         */
        size: {
            /**
             * Width in pixels.
             */
            width: number;
            /**
             * Height in pixels.
             */
            height: number;
        };
        /**
         * Part grid span.
         */
        span: {
            /**
             * Number of cols occupied.
             */
            colSpan: number;
            /**
             * Number of rows occupied.
             */
            rowSpan: number;
        };
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Parts\PartState.d.ts
declare module MsPortalFx.Parts {
    /**
     * Reflects the overall state of a Part, which determines whether or not it can be bound and displayed on the screen.
     */
    enum PartState {
        /**
         * The Part ready to be bound and displayed.
         */
        Ready = 0,
        /**
         * The Part is in a failed state where it cannot be bound and displayed. Instead, the user will see an error.
         */
        Failed = 1,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Parts\ResizeMode.d.ts
declare module MsPortalFx.Parts {
    enum ResizeMode {
        /**
         * Default mode.
            Resizes based on an optional set of fixed sizes.
         */
        Fixed = 0,
        /**
         * Resizes programmatically based on extension requesting size change.
         */
        Programmatic = 1,
        /**
         * Resizes based on user interaction.
         */
        User = 2,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Polyfills\array.d.ts
interface ImmutableArrayPolyfills<T> extends NumberMap<T> {
    /**
     * Deprecated. Please use MsPortalFx.union instead.
     */
    concatUnique(other: ImmutableArray<T>, predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * Deprecated. Please use MsPortalFx.find instead.
     */
    first(predicate?: (value: T) => boolean, startIndex?: number): T;
    /**
     * Deprecated. Please use MsPortalFx.findIndex instead.
     */
    firstIndex(predicate?: (value: T) => boolean, startIndex?: number): number;
    /**
     * Deprecated. Please use MsPortalFx.last instead.
     */
    last(): any;
    /**
     * Deprecated. Please use MsPortalFx.mapMany instead.
     */
    mapMany<U>(selector: (source: T) => ImmutableArray<U>): U[];
    /**
     * Deprecated. Please use MsPortalFx.stableSort instead.
     */
    stableSort(compare: (a: T, b: T) => number): T[];
    /**
     * Deprecated. Please use MsPortalFx.unique instead.
     */
    unique(predicate?: (value1: T, value2: T) => boolean): T[];
}
interface ArrayPolyfills<T> extends ImmutableArrayPolyfills<T> {
    /**
     * Deprecated. Please use MsPortalFx.union instead.
     */
    concatUnique(other: T[], predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * Deprecated. Please use MsPortalFx.remove instead.
     */
    remove(item: T): T[];
}
interface Array<T> extends ArrayPolyfills<T> {
}
/**
 *  An immutable array.
 */
interface ImmutableArray<T> extends ImmutableArrayPolyfills<T> {
    toString(): string;
    toLocaleString(): string;
    concat(...items: T[][]): T[];
    concat(...items: T[]): T[];
    join(separator?: string): string;
    slice(start?: number, end?: number): T[];
    indexOf(searchElement: T, fromIndex?: number): number;
    lastIndexOf(searchElement: T, fromIndex?: number): number;
    every(callbackfn: (value: T, index: number, array: ImmutableArray<T>) => boolean, thisArg?: any): boolean;
    some(callbackfn: (value: T, index: number, array: ImmutableArray<T>) => boolean, thisArg?: any): boolean;
    forEach(callbackfn: (value: T, index: number, array: ImmutableArray<T>) => void, thisArg?: any): void;
    map<U>(callbackfn: (value: T, index: number, array: ImmutableArray<T>) => U, thisArg?: any): U[];
    filter(callbackfn: (value: T, index: number, array: ImmutableArray<T>) => boolean, thisArg?: any): T[];
    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: ImmutableArray<T>) => U, initialValue: U): U;
}
/**
 * Returns a negative, zero or a positive number if its first
 * parameter is smaller, equal or greater than its second parameter
 * respectively.
 */
interface Comparator<T> {
    (a: T, b: T): number;
}
declare module MsPortalFx {
    /**
     * Detect a value is undefined.
     *
     *  @param unchangePropertyName : this.unchangePropertyName be unchange after invoke this call back function
     *  @param functionsMap : The functionsMap to look up for this method to be invokec.  Typically is a prototype object.  Array.prototype.
     *  @param functionName : The functionName to look up in functionName.
     *
     *  @return the new function: typeof functionsMap[functionName].  This is good for monkey patch for this method.
     */
    var getAssertSameInCallFunc: (unchangePropertyName: string, functionsMap: StringMap<(...args: any[]) => any>, fucntionName: string) => ((...args: any[]) => any);
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Polyfills\date.d.ts
interface Date {
    toString(value: string | MsPortalFx.Intl.DateTimeFormatOptions): string;
    /**
     * Calculates date for first day of the week for the date.
     *
     * @param firstDayOfWeek 0 - Sunday, 1 - Monday, ..., 6 - Saturday.
     *
     * @return date object representing the first day of the week for the date
     */
    getFirstDayOfWeek(firstDayOfWeek?: number): Date;
}
interface DateConstructor {
    getLocaleValues: () => any;
    setLocaleValues: (def?: any) => void;
}
declare module MsPortalFx.Polyfills {
    const getLocaleValues: () => {
        days: string[];
        daysAbbr: string[];
        months: string[];
        monthsAbbr: string[];
        ampm: string[];
        ampmAbbr: string[];
        dateSeparator: string;
        timeSeparator: string;
        standard: {
            d: string;
            D: string;
            f: string;
            F: string;
            g: string;
            G: string;
            m: string;
            M: string;
            r: string;
            R: string;
            s: string;
            t: string;
            T: string;
            u: string;
            y: string;
            Y: string;
        };
        firstDayOfWeek: number;
    };
    const setLocaleValues: (def?: any) => void;
    /**
     * Returns a toRelativeString for date. (this need to be date.)
     *
     * @param format The relative format option (difference or timestamp) used to render the string.
     * @param now The relative Date object to compare date to.
     * @return A string representing the relative date.
     */
    const dateToRelativeString: (format: string, now?: Date) => string;
    function getDateToStringFunc(regex: RegExp): (format?: string | MsPortalFx.Intl.DateTimeFormatOptions) => string;
    const dateParse: (value: string) => number;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Polyfills\string.d.ts
interface StringPolyfills {
    /**
     * Formats a string based on its key value pair object.
     *
     * @param args The list of arguments format arguments. For example: "String with params {0} and {1}".format("val1", "val2");.
     * @return Formatted string.
     */
    format(...restArgs: any[]): string;
    /**
     * Formats a string based on its key value pair object.
     *
     * @param formatSpecifierMap An object that contains that format mappings. For example: "String with parameters {one} and {two}".format({one: "val1", two: "val2"});.
     * @param tokenEncoder If specified, this callback will be used to produce a string representation of the tokens being injected into the string.
     * @return Formatted string.
     */
    format(formatSpecifierMap: Object, tokenFormatter?: (tokenValue: any) => string): string;
    /**
     * Deprecated. Please use MsPortalFx.replaceAll instead.
     */
    localeCompareIgnoreCase(value: string, locales?: string[], options?: any): number;
    /**
     * Deprecated. Please use MsPortalFx.replaceAll instead.
     */
    replaceAll(searchValue: string, replaceValue: string): string;
    /**
     * Deprecated. Please use MsPortalFx.replaceMany instead.
     */
    replaceMany(replacementMap: StringMap<string>): string;
    /**
     * Deprecated. Please use MsPortalFx.repeat instead.
      */
    repeat(count: number): string;
    /**
     * Deprecated. Please use MsPortalFx.startsWith instead.
     */
    startsWith(searchString: string, position?: number): boolean;
    /**
     * Deprecated. Please use MsPortalFx.endsWith instead.
     */
    endsWith(searchString: string, position?: number): boolean;
}
interface String extends StringPolyfills {
}
declare module MsPortalFx {
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Resources\Resources.FrameworkResources.d.ts
declare module MsPortalFx.Resources.Strings {
    module Toolbar {
        module MoveButton {
            /** Move */
            const title: string;
            /** Move to another subscription */
            const subscription: string;
            /** Move to another resource group */
            const resourcegroup: string;
        }
        interface IMoveButton {
            /** Move */
            title: string;
            /** Move to another subscription */
            subscription: string;
            /** Move to another resource group */
            resourcegroup: string;
        }
    }
    interface IToolbar {
        MoveButton: Toolbar.IMoveButton;
    }
    module Part {
        module PropertiesPart {
            /** change */
            const changeLabel: string;
            /** Change subscription */
            const changeSubscriptionLabel: string;
            /** Change resource group */
            const changeResourceGroupLabel: string;
        }
        interface IPropertiesPart {
            /** change */
            changeLabel: string;
            /** Change subscription */
            changeSubscriptionLabel: string;
            /** Change resource group */
            changeResourceGroupLabel: string;
        }
        module SettingList {
            module Group {
                /** Settings */
                const settings: string;
                /** General */
                const general: string;
                /** Monitoring */
                const monitoring: string;
                /** Quick access */
                const quickAccess: string;
                /** Support + troubleshooting */
                const support: string;
                /** Resource management */
                const resourceManagement: string;
            }
            interface IGroup {
                /** Settings */
                settings: string;
                /** General */
                general: string;
                /** Monitoring */
                monitoring: string;
                /** Quick access */
                quickAccess: string;
                /** Support + troubleshooting */
                support: string;
                /** Resource management */
                resourceManagement: string;
            }
            /** Properties */
            const properties: string;
            /** Resource providers */
            const resourceProviders: string;
            /** My permissions */
            const accessDetails: string;
            /** Resource locks */
            const locksForSubscriptions: string;
            /** Locks */
            const locks: string;
            module Keyword {
                /** insights */
                const insights: string;
                /** logs */
                const logs: string;
                /** events */
                const events: string;
            }
            interface IKeyword {
                /** insights */
                insights: string;
                /** logs */
                logs: string;
                /** events */
                events: string;
            }
            module Keywords {
                /** capture, automate, automation, PowerShell, command line, CLI, .NET, C#, csharp */
                const exportTemplate: string;
                /** event logs, operation logs, events, support, insights, monitoring */
                const eventLogs: string;
                /** support, advisor, recommendations, recommendation, best practice */
                const resourceAdvisor: string;
                /** support, help */
                const resourceHealth: string;
                /** troubleshooting, submit, support requests, cases, tickets, incidents, help */
                const troubleshoot: string;
                /** troubleshooting, submit, support request, cases, tickets, incidents, help, tools, diagnostics, problems, slow, connectivity, down */
                const helpRequest: string;
                /** cloud services, CPUs, processors, cores, storage accounts */
                const quotas: string;
            }
            interface IKeywords {
                /** capture, automate, automation, PowerShell, command line, CLI, .NET, C#, csharp */
                exportTemplate: string;
                /** event logs, operation logs, events, support, insights, monitoring */
                eventLogs: string;
                /** support, advisor, recommendations, recommendation, best practice */
                resourceAdvisor: string;
                /** support, help */
                resourceHealth: string;
                /** troubleshooting, submit, support requests, cases, tickets, incidents, help */
                troubleshoot: string;
                /** troubleshooting, submit, support request, cases, tickets, incidents, help, tools, diagnostics, problems, slow, connectivity, down */
                helpRequest: string;
                /** cloud services, CPUs, processors, cores, storage accounts */
                quotas: string;
            }
            /** Automation script */
            const exportTemplate: string;
            /** Activity log */
            const eventLogs: string;
            /** Advisor recommendations */
            const resourceAdvisor: string;
            /** Resource health */
            const resourceHealth: string;
            /** Diagnose and solve problems */
            const troubleshoot: string;
            /** New support request */
            const helpRequest: string;
            /** Access control (IAM) */
            const accessControl: string;
            /** Users */
            const users: string;
            /** Tags */
            const tags: string;
            /** Usage + quotas */
            const quotas: string;
            /** Management certificates */
            const subCerts: string;
            /** Roles */
            const roles: string;
            /** Resources */
            const resources: string;
            /** Resource groups */
            const resourceGroups: string;
            /** Access */
            const access: string;
            /** Filter settings */
            const searchBoxPlaceholder: string;
        }
        interface ISettingList {
            Group: SettingList.IGroup;
            /** Properties */
            properties: string;
            /** Resource providers */
            resourceProviders: string;
            /** My permissions */
            accessDetails: string;
            /** Resource locks */
            locksForSubscriptions: string;
            /** Locks */
            locks: string;
            Keyword: SettingList.IKeyword;
            Keywords: SettingList.IKeywords;
            /** Automation script */
            exportTemplate: string;
            /** Activity log */
            eventLogs: string;
            /** Advisor recommendations */
            resourceAdvisor: string;
            /** Resource health */
            resourceHealth: string;
            /** Diagnose and solve problems */
            troubleshoot: string;
            /** New support request */
            helpRequest: string;
            /** Access control (IAM) */
            accessControl: string;
            /** Users */
            users: string;
            /** Tags */
            tags: string;
            /** Usage + quotas */
            quotas: string;
            /** Management certificates */
            subCerts: string;
            /** Roles */
            roles: string;
            /** Resources */
            resources: string;
            /** Resource groups */
            resourceGroups: string;
            /** Access */
            access: string;
            /** Filter settings */
            searchBoxPlaceholder: string;
        }
        module CollectionSummary {
            /** {0}+ */
            const numberPlus: string;
            /** {0} */
            const number: string;
        }
        interface ICollectionSummary {
            /** {0}+ */
            numberPlus: string;
            /** {0} */
            number: string;
        }
        module ResourceSummary {
            /** Not available */
            const notAvailable: string;
            /** Subscription name */
            const subscriptionNamePropertyLabel: string;
            /** Subscription ID */
            const subscriptionIdPropertyLabel: string;
            /** Location */
            const locationPropertyLabel: string;
            /** Status */
            const statusPropertyLabel: string;
            /** Resource group */
            const resourceGroupPropertyLabel: string;
        }
        interface IResourceSummary {
            /** Not available */
            notAvailable: string;
            /** Subscription name */
            subscriptionNamePropertyLabel: string;
            /** Subscription ID */
            subscriptionIdPropertyLabel: string;
            /** Location */
            locationPropertyLabel: string;
            /** Status */
            statusPropertyLabel: string;
            /** Resource group */
            resourceGroupPropertyLabel: string;
        }
        module Chart {
            /** Edit */
            const editButtonText: string;
        }
        interface IChart {
            /** Edit */
            editButtonText: string;
        }
        module Quickstart {
            /** Quickstart */
            const title: string;
        }
        interface IQuickstart {
            /** Quickstart */
            title: string;
        }
        module Provisioning {
            /** Polling failed */
            const pollingFailed: string;
            /** Deployment status unavailable */
            const deploymentStatusUnavailable: string;
            /** In progress... */
            const description: string;
        }
        interface IProvisioning {
            /** Polling failed */
            pollingFailed: string;
            /** Deployment status unavailable */
            deploymentStatusUnavailable: string;
            /** In progress... */
            description: string;
        }
    }
    interface IPart {
        PropertiesPart: Part.IPropertiesPart;
        SettingList: Part.ISettingList;
        CollectionSummary: Part.ICollectionSummary;
        ResourceSummary: Part.IResourceSummary;
        Chart: Part.IChart;
        Quickstart: Part.IQuickstart;
        Provisioning: Part.IProvisioning;
    }
    module Azure {
        module Subscriptions {
            module DropDown {
                /** The subscription {0} is not allowed to register the resource provider(s): {1}.    {0} subscription name, {1} list of resource providers */
                const subDisallowedRP: string;
                /** The subscription {0} doesn't have permissions to register the resource provider(s): {1}.    {0} subscription name, {1} list of resource providers */
                const subCantRegisterWithRP: string;
                /** You don't have the required permissions ({0}) to create resources under the selected subscription    {0} the list of required permissions */
                const requiredPermissionsValidationMessage: string;
                /** The selected subscription is not allowed to create this resource. */
                const subscriptionNotAllowedForGalleryItemValidationMessage: string;
                /** The selected subscription is disabled. */
                const disabledSubscriptionValidationMessage: string;
                /** Subscription */
                const defaultLabel: string;
            }
            interface IDropDown {
                /** The subscription {0} is not allowed to register the resource provider(s): {1}.    {0} subscription name, {1} list of resource providers */
                subDisallowedRP: string;
                /** The subscription {0} doesn't have permissions to register the resource provider(s): {1}.    {0} subscription name, {1} list of resource providers */
                subCantRegisterWithRP: string;
                /** You don't have the required permissions ({0}) to create resources under the selected subscription    {0} the list of required permissions */
                requiredPermissionsValidationMessage: string;
                /** The selected subscription is not allowed to create this resource. */
                subscriptionNotAllowedForGalleryItemValidationMessage: string;
                /** The selected subscription is disabled. */
                disabledSubscriptionValidationMessage: string;
                /** Subscription */
                defaultLabel: string;
            }
        }
        interface ISubscriptions {
            DropDown: Subscriptions.IDropDown;
        }
        module ResourceManager {
            module Provisioner {
                module ArmValidation {
                    /** Unable to submit request. Check network connectivity and try again. */
                    const networkFailure: string;
                    /** There were validation errors. Click here to view details. */
                    const validationFailed: string;
                }
                interface IArmValidation {
                    /** Unable to submit request. Check network connectivity and try again. */
                    networkFailure: string;
                    /** There were validation errors. Click here to view details. */
                    validationFailed: string;
                }
                /** Automation options */
                const seeTemplateLink: string;
                /** Show pricing summary */
                const pricingSummaryLinkLabel: string;
            }
            interface IProvisioner {
                ArmValidation: Provisioner.IArmValidation;
                /** Automation options */
                seeTemplateLink: string;
                /** Show pricing summary */
                pricingSummaryLinkLabel: string;
            }
        }
        interface IResourceManager {
            Provisioner: ResourceManager.IProvisioner;
        }
        module ResourceGroups {
            module InfoBalloon {
                /** A resource group is a collection of resources that share the same lifecycle, permissions, and policies. */
                const text: string;
                /** Learn more here. */
                const linkText: string;
            }
            interface IInfoBalloon {
                /** A resource group is a collection of resources that share the same lifecycle, permissions, and policies. */
                text: string;
                /** Learn more here. */
                linkText: string;
            }
            module DropDown {
                module ProvisioningStateValidation {
                    /** You cannot create resources under the selected resource group. {0}    {0} reason/details */
                    const baseMessage: string;
                    /** The selected resource group is involved in a move operation. It may be selectable again in few minutes. */
                    const movingresources: string;
                    /** The selected resource group is being deleted. */
                    const deleting: string;
                    /** The selected resource group has been deleted. */
                    const deleted: string;
                }
                interface IProvisioningStateValidation {
                    /** You cannot create resources under the selected resource group. {0}    {0} reason/details */
                    baseMessage: string;
                    /** The selected resource group is involved in a move operation. It may be selectable again in few minutes. */
                    movingresources: string;
                    /** The selected resource group is being deleted. */
                    deleting: string;
                    /** The selected resource group has been deleted. */
                    deleted: string;
                }
                /** The selected resource group is read only */
                const lockedValidationMessage: string;
                /** You don't have the required permissions ({0}) to create resources under the selected resource group    {0} the list of required permissions */
                const requiredPermissionsValidationMessage: string;
                /** Resource group */
                const defaultLabel: string;
            }
            interface IDropDown {
                ProvisioningStateValidation: DropDown.IProvisioningStateValidation;
                /** The selected resource group is read only */
                lockedValidationMessage: string;
                /** You don't have the required permissions ({0}) to create resources under the selected resource group    {0} the list of required permissions */
                requiredPermissionsValidationMessage: string;
                /** Resource group */
                defaultLabel: string;
            }
        }
        interface IResourceGroups {
            InfoBalloon: ResourceGroups.IInfoBalloon;
            DropDown: ResourceGroups.IDropDown;
        }
        /** {0} (Code: {1})    {0} error message, {1} error code */
        const errorMessageWithCode: string;
        module Validators {
            module ReservedResourceName {
                /** The resource name '{0}' or a part of the name is a trademarked or reserved word.    {0} name checked. */
                const message: string;
            }
            interface IReservedResourceName {
                /** The resource name '{0}' or a part of the name is a trademarked or reserved word.    {0} name checked. */
                message: string;
            }
            module RequiredPermission {
                /** You don't have the required permissions ({0})    {0} actions. */
                const message: string;
            }
            interface IRequiredPermission {
                /** You don't have the required permissions ({0})    {0} actions. */
                message: string;
            }
        }
        interface IValidators {
            ReservedResourceName: Validators.IReservedResourceName;
            RequiredPermission: Validators.IRequiredPermission;
        }
        module Legal {
            module LegalTermsSelector {
                /** Review legal terms */
                const legalTermsMessage: string;
                /** Legal terms */
                const legalTermsLabel: string;
                /** Legal terms accepted */
                const legalTermsAcceptedMessage: string;
            }
            interface ILegalTermsSelector {
                /** Review legal terms */
                legalTermsMessage: string;
                /** Legal terms */
                legalTermsLabel: string;
                /** Legal terms accepted */
                legalTermsAcceptedMessage: string;
            }
        }
        interface ILegal {
            LegalTermsSelector: Legal.ILegalTermsSelector;
        }
        module BaseResourceDropDown {
            /** {0} does not exist in the list. */
            const searchingValidationMessage: string;
            /** Selected item doesn't exist in the list. */
            const creatingResourcedDisabledValidationMessage: string;
        }
        interface IBaseResourceDropDown {
            /** {0} does not exist in the list. */
            searchingValidationMessage: string;
            /** Selected item doesn't exist in the list. */
            creatingResourcedDisabledValidationMessage: string;
        }
        module Locations {
            module DropDown {
                /** No regions are enabled for this creation. Try using a different subscription or contact support if you believe this to be an error */
                const emptyMessage: string;
                /** Location */
                const defaultLabel: string;
            }
            interface IDropDown {
                /** No regions are enabled for this creation. Try using a different subscription or contact support if you believe this to be an error */
                emptyMessage: string;
                /** Location */
                defaultLabel: string;
            }
        }
        interface ILocations {
            DropDown: Locations.IDropDown;
        }
    }
    interface IAzure {
        Subscriptions: Azure.ISubscriptions;
        ResourceManager: Azure.IResourceManager;
        ResourceGroups: Azure.IResourceGroups;
        /** {0} (Code: {1})    {0} error message, {1} error code */
        errorMessageWithCode: string;
        Validators: Azure.IValidators;
        Legal: Azure.ILegal;
        BaseResourceDropDown: Azure.IBaseResourceDropDown;
        Locations: Azure.ILocations;
    }
    module Pickers {
        module Specs {
            module DropDown {
                /** View full pricing details */
                const labelLinkText: string;
                /** Recently Used */
                const recent: string;
                /** All Available Pricing */
                const available: string;
                /** Recommended */
                const recommended: string;
                /** Pricing tier ({0})    {0} link text */
                const labelFormatter: string;
            }
            interface IDropDown {
                /** View full pricing details */
                labelLinkText: string;
                /** Recently Used */
                recent: string;
                /** All Available Pricing */
                available: string;
                /** Recommended */
                recommended: string;
                /** Pricing tier ({0})    {0} link text */
                labelFormatter: string;
            }
            /** Pricing tier */
            const pricingTier: string;
        }
        interface ISpecs {
            DropDown: Specs.IDropDown;
            /** Pricing tier */
            pricingTier: string;
        }
        module AccessDenied {
            /** You can't pick this item because you don't have the required access */
            const reasonMessage: string;
        }
        interface IAccessDenied {
            /** You can't pick this item because you don't have the required access */
            reasonMessage: string;
        }
    }
    interface IPickers {
        Specs: Pickers.ISpecs;
        AccessDenied: Pickers.IAccessDenied;
    }
    module HeatMap {
        /** Legend */
        const legend: string;
        /** No items in heat map */
        const noUnitsMessage: string;
        /** Heat map */
        const name: string;
    }
    interface IHeatMap {
        /** Legend */
        legend: string;
        /** No items in heat map */
        noUnitsMessage: string;
        /** Heat map */
        name: string;
    }
    module Controls {
        module Grid2 {
            /** Click to open context menu */
            const contextMenu: string;
        }
        interface IGrid2 {
            /** Click to open context menu */
            contextMenu: string;
        }
    }
    interface IControls {
        Grid2: Controls.IGrid2;
    }
    module ViewModels {
        module Controls {
            module ResourceGroups {
                /** Select existing resource group */
                const selectExisting: string;
                /** Create new resource group */
                const createNew: string;
            }
            interface IResourceGroups {
                /** Select existing resource group */
                selectExisting: string;
                /** Create new resource group */
                createNew: string;
            }
            module DateTimePicker {
                /** Time */
                const timeLabel: string;
                /** Date */
                const dateLabel: string;
            }
            interface IDateTimePicker {
                /** Time */
                timeLabel: string;
                /** Date */
                dateLabel: string;
            }
            module DateTimePickerRange {
                /** Start time */
                const startTime: string;
                /** Start date */
                const startDate: string;
                /** End time */
                const endTime: string;
                /** End date */
                const endDate: string;
            }
            interface IDateTimePickerRange {
                /** Start time */
                startTime: string;
                /** Start date */
                startDate: string;
                /** End time */
                endTime: string;
                /** End date */
                endDate: string;
            }
            /** Calendar */
            const calendar: string;
            /** File upload */
            const fileUpload: string;
            /** Selector */
            const selector: string;
            /** Creator and selector */
            const creatorAndSelectorLabel: string;
            /** Button */
            const button: string;
            /** Remove item */
            const removeItem: string;
            /** Choose item */
            const chooseItem: string;
            /** Add item */
            const addItem: string;
            /** Spec comparison */
            const specComparison: string;
            /** Terminal */
            const terminal: string;
            /** Search box */
            const searchBox: string;
            module CreatorAndSelector {
                /** Select existing    Providing the option to select an existing option. */
                const selectExisting: string;
                /** Use existing */
                const useExisting: string;
                /** Create new */
                const createNew: string;
            }
            interface ICreatorAndSelector {
                /** Select existing    Providing the option to select an existing option. */
                selectExisting: string;
                /** Use existing */
                useExisting: string;
                /** Create new */
                createNew: string;
            }
            module CreatorAndComboBox {
                /** Use existing */
                const useExisting: string;
                /** Create new */
                const createNew: string;
            }
            interface ICreatorAndComboBox {
                /** Use existing */
                useExisting: string;
                /** Create new */
                createNew: string;
            }
            /** Search */
            const search: string;
            /** No results */
            const noRowsMessage: string;
        }
        interface IControls {
            ResourceGroups: Controls.IResourceGroups;
            DateTimePicker: Controls.IDateTimePicker;
            DateTimePickerRange: Controls.IDateTimePickerRange;
            /** Calendar */
            calendar: string;
            /** File upload */
            fileUpload: string;
            /** Selector */
            selector: string;
            /** Creator and selector */
            creatorAndSelectorLabel: string;
            /** Button */
            button: string;
            /** Remove item */
            removeItem: string;
            /** Choose item */
            chooseItem: string;
            /** Add item */
            addItem: string;
            /** Spec comparison */
            specComparison: string;
            /** Terminal */
            terminal: string;
            /** Search box */
            searchBox: string;
            CreatorAndSelector: Controls.ICreatorAndSelector;
            CreatorAndComboBox: Controls.ICreatorAndComboBox;
            /** Search */
            search: string;
            /** No results */
            noRowsMessage: string;
        }
        module Container {
            /** Not found */
            const notFound: string;
            /** Preview */
            const preview: string;
            /** No access */
            const unauthorizedText: string;
        }
        interface IContainer {
            /** Not found */
            notFound: string;
            /** Preview */
            preview: string;
            /** No access */
            unauthorizedText: string;
        }
    }
    interface IViewModels {
        Controls: ViewModels.IControls;
        Container: ViewModels.IContainer;
    }
    module ResourceGroup {
        module Validation {
            /** You do not have permissions to create resource groups under subscription {0}.    {0} is the subscription name */
            const subscriptionHasNoPermissionsMessage: string;
            /** Resource group name only allows up to 90 characters. */
            const lengthValidationMessage: string;
            /** Resource group name can only include alphanumeric characters, periods, underscores, hyphens and parenthesis and cannot end in a period. */
            const invalidMessage: string;
            /** A resource group with the same name already exists in the selected subscription {0}.    {0} is the subscription name */
            const alreadyExistsMessage: string;
        }
        interface IValidation {
            /** You do not have permissions to create resource groups under subscription {0}.    {0} is the subscription name */
            subscriptionHasNoPermissionsMessage: string;
            /** Resource group name only allows up to 90 characters. */
            lengthValidationMessage: string;
            /** Resource group name can only include alphanumeric characters, periods, underscores, hyphens and parenthesis and cannot end in a period. */
            invalidMessage: string;
            /** A resource group with the same name already exists in the selected subscription {0}.    {0} is the subscription name */
            alreadyExistsMessage: string;
        }
    }
    interface IResourceGroup {
        Validation: ResourceGroup.IValidation;
    }
    module UnitConversion {
        /** PB/s */
        const petabytesPerSecondSI: string;
        /** TB/s */
        const terabytesPerSecondSI: string;
        /** GB/s */
        const gigabytesPerSecondSI: string;
        /** MB/s */
        const megabytesPerSecondSI: string;
        /** PB */
        const petabytesSI: string;
        /** TB */
        const terabytesSI: string;
        /** GB */
        const gigabytesSI: string;
        /** MB */
        const megabytesSI: string;
        /** T/s */
        const trillionPerSecond: string;
        /** T */
        const trillion: string;
        /** K/s */
        const thousandPerSecond: string;
        /** K */
        const thousand: string;
        /** TiB/s */
        const terabytesPerSecond: string;
        /** TiB */
        const terabytes: string;
        /** s */
        const seconds: string;
        /** PiB/s */
        const petabytesPerSecond: string;
        /** PiB */
        const petabytes: string;
        /** % */
        const percentage: string;
        /** mins */
        const minutes: string;
        /** ms */
        const milliSeconds: string;
        /** M/s */
        const millionPerSecond: string;
        /** M */
        const million: string;
        /** s */
        const microSeconds: string;
        /** MiB/s */
        const megabytesPerSecond: string;
        /** MiB */
        const megabytes: string;
        /** kB/s */
        const kilobytesPerSecondSI: string;
        /** kB */
        const kilobytesSI: string;
        /** KiB/s */
        const kilobytesPerSecond: string;
        /** KiB */
        const kilobytes: string;
        /** hr */
        const hours: string;
        /** GiB/s */
        const gigabytesPerSecond: string;
        /** GiB */
        const gigabytes: string;
        /** days */
        const days: string;
        /** /s */
        const countPerSecond: string;
        /** /min */
        const countPerMinute: string;
        /** /hr */
        const countPerHour: string;
        /** /day */
        const countPerDay: string;
        /** B/s */
        const bytesPerSecond: string;
        /** B/min */
        const bytesPerMinute: string;
        /** B/hr */
        const bytesPerHour: string;
        /** B/day */
        const bytesPerDay: string;
        /** B */
        const bytes: string;
        /** B/s */
        const billionPerSecond: string;
        /** B */
        const billion: string;
    }
    interface IUnitConversion {
        /** PB/s */
        petabytesPerSecondSI: string;
        /** TB/s */
        terabytesPerSecondSI: string;
        /** GB/s */
        gigabytesPerSecondSI: string;
        /** MB/s */
        megabytesPerSecondSI: string;
        /** PB */
        petabytesSI: string;
        /** TB */
        terabytesSI: string;
        /** GB */
        gigabytesSI: string;
        /** MB */
        megabytesSI: string;
        /** T/s */
        trillionPerSecond: string;
        /** T */
        trillion: string;
        /** K/s */
        thousandPerSecond: string;
        /** K */
        thousand: string;
        /** TiB/s */
        terabytesPerSecond: string;
        /** TiB */
        terabytes: string;
        /** s */
        seconds: string;
        /** PiB/s */
        petabytesPerSecond: string;
        /** PiB */
        petabytes: string;
        /** % */
        percentage: string;
        /** mins */
        minutes: string;
        /** ms */
        milliSeconds: string;
        /** M/s */
        millionPerSecond: string;
        /** M */
        million: string;
        /** s */
        microSeconds: string;
        /** MiB/s */
        megabytesPerSecond: string;
        /** MiB */
        megabytes: string;
        /** kB/s */
        kilobytesPerSecondSI: string;
        /** kB */
        kilobytesSI: string;
        /** KiB/s */
        kilobytesPerSecond: string;
        /** KiB */
        kilobytes: string;
        /** hr */
        hours: string;
        /** GiB/s */
        gigabytesPerSecond: string;
        /** GiB */
        gigabytes: string;
        /** days */
        days: string;
        /** /s */
        countPerSecond: string;
        /** /min */
        countPerMinute: string;
        /** /hr */
        countPerHour: string;
        /** /day */
        countPerDay: string;
        /** B/s */
        bytesPerSecond: string;
        /** B/min */
        bytesPerMinute: string;
        /** B/hr */
        bytesPerHour: string;
        /** B/day */
        bytesPerDay: string;
        /** B */
        bytes: string;
        /** B/s */
        billionPerSecond: string;
        /** B */
        billion: string;
    }
    module NumericTextBox {
        /** Value must be a valid number. */
        const invalidText: string;
    }
    interface INumericTextBox {
        /** Value must be a valid number. */
        invalidText: string;
    }
    module DatePolyfill {
        module Months {
            /** September */
            const september: string;
            /** October */
            const october: string;
            /** November */
            const november: string;
            /** May */
            const may: string;
            /** March */
            const march: string;
            /** June */
            const june: string;
            /** July */
            const july: string;
            /** January */
            const january: string;
            /** February */
            const february: string;
            /** December */
            const december: string;
            /** August */
            const august: string;
            /** April */
            const april: string;
        }
        interface IMonths {
            /** September */
            september: string;
            /** October */
            october: string;
            /** November */
            november: string;
            /** May */
            may: string;
            /** March */
            march: string;
            /** June */
            june: string;
            /** July */
            july: string;
            /** January */
            january: string;
            /** February */
            february: string;
            /** December */
            december: string;
            /** August */
            august: string;
            /** April */
            april: string;
        }
        module MonthsAbbr {
            /** Sep */
            const september: string;
            /** Oct */
            const october: string;
            /** Nov */
            const november: string;
            /** May */
            const may: string;
            /** Mar */
            const march: string;
            /** Jun */
            const june: string;
            /** Jul */
            const july: string;
            /** Jan */
            const january: string;
            /** Feb */
            const february: string;
            /** Dec */
            const december: string;
            /** Aug */
            const august: string;
            /** Apr */
            const april: string;
        }
        interface IMonthsAbbr {
            /** Sep */
            september: string;
            /** Oct */
            october: string;
            /** Nov */
            november: string;
            /** May */
            may: string;
            /** Mar */
            march: string;
            /** Jun */
            june: string;
            /** Jul */
            july: string;
            /** Jan */
            january: string;
            /** Feb */
            february: string;
            /** Dec */
            december: string;
            /** Aug */
            august: string;
            /** Apr */
            april: string;
        }
        module Days {
            /** Wednesday */
            const wednesday: string;
            /** Tuesday */
            const tuesday: string;
            /** Thursday */
            const thursday: string;
            /** Saturday */
            const saturday: string;
            /** Monday */
            const monday: string;
            /** Friday */
            const friday: string;
            /** Sunday */
            const sunday: string;
        }
        interface IDays {
            /** Wednesday */
            wednesday: string;
            /** Tuesday */
            tuesday: string;
            /** Thursday */
            thursday: string;
            /** Saturday */
            saturday: string;
            /** Monday */
            monday: string;
            /** Friday */
            friday: string;
            /** Sunday */
            sunday: string;
        }
        module DaysAbbr {
            /** Wed */
            const wednesday: string;
            /** Tue */
            const tuesday: string;
            /** Thu */
            const thursday: string;
            /** Sat */
            const saturday: string;
            /** Mon */
            const monday: string;
            /** Fri */
            const friday: string;
            /** Sun */
            const sunday: string;
        }
        interface IDaysAbbr {
            /** Wed */
            wednesday: string;
            /** Tue */
            tuesday: string;
            /** Thu */
            thursday: string;
            /** Sat */
            saturday: string;
            /** Mon */
            monday: string;
            /** Fri */
            friday: string;
            /** Sun */
            sunday: string;
        }
        module AgoStrings {
            /** {0} yr ago */
            const years: string;
            /** {0} wk ago */
            const weeks: string;
            /** {0} mo ago */
            const months: string;
            /** {0} min ago */
            const minutes: string;
            /** Just now */
            const lessThanAMinute: string;
            /** {0} h ago */
            const hours: string;
            /** {0} d ago */
            const days: string;
            /** 1 yr ago */
            const aYear: string;
            /** 1 wk ago */
            const aWeek: string;
            /** 1 h ago */
            const anHour: string;
            /** 1 mo ago */
            const aMonth: string;
            /** 1 min ago */
            const aMinute: string;
            /** 1 d ago */
            const aDay: string;
        }
        interface IAgoStrings {
            /** {0} yr ago */
            years: string;
            /** {0} wk ago */
            weeks: string;
            /** {0} mo ago */
            months: string;
            /** {0} min ago */
            minutes: string;
            /** Just now */
            lessThanAMinute: string;
            /** {0} h ago */
            hours: string;
            /** {0} d ago */
            days: string;
            /** 1 yr ago */
            aYear: string;
            /** 1 wk ago */
            aWeek: string;
            /** 1 h ago */
            anHour: string;
            /** 1 mo ago */
            aMonth: string;
            /** 1 min ago */
            aMinute: string;
            /** 1 d ago */
            aDay: string;
        }
    }
    interface IDatePolyfill {
        Months: DatePolyfill.IMonths;
        MonthsAbbr: DatePolyfill.IMonthsAbbr;
        Days: DatePolyfill.IDays;
        DaysAbbr: DatePolyfill.IDaysAbbr;
        AgoStrings: DatePolyfill.IAgoStrings;
    }
    module FileDownload {
        /** No access */
        const unauthorizedText: string;
    }
    interface IFileDownload {
        /** No access */
        unauthorizedText: string;
    }
    module FileDownloadCommand {
        /** error */
        const fileDownloadErrorStatus: string;
        /** Default authorization token is not available */
        const authTokenNotAvailable: string;
    }
    interface IFileDownloadCommand {
        /** error */
        fileDownloadErrorStatus: string;
        /** Default authorization token is not available */
        authTokenNotAvailable: string;
    }
    module Services {
        module Gallery {
            /** View pricing summary */
            const viewPricingSummaryLabel: string;
        }
        interface IGallery {
            /** View pricing summary */
            viewPricingSummaryLabel: string;
        }
        module AssetHandler {
            /** Title */
            const titleGridColumn: string;
            /** Type */
            const assetTypeGridColumn: string;
        }
        interface IAssetHandler {
            /** Title */
            titleGridColumn: string;
            /** Type */
            assetTypeGridColumn: string;
        }
    }
    interface IServices {
        Gallery: Services.IGallery;
        AssetHandler: Services.IAssetHandler;
    }
    module Dialogs {
        /** OK */
        const okButtonText: string;
        /** Cancel */
        const cancelButtonText: string;
    }
    interface IDialogs {
        /** OK */
        okButtonText: string;
        /** Cancel */
        cancelButtonText: string;
    }
    module FileUpload {
        /** File upload operation is not supported for the current upload type or upload state. */
        const notSupported: string;
        /** File upload manager is still initializing and it's not ready to process new file uploads. */
        const notReady: string;
    }
    interface IFileUpload {
        /** File upload operation is not supported for the current upload type or upload state. */
        notSupported: string;
        /** File upload manager is still initializing and it's not ready to process new file uploads. */
        notReady: string;
    }
    module DeleteAssetConfirmation {
        /** Are you sure you want to delete {0}? */
        const bladeTitle: string;
        /** Warning! Deleting {0} is irreversible. The action you're about to take can't be undone. Going further will delete it and all the items in it permanently. */
        const warningText: string;
        /** Type the {0} name */
        const confirmationLabel: string;
        /** Please enter '{0}' below to confirm delete. */
        const assetNameValidationFailureMessage: string;
        /** Affected items */
        const affectedItemsLabel: string;
    }
    interface IDeleteAssetConfirmation {
        /** Are you sure you want to delete {0}? */
        bladeTitle: string;
        /** Warning! Deleting {0} is irreversible. The action you're about to take can't be undone. Going further will delete it and all the items in it permanently. */
        warningText: string;
        /** Type the {0} name */
        confirmationLabel: string;
        /** Please enter '{0}' below to confirm delete. */
        assetNameValidationFailureMessage: string;
        /** Affected items */
        affectedItemsLabel: string;
    }
    module DeleteCommand {
        module Failure {
            /** Error */
            const title: string;
            /** There was an error deleting it. */
            const message: string;
        }
        interface IFailure {
            /** Error */
            title: string;
            /** There was an error deleting it. */
            message: string;
        }
        module Confirmation {
            /** Delete */
            const title: string;
            /** Are you sure you want to delete it? */
            const message: string;
        }
        interface IConfirmation {
            /** Delete */
            title: string;
            /** Are you sure you want to delete it? */
            message: string;
        }
    }
    interface IDeleteCommand {
        Failure: DeleteCommand.IFailure;
        Confirmation: DeleteCommand.IConfirmation;
    }
    module ExtensionRequestHandler {
        /** Version mismatch */
        const versionMismatch: string;
    }
    interface IExtensionRequestHandler {
        /** Version mismatch */
        versionMismatch: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Services\Services.AssetHandler.d.ts
declare module MsPortalFx.Services {
    import FxBase = MsPortalFx.Base;
    /**
     * The asset expansion class provides several helpers for asset expanding regular value to asset values.
     */
    module AssetExpansion {
        /**
         * Gets the prefix of all the asset expansion properties.
         */
        const assetDetailsPropertyPrefix: string;
        /**
         * Gets the name of the asset details expanded property.
         */
        const assetDetailsPropertyName: string;
        /**
         * Gets the name of the asset title expanded property.
         */
        const titlePropertyName: string;
        /**
         * Gets the name of the asset description expanded property.
         */
        const descriptionPropertyName: string;
        /**
         * Gets the name of the asset icon expanded property.
         */
        const iconPropertyName: string;
        /**
         * Gets the name of the asset type string expanded property.
         */
        const assetTypeStringPropertyName: string;
        /**
         * Gets the name of the asset ID expanded property.
         */
        const assetIdPropertyName: string;
        /**
         * Checks if the given value has been asset expanded.
         *
         * @param value The value to check.
         * @return true if the value has been asset expanded, else null.
         */
        function isAssetExpanded(value: any): boolean;
        /**
         * Gets the asset expansion from the given value.
         *
         * @param value The value to use.
         * @return The asset expansion if the value was asset expanded, otherwise returns null.
         */
        function getAssetExpansion(value: any): AssetDetails;
        /**
         * Adds an asset expansion to the given value.
         *
         * @param value The value to expand.
         * @param assetDetails The asset expansion.
         * @return The value that was expanded.
         */
        function addAssetExpansion(value: any, assetDetails: AssetDetails): any;
        /**
         * Removes the asset expansion from the give value.
         *
         * @param value The value to unexpand.
         */
        function removeAssetExpansion(value: any): void;
    }
    /**
     * The asset details provides information about the asset.
     */
    interface AssetDetails {
        /**
         * The owner extension's name.
         */
        assetOwner: string;
        /**
         * The asset's ID.
         */
        assetId: any;
        /**
         * The asset's type.
         */
        assetType: string;
        /**
         * Title of the asset.
         */
        title: KnockoutObservableBase<string>;
        /**
         * Short text description of the asset.
         */
        description: KnockoutObservableBase<string>;
        /**
         * Optional icon representative of the asset.
         */
        icon?: KnockoutObservableBase<FxBase.Image>;
    }
    /**
     * Asset expands an item.
     *
     * @param item The item to be cloned and asset expanded.
     * @param mapFunc The mapping function to asset expand the items in the source data set.
     * @param context An opaque context object which is passed to the mapping function as the second parameter.
     * @return The cloned and asset expanded item.
     */
    function assetExpandItem<T>(item: T, mapFunc: (value: T, context?: any) => AssetDetails, context?: any): T;
    /**
     * Asset expands an item and adds the result to the observable result set.
     *
     * @param item The item to be cloned, asset expanded and added to the result set.
     * @param results The observable result set.
     * @param mapFunc The mapping function to asset expand the items in the source data set.
     * @param context An opaque context object which is passed to the mapping function as the second parameter.
     * @return The cloned and asset expanded item.
     */
    function assetExpandItemAndAddToResultSet<T>(item: T, results: KnockoutObservableArray<any>, mapFunc: (value: T, context?: any) => AssetDetails, context?: any): T;
    /**
     * The data set asset expansion mapper is used to watch a data set (typed observable array) and push asset expanded
     * values to a result set (untyped observable array).
     */
    module DataSetAssetExpansionMapper {
        /**
         * Connects a dataset to a set of results with a mapper and a cancellation flag.
         *
         * @param dataSet The source data set (typed observable array).
         * @param results The result set (untyped observable array).
         * @param mapFunc The mapping function to asset expand the items in the source data set.
         * @param context An opaque context object which is passed to the mapping function as the second parameter.
         * @return The knockout subscription for the connection (used to dispose on cancel).
         */
        function connectDataSet<T>(dataSet: KnockoutObservableArray<T>, results: KnockoutObservableArray<any>, mapFunc: (value: T, context?: any) => AssetDetails, context?: any): KnockoutSubscription<any>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Services\Services.Data.d.ts
declare module MsPortalFx.Services {
    /**
     * The data set subscription is used to watch a data set (typed observable array) and call callback functions for
     * insert/remove as values change.  The insert/remove callbacks include the include (handles 'sort' issues) and
     * helps maintain value order if copying the data set into another data set.
     */
    class DataSetSubscription {
        /**
         * Subscribes to a dataset to a set of results with callbacks for insert/remove.
         *
         * @param sourceDataSet The source data set (typed observable array).
         * @param insertFunc The insert function.
         * @param removeFun The remove function.
         * @param context An opaque context object which is passed to the callback functions as the context parameter.
         * @return The knockout subscription on the source data set must be disposed when complete.
         */
        static subscribeDataSet<T>(sourceDataSet: KnockoutObservableArray<T>, insertFunc?: (value: T, index: number, context?: any) => void, removeFunc?: (value: T, index: number, context?: any) => void, context?: any): KnockoutSubscription<T[]>;
        /**
         * Inserts an item into the destination data set at the given index.
         *
         * @param destinationDataSet The destination data set.
         * @param value The value to insert.
         * @param index The index in the data set where to insert the value.
         */
        static insertItem<T>(destinationDataSet: KnockoutObservableArray<T>, value: T, index: number): void;
        /**
         * Removes an item from the destination data set at the given index.
         *
         * @param destinationDataSet The destination data set.
         * @param value The value to remove.
         * @param index The index in the data set where to remove the value.
         */
        static removeItem<T>(destinationDataSet: KnockoutObservableArray<T>, value: T, index: number): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Services\Services.GalleryService.d.ts
declare module MsPortalFx.Services.Gallery {
    import FxPromiseV = MsPortalFx.Base.PromiseV;
    import FxGalleryService = MsPortalFx.Services.Gallery;
    import AzureResourceManager = MsPortalFx.Azure.ResourceManager;
    import DynamicBladeSelection = MsPortalFx.ViewModels.DynamicBladeSelection;
    var noSubCreateCategoryId: string;
    /**
     * Constants for the gallery.
     */
    module Constants {
        /**
         * Constants for the gallery create parameters.
         */
        var GalleryParametersKey: string;
        /**
         * Constants for the gallery create options.
         */
        var GalleryOptionsKey: string;
    }
    /**
     * The interface for the gallery service view model.
     */
    interface GalleryServiceContract {
        /**
         * Runs a gallery create pre-check before launching the create flow. This enables extensions
         * to run a pre-check on the create flow and launch an alternative blade instead.
         *
         * @param galleryItem The gallery item that the create flow belongs to.
         * @return A Jquery promise that is always resolved, either with the dynamic blade selection
         *      object or null.
         */
        galleryCreatePreCheck(galleryItem: GalleryItem): FxPromiseV<DynamicBladeSelection>;
    }
    /**
     * The base gallery service view model.
     */
    class BaseGalleryServiceViewModel implements FxGalleryService.GalleryServiceContract {
        /**
         * Runs a gallery create pre-check before launching the create flow. This enables extensions
         * to run a pre-check on the create flow and launch an alternative blade instead.
         *
         * @param galleryItem The gallery item that the create flow belongs to.
         * @return A Jquery promise that is always resolved, either with the dynamic blade selection
         *      object or null.
         */
        galleryCreatePreCheck(galleryItem: FxGalleryService.GalleryItem): FxPromiseV<DynamicBladeSelection>;
    }
    /**
     * Gallery item model.
     */
    interface GalleryItem extends StringMap<any> {
        /**
         * The Identity of the gallery item.
         */
        identity: string;
        /**
         * The Publisher name.
         */
        publisher: string;
        /**
         * Gets or sets Publisher display name.
         */
        publisherDisplayName: string;
        /**
         * Gets or sets item name.
         */
        itemName: string;
        /**
         * Gets or sets item type.
         */
        itemType?: string;
        /**
         * The item display name.
         */
        itemDisplayName: string;
        /**
         * The item version.
         */
        version: string;
        /**
         * The item summary.
         */
        summary: string;
        /**
         * The item long summary.
         */
        longSummary?: string;
        /**
         * The item description.
         */
        description: string;
        /**
         * The resource group name the gallery item belongs to.
         */
        resourceGroupName: string;
        /**
         * The uri to the ui definition file.
         */
        uiDefinitionUri: string;
        /**
         * The item artifacts, includes the CSM templates.
         */
        artifacts: Artifact[];
        /**
         * The list of category IDs the gallery item belongs to.
         */
        categoryIds: string[];
        /**
         * The list of screenshot image Uris provided for the item.
         */
        screenshotUris: string[];
        /**
         * The list of Links provided for the item.
         */
        links: LinkProperties[];
        /**
         * The dictionary of icon image Uris by icon type.
         */
        iconFileUris: StringMap<string>;
        /**
         * The dictionary of additional properties to be displayed.
         */
        properties?: StringMap<string>;
        /**
         * Gallery item products.
         */
        products?: GalleryItemProduct[];
        /**
         * The marketing material used to link to other marketing portals.
         */
        marketingMaterial?: MarketingMaterial;
        /**
         * The dictionary of metadata properties to be used by the extension.
         */
        metadata?: StringMap<string>;
        /**
         * Indicates if the package is currently in preview.
         */
        isPreview?: boolean;
    }
    /**
     * The artifact type.
    */
    enum ArtifactType {
        /**
         * Template artifact type, used by CSM.
         */
        template = 0,
        /**
         * Fragment artifact type, used by CSM.
         */
        fragment = 1,
        /**
         * Custom artifact, consumed by the extension ownner.
         */
        custom = 3,
        /**
         * Metadata artifact, consumed by the extension ownner.
         */
        metadata = 4,
    }
    /**
     * Gallery artifact model.
     */
    interface Artifact {
        /**
         * The artifact name.
         */
        name: string;
        /**
         * The URI to the artifact file.
         */
        uri: string;
        /**
         * The artifact type.
         */
        type: string;
    }
    /**
     * The artifact type.
     */
    interface MarketingMaterial {
        /**
         * The path to the marketing material.
         */
        path: string;
    }
    /**
     * Link properties model.
     */
    interface LinkProperties {
        /**
         * The id of the link.
         */
        id: string;
        /**
         * The display name of the link.
         */
        displayName: string;
        /**
         * The URI of the link.
         */
        uri: string;
    }
    /**
     * Gallery product (offer) model.
     * NOTE: This interface is obsolete. Use MsPortalFx.Azure.ResourceManager.GalleryItemProduct instead.
     */
    interface GalleryItemProduct extends AzureResourceManager.GalleryItemProduct {
    }
    /**
     * Gallery offer pricing details model.
     * Used to retrieve the pricing information for a gallery offer.
     * NOTE: This interface is obsolete. Use MsPortalFx.Azure.ResourceManager.GalleryItemOfferPricingDetails instead.
     */
    interface GalleryItemOfferPricingDetails extends AzureResourceManager.GalleryItemOfferPricingDetails {
    }
    /**
     * Gallery offer plan.
     * NOTE: This interface is obsolete. Use MsPortalFx.Azure.ResourceManager.GalleryItemOfferPlan instead.
     */
    interface GalleryItemOfferPlan extends AzureResourceManager.GalleryItemOfferPlan {
    }
    /**
     * The model for gallery parameters. All values must be strings.
     */
    interface GalleryParameters {
        /**
         * The selected CSM template id.
         */
        selectedTemplateId: string;
        /**
         * The inline deployment template JSON.
         */
        templateJson: string;
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The resource group name.
         */
        resourceGroupName: string;
        /**
         * The location/region.
         */
        resourceGroupLocation: string;
        /**
         * An array of the resource types being created.
         * Use JSON.stringify() to convert the string[] into a string.
         */
        resourceProviders: string;
        /**
         * The resource id for the primary resource to be created.
         */
        primaryResourceId?: string;
        /**
         * The deployment name.
         */
        deploymentName?: string;
    }
    /**
     * The base gallery data model. The parameter collection data model on the UI
     * elements (forms, wizards, etc.) used for gallery create should extend this.
     */
    class GalleryDataModel {
        /**
         * The gallery deployment parameters.
         */
        galleryParameters: {
            selectedTemplateId: KnockoutObservable<string>;
            templateJson: KnockoutObservable<string>;
            subscriptionId: KnockoutObservable<string>;
            resourceGroupName: KnockoutObservable<string>;
            resourceGroupLocation: KnockoutObservable<string>;
            resourceProviders: KnockoutObservable<string>;
            primaryResourceId: KnockoutObservable<string>;
            deploymentName: KnockoutObservable<string>;
        };
    }
    /**
     * The context from which a gallery create is kicked off.
     * NOTE: This interface is obsolete. Use MsPortalFx.Azure.ResourceManager.LaunchingContext instead.
     */
    interface LaunchingContext extends AzureResourceManager.LaunchingContext {
    }
    /**
     * Gallery item information extracted from the gallery item and passed over to the extension.
     * NOTE: This interface is obsolete. Use MsPortalFx.Azure.ResourceManager.GalleryItemExtract instead.
     */
    interface GalleryItemExtract extends AzureResourceManager.GalleryItemExtract {
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Services\Services.GeneralSettings.d.ts
declare module MsPortalFx.Services {
    import FxBase = MsPortalFx.Base;
    interface IGeneralSettings extends StringMap<KnockoutObservableBase<any>> {
        /**
         * Current theme.
         */
        "fxs-theme": KnockoutReadOnlyObservableBase<FxBase.Themes.Theme>;
    }
    /**
     * Get general settings from Shell
     */
    function getSettings(): Base.PromiseV<IGeneralSettings>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Services\Services.Images.d.ts
declare module MsPortalFx.Services.Image {
    /**
     *  Datatype used for rendering SVGs.
     */
    function newImageData(type: SvgType, options?: any): MsPortalFx.Base.Image;
    /**
     * List of available SVG's. Shouldn't be needed under normal circumstances (unless you're adding new icons to the framework).
     */
    const enum SvgType {
        Blank = 0,
        Custom = 1,
        ImageUri = 2,
        ActiveDirectory = 3,
        Add = 4,
        BadgeError = 6,
        BadgeNone = 7,
        BadgeSuccess = 8,
        BadgeWarning = 9,
        Book = 10,
        Bug = 11,
        Check = 12,
        CloudService = 13,
        Controls = 14,
        Cubes = 15,
        Database = 16,
        Delete = 17,
        Disabled = 18,
        Discard = 19,
        Download = 20,
        Fallback = 21,
        Filter = 22,
        FolderBlank = 23,
        FolderCube = 24,
        FolderWebsite = 25,
        Ftp = 26,
        Gear = 27,
        Grid = 28,
        Guide = 29,
        Heart = 30,
        Hyperlink = 31,
        Info = 32,
        JourneyHub = 33,
        Key = 34,
        Link = 35,
        Location = 36,
        Lock = 37,
        Media = 38,
        MediaFile = 39,
        Mobile = 40,
        Monitoring = 41,
        Notification = 42,
        Pending = 43,
        Person = 44,
        PersonWithFriend = 45,
        Pin = 46,
        Powershell = 47,
        Properties = 48,
        Question = 49,
        QuickStart = 50,
        Refresh = 51,
        Save = 52,
        Search = 53,
        SearchGrid = 54,
        ShellClose = 55,
        ShellCollapse = 56,
        ShellDefaultBlade = 57,
        ShellMaximize = 58,
        ShellRestore = 59,
        SslCustomDomains = 60,
        Start = 61,
        Stop = 62,
        Storage = 63,
        Store = 64,
        Subtract = 65,
        Swap = 66,
        TeamProject = 67,
        Toolbox = 68,
        Unlock = 69,
        Unpin = 70,
        VirtualMachine = 71,
        Website = 72,
        WebsitePower = 73,
        Canceled = 74,
        Clock = 75,
        Clone = 76,
        Error = 77,
        InfoAlert = 78,
        Paused = 79,
        Queued = 80,
        AddTeamMember = 82,
        Attachment = 83,
        AvatarDefault = 84,
        AvatarUnknown = 85,
        Backlog = 86,
        BacklogPoly = 87,
        BadgePending = 88,
        BadgeCanceled = 89,
        BadgeDisabled = 90,
        BadgeUnknown = 91,
        BillingHub = 92,
        Builds = 93,
        Code = 94,
        CodePoly = 95,
        Commit = 96,
        CommitPoly = 97,
        Disable = 98,
        Edit = 99,
        Favorite = 101,
        File = 102,
        GearFlat = 103,
        GetMoreLicense = 104,
        GetStarted = 105,
        GitLogo = 106,
        GitLogoBox = 107,
        Go = 108,
        History = 109,
        Inactive = 110,
        InstallVisualStudio = 111,
        Log = 112,
        Pause = 113,
        Postpone = 114,
        Release = 115,
        Request = 116,
        Retain = 117,
        Scale = 118,
        Tasks = 119,
        Triangle = 120,
        Upload = 121,
        UnknownBadge = 122,
        VisualStudio = 123,
        VisualStudioLogoBox = 124,
        CreateHub = 125,
        BrowseHub = 126,
        HomeHub = 127,
        JourneysHub = 128,
        AlertsHub = 129,
        Help = 130,
        BadgeStopped = 131,
        Connect = 132,
        Disconnect = 133,
        PolyAppInsights = 135,
        PolyAvailabilitySet = 136,
        PolyBackup = 137,
        PolyBrowser = 138,
        PolyCustomDomain = 139,
        PolyGlobe = 140,
        PolyIpAddress = 141,
        PolyLaunchPortal = 142,
        PolyLoadBalancer = 143,
        PolyLoadTest = 144,
        PolyLog = 145,
        PolyLogDiagnostics = 146,
        PolyLogStreaming = 147,
        PolyNetworkInterfaceCard = 148,
        PolyResourceDefault = 149,
        PolyResourceLinked = 150,
        PolyServerFarm = 151,
        PolySqlDataBaseServer = 152,
        PolyTfsVcRepository = 153,
        PolyWebHosting = 154,
        PolyWebsiteStaging = 155,
        PolyWebTest = 156,
        Redo = 157,
        ShellChevron = 158,
        Tools = 159,
        Wrench = 160,
        AzureQuickstart = 161,
        Publish = 162,
        PolyAutomation = 164,
        PolySqlDatabase = 165,
        PolyTrafficManager = 166,
        PolyWebEnvironment = 167,
        PolyWebJobs = 168,
        ShellDots = 169,
        BadgeErrorOutline = 170,
        BadgeInfoOutline = 171,
        BadgeSuccessOutline = 172,
        BadgeWarningOutline = 173,
        DownloadFlat = 174,
        BadgeStoppedOutline = 175,
        Ellipsis = 176,
        ForPlacementOnly = 177,
        PolyClearDBDatabase = 178,
        PolyResourceGroup = 179,
        PolyWorkflow = 180,
        LogoBitbucket = 181,
        LogoBitbucketBox = 182,
        LogoCodePlex = 183,
        LogoCodePlexBox = 184,
        LogoDropbox = 185,
        LogoDropboxBox = 186,
        LogoGit = 187,
        LogoGitBox = 188,
        LogoGitHub = 189,
        LogoGitHubBox = 190,
        LogoVisualStudio = 191,
        LogoVisualStudioBox = 192,
        MonitoringFlat = 193,
        PolyCertificate = 194,
        PolyClock = 195,
        PolyControlsHorizontal = 196,
        PolyInputOutput = 197,
        PolyModule = 198,
        PolyPowerUp = 199,
        PolySupport = 200,
        PolyTrafficManagerDisabled = 201,
        PolyTrafficManagerEnabled = 202,
        PolyVersions = 203,
        TrendDown = 204,
        TrendUp = 205,
        Variables = 206,
        PolyResourceList = 207,
        PolyResourceGroupList = 208,
        BadgeUnknownOutline = 209,
        Commits = 210,
        HeartPulse = 211,
        LogoExternalRepositoryBox = 212,
        PolyDevConsole = 213,
        PolyProductionReadyDb = 214,
        PolyWebSlots = 215,
        PowerUp = 216,
        GuideFlat = 218,
        Support = 219,
        LogoMicrosoft = 220,
        ShellCornerCheck = 221,
        PolyGlobeError = 222,
        PolyGlobeSuccess = 223,
        PolyGlobeWarning = 224,
        InfoFlat = 225,
        Signout = 226,
        LaunchCurrent = 227,
        Feedback = 228,
        LogoRedis = 229,
        PolyCache = 230,
        PolyBlobBlock = 231,
        PolyBlobPage = 232,
        PolyStorageContainer = 233,
        PolyStorageQueue = 234,
        PolyTable = 235,
        WebHostingPlan = 236,
        PolyExtensions = 237,
        BadgeUpdateOutline = 238,
        Tag = 239,
        PolyBranch = 240,
        PolyChart = 241,
        EmoticonHappy = 242,
        PolyDiscs = 244,
        PolyVirtualNetwork = 245,
        Tags = 246,
        ShellGear = 247,
        SearchFlat = 248,
        GearAlternate = 249,
        PolyCounter = 250,
        PolyProcessExplorer = 251,
        BadgeFailed = 252,
        BadgeFailedOutline = 253,
        PolyFile = 254,
        PolyFiles = 255,
        PolyImage = 256,
        TripleArrow = 257,
        LogoMicrosoftSquares = 258,
        AddAlternate = 259,
        ArrowDown = 260,
        ArrowLeft = 261,
        ArrowRight = 262,
        ArrowUp = 263,
        Columns = 264,
        FolderAlternate = 265,
        FlatKey = 266,
        Mail = 267,
        Message = 268,
        Query = 270,
        SaveAll = 271,
        Undo = 272,
        ShellHeaderDots = 273,
        ErrorIcon = 274,
        Tour = 275,
        PolyManagementPortal = 276,
        LogoChannel9 = 277,
        LogoStackOverflow = 278,
        Diagnostics = 279,
        PolySSD = 280,
        ArrowWideDown = 281,
        ArrowWideUp = 282,
        Star = 283,
        Trash = 284,
        Globe = 285,
        CaretDown = 286,
        CaretUp = 287,
        ResourceRole = 288,
        ShellMinimize = 289,
        PolyStorageAzureFiles = 290,
        PolyPower = 291,
        BadgeCritical = 292,
        BadgeCriticalOutline = 293,
        Preview = 294,
        LoadingEllipsisSquare = 295,
        Customize = 296,
        Plus = 297,
        Collapse = 298,
        Expand = 299,
        AddBoxed = 300,
        PolyApiManagement = 301,
        PolyBizTalk = 302,
        PolyCdn = 303,
        PolyEventHub = 304,
        PolyMobileEngagement = 305,
        PolyOperationalInsights = 306,
        PolyRemoteApp = 307,
        PolyScheduler = 308,
        PolyServiceBus = 309,
        PolySiteRecovery = 310,
        PolyStorSimple = 311,
        PolyStreamAnalytics = 312,
        Hamburger = 313,
        ShellCustomize = 314,
        BadgeErrorSolid = 315,
        BadgeInfoSolid = 316,
        BadgeWarningSolid = 317,
        AddTile = 318,
        SmileyHappy = 319,
        SmileyNeutral = 320,
        SmileySad = 321,
        ShellMiniSize = 322,
        ShellFullscreen = 323,
        ShellShare = 324,
        ShellAdd = 325,
        ShellFilter = 326,
        ShellTrashOutline = 327,
        LoadingSpinner = 328,
        LoadingLoader = 329,
        ShellSave = 330,
        ShellPin = 331,
        PolyOwl = 332,
        Console = 333,
        AzurePortal = 334,
        RasterizedSvgMarker = 999,
        PartGalleryCollectionPartWithRollup = 1000,
        PartGalleryCollectionSummary = 1001,
        PartGalleryDonutChart = 1002,
        PartGalleryDonutChartPartial = 1003,
        PartGalleryExtensions = 1004,
        PartGalleryGridWithMoreData = 1005,
        PartGalleryMap = 1006,
        PartGalleryMultiLineChartMultiTrendLine = 1007,
        PartGalleryMultiScatterChart = 1008,
        PartGalleryMultiStackedBarChart = 1009,
        PartGalleryMutliLineChart = 1010,
        PartGalleryPricingTier = 1011,
        PartGalleryQuotaGauge = 1012,
        PartGalleryResourceMap = 1013,
        PartGallerySingleAreaChart = 1014,
        PartGallerySingleAreaChartSingleThreshold = 1015,
        PartGallerySingleAreaChartSingleTrendline = 1016,
        PartGallerySingleBarChartLarge = 1017,
        PartGallerySingleBarChartSmall = 1018,
        PartGallerySingleLineChart = 1019,
        PartGallerySingleScatterChart = 1020,
        PartGallerySingleScatterSingleThreshold = 1021,
        PartGallerySingleValueGauge = 1022,
        PartGallerySplitBarChart = 1023,
        PartGalleryStackedAreaChart = 1024,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Services\Services.Rpc.d.ts
declare module MsPortalFx.Services.Rpc {
    interface EndPointRegistrationOptions {
        /**
         * A list of extension names that can be allowed to invoke this RPC callback.
         * If a falsy value is specified then all extensions are allowed to invoke this callback.
         */
        allowedOrigins: string[];
    }
    /**
     * Registers the given callback with the given callback name. The callback will now be callable over RPC using this name.
     *
     * @param callbackName The callback name.
     * @param callback The callback function.
     */
    function registerCallback(callbackName: string, callback: Function, options?: EndPointRegistrationOptions): void;
    /**
     * Invokes the RPC endpoint with the given callback name in the given extension.
     *
     * @param extensionName The extension name.
     * @param callbackName The callback name.
     * @param args The args of the callback.
     */
    function invokeCallback<T>(extensionName: string, callbackName: string, ...args: any[]): MsPortalFx.Base.PromiseV<T>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Services\Services.ServiceProvider.d.ts
declare module MsPortalFx.Services {
    import FxBase = MsPortalFx.Base;
    class ObservableServiceClientImpl<T> implements MsPortalFx.Extension.ObservableServiceClient<T> {
        private _extension;
        private _scope;
        constructor(hostExtensionId: string, scope: string);
        /**
         * See interface.
         */
        getObservable(): FxBase.PromiseV<T>;
        /**
         * See interface.
         */
        releaseObservable(observable: T): void;
        /**
         * See interface.
         */
        dispose(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Services\Services.Telemetry.d.ts
/**
 * Telemetry logging facilities.
 */
declare module MsPortalFx.Services {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import Telemetry = FxBase.Diagnostics.Telemetry;
    import TelemetryEventProcessor = Telemetry.TelemetryEventProcessor;
    function getTelemetryEventProcessor(uri?: string, extensionName?: string): TelemetryEventProcessor;
    function getConsoleTelemetryEventProcessor(): TelemetryEventProcessor;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\SharedSettings.d.ts
declare module MsPortalFx.Settings {
    /**
     * Interface for shared settings that can be used by other extensions.
     */
    interface SharedSettings {
        links: SharedLinks;
    }
    /**
     * Interface for blade deep links or external links.
     */
    interface SharedLinks {
        /**
         * Link to the account portal.
         */
        accountPortal: string;
        /**
         * Link to the classic portal.
         */
        classicPortal: string;
        /**
         * Link to create support request.
         */
        createSupportRequest: string;
        /**
         * Link to open help and support.
         */
        helpAndSupport: string;
        /**
         * Link to manage support requests.
         */
        manageSupportRequests: string;
        /**
         * Link to provide feedback.
         */
        giveFeedback: string;
        /**
         * Link to privacy and terms.
         */
        privacyAndTerms: string;
        /**
         * Link to learn related resources.
         */
        learnRelatedResources: string;
        /**
         * Link to resource groups overview
         */
        resourceGroupOverview: string;
    }
    /**
     * Gets the shared settings that are used by other extensions as well
     *
     * @return The info for the currently signed in user and directory.
     */
    function getSharedSettings(): MsPortalFx.Base.PromiseV<MsPortalFx.Settings.SharedSettings>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\UI\UI.AssetManager.d.ts
declare module FxImpl.AssetManager {
    import RpcActionEndPointDefinition = MsPortalFx.Base.Rpc.Internal.ActionEndPointDefinition;
    const resourceAssetType: string;
    interface AssetTripletWithOptionalCloud extends MsPortalFx.Assets.AssetTriplet {
        cloudName?: string;
    }
    interface HubsNotifyAssetDeletedParameters extends AssetTripletWithOptionalCloud {
        reason?: string;
    }
    /**
     * Notifies the shell that one or more assets has been deleted.
     *
     * @param asset An array of asset triplets with optional cloud name.
     */
    const notifyAssetDeletedBulk: (assets: AssetTripletWithOptionalCloud[]) => void;
    /**
     * Notifies the shell that an asset has been deleted.
     *
     * @param assetType Type of the asset that was deleted.
     * @param assetId Identifier of the asset that was deleted.
     * @param extensionName Optional extension name of the asset that was deleted.
     * @param cloudName Optional cloud name of the asset that was deleted.
     */
    function notifyAssetDeleted(assetType: string, assetId: any, extensionName?: string, cloudName?: string): void;
    /**
     * Notifies the shell that one or more resources has been deleted.
     *
     * @param resourceId A single or an array of resource IDs.
     * @param cloudName Optional cloud name of the asset that was deleted.
     */
    function notifyResourceDeleted(resourceId: string | string[], cloudName?: string): void;
    const notifyAssetDeletedDefinition: RpcActionEndPointDefinition<AssetTripletWithOptionalCloud | AssetTripletWithOptionalCloud[]>;
    const createResourceDeletedEventInHubsDefinition: RpcActionEndPointDefinition<AssetTripletWithOptionalCloud | AssetTripletWithOptionalCloud[]>;
    const hubsNotifyAssetDeletedDefinition: RpcActionEndPointDefinition<HubsNotifyAssetDeletedParameters | HubsNotifyAssetDeletedParameters[]>;
}
declare module MsPortalFx.UI.AssetManager {
    /**
     * Notifies the shell that an asset has been deleted.
     *
     * @param assetType Type of the asset that was deleted.
     * @param assetId Identifier of the asset that was deleted.
     * @param extensionName Optional extension name of the asset that was deleted.
     */
    function notifyAssetDeleted(assetType: string, assetId: any, extensionName?: string): void;
    /**
     * Notifies the shell that one or more assets has been deleted.
     *
     * @param asset An array of asset triplets.
     */
    function notifyAssetDeletedBulk(assets: MsPortalFx.Assets.AssetTriplet[]): void;
    /**
     * Notifies the shell that one or more resources has been deleted.
     *
     * @param resourceId A single or an array of resource IDs.
     */
    function notifyResourceDeleted(resourceId: string | string[]): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\UI\UI.Feedback.d.ts
declare module FxImpl {
    import FxBase = MsPortalFx.Base;
    import FxRpc = FxBase.Rpc.Internal;
    interface OpenFeedbackPaneOptions {
        feedbackType: FeedbackType;
        resourceId?: string;
        data?: any;
    }
    const enum FeedbackType {
        Default = 0,
        ResourceDeleted = 1,
    }
    /**
     * The RPC endpoint for requesting  feedback by opening the context pane.
     */
    const feedbackEndPoint: FxRpc.ActionEndPointDefinition<OpenFeedbackPaneOptions>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\UI\UI.NotificationManager.d.ts
declare module FxImpl.NotificationManager {
    import Rpc = MsPortalFx.Base.Rpc.Internal;
    /**
     * Interface for the parameters to be used with the addNotificationEndPoint.
     */
    interface AddNotificationParameters {
        notifications: MsPortalFx.UI.NotificationManager.Notification[];
    }
    /**
     * Interface for the parameters to be used with the addNotification2EndPoint.
     */
    interface AddNotification2Parameters {
        id: string;
        name: string;
        status: string;
        subStatus: string;
        assetId: any;
        properties: StringMap<string>;
    }
    /**
     * Interface for the parameters to be used with the addNotification2EndPoint.
     */
    interface UpdateNotificationParameters {
        id: string;
        propertyName: string;
        propertyValue: any;
    }
    /**
     * Interface for server event.
     */
    interface ServerEvent {
        operationName: string;
        source: string;
        status: string;
        subStatus: string;
        correlationId: string;
        assetId: string;
        timestamp: Date;
        properties: StringMap<string>;
    }
    /**
     * Interface for the parameters to be used with the addServerEventsEndPoint.
     */
    interface AddServerEventsParameters {
        serverEvents: ServerEvent[];
        cloudName: string;
    }
    /**
     * The RPC endpoint that lets extensions send notifications.
     */
    var addNotificationsEndPoint: Rpc.ActionEndPointDefinition<AddNotificationParameters>;
    /**
     * The RPC endpoint that lets extensions send notifications.
     */
    var addNotification2EndPoint: Rpc.ActionEndPointDefinition<AddNotification2Parameters>;
    /**
     * The RPC endpoint that lets extensions update a notification.
     */
    var updateNotificationEndPoint: Rpc.ActionEndPointDefinition<UpdateNotificationParameters>;
    /**
     * The RPC endpoint that lets hubsextension send server events.
     */
    var addServerEventsEndPoint: Rpc.ActionEndPointDefinition<AddServerEventsParameters>;
    /**
     * Test dispatcher to use when if required when setting up senders.
     */
    var rpcClient: Rpc.Client;
}
declare module MsPortalFx.UI.NotificationManager {
    /**
     * The notification class.
     */
    class Notification2 {
        /**
         * The notification name.
         */
        private _name;
        /**
         * The autogenerated notification id.
         */
        private _id;
        /**
         * Creates a new notification. This should not be called directly, please use the create() method to create a new notification.
         *
         * @param name The name of the notification.
         */
        constructor(name: string);
        /**
         * Creates a new notification. This should not be called directly, please use the create() method to create a new notification.
         *
         * @param state The status and substatus of the notification.
         * @param assetId The asset id associated with the notification. It is only used if an asset type is specified for the notification.
         * @param properties The notification properties. This is used to format the description.
         */
        raise(state: {
            status: string;
            subStatus?: string;
        }, assetId?: any, properties?: StringMap<string>): void;
        /**
         * Updates the correlation id on the notification.
         *
         * @param correlationId The correlation id.
         */
        updateCorrelationId(correlationId: string): void;
        /**
         * Updates the progress of the notification. This is only shown when a progress notification is being shown.
         *
         * @param percentComplete The percent complete.
         */
        reportProgress(percentComplete: number): void;
    }
    /**
     * Creates a new notification with the specified name.
     *
     * @param notificationName The notification name defined in PDL.
     * @return Notification object.
     */
    function create(notificationName: string): MsPortalFx.UI.NotificationManager.Notification2;
    /**
     * The notification state.
     */
    enum NotificationState {
        /**
         * An information notification
         */
        Information = 0,
        /**
         * A warning notification
         */
        Warning = 1,
        /**
         * An error notification
         */
        Error = 2,
        /**
         * An in progress notification
         */
        InProgress = 3,
        /**
         * A success notification
         */
        Success = 4,
    }
    /**
     * The notification client details are properties on a notification which are client-local only and not stored
     * on the server. These properties should NOT be set when creating and adding notifications to the system.
     */
    interface NotificationClientDetails {
        /**
         * The asset owner for the notification.
         */
        assetOwner?: string;
        /**
         * The asset type for the notification.
         */
        assetType?: string;
        /**
         * The blade name override for the notification.
         */
        bladeName?: string;
        /**
         * The blade extension override for the notification.
         */
        bladeExtension?: string;
    }
    /**
     * The notification model.
     */
    class Notification {
        /**
         * The notification source which is a globally unique identifier.
         */
        source: string;
        /**
         * The notification event type. The combination of source.eventtype will uniquely identify a notification.
         */
        eventType: string;
        /**
         * The notification state - Information, Warning, Error, InProgress.
         */
        state: NotificationState;
        /**
         * The notification label. This should be localized by the formatter.
         */
        label: string;
        /**
         * The notification timestamp.
         */
        timestamp: Date;
        /**
         * The notification description. This will have a default message but this can be overridden by the
         * message provided by the extension.
         */
        description: string;
        /**
         * A list of arguments used to string.format() the description.
         * When the extension provides a description, these arguments will be used to format the description.
         */
        descriptionArgs: string[];
        /**
         * The subscription Id associated with the notification.
         */
        subscriptionId: string;
        /**
         * The operation Id of the operation associated with the notification. Any new notification that is added
         * with an existing operation id, will be updated instead of creating a new notification.
         */
        operationId: string;
        /**
         * The correlation Id of the operation associated with the notification. Any new notification that is added
         * with an existing operation id, will be updated instead of creating a new notification.
         */
        correlationId: string;
        /**
         * The percentage of operation completed. If this value exists, a deterministic progress bar is shown.
         * If not, a non-deterministic progress icon is shown with a description.
         */
        percentOperationComplete: number;
        /**
         * The asset id associated with the notification. This will be used to launch the resource blade when the
         * notification is clicked.
         */
        assetId: any;
        /**
         * Flag indicating if the notification is a recommendation.
         */
        isRecommendation: any;
        /**
         * Additional event details.
         */
        eventDetails: any;
        /**
         * Additional properties.
         */
        additionalProperties: any;
        /**
         * The client details are the client-side details for the notification which are not stored. These properties
         * should NOT be set when creating and adding notifications to the system.
         */
        clientDetails: NotificationClientDetails;
        /**
         * Creates a new notification.
         *
         * @param source The notification source. This will be a unique identifier for the source of this notification.
         * @param eventType The notification event type.
         * @param state The notification state. Can be information, warning, error or inprogress.
         * @param descriptionArgs The description arguments used to format this notification.
         * @param subscriptionId The subscription id of the notification.
         * @param operationId The operation id, if the notification is associated with an operation.
         * @param percentOperationComplete The %age of operation completed, used only if this operation state is in progress.
         * @param assetId The ID of the asset associated with this notification.
         */
        constructor(source: string, eventType: string, state: NotificationState, descriptionArgs?: string[], subscriptionId?: string, operationId?: string, percentOperationComplete?: number, assetId?: any);
    }
    /**
     * Adds a single notification to the UI.
     *
     * @param notification The notification to add.
     */
    function addNotification(notification: Notification): void;
    /**
     * Adds notifications to the UI.
     *
     * @param notifications The list of notifications to add.
     */
    function addNotifications(notifications: Notification[]): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Util\ColorUtil.d.ts
declare module MsPortalFx.ColorUtil {
    enum AllRawColorCode {
        "Hex_fcd116" = 0,
        "Hex_eb3c00" = 1,
        "Hex_ba141a" = 2,
        "Hex_b4009e" = 3,
        "Hex_442359" = 4,
        "Hex_002050" = 5,
        "Hex_0072c6" = 6,
        "Hex_008272" = 7,
        "Hex_007233" = 8,
        "Hex_7fba00" = 9,
        "Hex_a0a5a8" = 10,
        "Hex_fff100" = 11,
        "Hex_ff8c00" = 12,
        "Hex_e81123" = 13,
        "Hex_ec008c" = 14,
        "Hex_68217a" = 15,
        "Hex_00188f" = 16,
        "Hex_00bcf2" = 17,
        "Hex_00b294" = 18,
        "Hex_009e49" = 19,
        "Hex_bad80a" = 20,
        "Hex_bbc2ca" = 21,
        "Hex_fffc9e" = 22,
        "Hex_ffb900" = 23,
        "Hex_dd5900" = 24,
        "Hex_f472d0" = 25,
        "Hex_9b4f96" = 26,
        "Hex_4668c5" = 27,
        "Hex_6dc2e9" = 28,
        "Hex_00d8cc" = 29,
        "Hex_55d455" = 30,
        "Hex_e2e584" = 31,
        "Hex_d6d7d8" = 32,
        "Hex_807900" = 33,
        "Hex_804600" = 34,
        "Hex_740912" = 35,
        "Hex_760046" = 36,
        "Hex_34113d" = 37,
        "Hex_000c48" = 38,
        "Hex_005e79" = 39,
        "Hex_084c41" = 40,
        "Hex_063d20" = 41,
        "Hex_3d460a" = 42,
        "Hex_32383f" = 43,
        "Hex_bfb500" = 44,
        "Hex_bf6900" = 45,
        "Hex_ae0d1a" = 46,
        "Hex_b10069" = 47,
        "Hex_4e195c" = 48,
        "Hex_00126b" = 49,
        "Hex_008db5" = 50,
        "Hex_00856f" = 51,
        "Hex_0f5b2f" = 52,
        "Hex_8ba208" = 53,
        "Hex_464f59" = 54,
        "Hex_fcf37e" = 55,
        "Hex_ffba66" = 56,
        "Hex_f1707b" = 57,
        "Hex_f466ba" = 58,
        "Hex_a47aaf" = 59,
        "Hex_6674bc" = 60,
        "Hex_66d7f7" = 61,
        "Hex_66d1bf" = 62,
        "Hex_66c592" = 63,
        "Hex_d6e86c" = 64,
        "Hex_8f9ca8" = 65,
        "Hex_fffccc" = 66,
        "Hex_ffe8cc" = 67,
        "Hex_facfd3" = 68,
        "Hex_fbcce8" = 69,
        "Hex_e1d3e4" = 70,
        "Hex_ccd1e9" = 71,
        "Hex_ccf2fc" = 72,
        "Hex_ccf0ea" = 73,
        "Hex_ccecdb" = 74,
        "Hex_f0f7b2" = 75,
        "Hex_63707e" = 76,
        max = 77,
    }
    enum ColorCode {
        "a1" = 0,
        "b1" = 1,
        "c1" = 2,
        "d1" = 3,
        "e1" = 4,
        "f1" = 5,
        "g1" = 6,
        "h1" = 7,
        "i1" = 8,
        "j1" = 9,
        "k1" = 10,
        "a0" = 11,
        "b0" = 12,
        "c0" = 13,
        "d0" = 14,
        "e0" = 15,
        "f0" = 16,
        "g0" = 17,
        "h0" = 18,
        "i0" = 19,
        "j0" = 20,
        "k0" = 21,
        "a2" = 22,
        "b2" = 23,
        "c2" = 24,
        "d2" = 25,
        "e2" = 26,
        "f2" = 27,
        "g2" = 28,
        "h2" = 29,
        "i2" = 30,
        "j2" = 31,
        "k2" = 32,
        "a0s2" = 33,
        "b0s2" = 34,
        "c0s2" = 35,
        "d0s2" = 36,
        "e0s2" = 37,
        "f0s2" = 38,
        "g0s2" = 39,
        "h0s2" = 40,
        "i0s2" = 41,
        "j0s2" = 42,
        "k0s2" = 43,
        "a0s1" = 44,
        "b0s1" = 45,
        "c0s1" = 46,
        "d0s1" = 47,
        "e0s1" = 48,
        "f0s1" = 49,
        "g0s1" = 50,
        "h0s1" = 51,
        "i0s1" = 52,
        "j0s1" = 53,
        "k0s1" = 54,
        "a0t1" = 55,
        "b0t1" = 56,
        "c0t1" = 57,
        "d0t1" = 58,
        "e0t1" = 59,
        "f0t1" = 60,
        "g0t1" = 61,
        "h0t1" = 62,
        "i0t1" = 63,
        "j0t1" = 64,
        "k0t1" = 65,
        "a0t2" = 66,
        "b0t2" = 67,
        "c0t2" = 68,
        "d0t2" = 69,
        "e0t2" = 70,
        "f0t2" = 71,
        "g0t2" = 72,
        "h0t2" = 73,
        "i0t2" = 74,
        "j0t2" = 75,
        "k0t2" = 76,
        max = 77,
    }
    /**
     * Returns the RawColorString (#0072c6) that can be used in the css or less from the index of the color code.
     * Note: AllRowColorCode["Hex_fcd116"] === 0 and AllRowColorCode[0] === "Hex_fcd116"
     * For example:
     *   getRawColorString(ColorCode.a1) will return "#fcd116".
     * This is same as
     *   getRowColorString(AllRawColorCode.Hex_fcd116) will return "#fcd116".
     * This is because both ColorCode.a1 and AllRawColorCode.Hex_fcd116 both are 0.
     *
     * @param colorIndex Index of the color. Can be either ColorCode Enum or AllRowColorCode number.
     * @return Css style of color hex code string. For example: "#fcd116".
     */
    function getRawColorString(colorIndex: number): string;
    /**
     * Returns the ColorCode string ("a1") base on the index number.
     * Note: ColorCode["a1"] === 0 and ColorCode[0] === "a1"
     * For example:
     *   getColorCodeString(ColorCode.a1) will return "a1".
     * This is same as
     *   getColorCodeString(AllRawColorCode.Hex_fcd116) will return "a1".
     * This is because both ColorCode.a1 and AllRawColorCode.Hex_fcd116 both are 0.
     *
     * @param colorIndex Index of the color. Can be either ColorCode Enum or AllRowColorCode number or numeric number.
     * @return Ux string code. For example: "a1".
     */
    function getColorCodeString(colorIndex: number): string;
    /**
     * Returns the RawColorString (0072c6) that can be use in the data coding.
     * Handles all different possible form of hex color code and format of string.
     * For example:
     *   getRawColorCode("fcd116") will return "fcd116".
     *   getRowColorString("#fcd116") will return "fcd116".
     *   getRowColorString("Hex_fcd116") will return "fcd116".
     *   If not in the above format, it will return null.
     *
     * @param rawColorData String data of any hex string code.
     * @return Css color hex code string. For example: "fcd116".
     */
    function getRawColorCode(rawColorData: string): string;
    /**
     * Returns the RawColorIndex (0 base index) that can be used in for indexing ColorCode or RawColorCode.
     * For example:
     *   getRawColorIndex("fcd116") will return 0.
     *   getRowColorString("#fcd116") will return 0.
     *   getRowColorString("Hex_fcd116") will return 0.
     *   If not in the above format, it will return null.
     *
     * @param rawColorData String data of any hex string code.
     * @return Index for either Enum ColorCode or RawColorCode. For example: 0. This number will be less than 77 (max) if not, returns null.
     */
    function getRawColorIndex(rawColorData: string): number;
    /**
     * Returns the colorIndex (0 base index) that can be used in for indexing ColorCode or RawColorCode.
     * For example:
     *   getColorIndex("fcd116") will return 0.
     *   getColorIndex("#fcd116") will return 0.
     *   getColorIndex("Hex_fcd116") will return 0.
     *   getColorIndex("a1") will return 0.
     *
     *   If invalid data is given, it will return null.
     *
     * @param colorData String data of any hex string code.
     * @return Index for either Enum ColorCode or RawColorCode. For example: 0. This number will be less than 77 (max) if not, returns null.
     */
    function getColorIndex(colorData: string): number;
    /**
     * Returns the Array of the Tint set corresponding to this color code.
     * For example:
     *   getColorCodeTintSet("fcd116") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSet("#fcd116") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSet("Hex_fcd116") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSet("a1") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *
     *   If invalid data is given, it will return null.
     *
     * @param colorData String data of any hex string code. The can be "fcd116", "#fcd116", "Hex_fcd116", or "a1".
     * @param rawColorData Optional boolean indicates that if you want to get the rowColorData. If set, this function returns ["#807900","#bfb500","fff100", "#fcf37e", "#fffccc"] instead of ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     * @return Array of the color code. Typicically. ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     */
    function getColorCodeTintSet(colorData: string, rawColorData?: boolean): string[];
    /**
     * Returns the Array of the Tint set corresponding to this color code.
     * For example:
     *   getColorCodeTintSetIndex(0) will return [33,44, 11, 55, 66] which corresponds to ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSetIndex(11) will return [33,44, 11, 55, 66] which corresponds to ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSetIndex(22) will return [33,44, 11, 55, 66] which corresponds to ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *      ....   (0, 11, 22, 33, 44, 55, 66) all return the same set because they are same color system in MsColorWheel.
     *   If invalid data is given, it will return null.
     *
     * @param colorIndex Index of the color. Can be either ColorCode Enum or AllRowColorCode number.
     * @return Array of the color code index. Typicically. [33, 44, 11, 55, 66]
     */
    function getColorCodeTintSetIndex(colorIndex: number): number[];
    /**
     * Returns the main color wheel color (33) colors. This exclude the set of Tint/Shade.
     *
     * @return Array of the color code index. Typicically. [0, 1, 2, ..., 32]
     */
    function getAllColorCodeIndexes(): number[];
    /**
     * Returns the Array of ms color wheel color set with a start point. This is very useful for color wheel.
     * For example:
     *   getRotatedArray<number>([33,44, 11, 55, 66], 2) will return [11, 55, 66, 33, 44].
     *
     * @param data Array of color number, code, represents a color wheel.
     * @param start Index of start point.
     * @return Array of the color code index. Typicically. [33, 44, 11, 55, 66]
     */
    function getRotatedArray<T>(data: T[], start?: number): T[];
    /**
     * Returns the gradient color wheel color (27) colors index. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code index.
     */
    function getGradientColorCodeIndexes(start?: number): number[];
    /**
     * Returns the rainbow color wheel color (27) colors index. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Line Chart where the colors DO overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code index.
     */
    function getRainbowColorCodeIndexes(start?: number): number[];
    /**
     * Returns the gradient color wheel color (27) colors string. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code string array [a0,a1,b2,b0,c2,b1,c0,c1,d0,d1,e2,e0,e1,f1,f0,g1,g0,g2,h2,h0,h1,i1,i0,i2,j1,j0,j2,]
     */
    function getGradientColorCode(start?: number): string[];
    /**
     * Returns the gradient color wheel color (27) raw colors string. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code string array ["#fcd116", .....]
     */
    function getRawGradientColorCode(start?: number): string[];
    /**
     * Returns the gradient color wheel color (27) raw colors string. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code string array [a0,a1,b2,b0,c2,b1,c0,c1,d0,d1,e2,e0,e1,f1,f0,g1,g0,g2,h2,h0,h1,i1,i0,i2,j1,j0,j2,]
     */
    function getRainbowColorCode(start?: number): string[];
    /**
     * Returns the rainbow color wheel color (27) colors string.  This exclude the set of Tint/Shade.
     * Ux specifies this to used as default for the Donut and barChart where the color doesn't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @return Array of the color code string array ["#fcd116", .....]
     */
    function getRawRainbowColorCode(start?: number): string[];
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Util\Cryptography.d.ts
declare module FxImpl {
    import FxBase = MsPortalFx.Base;
    import FxRpc = FxBase.Rpc.Internal;
    module InternalCryptography {
        /**
         * Internal RPC endpoint to obtain a hmac sha256 token.
         */
        const getHmacSha256EndPoint: FxRpc.FuncEndPointDefinition<Cryptography.GetHmacSha256Options, string>;
    }
    module Cryptography {
        /**
         * Parameters that must be passed when calling the getHmacSha256 function.
         */
        interface GetHmacSha256Options {
            /**
             * The string to hash, can be any length.
             */
            stringToHash: string;
            /**
             * The key, encoded in base 64.
             */
            key: string;
            /**
             * DEPRECATED: use stringToHash instead.
             */
            stringToSign?: Obsolete;
        }
        /**
         * Returns an hmac sha256 token generated by hashing the provided string with the specified key.
         *
         * @param args Parameters required by the function.
         * @return A promise that resolves to a hmac sha256 hashed string.
         */
        function getHmacSha256(args: GetHmacSha256Options): FxBase.PromiseV<string>;
    }
}
declare module "Fx/Cryptography" {
    import Impl = FxImpl.Cryptography;
    export = Impl;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Util\DateUtil.d.ts
declare module MsPortalFx.DateUtil {
    /**
     * Used to specify date/time range in which user can select date/time.
     */
    class DateTimeRange {
        /**
         * Start date/time.
         */
        startDateTime: KnockoutObservable<Date>;
        /**
         * End date/time.
         */
        endDateTime: KnockoutObservable<Date>;
        /**
         * Timezone offset.
         */
        timezoneOffset: KnockoutObservable<number>;
        constructor(startDateTime?: Date, endDateTime?: Date, timezoneOffset?: number);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Util\UnitConversion.d.ts
declare module MsPortalFx.UnitConversion {
    import Fx = MsPortalFx;
    import FxUnitConversionUtil = Fx.UnitConversionUtil;
    import FxIntl = Fx.Intl;
    enum Unit {
        None = 0,
        Percentage = 1,
        Bytes = 2,
        Kilobytes = 3,
        Megabytes = 4,
        Gigabytes = 5,
        Terabytes = 6,
        Petabytes = 7,
        BytesPerDay = 8,
        BytesPerHour = 9,
        BytesPerMinute = 10,
        BytesPerSecond = 11,
        KilobytesPerSecond = 12,
        MegabytesPerSecond = 13,
        GigabytesPerSecond = 14,
        TerabytesPerSecond = 15,
        PetabytesPerSecond = 16,
        Count = 17,
        Thousand = 18,
        Million = 19,
        Billion = 20,
        Trillion = 21,
        MicroSeconds = 22,
        MilliSeconds = 23,
        Seconds = 24,
        Minutes = 25,
        Hours = 26,
        Days = 27,
        CountPerDay = 28,
        CountPerHour = 29,
        CountPerMinute = 30,
        CountPerSecond = 31,
        ThousandPerSecond = 32,
        MillionPerSecond = 33,
        BillionPerSecond = 34,
        TrillionPerSecond = 35,
        Bytes_SI = 36,
        Kilobytes_SI = 37,
        Megabytes_SI = 38,
        Gigabytes_SI = 39,
        Terabytes_SI = 40,
        Petabytes_SI = 41,
        BytesPerDay_SI = 42,
        BytesPerHour_SI = 43,
        BytesPerMinute_SI = 44,
        BytesPerSecond_SI = 45,
        KilobytesPerSecond_SI = 46,
        MegabytesPerSecond_SI = 47,
        GigabytesPerSecond_SI = 48,
        TerabytesPerSecond_SI = 49,
        PetabytesPerSecond_SI = 50,
    }
    /**
     * Returns the most appropriate unit for formatting the value.
     *
     * @param value The value to find the unit.
     * @param originalUnit The original unit of the value.
     * @param defaultZeroUnit Optionally specify the unit to display for 0 value. By default the 0 value will show the originalUnit.
     * @return The unit allowing to display the value shortly.
     */
    function getAppropriateUnit(value: number, originalUnit: Unit, defaultZeroUnit?: Unit): Unit;
    /**
     * Return the conversion factor from one unit to another.
     *
     * @param orignalUnit The original unit.
     * @param unit The unit to be converted to.
     * @return The conversion factor used to divide from the originalUnit to the unit.
     */
    function getConversionFactor(originalUnit: Unit, toUnit: Unit): number;
    /**
     * Returns a string representation of the Unit enum.
     *
     * @param unit The unit to be represented with a string.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @return The string representation.
     */
    function toString(unit: Unit, displaySIUnit?: boolean): string;
    /**
     * This API takes in a value of specified unit and auto converts to appropriate scaled unit and returns a globalized string with converted value and scaled unit.
     *
     * @param value The original value to be converted.
     * @param originalUnit The original unit of the value.
     * @param numberFormat Optional parameter specifying the globalized number format options for min/max precision. By default the API truncates to 2 decimal places.
     * @param displayFormat Optional display format to specify the converted value and scaled unit.
     *                      {0} is converted value
     *                      {1} is the string representation of target unit
     *                      default format is "{0} {1}". Eg. 256 KB
     * @param defaultZeroUnit Optionally specify the unit to display for 0 value. By default the 0 value will show the originalUnit.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @return The globalized string representation of auto scaled value and unit.
     */
    function getConvertedValue(value: number, originalUnit: Unit, numberFormat?: FxIntl.NumberFormatOptions, displayFormat?: string, defaultZeroUnit?: Unit, displaySIUnit?: boolean): string;
    /**
     * This API takes in a value of specified unit and converts to the specified target unit and returns a globalized string with converted value and target unit.
     *
     * @param value The original value to be converted.
     * @param originalUnit The original unit of the value.
     * @param toUnit The target unit to which the value should be converted.
     * @param numberFormat Optional parameter specifying the globalized number format options for min/max precision. By default the API truncates to 2 decimal places.
     * @param displayFormat Optional display format to specify the converted value and scaled unit.
     *                      {0} is converted value
     *                      {1} is the string representation of target unit
     *                      default format is "{0} {1}". Eg. 256 KB
     * @param defaultZeroUnit Optionally specify the unit to display for 0 value. By default the 0 value will show the toUnit.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @return The globalized string representation of auto scaled value and unit.
     */
    function getConvertedValueForTargetUnit(value: number, originalUnit: Unit, toUnit: Unit, numberFormat?: FxIntl.NumberFormatOptions, displayFormat?: string, defaultZeroUnit?: Unit, displaySIUnit?: boolean): string;
    /**
     * Convert MsPortal Unit to internal Unit which has expanded enumaration values.
     * MsPortal.UnitConversion.Unit have to keep the 0 base enum with no gap due to .d.ts generation which remove the number from the enum.
     * As result, MsPortal.UnitConversion.Unit should not be directly pass into the UnitConversionUtil routines.
     *
     * @param MsPortalFx.UnitConversion.Unit
     * @return MsPortalFx.UnitConversionUtil.Unit
     *
     * Note this odd looking code leverage TypeScript enum speciality.  TypeScript Enum setup 2 map
     *  map 1
     *   MsPortalFx.UnitConversion.Unit.Count === 17
     *   this is equvalient to
     *   MsPortalFx.UnitConversion.Unit["Count"] === 17
     *
     *   The reverse map: NumberMap.
     *   MsPortalFx.UnitConversion.Unit[17] === "Count"
     * This code leverage 2nd map.  In the above example, unitString get "Count", then we use utilUnit["Count"] to get the viva enum.
     */
    function _convertUnitToInternalConversionUnit(unit: Unit): FxUnitConversionUtil.Unit;
    /**
     * Converts the internal ConversionUnitUtil's Unit to public Unit.
     * MsPortal.UnitConversion.Unit have to keep the 0 base enum with no gap due to .d.ts generation which remove the number from the enum.
     * As result, MsPortal.UnitConversion.Unit should not be directly pass into the UnitConversionUtil routines.
     *
     * @param MsPortalFx.UnitConversionUtil.Unit
     * @return MsPortalFx.UnitConversion.Unit
     *
     * Note this odd looking code leverage TypeScript enum speciality.  TypeScript Enum setup 2 map
     *  map 1
     *   MsPortalFx.UnitConversion.Unit.Count === 17
     *   this is equvalient to
     *   MsPortalFx.UnitConversion.Unit["Count"] === 17
     *
     *   The reverse map: NumberMap.
     *   MsPortalFx.UnitConversion.Unit[17] === "Count"
     * This code leverage 2nd map.  In the above example, unitString get "Count", then we use utilUnit["Count"] to get the viva enum.
     */
    function _convertInternalConversionUnitToUnit(unit: FxUnitConversionUtil.Unit): Unit;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Util\UnitConversionUtil.d.ts
declare module MsPortalFx.UnitConversionUtil {
    /**
     * Defines units. This is internal Unit which has expanded/specific assigned enum values. Due to typescript compiler issue, another public Unit enum is exposed with sequential values.
     */
    enum Unit {
        None,
        Percentage,
        Bytes,
        Kilobytes,
        Megabytes,
        Gigabytes,
        Terabytes,
        Petabytes,
        BytesPerDay,
        BytesPerHour,
        BytesPerMinute,
        BytesPerSecond,
        KilobytesPerSecond,
        MegabytesPerSecond,
        GigabytesPerSecond,
        TerabytesPerSecond,
        PetabytesPerSecond,
        Count,
        Thousand,
        Million,
        Billion,
        Trillion,
        MicroSeconds,
        MilliSeconds,
        Seconds,
        Minutes,
        Hours,
        Days,
        CountPerDay,
        CountPerHour,
        CountPerMinute,
        CountPerSecond,
        ThousandPerSecond,
        MillionPerSecond,
        BillionPerSecond,
        TrillionPerSecond,
        Bytes_SI,
        Kilobytes_SI,
        Megabytes_SI,
        Gigabytes_SI,
        Terabytes_SI,
        Petabytes_SI,
        BytesPerDay_SI,
        BytesPerHour_SI,
        BytesPerMinute_SI,
        BytesPerSecond_SI,
        KilobytesPerSecond_SI,
        MegabytesPerSecond_SI,
        GigabytesPerSecond_SI,
        TerabytesPerSecond_SI,
        PetabytesPerSecond_SI,
    }
    /**
     * Returns the most appropriate unit for formatting the value. Used internally by various controls.
     *
     * @param value The value to find the unit.
     * @param originalUnit The original unit of the value.
     * @return The unit allowing to display the value shortly.
     */
    function getAppropriateUnit(value: number, originalUnit: Unit, defaultZeroUnit?: Unit): Unit;
    /**
     * Return the conversion factor from one unit to another.  Used internally by various controls.
     *
     * @param orignalUnit The original unit.
     * @param unit The unit to be converted to.
     * @return The conversion factor used to divide from the originalUnit to the unit.
     */
    function getConversionFactor(originalUnit: Unit, toUnit: Unit): number;
    /**
     * Returns a string representation of the Unit enum.  Used internally by various controls.
     *
     * @param unit The unit to be represented with a string.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @return The string representation.
     */
    function toString(unit: Unit, displaySIUnit?: boolean): string;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Util\Util.d.ts
declare module MsPortalFx {
    module Util {
        /**
         * Utility to map a knockout projected array to an observable array.
         * Knockout projection which returns observable of array while many view model exposes KnokoutObservableArray.
         * This utility will help in mapping the projected array to ObservableArray.
         *
         * @param mappedArray Knockout projected array.
         * @param lifetime The LifetimeManager reflecting the lifetime of the array that's returned.
         * @return returns KnockoutObservableArray.
         */
        function thunkArray<T>(lifetime: Base.LifetimeManagerBase, mappedArray: KnockoutObservableBase<T[]>): KnockoutObservableArrayDisposable<T>;
        class KnockoutDelayTrigger {
            /**
             * This is internal implementation
             */
            private _value;
            /**
             * Creates a KOUpdateTrigger with certain extension
             *
             * @param knockoutObserveExtend the knockout extend apply to this value observable
             */
            constructor(knockoutObserveExtend?: any);
            /**
             * This is the value to subscribe to the delay trigger.
             */
            value: KnockoutObservableBase<number>;
            touch(): void;
        }
        /**
         * Encodes html attribute string.
         *
         * @param value The string to encode.
         * @return The encoded string.
         */
        function encodeAttribute(value: string): string;
        /**
         * Encodes html string.
         *
         * @param value The string to encode.
         * @return The encoded string.
         */
        function encodeHtml(value: string): string;
        /**
         * Checks if the given object can be sent through postMessage().
         * E.g., postMessage() does not support functions, Errors, or DOM nodes.
         *
         * @param root The object to check.
         * @return True if the object can be sent through postMessage()
         */
        function canSendThroughPostMessage(root: any): boolean;
        /**
         * Compares two values.
         * Works for primative types string, date, number, and boolean.
         * Works for observables contining the primative types.
         *
         * @param value The value.
         * @param compareTo The compare to value.
         * @return An integer indicating if the value is greater or less than the compareTo.
         */
        function compare(value: any, compareTo: any): number;
        /**
         * Deprecated as of 4/2016.
         * Use MsPortalFx.initValue instead.
         */
        export import initValue = MsPortalFx.initValue;
        /**
         * Deprecated as of 4/20016.
         * Use MsPortalFx.initObservable instead.
         */
        export import initObservable = MsPortalFx.initObservable;
        /**
         * Deprecated as of 4/20016.
         * Use MsPortalFx.initObservable instead.
         */
        export import initObservableBase = MsPortalFx.initObservable;
        /**
         * Deprecated as of 4/20016.
         * Use MsPortalFx.initObservableArray instead.
         */
        export import initObservableArray = MsPortalFx.initObservableArray;
    }
    const initValue: <T>(value?: T, defaultValue?: T) => T;
    /**
     * Initializes an observable value.
     *
     * @param value The value to use.
     * @param defaultValue The value to use when value is undefined.
     * @return The initial observable value.
     */
    function initObservable<T>(value?: T | KnockoutObservable<T>, defaultValue?: T): KnockoutObservable<T>;
    /**
     * Initializes an observable value.
     *
     * @param value The value to use.
     * @param defaultValue The value to use when value is undefined.
     * @return The initial observable value.
     */
    function initObservable<T>(value?: T | KnockoutObservableBase<T>, defaultValue?: T): KnockoutObservableBase<T>;
    /**
     * Initializes an observable array of values.
     *
     * @param values The values to use.
     * @param defaultValues The values to use when values is undefined.
     * @return The initial observable values.
     */
    function initObservableArray<T>(values?: T[] | KnockoutObservableArray<T>, defaultValues?: T[]): KnockoutObservableArray<T>;
    /**
     * Initializes an observable array of values.
     *
     * @param values The values to use.
     * @param defaultValues The values to use when values is undefined.
     * @return The initial observable values.
     */
    function initObservableArray<T>(values?: T[] | KnockoutReadOnlyObservableArray<T>, defaultValues?: T[]): KnockoutReadOnlyObservableArray<T>;
}
declare module FxImpl {
    function setupRequire(requireBundle: RequireConfig, fxRequireBundle?: RequireConfig): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Utilities.d.ts
declare module MsPortalFx {
    function uncurryThis(f: (...args: any[]) => any): (...args: any[]) => any;
    const applyCall: (f: (...args: any[]) => any, target: any, args: any[] | IArguments) => any;
    const applyUncurry: (f: (...args: any[]) => any, target: any, args: any[] | IArguments) => any;
    /**
     * For testing only. Use Object.keys.
     */
    function _objectKeysPolyfill(o: any): string[];
    function forEachKey<T>(obj: StringMap<T>, iterator: (key: string, value: T) => void): void;
    function forEachKey<T>(obj: NumberMap<T>, iterator: (key: number, value: T) => void): void;
    /**
     * Shortcut for Object.keys(obj || {}).length.
     * @return number.
     */
    function keysLength(obj: Object): number;
    /**
     * Determines whether an object has properties on it.
     * Will return true for the following inputs: [], {}, "", 0, 1, true, false, new Date(), function() {}.
     * Will return false for the following inputs: [1], {a:1}, "123".
     * @return boolean.
     */
    function isEmpty(obj: Object): boolean;
    /**
     * Detect a value is Disposable.
     *
     * @param value The value to check against value.dispose is a function.
     * @return boolean.
     */
    function isDisposable(value: any): boolean;
    /**
     * call value.dispose() if a value is Disposable.
     *
     * @param value The value to call value.dispose()
     * @return boolean;
     */
    const disposeDisposable: (...values: any[]) => void;
    /**
     * Detect a value is null.
     *
     * @param value The value to check against null.
     * @return boolean.
     */
    function isNull(value: any): boolean;
    /**
     * Detect a value is undefined.
     *
     * @param value The value to check against undefined.
     * @return boolean.
     */
    function isUndefined(value: any): boolean;
    /**
     * Indicates whether the specified object is null or undefined.
     *
     * @param value The value to test.
     * @returns True if the value parameter is null or undefined; otherwise, false.
     */
    function isNullOrUndefined(value: any): boolean;
    /**
     * Indicates whether the specified object is not null or undefined.
     *
     * @param value The value to test.
     * @returns True if the value parameter is null or undefined; otherwise, false.
     */
    function notNullOrUndefined(value: any): boolean;
    /**
     * Checks if the string is null, undefined or whitespace.
     *
     * @param  value The target string.
     * @return true if the string is null, undefined or whitespace; otherwise, false.
     */
    function isNullOrWhiteSpace(value: string): boolean;
    interface IMap<K, V> extends Map<K, V> {
        delete(key: K): boolean;
        get(key: K): V;
        has(key: K): boolean;
        set(key: K, value: V): void;
        clear(): void;
        forEach(callbackfn: (value: V, index: K, map: IMap<K, V>) => void, thisArg?: any): void;
    }
    var Map: {
        new <K, V>(): Map<K, V>;
    };
    interface Memoized<TResult> {
        /**
         * Executes the memoized calback.
         *
         * @returns The memoized result.
         */
        (): TResult;
        /**
         * Disposes the memoized results.
         */
        dispose(): void;
    }
    interface MemoizedV<T, TResult> {
        /**
         * Executes the memoized calback.
         *
         * @returns The memoized result.
         */
        (input: T): TResult;
        /**
         * Disposes the memoized results.
         */
        dispose(): void;
    }
    /**
     * Memoize the specified callback.
     *
     * @param callback The function to memoize.
     * @returns The memoized function call.
     */
    function memoize<TResult>(callback: () => TResult): Memoized<TResult>;
    /**
     * Memoize the specified callback.
     *
     * @param callback The function to memoize.
     * @returns The memoized function call.
     */
    function memoize<T, TResult>(callback: (input: T) => TResult, cacheFactory?: () => IMap<T, TResult>): MemoizedV<T, TResult>;
    function require<T>(moduleId: string, localRequire?: LocalRequire, ignoreErrors?: boolean): Q.Promise<T>;
    /**
     * Firds the index of the first element of an array that matches the predicate.
     *
     * @param predicate The Predicate function.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you much pass in startIndex = (prevReturn - length -1)
     *
     * @return The first index that matches the predicate.
     */
    function findIndex<T>(array: T[], predicate?: (value: T, index: number, array: T[]) => boolean, startIndex?: number): number;
    /**
     * Finds the first element of an array that matches the predicate.
     *
     * @param predicate The Predicate function.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you much pass in startIndex = (prevReturn - length -1)
     *
     * @return The first element that matches the predicate.
     */
    function find<T>(array: T[], predicate?: (value: T, index: number, array: T[]) => boolean, startIndex?: number): T;
    /**
     * Returns the first element of the sequence.
     *
     * @return The element
     */
    function first<T>(array: T[]): T;
    /**
     * Returns the last element of the sequence.
     *
     * @return The element
     */
    function last<T>(array: T[]): T;
    /**
     * Removes all values that equal the given item and returns them as an array
     *
     * @param item The value to be removed.
     * @return The removed items.
     */
    function remove<T>(array: T[], itemOrPredicate: T | ((value: T) => boolean), startIndex?: number): T[];
    function pushUnique<T>(uniqueTarget: T[], source: T[], predicate?: (value1: T, value2: T) => boolean, sourceUnique?: boolean): T[];
    /**
     * Returns a unique set from this array based on the predicate.
     *
     * @param predicate The predicate function. Added to the result if the predicate returns false.
     * @return A new array with the unique values.
     */
    function unique<T>(array: T[], predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * Returns a unique concatenated set from this array and the given array based on the predicate.
     *
     * @param arrays The list of arrays to get union of.
     * @return A new array with the unique values.
     */
    function union<T>(...arrays: T[][]): T[];
    /**
     * Returns a unique concatenated set from this array and the given array based on the predicate.
     *
     * @param other The other array to concatenate with this one.
     * @param predicate The predicate function. Added to the result if the predicate returns false.
     * @return A new array with the unique values.
     */
    function union<T>(array: T[], other: T[], predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * Merge multiple T, T[] into a combine T[] exclude null or undefined arguments.
     *
     * @param data, a list fo T, T[]
     * @returns concattenated array.
     */
    var merge: <T>(...data: (T | T[])[]) => T[];
    /**
     * Projects each element of a sequence to a sequence and flattens the resulting sequences into one sequence.
     *
     * @param selector The projection function.
     * @return A flattened array.
     */
    function mapMany<T, TResult>(array: T[], selector: (source: T) => TResult[]): TResult[];
    /**
     * Sorts an array using a stable sort algorithm.
     *
     * This method returns a new array, it does not sort in place.
     *
     * @param compare The Compare function.
     * @return Sorted array.
     */
    function stableSort<T>(array: T[], compare: (a: T, b: T) => number): T[];
    /**
     * Extends from  a source array into an existing string map of key => item.
     *
     * @param objToExtend The target object to be extended.
     * @param sourceArray The source array to convert to a map properties of target object.
     * @param getKeyCallback The callback used to provide the key for the item.
     * @param getValueCallback The optional callback used to provide the key for the item, otherwise the item itself is used.
     * @param  onlyIfNotExist If true, only Extend the value in array if the existing slot is still undefine. (This behaves like type script argument default value, it only fill in if the value is undefined.)
     *
     * @return The string map of key => item for the source array.
     */
    function extendArrayIntoMap<T, U>(objToExtend: StringMap<U>, sourceItems: T[], getKeyCallback?: (item: T, index?: number) => string, getValueCallback?: (item: T, index?: number, key?: string) => U, onlyIfNotExist?: boolean): void;
    function extendArrayIntoMap<T, U>(objToExtend: NumberMap<U>, sourceItems: T[], getKeyCallback?: (item: T, index?: number) => number, getValueCallback?: (item: T, index?: number, key?: string) => U, onlyIfNotExist?: boolean): void;
    /**
     * Extends from  a source array into an existing string map of key => item.
     *
     * @param objToExtend The target object to be extended.
     * @param sourceArray The source array to convert to a map properties of target object.
     * @param getKeyCallback The callback used to provide the key for the item.
     * @param getValueCallback The optional callback used to provide the key for the item, otherwise the item itself is used.
     * @param  onlyIfNotExist If true, only Extend the value in array if the existing slot is still undefine. (This behaves like type script argument default value, it only fill in if the value is undefined.)
     *
     * @return The string map of key => item for the source array.
     */
    function extendStringMapIntoMap<T, U>(objToExtend: StringMap<U>, sourceItems: StringMap<T>, getValueCallback?: (item: T, key?: string) => U, onlyIfNotExist?: boolean): void;
    /**
     * Helpers funciton to create a object lightweight constructor
     *
     * @param keys the ordered argument keys
     *
     * @return The function that will return string map base on the arguments index order of keys
     */
    function getStringMapFunc(...keys: string[]): Func<StringMap<any>>;
    function getStringMapFunc(keys: string[]): Func<StringMap<any>>;
    /**
     * Helpers funciton to create a object lightweight constructor
     *
     * @param keys the ordered argument keys
     *
     * @return The function that will return string map base on the arguments index order of keys
     */
    function applyStringMapFunc(keys: string[]): Func<StringMap<any>>;
    /**
     * Helpers funciton to create a object of type NameValue<N, T>
     *
     * @param name name
     * @param value value
     *
     * @return an object of NameValue<N, T>
     */
    const getNameValue: <N, T>(name: N, value: T) => NameValue<N, T>;
    /**
     * Get a list of typeScript Enum into Array
     *
     * @param tsEnumeration The Type script Enum Array
     * @param sort optional whether to sort by enum's value
     * @return all NameValue<string, number>[] for this typeScriptEnum
     */
    function getEnumArray(tsEnumeration: any, sort?: boolean): NameValue<string, number>[];
    /**
     * Coerce an input into an array if it isn't already one.
     */
    function makeArray<T>(input: T | T[]): T[];
    /**
     * Checks if given dates are equal.
     *
     * @param left Left hand side date.
     * @param left Right hand side date.
     * @return True if left date is equal to right date.
     */
    function areEqualDates(left: any, right: any): boolean;
    /**
     * Round down the date.getTime() to seconds
     *
     * @param date.
     * @return the getTime in seconds
     */
    function toSeconds(date: Date): number;
    /**
     * Returns 'true' if 'data' is an observable array (including KnockoutObservableArray<T> and KnockoutObservableBase<T[]>).
     *
     * @param data The data.
     * @return 'true' if the supplied data is an observable array.
     */
    function isObservableArray(data: any): boolean;
    /**
     * Returns 'true' if 'data' is an array or observable array (including T[], KnockoutObservableArray<T> and KnockoutObservableBase<T[]>).
     *
     * @param data The data.
     * @return 'true' if the supplied data is an array or an observable array.
     */
    function isArrayOrObservableArray(data: any): boolean;
    /**
     * Returns a GUID such as xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx.
     *
     * @return New GUID.
     */
    const newGuid: () => string;
    /**
     * Returns a function that can generate globally unique identifiers.
     * Generates a new guid every 4096 calls and concatenates it with an
     * auto incrementing number.  This maintains a complient GUID 4 format
     * if no prefix is added.
     *
     * @return a globally unique string generating function.
     */
    function getUniqueIdGenerator(prefix?: string): () => string;
    /**
     * Returns a function that can generate unique id under the prefix
     * Concatenates prefix with an auto incrementing number.
     *
     * @return a unique string generating function which return a prefix with auto incrementing number
     */
    function getIdGenerator(prefix: string): () => string;
    /**
     * Returns a globally unique identifier string.
     * Lighter-weight than newGuid.
     *
     * @return a globally unique string.
     */
    const getUniqueId: () => string;
    /**
     * Rounds a number to the specified precision.
     *
     * @param number The number to round.
     * @param precision The precision to round the number to. Defaults to 0.
     * @returns The rounded number.
     */
    function round(number: number, precision?: number): number;
    /**
     * Truncates a number to the integer part.
     *
     * @param value The number to truncate.
     * @return The integer number.
     */
    function truncate(value: number): number;
    /**
     * Returns the result of the boolean exclusive-or operator.
     *
     * @param a First operand.
     * @param b Second operand.
     * @return true if the arguments have different values, false otherwise.
     */
    function xor(a: boolean, b: boolean): boolean;
    /**
     * Generates a random integer between min and max inclusive.
     *
     * @param min The minimum integer result.
     * @param max The maximum integer result.
     * @return A random integer.
     */
    function random(min: number, max: number): number;
    /**
     * Determines whether an object has a property with the specified name.
     * @param target the object to check.
     * @param v A property name.
     */
    const hasOwnProperty: (target: Object, v: string) => boolean;
    /**
     * Helper function to set a object property as observable if not exists, if is already an observable, set the observableValue.
     * @param obj the object to set property on .
     * @param key A property name.
     * @param value Optional,  of the observable will be. when not provided. this observable will reset to undefeined.
     */
    function setObjPropAsObservable(obj: StringMap<any>, key: string, value?: any): void;
    /**
     * Returns a boolean reflecting whether two scalar values (not object-typed, not array-typed, not function-typed)
     * are equal.  Accounts for the fact that JavaScript Date derives from Object.
     * The caller is responsible for supplying exclusively number-, string- or Date-typed values here.
     *
     * @param left The first scalar value.
     * @param right The second scalar value.
     * @return A boolean reflecting whether the two scalar values are equal.
     */
    function areEqual<T>(left: T, right: T): boolean;
    /**
     * Verifies that two arrays are equal.
     *
     * @param array1 The array to check.
     * @param array2 The array to compare the first array to.
     * @returns A value indicating whether or not the two arrays are equal.
     */
    function arrayEquals<T>(array1: T[], array2: T[]): boolean;
    function getTypeOf(x: any): string;
    function deepEquals<T>(a: T, b: T, peek?: boolean): boolean;
    /**
     * Checks if a given value is an object or not.
     *
     * @param value Value to test.
     * @return True if value is an object, false otherwise.
     */
    function isObject(value: any): boolean;
    /**
     * Maps each value of the input object. Values that map to null or undefined are skipped.
     *
     * @param obj Input object whose properties are to be mapped.
     * @param callback Invoked for each property of the object to perform the mapping.
     * @param arg An Optional value that can be passed to callback.
     * @return An array of mapped values.
     */
    function map<T, U>(obj: StringMap<T>, callback: (item: T, key?: string, arg?: any) => U, arg?: any): U[];
    /**
     * Shallow copy from a key/value pairs object.
     *
     * @param to An un-typed object to be populated.
     * @param from An un-typed object with values to populate.
     * @param scopes Scoped down the list for shallowCopy
     */
    function shallowCopyFromObject(to: Object, from: Object, scopes?: string[]): void;
    /**
     * Determines if the current string ends with the given string.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
     * http://jsperf.com/string-prototype-endswith/18
     *
     * @param input The input string.
     * @param searchString The characters to be searched for at the end of this string.
     * @param position Optional. Search within this string as if this string were only this long; defaults to this string's actual length, clamped within the range established by this string's length.
     * @return A value indicating whether or not the input string ends with the search string.
     */
    function endsWith(input: string, searchString: string, position?: number): boolean;
    /**
     * Compares the current string to another string and returns a value indicating their relative ordering.
     *
     * @param input The input string to compare.
     * @param other The value to compare the input string to.
     * @param locales The optional array of locale values that will be passed to localeCompare.
     * @param options The options supported by localeCompare.
     * @return 0, if the strings are equal; a negative number if the current string is ordered before value; a positive non-zero number if the current string is orered after value.
     */
    function localeCompareIgnoreCase(input: string, other: string, locales?: string[], options?: CollatorOptions): number;
    /**
     * Repeats the string the specified number of times.
     * @param input The input string.
     * @param count The number of times to repeat the string.
     * @returns The result string.
     *  http://jsperf.com/repeatstring2
     */
    function repeat(input: string, count: number): string;
    /**
     * reverse the string.
     * @param input The input string.
     * @returns The result string.
     */
    function reverse(input: string): string;
    /**
     * Return a function that will perform join with that separator
     *
     * @returns a function that will join the parts together with the character, for example.
     *   joinPaths = getJoinFunc("/");
     *   joinByDash = getJoinFunc("-");
     *
     *  joinPaths("a", "b", "c") will return  "a/b/c";
     *  joinByDash("a", "b", "c") will return  "a-b-c";
     */
    function getJoinFunc(sep: string): (...parts: string[]) => string;
    /**
     * Return a function that will perform quote the input.  (Mimizer helper).
     *
     * @returns a function that will join the parts together with the character(s).
        For example.
            quote = getQuoteFunc("'");
            parenthesis = getQuoteFunc("(", ")");
            poMarker = getQuoteFunc("####");
     *
     * quote("abc") will return "'abc'";
     * parenthesis("abc") will reutrn "(abc)";
     * poMarker("abc") will return "####abc####";
     */
    function getQuoteFunc(prefix: string, suffix?: string): (input: string) => string;
    /**
     * Replaces all instances of a value in a string.
     *
     * @param input The input string.
     * @param searchValue The value to replace.
     * @param replaceValue The value to replace with.
     * @return A new string with all instances of searchValue replaced with replaceValue.
     */
    function replaceAll(input: string, searchValue: string, replaceValue: string): string;
    /**
     * Replaces multiple instances of search values and replacement values in a string.
     *
     * @param input The input string.
     * @param replacementMap A string map where each key represents the string to replace, and that key's value represents the value to replace it with.
     * @return A new string with replacementMap values replaced.
     */
    function replaceMany(input: string, replacementMap: StringMap<string>): string;
    /**
     * Splits a string into the specified number of parts.
     * Differs from string.split in that it leaves the last part containing the remaining string (with separators in it).
     * string.split truncates the extra parts.
     * @param input The string to be split.
     * @param separator A string that identifies the character or characters to be used as the separator.
     * @param limit A value used to limit the number of elements returned in the array.
     * @return An array of strings whose length is at most the value of limit.
     */
    function split(input: string, separator: string, limit: number): string[];
    /**
     * Determines if the current string starts with the given string.
     * http://jsperf.com/string-startswith/49
     *
     * @param input The input string.
     * @param searchString The characters to be searched for at the start of this string.
     * @param position Optional. The position in this string at which to begin searching for searchString; defaults to 0.
     * @return A value indicating whether or not the input string begins with the search string.
     */
    function startsWith(input: string, searchString: string, position?: number): boolean;
    /**
     * Trims all occurrences of the given set of strings off the end of the input.
     */
    function trimEnd(input: string, ...values: string[]): string;
    /**
     * Trims all occurrences of the given set of strings off the start of the input.
     */
    function trimStart(input: string, ...values: string[]): string;
    /**
     * Ensures that the given string ends with the suffix provided.
     * If it already does, it just returns the input string.
     * If it does not, then the suffix is appended and the result is returned.
     */
    function ensureSuffix(input: string, suffix: string): string;
    /**
     * Ensures that the given string starts with the prefix provided.
     * If it already does, it just returns the input string.
     * If it does not, then the prefix is applied and the result is returned.
     */
    function ensurePrefix(input: string, prefix: string): string;
    /**
     * Joins strings in the components array with the specified separator between them.
     * Ignores empty/falsy entries in the components array.
     * If a leading (or trailing) separator is desired, prefix (or suffix)
     * the array of components with an entry that is a separator.
     */
    function pathJoin(pathSeparator: string, ...pathComponents: string[]): string;
    function pathJoin(pathSeparator: string, pathComponents: string[]): string;
    /**
     * Parse an uri and return the Authority of the uri.
     *
     * @param uri The string of uri.
     * @return Authority of the uri.
     */
    function getUriAuthority(uri: string, includePort?: boolean): string;
    /**
     * Verify if one Url is subdomain of another Url.
     *
     * @param domain The string of domain.
     * @param subdomain The string of subdomain
     * @return True if subdomain is subdomain of domain.
     */
    function isSubdomain(domain: string, subdomain: string): boolean;
    /**
     * Returns whether the given URI is an absolute URI.
     *
     * @param uri The URI.
     * @return A boolean value indicating whether the URI is absolute.
     */
    function isUriAbsolute(uri: string): boolean;
    /**
     * Attempts to execute on fulfill or on reject callbacks immediately if the promise is already resolved or rejected,
     * or waits for the resolution or the rejection otherwise.
     *
     * @param promise The promise expected to be resovled or rejected.
     * @param onFulfill The callback to be executed if resolved.
     * @param onReject The callback to be executed if rejected.
     * @return The callback result.
     */
    function tryImmediateResolve(promise: Q.Promise<any>, onFulfill: (value: any) => any, onReject?: (reason?: any) => any): any;
    /**
     * Attempts to execute the callback if the promise is already resolved or rejected,
     * otherwise, waits for the promise resolution or rejection.
     *
     * @param promise The promise to be resolved or rejected.
     * @param onFinally The callback to be executed.
     */
    function tryImmediateFinally(promise: Q.Promise<any>, onFinally: () => any): void;
    /**
     * Resolves the given deferred when the observable has a value set with that value.
     * Resolves the deferred immediately if a value is already set with that value.
     * Rejects the deferred when the given lifetime manager disposes its disposables.
     *
     * @param deferred The deferred.
     * @param lifetime The lifetime manager.
     * @param observable The observable.
     * @return The deferred.
     */
    function resolveWhen<T>(deferred: Q.Deferred<T>, lifetime: Base.LifetimeManager, observable: KnockoutObservableBase<T>): Q.Deferred<T>;
    function resolveWhen<T>(deferred: JQueryDeferredV<T>, lifetime: Base.LifetimeManager, observable: KnockoutObservableBase<T>): JQueryDeferredV<T>;
    /**
     * Escapes regular expression special characters -[]/{}()*+?.\^$|
     *
     * @param str The string to escape.
     * @return The escaped string.
     */
    function regexEscape(str: string): string;
    /**
     * No-op function.
     */
    const noop: () => void;
    /**
     * Returns whether the given data is primitive data type.
     * ECMAScript 6 standard defines 6 primitive data types: Boolean, Null, Undefined, Number, String, Symbol(new in ECMAScript 6)
     *
     * @param data The input data.
     * @return A boolean value indicating whether the data is primitive data type.
     */
    function isPrimitive(data: any): boolean;
    /**
     * Applies polyfills as properties to the prototype of the given object.
     * If force is specified the polyfills will overwrite any existing properties.
     */
    function polyfill(type: {
        prototype: Object;
    }, fills: Object, force?: boolean): void;
    /**
     * Get a readonly map that is a faster alternative to cast a string to small and non-negative integers.
     * - Doesn't support negative integer since the performance is significantly decreased for negative integer.
     * - The JSperf links: http://jsperf.com/int-to-string-map/4, http://jsperf.com/cast-int-to-string-in-loop.
     *
     * The StringToIntMap is mainly used to convert string to const enum. For example:
     * const enum Fruit {
     *   Unknown = 0,
     *   Apple = 1,
     *   Banana = 2,
     *   Max = 3
     * }
     * var stringToIntMap = utilities.getStringToIntMap(Fruit.Max);
     * strictEqual(stringToIntMap["1"], Fruit.Apple);
     * strictEqual(stringToIntMap["2"], Fruit.Banana);
     *
     * @param requiredMaxInteger The required max integer.
     * @returns The object have one to one mapping between the string and the corresponding integer. e.g. {"0":0,"1":1,"2":2,"3":3,"4":4, ... }.
     */
    function getIntToStringMap(requiredMaxInteger: number): string[];
    /**
     * Get a readonly map that is a faster alternative to cast a small and non-negative integer to string.
     * - Doesn't support negative integer since the performance is significantly decreased for negative integer.
     * - The JSperf links: http://jsperf.com/parseint-vs-map-lookup/2, http://jsperf.com/parseint-vs-map-lookup-2
     *
     * The intToStringMap is mainly used to convert const enum to string. For example:
     * const enum Fruit {
     *     Unknown = 0,
     *     Apple = 1,
     *     Banana = 2,
     *     Max = 3
     * }
     *
     * var stringToIntMap = utilities.getStringToIntMap(Fruit.Max);
     * strictEqual(intToStringMap[Fruit.Unknown], "0");
     * strictEqual(intToStringMap[Fruit.Apple], "1");
     *
     * @param requiredMaxInteger The required max integer.
     * @returns The array to have increment integer in string representation. e.g. ["0","1","2","3","4", ...].
     */
    function getStringToIntMap(requiredMaxInteger: number): StringMap<number>;
    /**
     * Makes a shallow clone of the source object with the same prototype and rebinds all functions
     * on the clone to use the source object as 'this'.
     *
     * @param object The source object.
     * @return The cloned object.
     */
    function cloneAndRebindFunctions<T>(object: T): T;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ActionBars\ViewModels.ActionBarBase.d.ts
declare module MsPortalFx.ViewModels.ActionBars.Base {
    /**
     * The style for the secondary link.
     */
    const enum SecondaryLinkStyle {
        /**
         * Leave the secondary link unstyled.
         */
        Unstyled = 0,
        /**
         * Shows the secondary link as a bottom banner.
         */
        BottomBanner = 1,
    }
    /**
     * Specifies the status of the operation.
     */
    const enum Status {
        /**
         * Indicates that the operation in the enclosing blade is not started.
         */
        NotStarted = 0,
        /**
         * Indicates that the operation in the enclosing blade is in progress.
         */
        InProgress = 1,
        /**
         * Indicates that the operation in the enclosing blade is in an erroneous state.
         */
        Error = 2,
        /**
         * Indicates that the operation in the enclosing blade is completed.
         */
        Completed = 3,
    }
    /**
     * Specifies the action to be taken.
     */
    const enum Action {
        /**
         * No action should be taken.
         */
        None = 0,
        /**
         * Go to the previous step.
         */
        Previous = 1,
        /**
         * Go to the next step.
         */
        Next = 2,
        /**
         * Skip and go to the next step.
         */
        Skip = 3,
        /**
         * Complete the wizard.
         */
        Complete = 4,
        /**
         * Cancel the action.
         */
        Cancel = 5,
    }
    interface InputOutputBase {
        /**
         * The status of the operation.
         */
        status: Status;
        /**
         * The ID uniquely identifying the create step.
         */
        stepId?: string;
    }
    /**
     * Specifies the source of the action/click.
     */
    const enum ActionSource {
        /**
         * The primary/default button.
         */
        Default = 0,
        /**
         * The secondary link.
         */
        SecondaryLink = 1,
    }
    interface ActionBarInput extends InputOutputBase {
        /**
         * A value indicating whether this is the first step.
         */
        isFirstStep?: boolean;
        /**
         * True if this is the last step in a create flow; else false.
         */
        isLastStep?: boolean;
        /**
         * A value indicating whether the step is optional.
         */
        isOptional?: boolean;
        /**
         * A value indicating whether or not the step is disabled.
         * This value specifies whether or not there are any prerequisite steps that have not been completed.
         */
        disabled?: boolean;
    }
    interface ActionBarOutput extends InputOutputBase {
        /**
         * The action to perform.
         */
        action: Action;
        /**
         * A unique id to track changes.
         */
        commitId?: string;
    }
    interface Contract extends Controls.Loadable.Contract {
        /**
         * Indicates whether the blade enclosing the action bar is valid.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * The input data for the current step.
         */
        input: KnockoutObservable<ActionBarInput>;
        /**
         * The data outputted by the current step.
         */
        output: KnockoutObservable<ActionBarOutput>;
    }
    /**
     * Checks if the specified wizard/form/selector action is completed.
     *
     * @param actionBarOutput The output from the action bar for the wizard/form/selector to verify.
     * @return True if the action is completed; else false.
     */
    function isCompleted(actionBarOutput: any): boolean;
    /**
     * The view model class for Wizard portal control.
     */
    class ViewModel extends Controls.Loadable.ViewModel implements Contract {
        /**
         * See interface.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        input: KnockoutObservable<ActionBarInput>;
        /**
         * See interface.
         */
        output: KnockoutObservable<ActionBarOutput>;
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ActionBars\ViewModels.CreateActionBar.d.ts
declare module MsPortalFx.ViewModels.ActionBars.CreateActionBar {
    import FxBase = MsPortalFx.Base;
    enum ActionButtonText {
        /**
         * Shows the default action button text
         * 'Create' for provisioning blade and 'OK' for non-provisioning blade
         */
        Default = 0,
        /**
         * Change the action button text to 'Purchase'
         */
        Purchase = 1,
    }
    enum SecondaryLinkStyle {
        /**
         * Leave the secondary link unstyled.
         */
        Unstyled = 0,
        /**
         * Shows the secondary link as a bottom banner.
         */
        BottomBanner = 1,
    }
    interface ActionBarInput extends Base.ActionBarInput {
        /**
         * True, if user can choose whether provisioning happens on blade or startboard part.
         * Else false.
         */
        allowToggleProvisioningLocation: boolean;
        /**
         * True if the master part that opened the create blade is a provisioning part; else false.
         */
        masterIsProvisioningPart?: boolean;
    }
    interface ActionBarOutput extends Base.ActionBarOutput {
        /**
         * An optional link text used in create action bar scenarios.
         */
        secondaryLinkClicked?: string;
    }
    interface Options {
        /**
         * Optional. Hides the action bar.
         */
        hideActionBar?: boolean;
    }
    interface Contract extends ErrorInfoBoxActionBar.Contract {
        /**
         * INTERNAL USE ONLY
         * Indicates whether an action is in progress or not.
         * An action in progress will disable the action button regardless of its validity.
         */
        actionInProgress: KnockoutObservable<boolean>;
        /**
         * The input data for the current step.
         */
        input: KnockoutObservable<ActionBarInput>;
        /**
         * True, if the enclosing blade is used for provisioning; else false.
         */
        isProvisioningBlade: KnockoutObservable<boolean>;
        /**
         * True, if the enclosing blade should do provisioning; false, if provisioning should be done in a startboard part.
         */
        provisionOnStartboardPart: KnockoutObservable<boolean>;
        /**
         * True if the master part that opened the create blade is a provisioning part; else false.
         */
        masterIsProvisioningPart?: KnockoutObservable<boolean>;
        /**
         * The summary and/or link to the EULA for the create step.
         */
        eula: KnockoutObservable<string>;
        /**
         * The display text for the link to the right of the create button.
         */
        secondaryLinkDisplayText: KnockoutObservable<string>;
        /**
         * Boolean indicating if clicking on the secondary link should trigger validation.
         */
        secondaryLinkTriggerValidation?: KnockoutObservable<boolean>;
        /**
         * The display style for the link to the right of the create button.
         * The link can also be styled to show at the bottom as a banner, or other value according to the enum.
         */
        secondaryLinkStyle: KnockoutObservable<SecondaryLinkStyle>;
        /**
         * Disables the primary button on the action bar.
         */
        disablePrimaryButton?: KnockoutObservable<boolean>;
        /**
         * Triggers the select action.
         */
        triggerSelectAction: KnockoutObservable<string>;
        /**
         * Forces the an in progress status when the create button is clicked.
         */
        forceInProgressStatus: KnockoutObservable<boolean>;
        /**
         * The observable that populates the selector dropdown with the provided ViewModel. If not
         * provided, the dropdown is not shown.
         */
        dropDown?: KnockoutObservable<MsPortalFx.ViewModels.Forms.DropDown.ViewModel<any>>;
        /**
         * Shows/hides the action bar.
         */
        showActionBar: KnockoutObservable<boolean>;
        /**
         * If defined, clicking the action bar will launch a URI in a new window instead the default
         * behavior.
         */
        actionButtonUri?: KnockoutObservable<string>;
        /**
         * Specifies what the action button display text should be.
         */
        actionButtonLabel?: KnockoutObservable<ActionButtonText>;
    }
    class ViewModel extends ErrorInfoBoxActionBar.ViewModel implements Contract {
        /**
         * See interface.
         */
        actionInProgress: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        input: KnockoutObservable<ActionBarInput>;
        /**
         * See interface.
         */
        isProvisioningBlade: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        provisionOnStartboardPart: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        masterIsProvisioningPart: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        eula: KnockoutObservable<string>;
        /**
         * See interface.
         */
        secondaryLinkDisplayText: KnockoutObservable<string>;
        /**
         * See interface.
         */
        secondaryLinkTriggerValidation: KnockoutObservable<boolean>;
        /**
         * See interface
         */
        secondaryLinkStyle: KnockoutObservable<SecondaryLinkStyle>;
        /**
         * Disables the primary button on the action bar.
         */
        disablePrimaryButton: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        triggerSelectAction: KnockoutObservable<string>;
        /**
         * See interface.
         */
        forceInProgressStatus: KnockoutObservable<boolean>;
        /**
         * See interface.
        */
        dropDown: KnockoutObservable<Forms.DropDown.ViewModel<any>>;
        /**
         * See interface.
         */
        showActionBar: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        actionButtonUri: KnockoutObservable<string>;
        /**
         * See interface.
         */
        actionButtonLabel: KnockoutObservable<ActionButtonText>;
        /**
         * Creates a create action bar view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options The options to configure the create action bar.
         */
        constructor(lifetimeManager: FxBase.LifetimeManager, options?: Options);
        /**
         * See interface.
         */
        onInputsSet(inputs?: any): FxBase.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ActionBars\ViewModels.DeleteActionBar.d.ts
declare module MsPortalFx.ViewModels.ActionBars.DeleteActionBar {
    import ActionBarsBase = Base;
    /**
     * The actionbar output of the delete asset confirmation blade.
     */
    interface ActionBarOutput extends ActionBarsBase.ActionBarOutput {
        /**
         * The identifier of the user actions on the action bar.
         */
        userActionId: string;
    }
    interface Contract extends ActionBarsBase.Contract {
        /**
         * Callback to execute when the save button is clicked.
         */
        deleteButtonClick(): void;
        /**
         * Callback to execute when the save button is clicked.
         */
        cancelButtonClick(): void;
    }
    class ViewModel extends ActionBarsBase.ViewModel implements Contract {
        /**
         * See interface.
         */
        deleteButtonClick(): void;
        /**
         * See interface.
         */
        cancelButtonClick(): void;
        private _onButtonClicked(executed);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ActionBars\ViewModels.ErrorInfoBoxActionBar.d.ts
declare module MsPortalFx.ViewModels.ActionBars.ErrorInfoBoxActionBar {
    interface AsyncValidationResult extends ValidationResult {
        /**
         * Blade to open from the infobox
         */
        blade?: DynamicBladeSelection;
    }
    interface AsyncValidation {
        /**
         * Validation function returning a ValidationResult promise.
         *
         * @param source The source of the click (e.g. default button, secondary link, etc.).
         * @return A promise resolved with an async validation result object.
         */
        validate: (source: Base.ActionSource) => MsPortalFx.Base.PromiseV<AsyncValidationResult>;
    }
    interface GroupValidation extends AsyncValidation {
    }
    interface Contract extends Base.Contract {
        /**
         * Displays the error info box when the primary button is clicked and the form is invalid.
         */
        enableErrorInfoBox?: KnockoutObservable<boolean>;
        /**
         * If defined, the action bar will run this validation in addition to the form validation before submitting
         */
        groupValidation?: GroupValidation;
        /**
         * The action bar will run these validations (in addition to the form validation) before submitting.
         */
        asyncValidations: AsyncValidation[];
    }
    class ViewModel extends Base.ViewModel implements Contract {
        /**
         * Displays the error info box when the primary button is clicked and the form is invalid.
         */
        enableErrorInfoBox: KnockoutObservable<boolean>;
        /**
         * Hide the infobox when it shows the group validation error message
         */
        clearGroupValidationMessage(): void;
        /**
         * InfoBox selectable
         */
        infoBoxSelectable: MsPortalFx.ViewModels.Selectable<MsPortalFx.ViewModels.DynamicBladeSelection>;
        /**
         * Internal - handle to clear group validation message
         */
        _msPortalFxClearGroupValidationMessage: KnockoutObservable<() => void>;
        /**
         * The action bar will run these validations (in addition to the form validation) before submitting.
         */
        asyncValidations: AsyncValidation[];
        /**
         * If defined, the action bar will run this validation in addition to the form validation before submitting
         */
        groupValidation: GroupValidation;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ActionBars\ViewModels.FilterActionBar.d.ts
declare module MsPortalFx.ViewModels.ActionBars.FilterActionBar {
    interface Contract extends Base.Contract {
        /**
         * Callback to execute when the update button is clicked.
         */
        updateButtonClick(): void;
        /**
         * Callback to execute when the reset button is clicked.
         */
        resetButtonClick(): void;
    }
    class ViewModel extends Base.ViewModel implements Contract {
        /**
         * Callback to execute when the update button is clicked.
         */
        updateButtonClick(): void;
        /**
         * Callback to execute when the reset button is clicked.
         */
        resetButtonClick(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ActionBars\ViewModels.FormActionBar.d.ts
declare module MsPortalFx.ViewModels.ActionBars.FormActionBar {
    interface Contract extends Base.Contract {
        /**
         * Callback to execute when the save button is clicked.
         */
        saveButtonClick(): void;
        /**
         * Callback to execute when the save button is clicked.
         */
        discardButtonClick(): void;
    }
    class ViewModel extends Base.ViewModel implements Contract {
        /**
         * See interface.
         */
        saveButtonClick(): void;
        /**
         * See interface.
         */
        discardButtonClick(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ActionBars\ViewModels.GenericActionBar.d.ts
declare module MsPortalFx.ViewModels.ActionBars.GenericActionBar {
    import SecondaryLinkStyle = Base.SecondaryLinkStyle;
    interface ActionBarOutput extends Base.ActionBarOutput {
        /**
         * An optional link text used in create action bar scenarios.
         */
        secondaryLinkClicked?: string;
    }
    interface Contract extends ErrorInfoBoxActionBar.Contract {
        /**
         * The display text for the action button.
         */
        actionButtonLabel?: KnockoutObservable<string>;
        /**
         * If defined, clicking the action button will also launch a URI in a new window.
         * NOTE : this feature is not compatible with groupValidation & asyncValidations
         */
        actionButtonUri?: KnockoutObservable<string>;
        /**
         * If defined, specifies the value of the strWindowFeatures parameter to the
         * window.open call used to open the actionButtonUri.
         */
        actionButtonUriWindowFeatures?: KnockoutObservable<string>;
        /**
         * The summary html displayed on top of the action button.
         */
        actionSummaryHtml?: KnockoutObservable<string>;
        /**
         * Callback to execute when the action button is clicked.
         */
        actionButtonClick(): void;
        /**
         * True, if user can choose whether provisioning happens on blade or startboard part.
         * Else false.
         */
        allowToggleProvisioningLocation?: KnockoutObservable<boolean>;
        /**
         * The display text for the link to the right of the create button.
         */
        secondaryLinkDisplayText: KnockoutObservable<string>;
        /**
         * Boolean indicating if clicking on the secondary link should trigger validation.
         */
        secondaryLinkTriggerValidation?: KnockoutObservable<boolean>;
        /**
         * The display style for the link to the right of the create button.
         * The link can also be styled to show at the bottom as a banner, or other value according to the enum.
         */
        secondaryLinkStyle: KnockoutObservable<SecondaryLinkStyle>;
    }
    class ViewModel extends ErrorInfoBoxActionBar.ViewModel implements Contract {
        /**
         * Displays the error info box when the primary button is clicked and the form is invalid.
         */
        enableErrorInfoBox: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        actionButtonLabel: KnockoutObservable<string>;
        /**
         * See interface.
         */
        actionButtonUri: KnockoutObservable<string>;
        /**
         * See interface.
         */
        actionButtonUriWindowFeatures: KnockoutObservable<string>;
        /**
         * See interface.
         */
        actionSummaryHtml: KnockoutObservable<string>;
        /**
         * See interface.
         */
        actionButtonClick(): void;
        /**
         * See interface.
         */
        allowToggleProvisioningLocation: KnockoutObservable<boolean>;
        /**
        * See interface.
        */
        secondaryLinkDisplayText: KnockoutObservable<string>;
        /**
         * See interface.
         */
        secondaryLinkTriggerValidation: KnockoutObservable<boolean>;
        /**
         * See interface
         */
        secondaryLinkStyle: KnockoutObservable<SecondaryLinkStyle>;
        /**
         * See interface.
         */
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ActionBars\ViewModels.PickerActionBar.d.ts
declare module MsPortalFx.ViewModels.ActionBars.PickerActionBar {
    interface Contract extends Base.Contract {
        /**
         * Triggers the select action.
         */
        triggerSelectAction: KnockoutObservable<string>;
        /**
         * The summary and/or link to the EULA.
         */
        eula: KnockoutObservable<string>;
        /**
         * Indicates if the associated picker supports multiselect.
         */
        showSelectButton: KnockoutObservable<boolean>;
        /**
         * Optional. An alternate text to use for the select button label.
         */
        selectButtonText?: KnockoutObservable<string>;
    }
    class ViewModel extends Base.ViewModel implements Contract {
        /**
         * See interface.
         */
        triggerSelectAction: KnockoutObservable<string>;
        /**
         * See interface.
         */
        eula: KnockoutObservable<string>;
        /**
         * See interface.
         */
        showSelectButton: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        selectButtonText: KnockoutObservable<string>;
        /**
         * See interface.
         */
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ClickableLink.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model that represents a click target that opens a link.
     */
    class ClickableLink {
        /**
         * The URI that will be opened.
         */
        uri: KnockoutObservable<string>;
        /**
         * The link target. Target is _blank if unspecified.
         */
        target: KnockoutObservable<string>;
        /**
         * The callback triggered after the link is opened.
         *
         * @param keypress Indicates if the link is opened by keypress.
         */
        onLinkOpened: (keypress: boolean) => void;
        /**
         * Construct an instance of the view model.
         *
         * @param uri The URI that will be opened when target is clicked.
         * @param target The link target.
         */
        constructor(uri: KnockoutObservable<string>, target?: KnockoutObservable<string>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Commands\Command.d.ts
declare module MsPortalFx.ViewModels.Commands {
    interface Command<T> {
        /**
         * A value indicating whether or not the command can be executed.
         */
        canExecute: KnockoutObservableBase<boolean>;
        /**
         * Executes the specified command.
         *
         * @param context The context under which the command is executed.
         * @returns The promise for execution completion.
         */
        execute(context: T): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Composition\CompositionState.d.ts
declare module FxImpl.ViewModels {
    enum CompositionState {
        /**
         * The composition is ready to be bound and displayed.
         */
        Ready = 0,
        /**
         * The composition is in a failed state.
         */
        Failed = 1,
        /**
         * The composition has one or more operations in progress.
         */
        Preparing = 2,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Composition\ViewModels.Composition.d.ts
declare module FxImpl.ViewModels {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import FxPromise = FxBase.Promise;
    import FxImplExtension = FxImpl.Extension;
    const internalCloudNamePropertyName: string;
    /**
     * internal interface used by the shell
     */
    interface FrameworkViewModelContract {
        /**
         * selectables that are managed by the shell
         */
        selectable: KnockoutObservable<any>;
        /**
         * Indicates whether the part's UI may be blocked, e.g., because there are outstanding operations.
         */
        allowUiBlocking: KnockoutObservable<boolean>;
        /**
         * Specifies cloud name for static blade actions.
         * This property is only needed when a Hubs command/part has blade action(s) opening a Hubs blade.
         * During definition preprocessing, a cloud name blade input is added to blade action,
         * if the corresponding Hubs command/part has blade action(s) opening a Hubs blade.
         */
        cloudName?: KnockoutObservable<string>;
    }
    interface FrameworkPartViewModelContract extends FrameworkViewModelContract {
        /**
         * selectables dynamically registered by the view model.
         * this feature is only used by part view models currently.
         */
        registeredSelectables: KnockoutObservableBase<StringMap<MsPortalFx.ViewModels.Selectable<any> | MsPortalFx.ViewModels.SetSelection<any>>>;
        /**
         * options for registered selectables
         */
        registeredSelectableOptions: KnockoutObservableBase<StringMap<any>>;
        /**
         * Used to communicate Configuration changes back to the Shell.
         */
        updatedConfiguration: KnockoutObservableBase<UpdatedConfiguration>;
        /**
         * A mechanism that allows the part viewmodel to determine whether 'revealContent' was invoked
         * from the part's constructor, and to respond to subsequent calls.
         *
         * The name has the underscore prefix purely so it doesn't get proxied. We have no use for it
         * on the Shell side.
         */
        _revealContentCallCount: KnockoutObservable<number>;
        /**
         * A mechanism by which the PartContainer can be aware of 'updatePartInputValues' calls.
         *
         * @param inputs The inputs to the part.
         * @param settings The settings for the part.
         * @param inputsMetadata Metadata describing the current configuration state of the Part's inputs (used by its Configuration API).
         */
        _onInputValuesUpdated: (inputs: any, settings: any, inputsMetadata: FxImplExtension.InputsMetadata) => void;
        /**
         * If a blade was opened from the context menu this member ensures the PO layer has a reference
         * to the command so it is not freed too early.
         */
        activeOpenBladeCommand: KnockoutObservable<any>;
    }
    /**
     * Used to communicate Configuration changes back to the Shell.
     */
    interface UpdatedConfiguration {
        /**
         * Part inputs, possibly updated by the user by way of the Part's Configuration API.
         */
        inputs: any;
        /**
         * Part settings, possibly updated by the user by way of the Part's Configuration API.
         */
        settings: any;
        /**
         * Metadata describing the optional binding of Part inputs to properties on the enclosing Dashboard,
         * possibly updated by the user by way of the Part's Configuration API.
         */
        inputsMetadata: StringMap<UpdatedInputMetadata>;
    }
    /**
     * Used to communicate to the Shell changes to the binding of Part inputs to properties on the enclosing Dashboard.
     */
    interface UpdatedInputMetadata {
        /**
         * The name of the new, active binding source for this Part input (a property name on the containing Dashboard).
         */
        activeBindingSourceName?: string;
        /**
         * Directs the Shell to push the associated updated input value to the property on the containing Dashboard.
         */
        applyUpdatedValueToActiveBindingSource?: boolean;
    }
    /**
     * Tracing options for InputsSet.
     */
    interface CompositionViewModelTraceOptions {
        /**
         * Runtime identifier of the view model.
         */
        debugId: string;
        /**
         * Whether to break before onInputsSet is called.
         */
        breakOnInputsSet: boolean;
    }
    /**
     * The interface implemented by view models returned to the shell.
     * It is called the composition view model because it is
     * composed of objects provided by the framework and objects provided by the extension author.
     */
    interface CompositionViewModelContract<TContainer, TContent, TFramework extends FrameworkViewModelContract> {
        /**
         * The view model for the container of a composition.
         */
        container: TContainer;
        /**
         * The view model for the content of a composition.
         */
        content: TContent;
        /**
         * Private interface used by the shell.
         */
        internal: TFramework;
        /**
         * Triggers a call to the onInputsSet of the content view model if it is defined.
         *
         * @param parameters Inputs and options with which to update the view model.
         * @param settings Object with settings loaded for these set of inputs.
         * @param traceOptions Options to enable tracing during operation.
         * @param viewModelName An identifier for the composition item that can be used in diagnostic traces.
         * Configuration API).
         * @return The promise for the onInputsSet.
         */
        updatePartInputValues(inputs: any, settings?: any, traceOptions?: CompositionViewModelTraceOptions, viewModelName?: string): FxPromise;
        /**
         * Promise from onInputsSet, if that was called shortly after the view model was created.
         * Undefined otherwise.
         */
        onInputsSetPromise?: FxPromise;
    }
    function createFrameworkPartViewModel(): FrameworkPartViewModelContract;
    /**
     * The view model base class for all compositions.
     */
    class CompositionViewModelBase<ContainerType, ViewModelType, FrameworkType extends FrameworkViewModelContract> implements CompositionViewModelContract<ContainerType, ViewModelType, FrameworkType> {
        /**
         * The view model for the container of a composition.
         */
        container: ContainerType;
        /**
         * The view model for the content of a composition.
         */
        content: ViewModelType;
        /**
         * Private interface for shell functionality.
         */
        internal: FrameworkType;
        /**
         * If true, we know the internal cloud name property for blade actions has been created.
         */
        private _hadHubsInternalCloudNameProperty;
        constructor(internal: FrameworkType, container: ContainerType, content: ViewModelType, viewModelInitialState: any, createHubsInternalCloudNameProperty: boolean);
        /**
         * Triggers a call to the onInputsSet callbacks on the content and container view models where defined.
         * This is a abstract method and must be implemented by child classes.
         *
         * @param inputs The inputs to the part.
         * @param settings Object with settings loaded for these set of inputs.
         * @param traceOptions Options to enable tracing during operation.
         * @param viewModelName An identifier for the composition item that can be used in diagnostic traces.
         * @param inputsMetadata For Parts only, metadata describing the current configuration state of the Part's inputs (used by its
         * Configuration API).
         * @return The promise for the onInputsSet.
         */
        updatePartInputValues(inputs: any, settings?: any, traceOptions?: CompositionViewModelTraceOptions, viewModelName?: string, inputsMetadata?: FxImplExtension.InputsMetadata): FxPromise;
    }
    /**
     * The view model base class  for compositions which are not for parts
     */
    class CompositionViewModel extends CompositionViewModelBase<MsPortalFx.ViewModels.ContainerContract, any, FrameworkViewModelContract> {
        /**
         * The state of the composition.
         */
        state: KnockoutObservable<CompositionState>;
        constructor(container: MsPortalFx.ViewModels.ContainerContract, content: any, viewModelInitialState: any, createHubsInternalCloudNameProperty?: boolean);
        /**
         * Triggers a call to the onInputsSet callbacks on the content and container view models where defined.
         *
         * @param inputs The inputs to the part.
         * @param settings Object with settings loaded for these set of inputs.
         * @param traceOptions Options to enable tracing during operation.
         * @param viewModelName An identifier for the composition item that can be used in diagnostic traces.
         * @return The promise for the onInputsSet.
         */
        updatePartInputValues(inputs: any, settings?: any, traceOptions?: CompositionViewModelTraceOptions, viewModelName?: string): FxPromise;
    }
    function initializeSelectableSet(selectableSet: any, initialState: any): void;
    /**
     * Determines if the object has activatedItems and selectedItems collections.
     * We are looking for objects that are SelectableSet like.   Does not need to have all SelectableSet features to qualify.
     */
    function isSelectableSetLike(value: any): boolean;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Composition\ViewModels.Composition.Part.d.ts
declare module FxImpl.ViewModels.Part {
    import FxViewModels = MsPortalFx.ViewModels;
    import PartContract = FxViewModels.PartContract;
    import PartLocation = FxViewModels.PartLocation;
    interface ComposePartViewModelOptions {
        initialState?: any;
        createSelectable?: boolean;
        /**
         * If true, an internal property should be created for Hubs extension to flow cloud name around.
         */
        createHubsInternalCloudNameProperty?: boolean;
        location?: PartLocation;
    }
    function composePartViewModel<T>(viewModelFactory: (container: FxViewModels.PartContainerContract) => T, options?: ComposePartViewModelOptions): PartContract<T>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\AzureMediaPlayer.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.Unsupported.AzureMediaPlayer {
    interface Options {
        /**
        * Start playing the video automatically or not. Default is false.
        */
        autoplay?: boolean;
        /**
        * Should display the media playback controls. Default is true.
        */
        controls?: boolean;
        /**
        * Url of poster image shown before video is played.
        */
        poster?: string;
        /**
        * Azure media services logo display configuration.
        */
        logo?: LogoConfig;
        /**
        * Video source information for playback.
        */
        source: Source;
    }
    /**
    * Interface for the Logo of Azure media player
    */
    interface LogoConfig {
        /**
        * Displays Azure Media Services logo in the player. Default is false.
        */
        enabled?: boolean;
    }
    /**
    * Source object to hold the source information in Options.
    */
    interface Source {
        /**
        * Url of the media source
        */
        url: string;
        mimeType: StreamingFormatMimeType;
        /**
        * Protection information for encrypted media content
        */
        protectionInfo?: ProtectionInfo[];
    }
    /**
    * Interface for protection information of the Source.
    */
    interface ProtectionInfo {
        /**
        * Media protection type
        */
        type: ProtectionType;
        /**
        * Authentication token for protected media content
        */
        authenticationToken?: string;
    }
    /**
    * Protection types for Azure media player
    */
    enum ProtectionType {
        PlayReady = 0,
        Widevine = 1,
        AES = 2,
    }
    /**
    * Supported streaming MIME types in Azure media player
    */
    enum StreamingFormatMimeType {
        Smooth = 0,
        Dash = 1,
        HLS = 2,
        ProgressiveMP4 = 3,
    }
    class ViewModel extends Base.ViewModel implements Options {
        /**
         * See interface.
         */
        autoplay: boolean;
        /**
         * See interface.
         */
        controls: boolean;
        /**
         * See interface.
         */
        poster: string;
        /**
         * See interface.
         */
        logo: LogoConfig;
        /**
         * See interface.
         */
        source: Source;
        /**
         * Constructs an AzureMediaPlayer view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options Optional The set of options to configure the AzureMediaPlayer control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Balloon.d.ts
declare module MsPortalFx.ViewModels.Controls.Balloon {
    enum Position {
        /**
         * Display the balloon on top.
         */
        Top = 0,
        /**
         * Display the balloon on the right.
         */
        Right = 1,
        /**
         * Display the balloon on the bottom.
         */
        Bottom = 2,
        /**
         * Display the balloon on the left.
         */
        Left = 3,
    }
    interface Contract extends Loadable.Contract {
        /**
         * Whether the balloon is visible or not.
         */
        visible: KnockoutObservable<boolean>;
        /**
         * The box relative to which the balloon will be rendered.
         */
        box: KnockoutObservable<Box>;
        /**
         * The content to display the balloon. It can be empty if there's existing content in the element.
         */
        content: KnockoutObservable<string>;
        /**
         * The balloon link.
         */
        link: KnockoutObservable<Link>;
        /**
         * The position where the balloon will show around the element (Top, Right, Bottom, Left).
         */
        position: KnockoutObservable<Position>;
        /**
         * The amount to offset the pointer when the balloon is in a horizontal layout.
         */
        horizontalOffset: Offset;
        /**
         * The amount to offset the pointer when the balloon is in a vertical layout.
         */
        verticalOffset: Offset;
        /**
         * jQuery selector string representing the element to append the balloon element to.
         */
        appendTo: string;
        /**
         * Hides all the other balloons that have been previously opened when shown.
         */
        closeOtherBalloons: boolean;
    }
    class Link {
        /**
         * Link text.
         */
        linkText: string;
        /**
         * Link Uri.
         */
        linkUri: string;
        /**
         * Creates a Link class.
         *
         * @param linkText The link text to be displayed.
         * @param linkUri The link uri.
         */
        constructor(linkText?: string, linkUri?: string);
    }
    class Offset {
        /**
         * Pixel offset applied when the preferred layout is rendered.
         */
        preferred: number;
        /**
         * Pixel offset applied when the alternate layout is rendered (due to space constraints).
         */
        alternate: number;
        /**
         * Creates an Offset class.
         *
         * @param preferred The offset amount to apply when the preferred layout is chosen.
         * @param alternate The offset amount to apply when the alternate layout is chosen.
         */
        constructor(preferred?: number, alternate?: number);
    }
    class Box {
        /**
         * Vertical distance from the top of the document.
         */
        top: number;
        /**
         * Horizontal distance from the left of the document.
         */
        left: number;
        /**
         * Width of the box.
         */
        width: number;
        /**
         * Height of the box.
         */
        height: number;
        /**
         * Creates a Box class.
         *
         * @param top The horizontal offset from the top of the document.
         * @param left The vertical offset from the left of the document.
         * @param width The width of the box.
         * @param height The height of the box.
         */
        constructor(top?: number, left?: number, width?: number, height?: number);
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * See interface.
         */
        visible: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        box: KnockoutObservable<Box>;
        /**
         * See interface.
         */
        content: KnockoutObservable<string>;
        /**
         * The link to display in the balloon.
         */
        link: KnockoutObservable<Link>;
        /**
         * See interface.
         */
        position: KnockoutObservable<Position>;
        /**
         * See interface.
         */
        horizontalOffset: Offset;
        /**
         * See interface.
         */
        verticalOffset: Offset;
        /**
         * See interface.
         */
        appendTo: string;
        /**
         * See interface.
         */
        closeOtherBalloons: boolean;
        /**
         * Creates a balloon.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Base.d.ts
declare module MsPortalFx.ViewModels.Controls.Base {
    interface Contract extends MsPortalFx.Base.Disposable {
        /**
         * Enum that defines the type of the control.
         */
        controlType: ControlType;
    }
    class ViewModel implements Contract {
        /**
         * Enum that defines the type of the control.
         */
        controlType: ControlType;
        /**
         * Lifetime manager.
         */
        private _lifetimeManager;
        /**
         * Obsolete.  Do not use will be removed after 1/12/2017
         */
        _disposed: void;
        /**
         * Creates a Base ViewModel.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
        /**
         * Method that can be called to explicitly dispose of view model resources.
         */
        dispose(): void;
        /**
         * Lifetime manager instance that is disposed when the widget is disposed.
         */
        lifetimeManager: MsPortalFx.Base.LifetimeManager;
        /**
         * Populates the view model from a key/value pairs object.
         * The keys should map to properties on the view model.
         * The values are applied to the corresponding keys.
         *
         * @param object An untyped object with values to populate on the view model.
         */
        populateFromObject(object: Object): void;
        /**
         * Adds a subscription to be cleaned up in the dispose().
         *
         * @param disposable One KnockoutDisposable to be added to this._disposables.
         */
        _addDisposablesToCleanUp(disposable: MsPortalFx.Base.Disposable): void;
        /**
         * Adds a list of computed to be cleaned up in the dispose().
         *
         * @param disposable Array of KnockoutDisposable to be added to this._disposables.
         */
        _addDisposablesToCleanUp(disposable: MsPortalFx.Base.Disposable[]): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Base\Loadable.d.ts
declare module MsPortalFx.ViewModels.Controls.Loadable {
    interface Options {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled?: KnockoutObservable<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading?: KnockoutObservable<boolean>;
    }
    interface Contract extends MsPortalFx.ViewModels.Controls.Base.Contract {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled: KnockoutObservable<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading: KnockoutObservable<boolean>;
    }
    class ViewModel extends MsPortalFx.ViewModels.Controls.Base.ViewModel implements Contract {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled: KnockoutObservable<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading: KnockoutObservable<boolean>;
        /**
         * Creates a Base ViewModel.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param loading Default loading state.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
        /**
         * Creates a Base ViewModel.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param loading Default loading state.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, loading?: boolean);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Command.d.ts
declare module MsPortalFx.ViewModels.Controls.Command {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    /**
     * Command execution status.
     */
    enum Status {
        /**
         * Command has not been executed.
         */
        None = 0,
        /**
         * Command is in the process of executing.
         */
        Pending = 1,
        /**
         * Command execution succeded.
         */
        Success = 2,
        /**
         * Command execution failed.
         */
        Failure = 3,
    }
    /**
     * Command handler interface.
     */
    interface Handler {
        /**
         * Determines if the command is currently executable.
         */
        canExecute: KnockoutComputed<boolean>;
        /**
         * Executes the command.
         */
        execute: () => void | FxPromise;
    }
    /**
     * Command base view model interface.
     */
    interface Contract extends Loadable.Contract {
        /**
         * Indicates if the command should be displayed.
         * This can be changed  to hide/show the command.
         * It is up to UI consumers of the command to determine how to hide/show based on this value.
         */
        visible: KnockoutObservable<boolean>;
        /**
         * The command display text.
         * It is up to UI consumers of the command to determine how to show the text.
         */
        text: KnockoutObservable<string>;
        /**
         * The latest command status.
         */
        status: KnockoutObservable<Status>;
        /**
         * The latest command error.
         */
        error: KnockoutObservable<any>;
        /**
         * Handles the command execution.
         */
        handler: KnockoutObservable<Handler>;
        /**
         * Notification that command execution has occured.
         */
        afterExecute: () => void;
        /**
         * Executes the command.
         */
        execute(): FxPromise;
        /**
         * Attaches to the command.
         *
         * @param execute The command execution function.
         * @param canExecute The command availability function.
         */
        attach(execute?: () => void | FxPromise, canExecute?: () => boolean): void;
        /**
         * Detaches from the command.
         */
        detach(): void;
    }
    /**
     * Command base view model.
     */
    class ViewModel extends Loadable.ViewModel {
        /**
         * Indicates if the command should be displayed.
         * This can be changed  to hide/show the command.
         * It is up to UI consumers of the command to determine how to hide/show based on this value.
         */
        visible: KnockoutObservable<boolean>;
        /**
         * The command display text.
         * It is up to UI consumers of the command to determine how to show the text.
         */
        text: KnockoutObservable<string>;
        /**
         * The latest command status.
         */
        status: KnockoutObservable<Status>;
        /**
         * The latest command error.
         */
        error: KnockoutObservable<any>;
        /**
         * Handles the command execution.
         */
        handler: KnockoutObservable<Handler>;
        /**
         * Notification that command execution has occured.
         */
        afterExecute: () => void;
        /**
         * Creates a command view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param text The command text.
         * @param enabled The default enabled state.
         * @param visible The default visiblity.
         */
        constructor(lifetimeManager: FxBase.LifetimeManager, text?: string, execute?: () => void | FxPromise, canExecute?: () => boolean);
        /**
         * Executes the command.
         *
         * @return Callback promise for completion or failure.
         */
        execute(): FxPromise;
        /**
         * Attaches to the command.
         *
         * @param execute The command execution function.
         * @param canExecute The command availability function.
         */
        attach(execute: () => void | FxPromise, canExecute?: () => boolean): void;
        /**
         * Attaches handler to the command.
         *
         * @param handler The command handler to attach.
         */
        attachHandler(handler: Handler): void;
        /**
         * Detaches from the command.
         */
        detach(): void;
    }
    /**
     * Basic command handler implementation.
     */
    class DelegatingHandler implements Handler {
        /**
         * Indicates if the command can be executed.
         */
        canExecute: KnockoutComputed<boolean>;
        /**
         * Executes the command.
         */
        execute: () => void | FxPromise;
        /**
         * Creates a delegating command handler.
         *
         * @param execute The command execution function.
         * @param canExecute The command availability function. Can be left off or null if always true.
         * @param context The this context for the execute and canExecute callbacks.
         */
        constructor(execute: () => void | FxPromise, canExecute?: () => boolean, context?: any);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Console.d.ts
declare module MsPortalFx.ViewModels.Controls.Console {
    interface Contract extends Loadable.Contract {
        /**
         * Command output expose by the view model to be read by the console interface or backend service and executed.
         */
        command: KnockoutObservable<string>;
        /**
         * Creates text log displayed to the console log.
         */
        text: KnockoutObservable<string>;
        /**
         * Creates information log displayed to the console log.
         */
        info: KnockoutObservable<string>;
        /**
         * Creates success log displayed to the console log.
         */
        success: KnockoutObservable<string>;
        /**
         * Creates warning log displayed to the console log.
         */
        warning: KnockoutObservable<string>;
        /**
         * Creates error log displayed to the console log.
         */
        error: KnockoutObservable<string>;
        /**
         * Provides the text used for the CLI prompt.
         */
        prompt: KnockoutObservable<string>;
        /**
         * Changes from false to true when the console is ready.
         */
        isReady: KnockoutObservableBase<boolean>;
        /**
         * Clears the console.
         */
        clear: MsPortalFx.ViewModels.Controls.Command.Contract;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Command output expose by the view model to be read by the console interface or backend service and executed.
         */
        command: KnockoutObservable<string>;
        /**
         * Creates text log displayed to the console log.
         */
        text: KnockoutObservable<string>;
        /**
         * Creates information log displayed to the console log.
         */
        info: KnockoutObservable<string>;
        /**
         * Creates success log displayed to the console log.
         */
        success: KnockoutObservable<string>;
        /**
         * Creates warning log displayed to the console log.
         */
        warning: KnockoutObservable<string>;
        /**
         * Creates error log displayed to the console log.
         */
        error: KnockoutObservable<string>;
        /**
         * Provides the text used for the CLI prompt.
         */
        prompt: KnockoutObservable<string>;
        /**
         * Changes from false to true when the console is ready.
         */
        isReady: KnockoutReadOnlyObservable<boolean>;
        /**
         * Clears the console.
         */
        clear: MsPortalFx.ViewModels.Controls.Command.Contract;
        /**
         * Constructs a console view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ConsoleV2.d.ts
declare module MsPortalFx.ViewModels.Controls.Unsupported.ConsoleV2 {
    enum Color {
        /**
         * The text background color.
         */
        TextBackground = 1,
        /**
         * The text foreground color.
         */
        Text = 2,
        /**
         * The debug message color.
         */
        Debug = 3,
        /**
         * The informational or verbose message color.
         */
        Informational = 4,
        /**
         * The warning message color.
         */
        Warning = 5,
        /**
         * The error message color.
         */
        Error = 6,
        /**
         * Color Black.
         */
        Black = 101,
        /**
         * Color DarkBlue.
         */
        DarkBlue = 102,
        /**
         * Color Blue.
        */
        Blue = 103,
        /**
         * Color Green.
         */
        Green = 104,
        /**
         * Color Cyan.
         */
        Cyan = 105,
        /**
         * Color DarkGreen.
        */
        DarkGreen = 106,
        /**
         * Color DarkCyan.
         */
        DarkCyan = 107,
        /**
         * Color Gray.
         */
        Gray = 108,
        /**
         * Color DarkRed.
        */
        DarkRed = 109,
        /**
         * Color DarkMagenta.
        */
        DarkMagenta = 110,
        /**
         * Color DarkYellow.
         */
        DarkYellow = 111,
        /**
         * Color DarkGray.
         */
        DarkGray = 112,
        /**
         * Color Red.
        */
        Red = 113,
        /**
         * Color Magenta.
         */
        Magenta = 114,
        /**
         * Color Yellow.
         */
        Yellow = 115,
        /**
         * Color White.
        */
        White = 116,
        /**
         * Color LightSteelBlue.
         */
        LightSteelBlue = 201,
        /**
         * Color LightCyan.
         */
        LightCyan = 202,
        /**
         * Color Violet.
         */
        Violet = 203,
        /**
         * Color Moccasin.
         */
        Moccasin = 204,
        /**
         * Color PaleGreen.
         */
        PaleGreen = 205,
        /**
         * Color Bisque.
         */
        Bisque = 206,
        /**
         * Color Light Gray.
         */
        LightGray = 207,
        /**
         * Color PaleVioletRed.
         */
        PaleVioletRed = 208,
        /**
         * Color DarkSeaGreen.
         */
        DarkSeaGreen = 209,
        /**
         * Color OrangeRed.
         */
        OrangeRed = 210,
        /**
         * Color DarkOrange.
         */
        DarkOrange = 211,
        /**
         * Color WhiteSmoke.
         */
        WhiteSmoke = 212,
        /**
         * Color PowerShell background
         */
        PowerShellBackground = 213,
    }
    /**
     * The mode of command.
     */
    enum CommandMode {
        /**
         * User press Enter key.
         */
        Enter = 1,
        /**
         * User press Tab key.
         */
        Tab = 2,
        /**
         * User press Shift-Tab key.
         */
        ShiftTab = 3,
        /**
         * User press Cancel key.
         */
        Cancel = 4,
    }
    /**
     * The color palette.
     */
    interface ColorPalette {
        /**
         * The text background color.
         */
        textBackground?: Color;
        /**
         * The text foreground color.
         */
        text?: Color;
        /**
         * The debug message color.
         */
        debug?: Color;
        /**
         * The informational or verbose message color.
         */
        informational?: Color;
        /**
         * The warning message color.
         */
        warning?: Color;
        /**
         * The error message color.
         */
        error?: Color;
    }
    interface CommandInfo {
        /**
         * The command to submit.
         */
        text: string;
        /**
         * The command mode of submit.
         */
        mode: CommandMode;
        /**
         * The cursor position.
         */
        position: number;
    }
    interface WriteInfo {
        /**
         * The text to display.
         */
        textArray: string[];
        /**
         * The new line after display.
         */
        newline?: boolean;
        /**
         * The foreground color of the text.
         */
        foregroundColor?: Color;
        /**
         * The emphasis of the infomation in the text.
         */
        backgroundColor?: Color;
    }
    interface PromptInfo {
        /**
         * The prompt to display.
         */
        text: string;
        /**
         * The replacement charactor for password typing mode.
         */
        password?: string;
    }
    interface InputInfo {
        /**
         * The input text to the command line.
         */
        text: string;
        /**
         * The cursor position.
         */
        position: number;
    }
    interface Options {
        /**
         * Command output expose by the view model to be read by the console interface or backend service and executed.
         */
        command?: KnockoutObservableBase<(commandInfo: CommandInfo) => MsPortalFx.Base.Promise>;
        /**
         * Write text array to the console output.
         */
        write?: KnockoutObservableBase<WriteInfo>;
        /**
         * Display progress text to the console.
         */
        progress?: KnockoutObservableBase<WriteInfo>;
        /**
         * Provides the text used for the CLI prompt.
         */
        prompt?: KnockoutObservableBase<PromptInfo>;
        /**
         * Update the command line input text.
         */
        input?: KnockoutObservableBase<InputInfo>;
        /**
         * The number of lines to keep displayed in console history.
         */
        maxLines?: KnockoutObservableBase<number>;
        /**
         * The color palette.
         */
        colorPalette?: ColorPalette;
        /**
         * Clears the console.
         */
        clear?: MsPortalFx.ViewModels.Controls.Command.ViewModel;
    }
    class ViewModel extends Base.ViewModel {
        /**
         * Command output expose by the view model to be read by the console interface or backend service and executed.
         */
        command: KnockoutObservableBase<(commandInfo: CommandInfo) => MsPortalFx.Base.Promise>;
        /**
         * Write text array to the console output.
         */
        write: KnockoutObservableBase<WriteInfo>;
        /**
         * Display progress text to the console.
         */
        progress: KnockoutObservableBase<WriteInfo>;
        /**
         * Provides the text used for the CLI prompt.
         */
        prompt: KnockoutObservableBase<PromptInfo>;
        /**
         * Update the command line input text.
         */
        input: KnockoutObservableBase<InputInfo>;
        /**
         * The number of lines to keep displayed in console history.
         */
        maxLines: KnockoutObservableBase<number>;
        /**
         * The color palette.
         */
        colorPalette: ColorPalette;
        /**
         * Clears the console.
         */
        clear: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Constructs a console view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options Optional The set of options to configure the ConsoleV2 control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: MsPortalFx.ViewModels.Controls.Unsupported.ConsoleV2.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Data\QueryBuilder.d.ts
declare module MsPortalFx.ViewModels.Controls.Data.QueryBuilder {
    /**
     * An interface for a query update object.
     */
    interface QueryLoading {
        /**
         * The status of the query update.
         */
        status: QueryLoadingStatus;
        /**
         * An optional message corresponding to the update status.
         */
        message?: string;
    }
    enum QueryLoadingStatus {
        /**
         * The query is not loading.
         */
        NotLoading = 0,
        /**
         * The query is done loading.
         */
        Loading = 1,
        /**
         * The query failed to load.
         */
        Failed = 2,
    }
    /**
     * The callback method query.
     */
    interface CallbackMethodQuery {
        /**
         * A collection of operator ids.
         */
        operatorIds: string[];
        /**
         * A collection of field ids.
         */
        fieldIds: string[];
        /**
         * The type of the callback.
         */
        type: CallbackMethodType;
        /**
         * The original query object of the predicate invoking the callback.
         */
        originalPredicate: QueryPredicate;
    }
    /**
     * The callback method type.
     */
    enum CallbackMethodType {
        /**
         * A callback requesting operator data.
         */
        Operator = 0,
        /**
         * A callback requesting operand data.
         */
        Operand = 1,
    }
    /**
     * The callback method for dynamic schema loading.
     */
    interface CallbackMethod {
        (query: CallbackMethodQuery): MsPortalFx.Base.PromiseV<Schema>;
    }
    /**
     * Query definition.
     */
    interface Query {
        /**
         * The query expression.
         */
        expressions: Array<QueryExpression | QueryGroup | QueryPredicate>;
    }
    /**
     * Query expression type for expression persistence.
     */
    class QueryExpressionType {
        /**
          * Query expression type for expression persistence.
          */
        static Group: string;
        /**
         * Query expression type for expression persistence.
         */
        static Predicate: string;
    }
    /**
     * Expression definition.
     */
    interface QueryExpression {
        /**
         * The expression type.
         * QueryExpressionType.Group or QueryExpressionType.Predicate.
         */
        type: string;
        /**
         * The expression connector id.
         */
        connector: string;
    }
    /**
     * Group expression definition.
     */
    interface QueryGroup extends QueryExpression {
        /**
         * The expressions in the group.
         */
        expressions: Array<QueryExpression | QueryGroup | QueryPredicate>;
    }
    /**
     * Predicate expression definition.
     */
    interface QueryPredicate extends QueryExpression {
        /**
         * The predicate field id.
         */
        field: string;
        /**
         * The predicate operator id.
         */
        operator: string;
        /**
         * The predicate operands.
         */
        operands: QueryPredicateOperands;
    }
    /**
     * Predicate operands.
     *
     * The operands are not defined on this interface since they can vary by name.
     * They can be accessed directly off this object by operand id.
     * The operand values will be in the following forms:
     *     QueryPredicateOperandValue         // For input and select templates
     *     [QueryPredicateOperandValue, ...]  // For multiple select templates
     */
    interface QueryPredicateOperands {
    }
    /**
     * Predicate operand value.
     */
    interface QueryPredicateOperandValue {
        /**
         * The user selected option id.
         */
        option?: string;
        /**
         * The user selected or supplied value.
         */
        value?: any;
    }
    /**
     * The root interface defining a field schema.
     */
    interface Schema {
        /**
         * Logical connectors for predicates.
         */
        connectors: SchemaConnector[];
        /**
         * Field definitions.
         */
        fields: SchemaField[];
        /**
         * Predicate operator definitions.
         */
        operators?: SchemaOperator[];
    }
    /**
     * The base interface for schame objects.
     */
    interface SchemaObject {
        /**
         * Identifier for the object.
         */
        id: string;
    }
    /**
     * A logical connector for connecting a predicate to a query ("And"/"Or").
     */
    interface SchemaConnector extends SchemaObject {
        /**
         * Text fo label the connector when displayed.
         */
        name?: string;
    }
    /**
     * Schema field definition.
     */
    interface SchemaField extends SchemaObject {
        /**
         * Text to display for the schema field.
         */
        name: string;
        /**
        * Field default operator id.
         */
        defaultOperator?: string;
        /**
         * Field operator and operator group ids.
         */
        operators?: SchemaOperator[];
    }
    /**
     * A predicate operand definition.
     */
    interface SchemaOperand extends SchemaObject {
        /**
         * Text to label the operand in the display.
         */
        name?: string;
        /**
         * The form control used to handle the input for the operand.
         */
        control: MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<any>;
    }
    /**
     * A predicate operator definition.
     */
    interface SchemaOperator extends SchemaObject {
        /**
         * Text to display for the operator.
         */
        name?: string;
        /**
         * Set of operands for the predicate.
         */
        operands?: SchemaOperand[];
    }
    /**
     * Localizable resource strings for the control.
     */
    interface ResourceStrings {
        /**
         * Column header for predicate connectors.
         */
        connectorColumnHeader: string;
        /**
         * Column header for predicate fields.
         */
        fieldColumnHeader: string;
        /**
         * Column header for predicate operators.
         */
        operatorColumnHeader: string;
        /**
         * Column header for predicate values/operands.
         */
        valueColumnHeader: string;
        /**
         * Add command label.
         */
        addCommandLabel: string;
        /**
         * Insert command label.
         */
        insertCommandLabel: string;
        /**
         * Remove command label.
         */
        removeCommandLabel: string;
        /**
         * Remove command label for multiple items.
         */
        removeCommandLabelMultiple: string;
        /**
         * Group command label.
         */
        groupCommandLabel: string;
        /**
         * Ungroup command label.
         */
        ungroupCommandLabel: string;
    }
    /**
     * Resource item contract.
     */
    interface ResourceItem {
        /**
         * Name of the current resource.
         */
        name: KnockoutObservable<string>;
        /**
         * Unique id of the resource.
         */
        id: KnockoutObservable<string>;
        /**
         * Additional information about the resource.
         */
        description: KnockoutObservable<string>;
        /**
         * Specify the resource type.
         */
        type: KnockoutObservable<string>;
    }
    interface ISchemaObjectBaseViewModel {
        /**
         * Gets the object id.
         *
         * @return The object id.
         */
        id: string;
    }
    interface ISchemaConnectorViewModel {
        /**
         * Gets the connector name.
         *
         * @return The connector name.
         */
        name: string;
    }
    interface IQueryExpressionViewModel {
        /**
         * Gets the expression collection.
         *
         * @return The expression collection.
         */
        collection: KnockoutObservableArray<IQueryExpressionViewModel>;
        /**
         * Gets the expression connector.
         *
         * @return The expression connector.
         */
        connector: KnockoutObservable<ISchemaConnectorViewModel>;
        /**
         * Gets the expression type.
         *
         * @return The expression type.
         */
        type: string;
        /**
         * Gets the selection state of the expression.
         *
         * @return The selection state of the expression.
         */
        selected: KnockoutObservable<boolean>;
        /**
         * Gets the toggle select handler for the selected state.
         *
         * @return The select handler for the selected state.
         */
        select: () => void;
        /**
         * Gets the expression template name for rendering.
         *
         * @return The expression template name for rendering.
         */
        template: string;
        /**
         * Adds the expression to the end of the collection.
         *
         * @param collection The collection to add into.
         */
        add: (collection: KnockoutObservableArray<IQueryExpressionViewModel>) => void;
        /**
         * Groups the expression and its contiguous siblings.
         *
         * @param length The number of siblings after this expression to group.
         * @param group The group to add the expressions to.
         */
        group: (length: number, group: IQueryGroupViewModel) => void;
        /**
         * Inserts the expression after the selected expression.
         *
         * @param selected The selected expression.
         */
        insert: (selected: IQueryExpressionViewModel) => void;
        /**
         * Removes the expression from the current parent collection.
         */
        remove: () => void;
        /**
         * Replaces the specified children of the collection with the expression.
         *
         * @param collection The collection to put the expression in.
         * @param index The start index for the replace.
         * @param count The number of expressions to replace.
         */
        replace: (collection: KnockoutObservableArray<IQueryExpressionViewModel>, index: number, count: number) => void;
    }
    interface ISchemaFieldViewModel {
        /**
         * Gets the field default operator.
         *
         * @return The field default operator.
         */
        defaultOperator: ISchemaOperatorViewModel;
        /**
         * Gets the field name.
         *
         * @return The field name.
         */
        name: string;
        /**
         * Gets the field named operators.
         *
         * @return The field named operators.
         */
        namedOperators: ISchemaOperatorViewModel[];
        /**
         * Gets the field operators.
         *
         * @return The field operators.
         */
        operators: ISchemaOperatorViewModel[];
    }
    interface ISchemaOperatorViewModel {
        /**
         * Gets the operator name.
         *
         * @return The operator name.
         */
        name: string;
        /**
         * Gets the operator operands.
         *
         * @return The operator operands.
         */
        operands: ISchemaOperandViewModel[];
    }
    interface ISchemaOperandViewModel {
        /**
         * Gets the operand name.
         *
         * @return The operand name.
         */
        name: string;
        /**
         * Gets the operand control.
         *
         * @return The operand control.
         */
        control: MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<any>;
    }
    interface IQueryPredicateOperandViewModel {
        /**
         * Gets the id.
         *
         * @return The operand id.
         */
        id: string;
        /**
         * Gets the name.
         *
         * @return The operand name.
         */
        name: string;
        /**
         * Gets the control.
         *
         * @return The operand control.
         */
        control: MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<any>;
        /**
         * Gets the current value.
         *
         * @return The current value.
         */
        value: KnockoutObservable<any>;
        /**
         * Gets the selection state of the expression.
         *
         * @return The selection state of the expression.
         */
        selected: KnockoutObservable<boolean>;
        /**
         * Gets the selected option value.
         *
         * @return The selected option value.
         */
        selectedValue: KnockoutComputed<string>;
        /**
         * Saves the query predicate operand view model.
         *
         * @return The query predicate operand value in the format QueryPredicateOperandValue or [QueryPredicateOperandValue] depending on the template.
         */
        serialize: () => any;
    }
    interface IQueryPredicateViewModel {
        /**
         * Gets the current predicate field view model.
         *
         * @return The current predicate field view model.
         */
        field: KnockoutObservable<ISchemaFieldViewModel>;
        /**
         * Gets the available schema fields.
         *
         * @return The schema fields.
         */
        fields: KnockoutObservableArray<ISchemaFieldViewModel>;
        /**
         * Gets the current predicate operator view model.
         *
         * @return The current predicate operator view model.
         */
        operator: KnockoutObservable<ISchemaOperatorViewModel>;
        /**
         * Gets the available operators for the current field.
         *
         * @return The operators.
         */
        operators: KnockoutObservableArray<ISchemaOperatorViewModel>;
        /**
         * Gets the available named operators for the current field.
         *
         * @return The operators.
         */
        namedOperators: KnockoutObservableArray<ISchemaOperatorViewModel>;
        /**
         * Gets the current predicate operand view models.
         *
         * @return The current predicate operand view models.
         */
        operands: KnockoutObservable<IQueryPredicateOperandViewModel[]>;
        /**
         * Gets the current loading state of the query.
         *
         * @return The current loading state of the query.
         */
        queryLoading: KnockoutObservable<QueryLoading>;
        /**
         * Saves the query predicate.
         *
         * @return Persistable predicate object.
         */
        serialize: () => QueryPredicate;
    }
    interface IQueryGroupViewModel {
        /**
         * Gets the expressions in this group.
         *
         * @return The expressions in this group.
         */
        expressions: KnockoutObservableArray<IQueryExpressionViewModel>;
        /**
         * Gets the first nested predicate in this group.
         *
         * @return The first predicate.
         */
        firstPredicate: KnockoutComputed<IQueryPredicateViewModel>;
        /**
         * Saves the query group.
         *
         * @return Persistable group object.
         */
        serialize: () => QueryGroup;
        /**
         * Ungroup this group.
         * Replaces the group with its children.
         */
        ungroup: () => void;
    }
    interface IQueryViewModel {
        /**
         * Gets the query expressions.
         *
         * @return The query expressions.
         */
        expressions: KnockoutObservableArray<IQueryExpressionViewModel>;
        /**
         * Gets the query loading status.
         *
         * @return The query loading status.
         */
        queryLoading: KnockoutObservableBase<QueryLoading>;
        /**
         * Gets the query dirty status.
         *
         * @return The query dirty status.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * Gets the query initialized status.
         *
         * @return The query initialized status.
         */
        initialized: KnockoutObservable<boolean>;
        /**
         * Saves the query.
         *
         * @return Persistable query object with only the query interface members.
         */
        serialize: () => Query;
    }
    /**
     * QueryBuilder view model.
     */
    interface Contract extends Loadable.Contract {
        /**
         * Shows the query builder header.
         */
        showHeader: KnockoutObservable<boolean>;
        /**
         * Shows the query builder footer.
         */
        showFooter: KnockoutObservable<boolean>;
        /**
         * Title displayed on query expression builder.
         */
        title: KnockoutObservable<string>;
        /**
         * Schema defining fields and operations allowed in the query expression.
         */
        schema: KnockoutObservable<Schema>;
        /**
         * Query expression to be loaded.
         */
        query: KnockoutObservable<Query>;
        /**
         * Query expression to be saved to.
         */
        queryViewModel: KnockoutObservable<IQueryViewModel>;
        /**
         * Query expression to be saved to.
         */
        savedQuery: KnockoutObservable<Query>;
        /**
         * Adds a new predicate to the end of the query expressions.
         */
        add: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Inserts a new predicate after the currently selected predicate and in the same group.
         */
        insert: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Removes all the selscted expressions and ungroups any groups with less than two expressions.
         */
        remove: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Groups contiguous selected expressions.
         */
        group: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Ungroups the selected group.
         */
        ungroup: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Saves the current query.
         */
        save: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         *  Defines the callback method for extending the schema.
         */
        callback: CallbackMethod;
        /**
         * The loading status of the query and control.
         */
        queryLoading: KnockoutObservableBase<QueryLoading>;
        /**
         * The query expression.
         */
        _msPortalFxOperandControls: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<any>>;
    }
    /**
     * QueryBuilder view model.
     */
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Shows the query builder header.
         */
        showHeader: KnockoutObservable<boolean>;
        /**
         * Shows the query builder footer.
         */
        showFooter: KnockoutObservable<boolean>;
        /**
         * Title displayed on query expression builder.
         */
        title: KnockoutObservable<string>;
        /**
         * Schema defining fields and operations allowed in the query expression.
         */
        schema: KnockoutObservable<Schema>;
        /**
         * Query expression to be saved to.
         */
        query: KnockoutObservable<Query>;
        /**
         * Query expression to be saved to.
         */
        queryViewModel: KnockoutObservable<IQueryViewModel>;
        /**
         * Query expression to be loaded or saved.
         */
        savedQuery: KnockoutObservable<Query>;
        /**
         * Adds a new predicate to the end of the query expressions.
         */
        add: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Inserts a new predicate after the currently selected predicate and in the same group.
         */
        insert: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Removes all the selscted expressions and ungroups any groups with less than two expressions.
         */
        remove: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Groups contiguous selected expressions.
         */
        group: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Ungroups the selected group.
         */
        ungroup: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         * Saves the current query.
         */
        save: MsPortalFx.ViewModels.Controls.Command.ViewModel;
        /**
         *  Defines the callback method for extending the schema.
         */
        callback: CallbackMethod;
        /**
         * The loading status of the query and control.
         */
        queryLoading: KnockoutObservableBase<QueryLoading>;
        /**
         * The query expression.
         */
        _msPortalFxOperandControls: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<any>>;
        /**
         * Contstructs a query builder view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param schema The schema used to define the structure of the query builder
         * @param title The title of the query builder
         * @param query The initial query to populate into the query builder
         * @param callback The callback method for extending the schema.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, schema: Schema);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\DockedBalloon.d.ts
declare module MsPortalFx.ViewModels.Controls.DockedBalloon {
    enum Type {
        /**
         * Displays a circle with an "i" in it as an anchor.
         */
        Info = 0,
        /**
         * Displays a box with an "!" in it as an anchor.
         */
        Validation = 2,
    }
    interface Contract extends Loadable.Contract {
        /**
         * The type of balloon anchor to show (Info, Help, or Validation).
         */
        type: Type;
        /**
         * The position where the balloon will show around the element (Top, Right, Bottom, Left).
         */
        position: KnockoutObservable<MsPortalFx.ViewModels.Controls.Balloon.Position>;
        /**
         * The content to display the balloon. It can be empty if there's existing content in the element.
         * This renders as plain text.
         */
        content: KnockoutObservable<string>;
        /**
         * The balloon link.
         */
        link: KnockoutObservable<MsPortalFx.ViewModels.Controls.Balloon.Link>;
        /**
         * Whether the balloon is visible or not.
         */
        balloonVisible: KnockoutObservable<boolean>;
        /**
         * Stop or enable click propagation.
         */
        stopClickPropagation?: KnockoutObservable<boolean>;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * See interface.
         */
        type: Type;
        /**
         * See interface.
         */
        position: KnockoutObservable<MsPortalFx.ViewModels.Controls.Balloon.Position>;
        /**
         * See interface.
         */
        content: KnockoutObservable<string>;
        /**
         * The link to display in the balloon.
         */
        link: KnockoutObservable<MsPortalFx.ViewModels.Controls.Balloon.Link>;
        /**
         * See interface.
         */
        balloonVisible: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        stopClickPropagation: KnockoutObservable<boolean>;
        /**
         * Constructs a docked balloon view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Documents\DiffEditor.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.DiffEditor {
    /**
     * DiffEditor options.
     */
    interface Options extends MsPortalFx.ViewModels.Controls.Documents.Editor.Options {
        /**
         * Enables splitter between the content panes
         */
        enableSplitViewResizing?: boolean;
        /**
         * Render the differences in two side-by-side editors.
         * Defaults to true.
         */
        renderSideBySide?: boolean;
    }
    /**
     * DiffEditor view model contract.
     */
    interface Contract extends MsPortalFx.ViewModels.Controls.Documents.Editor.Contract {
        /**
         * The original document contents.
         */
        originalContent: KnockoutObservable<string>;
        /**
         * The diff editor options.
         */
        options: KnockoutObservable<Options>;
    }
    /**
     * DiffEditor view model implementation.
     */
    class ViewModel extends MsPortalFx.ViewModels.Controls.Documents.Editor.ViewModel implements Contract {
        /**
         * The original contents of the document.
         */
        originalContent: KnockoutObservable<string>;
        /**
         * The diff editor options.
         */
        options: KnockoutObservable<Options>;
        /**
         * Creates a diff editor view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param contentType The document content type.
         * @param originalContent The original contents of the document.
         * @param content The modified contents of the document.
         * @param options The diff editor options.
         * @param extensions List of extensions to use.
         * @param extensionOptions Options for the specified extensions.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, contentType: Editor.ContentType, originalContent: string, content: string, options?: Options, extensions?: Editor.Extensions, extensionOptions?: Editor.ExtensionOptions);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Documents\DiffList.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.DiffList {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxControls = FxViewModels.Controls;
    import FxPromiseV = FxBase.PromiseV;
    import DiffView = FxControls.Documents.DiffView;
    import Editor = FxControls.Documents.Editor;
    /**
     * Group by type for the item list.
     */
    enum DiffListGroupBy {
        /**
         * Items are grouped by name.
         */
        Name = 0,
        /**
         * Items are grouped by path.
         */
        Path = 1,
        /**
         * Items are grouped by change type.
         */
        Type = 2,
    }
    /**
     * Result of a diff fetch operation.
     */
    interface DiffFetchResult {
        /**
         * Fetched diff blocks.
         */
        blocks: DiffView.DiffBlock[];
        /**
         * Discussion threads associated with the fetched diff blocks.
         */
        threads: Editor.EditorThread[];
        /**
         * Custom message to be displayed instead of DiffView.
         */
        message?: string;
    }
    /**
     * Item representing a file in the diff list.
     */
    interface DiffListItem {
        /**
         * Name of the file.
         */
        name: KnockoutObservable<string>;
        /**
         * Path of the file.
         */
        path: KnockoutObservable<string>;
        /**
         * Change type of the file.
         */
        type: KnockoutObservable<string>;
        /**
         * Command to fetch the diff info.
         */
        fetch?: Editor.ExtensionCommand<DiffListItem, DiffFetchResult>;
    }
    /**
     * DiffList view model contract.
     */
    interface Contract extends FxControls.Loadable.Contract {
        /**
         * Items to be displayed in the DiffList.
         */
        items: KnockoutObservableArray<DiffListItem>;
        /**
         * Indicates how to group the items.
         */
        groupBy: KnockoutObservable<DiffListGroupBy>;
        /**
         * Enables expanding/collapsing all items at once.
         */
        expandAll: KnockoutObservable<boolean>;
        /**
         * If the number of items exceeds this limit, all items are collapsed by default (Default 15).
         */
        expandLimit: KnockoutObservable<number>;
        /**
         * Discussion options for the DiffList.
         */
        discussionOptions?: DiffView.DiscussionOptions;
        /**
         * Delegate executed when a fetch for item is required.
         */
        fetchDiff?: (name: string, path: string) => FxPromiseV<DiffFetchResult>;
        filterPath: KnockoutObservable<string>;
        /**
         * List of view models for diffs.
         */
        diffViewModels: KnockoutObservableArray<DiffView.ViewModel>;
        /**
         * Command for item click.
         */
        click?: Editor.ExtensionCommand<DiffListItem, void>;
        /**
         * Delegate executed when an item is clicked.
         */
        itemClick?: (name: string, path: string) => void;
    }
    /**
     * DiffList view model implementation.
     */
    class ViewModel extends FxControls.Loadable.ViewModel implements Contract {
        /**
         * Items to be displayed in the DiffList.
         */
        items: KnockoutObservableArray<DiffListItem>;
        /**
         * Indicates how to group the items.
         */
        groupBy: KnockoutObservable<DiffListGroupBy>;
        /**
         * Enables expanding/collapsing all items at once.
         */
        expandAll: KnockoutObservable<boolean>;
        /**
         * If the number of items exceeds this limit, all items are collapsed by default (Default 15).
         */
        expandLimit: KnockoutObservable<number>;
        /**
         * Discussion options for the DiffList.
         */
        discussionOptions: DiffView.DiscussionOptions;
        /**
         * Delegate executed when a fetch for item is required.
         */
        fetchDiff: (name: string, path: string) => FxPromiseV<DiffFetchResult>;
        filterPath: KnockoutObservable<string>;
        /**
         * List of view models for diffs.
         */
        diffViewModels: KnockoutObservableArray<DiffView.ViewModel>;
        /**
         * Command for item click.
         */
        click: Editor.ExtensionCommand<DiffListItem, void>;
        /**
         * Delegate executed when an item is clicked.
         */
        itemClick: (name: string, path: string) => void;
        /**
         * Creates a DiffList view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param items Items to be displayed in the DiffList.
         * @param fetchDiff Delegate executed when a fetch for item is required.
         * @param groupBy Indicates how to group the items.
         * @param expandLimit If the number of items exceeds this limit, all items are collapsed by default (Default 15).
         * @discussionOptions Discussion options for the DiffList.
         */
        constructor(lifetimeManager: FxBase.LifetimeManager, items: DiffListItem[], fetchDiff?: (name: string, path: string) => FxPromiseV<DiffFetchResult>, groupBy?: DiffListGroupBy, expandLimit?: number, discussionOptions?: DiffView.DiscussionOptions);
        private _ensureFetchCommand();
        private _ensureItemClickCommand();
        private _createDiffViewModel(lifetimeManager, containerName, blocks, threads?);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Documents\DiffView.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.DiffView {
    /**
     * Change type of a diff block.
     */
    enum DiffBlockChangeType {
        /**
         * No change.
         */
        None = 0,
        /**
         * Block added.
         */
        Add = 1,
        /**
         * Block deleted.
         */
        Delete = 2,
        /**
         * Block edited.
         */
        Edit = 3,
    }
    /**
     * Interface representing a diff block.
     */
    interface DiffBlock {
        /**
         * Change type of the block.
         */
        changeType: DiffBlockChangeType;
        /**
         * Modified side line number start.
         */
        modifiedLineNumber: number;
        /**
         * Modified side lines existing in this block.
         */
        modifiedLines: string[];
        /**
         * Original side line number start.
         */
        originalLineNumber: number;
        /**
         * Original side lines existing in this block.
         */
        originalLines: string[];
        /**
         * Indicates whether lines before this block exist or not.
         */
        truncatedAfter?: boolean;
        /**
         * Indicates whether lines after this block exist or not.
         */
        truncatedBefore?: boolean;
    }
    /**
     * Discussion options for the DiffView.
     */
    interface DiscussionOptions extends MsPortalFx.ViewModels.Controls.Documents.Editor.DiscussionOptions {
        /**
         * Indicates whether discussions are enabled or not.
         */
        enabled: KnockoutObservable<boolean>;
        /**
         * Add thread icon. It can be data/img or URL.
         */
        addIcon: KnockoutObservable<string>;
        /**
         * Indicates whether add thread icon will be on the left side or not.
         */
        addIconOnLeft: KnockoutObservable<boolean>;
    }
    /**
     * DiffView view model contract.
     */
    interface Contract extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * Diff blocks to be displayed in the DiffView.
         */
        blocks: KnockoutObservableArray<DiffBlock>;
        /**
         * Discussion options for the DiffView.
         */
        discussionOptions?: DiscussionOptions;
    }
    /**
     * DiffView view model implementation.
     */
    class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract {
        /**
         * Diff blocks to be displayed in the DiffView.
         */
        blocks: KnockoutObservableArray<DiffBlock>;
        /**
         * Discussion options for the DiffView.
         */
        discussionOptions: DiscussionOptions;
        /**
         * Creates a DiffView view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param blocks Blocks to be displayed in the DiffView.
         * @param discussionOptions Discussion options for the DiffView.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, blocks: DiffBlock[], discussionOptions?: DiscussionOptions);
        static getDefaultDiscussionOptions(): DiscussionOptions;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Documents\DiscussionThread.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.DiscussionThread {
    /**
     * Represents a result for save command.
     */
    interface DiscussionSaveResult {
        /**
         * Id of the item.
         */
        id?: number;
        /**
         * Published date of the item.
         */
        publishedDate?: Date;
        /**
         * Last updated date of the item.
         */
        lastUpdatedDate?: Date;
    }
    /**
     * Represents a result for comment save command.
     */
    interface DiscussionCommentSaveResult extends DiscussionSaveResult {
    }
    /**
     * Represents a result for thread save command.
     */
    interface DiscussionThreadSaveResult extends DiscussionSaveResult {
        /**
         * Result for the single comment in a newly saved thread.
         */
        commentResult?: DiscussionCommentSaveResult;
    }
    /**
     * Represents an author of a code discussion.
     */
    interface DiscussionAuthor {
        /**
         * Id of the author.
         */
        id: KnockoutObservable<string>;
        /**
         * Display name of the author.
         */
        displayName: KnockoutObservable<string>;
        /**
         * Profile image of the author. It can be base64 data or URL.
         */
        image?: KnockoutObservable<string>;
    }
    /**
     * Base interface for thread and comment.
     */
    interface DiscussionItem {
        /**
         * Id of the discussion item.
         */
        id: KnockoutObservable<number>;
        /**
         * Published date of the discussion item.
         */
        publishedDate: KnockoutObservable<Date>;
        /**
         * Last updated date of the discussion item.
         */
        lastUpdatedDate: KnockoutObservable<Date>;
    }
    /**
     * Represents a comment in a discussion thread.
     */
    interface DiscussionComment extends DiscussionItem {
        /**
         * Id of the parent comment.
         */
        parentId: KnockoutObservable<number>;
        /**
         * Id of the discussion thread.
         */
        threadId: KnockoutObservable<number>;
        /**
         * Author of this comment.
         */
        author: KnockoutObservable<DiscussionAuthor>;
        /**
         * Content of this comment.
         */
        content: KnockoutObservable<string>;
        /**
         * Determines whether this comment can be deleted or not.
         */
        canDelete: KnockoutObservable<boolean>;
        /**
         * Determines whether this comment is editable or not.
         */
        isEditable: KnockoutObservable<boolean>;
        /**
         * Save action for the comment.
         */
        save: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, DiscussionCommentSaveResult>;
    }
    class DiscussionCommentViewModel implements DiscussionComment {
        /**
         * Id of the comment.
         */
        id: KnockoutObservable<number>;
        /**
         * Published date of the comment.
         */
        publishedDate: KnockoutObservable<Date>;
        /**
         * Last updated date of the comment.
         */
        lastUpdatedDate: KnockoutObservable<Date>;
        /**
         * Id of the parent comment.
         */
        parentId: KnockoutObservable<number>;
        /**
         * Id of the discussion thread.
         */
        threadId: KnockoutObservable<number>;
        /**
         * Author of this comment.
         */
        author: KnockoutObservable<DiscussionAuthor>;
        /**
         * Content of this comment.
         */
        content: KnockoutObservable<string>;
        /**
         * Determines whether this comment can be deleted or not.
         */
        canDelete: KnockoutObservable<boolean>;
        /**
         * Determines whether this comment is editable or not.
         */
        isEditable: KnockoutObservable<boolean>;
        /**
         * Save action for the comment.
         */
        save: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, DiscussionCommentSaveResult>;
        /**
         * Creates a discussion comment class.
         *
         * @param id Id of the comment.
         * @param content Content of the comment.
         * @param author Author of the comment.
         */
        constructor(id?: number, content?: string, author?: DiscussionAuthor);
    }
    /**
     * Represents a thread in a code discussion.
     */
    interface DiscussionThread extends DiscussionItem {
        /**
         * Comments added to this discussion thread.
         */
        comments: KnockoutObservableArray<DiscussionComment>;
        /**
         * Save action for the thread.
         */
        save: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, DiscussionThreadSaveResult>;
        /**
         * Action for adding new comment.
         */
        addComment: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, any>;
        /**
         * Action for deleting the comment.
         */
        deleteComment: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<number, any>;
    }
    class DiscussionThreadViewModel implements DiscussionThread {
        /**
         * Id of the thread.
         */
        id: KnockoutObservable<number>;
        /**
         * Published date of the thread.
         */
        publishedDate: KnockoutObservable<Date>;
        /**
         * Last updated date of the thread.
         */
        lastUpdatedDate: KnockoutObservable<Date>;
        /**
         * Comments added to this discussion thread.
         */
        comments: KnockoutObservableArray<DiscussionComment>;
        /**
         * Save action for the thread.
         */
        save: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, DiscussionThreadSaveResult>;
        /**
         * Action for adding new comment.
         */
        addComment: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<any, any>;
        /**
         * Action for deleting the comment.
         */
        deleteComment: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<number, any>;
        /**
         * Creates a discussion thread class.
         *
         * @param id Id of the thread.
         * @param comments Comments of the thread.
         */
        constructor(id?: number, comments?: DiscussionComment[]);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Documents\DiscussionTimeline.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.DiscussionTimeline {
    import Documents = MsPortalFx.ViewModels.Controls.Documents;
    /**
     * Thread used in the DiscussionTimeline.
     */
    interface TimelineThread extends Documents.Editor.EditorThread {
        /**
         * Name of the item to be displayed in the control.
         */
        itemName: KnockoutObservable<string>;
        /**
         * Full path of the item.
         */
        itemPath: KnockoutObservable<string>;
        /**
         * Indicates whether this thread is contains a single system message or not.
         */
        isSystemMessage: KnockoutObservable<boolean>;
    }
    /**
     * Thread view model used in the DiscussionTimeline.
     */
    class TimelineThreadViewModel extends Documents.Editor.EditorThreadViewModel implements TimelineThread {
        /**
         * Name of the item to be displayed in the control.
         */
        itemName: KnockoutObservable<string>;
        /**
         * Full path of the item.
         */
        itemPath: KnockoutObservable<string>;
        /**
         * Indicates whether this thread is contains a single system message or not.
         */
        isSystemMessage: KnockoutObservable<boolean>;
        /**
         * Creates an editor thread class.
         *
         * @param id Id of the thread.
         * @param comment Comments of the thread.
         * @param position Position of the thread.
         * @param itemName Name of the item to be displayed in the control.
         * @param itemPath Full path of the item.
         * @param isSystemMessage Indicates whether this thread is contains a single system message or not.
         */
        constructor(id?: number, comments?: Documents.DiscussionThread.DiscussionComment[], position?: Documents.Editor.EditorThreadPosition, itemName?: string, itemPath?: string, isSystemMessage?: boolean);
    }
    /**
     * Options for DiscussionTimeline.
     */
    interface DiscussionOptions extends Documents.Editor.BaseDiscussionOptions<TimelineThread> {
    }
    /**
     * DiscussionTimeline view model contract.
     */
    interface Contract extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * Discussion options for the DiscussionTimeline.
         */
        discussionOptions: DiscussionOptions;
        /**
         * Indicates whether to sort thread chronological or reverse chronological.
         */
        sortChronologically: KnockoutObservable<boolean>;
        /**
         * Indicates whether to display sistem messages or not.
         */
        showSystemMessages: KnockoutObservable<boolean>;
        /**
         * Format of the group text.
         */
        groupFormat: KnockoutObservable<string>;
        /**
         * Command for item click.
         */
        click?: Documents.Editor.ExtensionCommand<TimelineThread, void>;
        /**
         * Delegate executed when an item is clicked.
         */
        itemClick?: (itemPath: string, position: Documents.Editor.EditorThreadPosition) => void;
    }
    /**
     * DiscussionTimeline view model implementation.
     */
    class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract {
        /**
         * Discussion options for the DiscussionTimeline.
         */
        discussionOptions: DiscussionOptions;
        /**
         * Indicates whether to sort thread chronological or reverse chronological.
         */
        sortChronologically: KnockoutObservable<boolean>;
        /**
         * Indicates whether to display sistem messages or not.
         */
        showSystemMessages: KnockoutObservable<boolean>;
        /**
         * Format of the group text.
         */
        groupFormat: KnockoutObservable<string>;
        /**
         * Command for item click.
         */
        click: Documents.Editor.ExtensionCommand<TimelineThread, void>;
        /**
         * Delegate executed when an item is clicked.
         */
        itemClick: (itemPath: string, position: Documents.Editor.EditorThreadPosition) => void;
        /**
         * Creates a DiscussionTimeline view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param discussionOptions Discussion options for the DiscussionTimeline.
         * @param sortChronologically Indicates whether to sort thread chronological or reverse chronological.
         * @param showSystemMessages Indicates whether to display sistem messages or not.
         * @param groupFormat Format of the group text.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, discussionOptions: DiscussionOptions, sortChronologically?: boolean, showSystemMessages?: boolean, groupFormat?: string);
        /**
         * Adds a new empty discussion thread. Ensures only single unsaved thread exists.
         */
        addNewThread(): void;
        private _ensureItemClickCommand();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Documents\Editor.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.Editor {
    /**
     * Type of editor content.
     * Used to enable language specific editor features like colorization.
     */
    enum ContentType {
        /**
         * Text.
         * 'text/plain'
         */
        Text = 0,
        /**
         * Custom Content Type.
         */
        Custom = 1,
        /**
         * Batch Script.
         * 'text/x-bat'
         */
        Bat = 2,
        /**
         * C.
         * 'text/x-c'
         */
        C = 3,
        /**
         * Coffee Script.
         * 'text/x-coffeescript', 'text/coffeescript'
         */
        CoffeeScript = 4,
        /**
         * C++.
         * 'text/x-cpp'
         */
        Cpp = 5,
        /**
         * C#.
         * 'text/x-csharp'
         */
        CSharp = 6,
        /**
         * C# WebPages.
         * 'text/x-cshtml'
         */
        CSHtml = 7,
        /**
         * Cascading Style Sheet.
         * 'text/css'
         */
        Css = 8,
        /**
         * Dockerfile.
         * 'text/x-dockerfile'
         */
        Dockerfile = 9,
        /**
         * F#.
         * 'text/x-fsharp'
         */
        FSharp = 10,
        /**
         * Go.
         * 'text/x-go'
         */
        Go = 11,
        /**
         * Handlebars template.
         * 'text/x-handlebars-template'
         */
        Handlebars = 12,
        /**
         * Html.
         * 'text/html'
         */
        Html = 13,
        /**
         * Initialization file.
         * 'text/x-ini'
         */
        Ini = 14,
        /**
         * Jade.
         * 'text/x-jade'
         */
        Jade = 15,
        /**
         * Java.
         * 'text/x-java-source'
         */
        Java = 16,
        /**
         * JavaScript.
         * 'text/javascript'
         */
        JavaScript = 17,
        /**
         * JSHtm.
         * 'text/x-jshtm'
         */
        JSHtm = 18,
        /**
         * JSON.
         * 'application/json'
         */
        Json = 19,
        /**
         * Less.
         * 'text/x-less', 'text/less'
         */
        Less = 20,
        /**
         * Lua.
         * 'text/x-lua'
         */
        Lua = 21,
        /**
         * Mark Down.
         * 'text/x-markdown'
         */
        MarkDown = 22,
        /**
         * Objective-C
         * 'objective-c'
         */
        ObjectiveC = 23,
        /**
         * PHP.
         * 'application/x-php'
         */
        Php = 24,
        /**
         * Power Shell.
         * 'text/x-powershell'
         */
        PowerShell = 25,
        /**
         * Python.
         * 'text/x-python', 'text/python'
         */
        Python = 26,
        /**
         * R.
         * 'text/x-r'
         */
        R = 27,
        /**
         * Ruby.
         * 'text/x-ruby'
         */
        Ruby = 28,
        /**
         * SQL.
         * 'sql'
         */
        Sql = 29,
        /**
         * Swift.
         * 'swift'
         */
        Swift = 30,
        /**
         * TypeScript.
         * 'text/typescript'
         */
        TypeScript = 31,
        /**
         * Visual Basic.
         * 'text/x-vb'
         */
        VisualBasic = 32,
        /**
         * Xaml.
         * 'application/xaml+xml'
         */
        Xaml = 33,
        /**
         * Xml.
         * 'text/xml', 'application/xml'
         */
        Xml = 34,
    }
    /**
     * Editor options.
     */
    interface Options {
        /**
         * Indicates if edits are allowed.
         */
        readOnly?: boolean;
        /**
         * Indicates if line numbers are displayed.
         */
        lineNumbers?: boolean;
        /**
         * Controls the size of tabs in the document.
         */
        tabSize?: number;
        /**
         * Indicates if spaces are inserted instead of tabs.
         */
        insertSpaces?: boolean;
        /**
         * Indicates if the editor allows Tab and Shift+Tab to change focus.
         */
        tabFocusMode?: boolean;
        /**
         * Indicates if the wrapping column of the editor.
         *     -1  no wrapping
         *      0  wraps to the current viewport width
         *      n  wraps at fixed column
         */
        wrappingColumn?: number;
    }
    /**
     * Definition of a custom content type.
     * See https://opentools.azurewebsites.net/Content/monarch/monarch-documentation.html
     */
    interface CustomContentType {
        /**
         * The display name of your language.
         */
        displayName?: string;
        /**
         * Ignore case when compiling regular expressions defined in 'tokenizer'.
         * Default is false.
         */
        ignoreCase?: boolean;
        /**
         * An optional line comment starter.Used in the editor to insert line comments (ctrl + /).
         * Default is two forward slashes.
         */
        lineComment?: string;
        /**
         * A block comment start marker. Used by the editor to insert block comments (shift+alt+A).
         * Default is forward slash asterisk.
         */
        blockCommentStart?: string;
        /**
         * A block comment end marker.
         * Default is asterisk forward slash.
         */
        blockCommentEnd?: string;
        /**
         * The default token returned if nothing matches in the tokenizer.
         * Default is "source".
         * It can be convenient to set this to "invalid" during development of your colorizer to easily spot what is not matched yet.
         */
        defaultToken?: string;
        /**
         * This is used by the tokenizer to easily define matching braces.
         * Each bracket definition is an array of 3 elements, or object, describing the open brace, the close brace, and the token class.
         * The default definition is:
         * [ ['{','}','delimiter.curly'],
         *   ['[',']','delimiter.square'],
         *   ['(',')','delimiter.parenthesis'],
         *   ['<','>','delimiter.angle'] ]
         */
        brackets?: string[][];
        /**
         * A list of auto closing character pairs, used in the editor to automatically insert the closing brace of the pair.
         * The list may end with the single string '@brackets' which automatically includes single-character close brackets defined in the brackets attribute.
         * By default the auto closing pairs are defined as: [['"','"'], ['\'','\''], ['@brackets']]
         */
        autoClosingPairs?: string[][];
        /**
         * Optional postfix attached to all returned tokens.
         * By default this attaches the language name so in the CSS you can refer to your specific language.
         * For example, for the Java language, we could use .identifier.java to target all Java identifiers specifically in CSS.
         */
        tokenPostfix?: string;
        /**
         * The start state of the tokenizer.
         * By default, this is the first entry in the tokenizer attribute.
         */
        start?: string;
        /**
         * Optional list of token classes that are non-word tokens.
         * By default this is defined as: ['delimiter','delimiter.parenthesis','delimiter.curly','delimiter.square','delimiter.angle']
         */
        nonWordTokens?: string[];
        /**
         * Optional string that defines characters that when typed could cause outdentation.
         * This attribute is only used when using advanced brace matching in combination with the bracket attribute.
         * By default it always includes the last characters of the closing brackets in the brackets list.
         * Outdentation happens when the user types a closing bracket word on an line that starts with only white space.
         * If the closing bracket matches a open bracket it is indented to the same amount of that bracket.
         * Usually, this causes the bracket to outdent. For example, in the Ruby language, the end keyword would match with an open declaration like def or class.
         * To make outdentation happen though, we would need to include the d character in the outdentTriggers attribute so it is checked when the users type end:
         *
         * outdentTriggers: 'd',
         */
        outdentTriggers?: string;
        /**
         * This can be used to get autocompletion for certain constructs.
         * For example, in HTML we may want to auto complete a tag with its closing tag when the user types >.
         * A possible way to do this is to define autoComplete:
         *
         * autoComplete: [{
         *     triggers: '>',
               match   : '\\s<(\\w+)[^>]*>\\s$',
         *     complete: '</$1>'
         * }],
         *
         * Each matcher specifies three attributes:
         * the triggers attribute gives a string of characters where autocompletion should be checked.
         * On such character, the current input line is tested against match regular expression.
         * If it succeeds, complete is appended to the source with captured groups expanded.
         * To help with matching input, the editor first filters out all whitespace and comment tokens, and then concatenates the remaining tokens where every token is surrounded with a space.
         * The match regular expression is matched against the resulting string.
         */
        autoComplete?: CustomContentTypeAutoCompleteMatcher[];
        /**
         * This can be used to specify custom auto indentation beyond what is already done for brackets and the bracket attributes.
         * Suppose for example we would like to indent for begin/end pairs.
         * The easy way to do this is off course to just specify this pair as part of the brackets attribute.
         * But for the sake of an example, here is how to do it using autoIndent:
         *
         * autoIndent: [{
         *     match     : "\\sbegin\\s(((?!\\send\\s).)*)$",
         *     matchAfter: "\\send\\s"
         * }],
         *
         * On an enter, the current line is matched against the match regular expression.
         * Note that the line is processed as described in autoComplete where each token is surrounded by a space.
         * If the match succeeds, the next line is indented.
         * If also the matchAfter regular expression matches the tokens following the line break, then an extra break is inserted that is outdented (creating a nice block structure).
         * In the example, the match regular expression matches a line where a begin keyword is present.
         * It uses (?!\\send\\s) to ensure there is no closing end after the begin.
         */
        autoIndent?: CustomContentTypeAutoIndentMatcher[];
        /**
         * As described for the bracket attribute, the editor uses auto indentation for any bracket.
         * This attribute suppresses auto indentation for any brackets that match the regular expression.
         * For example, here is how to suppress auto indentation for parenthesis and angled braces:
         *
         * noindentBrackets: /[()<>]/,
         */
        noindentBrackets?: RegExp;
        /**
         * Monarch custom language tokenization rules.
         *
         * The tokenizer attribute describes how lexical analysis takes place, and how the input is divided into tokens.
         * Each token is given a CSS class name which is used to render each token in the editor.
         * Standard CSS token classes include:
         *
         *     identifier         entity           constructor
         *     operators          tag              namespace
         *     keyword            info-token       type
         *     string             warn-token       predefined
         *     string.escape      error-token      invalid
         *     comment            debug-token
         *     comment.doc        regexp
         *     constant           attribute
         *
         *     delimiter .[curly,square,parenthesis,angle,array,bracket]
         *     number    .[hex,octal,binary,float]
         *     variable  .[name,value]
         *     meta      .[content]
         *
         *     A tokenizer consists of an object that defines states.
         *     The initial state of the tokenizer is the first state defined in the tokenizer.
         *     When a tokenizer is in a certain state, only the rules in that state will be applied.
         *     All rules are matched in order and when the first one matches its action is used to determine the token class.
         *     No further rules are tried.
         *     Therefore, it can be important to order the rules in a way that is most efficient, i.e. whitespace and identifiers first.
         *
         *     (Advanced) A state is interpreted as dot (.) separated sub-states.
         *     When looking up the rules for a state, the tokenizer first tries the entire state name, and then looks at its parent until it finds a definition.
         *     For example, in our example, the states "comment.block" and "comment.foo" would both be handled by the comment rules.
         *     Hierarchical state names can be used to maintain complex lexer states, as shown for example in the section on complex embeddings.
         *
         *     Each state is defined as an array of rules which are used to match the input.
         */
        tokenizer: {
            [stateName: string]: CustomContentTypeTokenizationRule[];
        };
        /**
         * Code completion suggestion support for the custom language.
         */
        suggestSupport?: CustomContentTypeSuggestSupport;
    }
    /**
     * Defines a tokenizer rule.
     * Rules can have the following forms:
     *
     *     {regex: regex, action: action }
     *          CustomContentTypeTokenizationRegexRule
     *
     *     { include: state }
     *         CustomContentTypeTokenizationIncludeRule
     *
     *     [regex, action]
     *         Shorthand for CustomContentTypeTokenizationRegexRule with action: { regex: regex, action: action }
     *
     *     [regex, action, next]
     *         Shorthand for CustomContentTypeTokenizationRegexRule with action having next: { regex: regex, action: action{ next: next } }
     */
    type CustomContentTypeTokenizationRule = CustomContentTypeTokenizationRegexRule | CustomContentTypeTokenizationIncludeRule | (RegExp | string | CustomContentTypeTokenizationRuleAction)[];
    /**
     * Defines a regular expression tokenization rule.
     * When regex matches against the current input, then action is applied to set the token class.
     */
    interface CustomContentTypeTokenizationRegexRule {
        /**
         * The regular expression for the rule.
         *
         * The regular expression regex can be either a regular expression (using /regex/), or a string representing a regular expression.
         * If it starts with a ^ character, the expression only matches at the start of a source line.
         * The $ can be used to match against the end of a source line.
         * Note that the tokenizer is not called when the end of the line is already reached, and the empty pattern /$/ will therefore never match (but see '@eos' too).
         * Inside a regular expression, you can reference a string attribute named attr as @attr, which is automatically expanded.
         * This is used in the standard example to share the regular expression for escape sequences using '@escapes' inside the regular expression for characters and strings.
         *
         * Regular expression primer: common regular expression escapes we use are \d for [0-9], \w for [a-zA-Z0-9_], and \s for [ \t\r\n].
         * The notation regex{n} stands for n occurrences of regex.
         * Also, we use (?=regex) for non-consuming `followed by regex', (?!regex) for `not followed by', and (?:regex) for a non-capturing group (i.e. cannot use $n to refer to it).
         */
        regex: RegExp | string;
        /**
         * The action for the rule.
         */
        action: CustomContentTypeTokenizationRuleAction[];
    }
    /**
     * Used for nice organization of your rules and expands to all the rules defined in state.
     * This is pre-expanded and has no influence on performance.
     * Many samples include the '@whitespace' state for example.
     */
    interface CustomContentTypeTokenizationIncludeRule {
        /**
         * The state to include.
         */
        include: string;
    }
    /**
     * The scalar rule actions that are allowed.
     */
    type CustomContentTypeTokenizationRuleScalarAction = CustomContentTypeTokenizationRuleTokenAction | CustomContentTypeTokenizationRuleCasesAction | string;
    /**
     * Defines a rule action.
     * An action can have the following forms:
     *
     *     { token: tokenclass }
     *         CustomContentTypeTokenizationRuleTokenAction
     *
     *     { cases: { guard1: action1, ..., guardN: actionN } }
     *         CustomContentTypeTokenizationRuleCasesAction
     *
     *     string
     *         Shorthand for CustomContentTypeTokenizationRuleTokenAction with token only: { token: string }.
     *
     *     [action1,...,actionN]
     *         An array of N actions.
     */
    type CustomContentTypeTokenizationRuleAction = CustomContentTypeTokenizationRuleScalarAction | CustomContentTypeTokenizationRuleScalarAction[];
    /**
     * An object that defines the token class used with CSS rendering.
     */
    interface CustomContentTypeTokenizationRuleTokenAction {
        /**
         * The token class.
         *
         * Common token classes are for example 'keyword', 'comment' or 'identifier'.
         * You can use a dot to use hierarchical CSS names, like 'type.identifier' or 'string.escape'.
         * You can also include $ patterns that are substituted with a captured group from the matched input or the tokenizer state.
         * There are some special token classes:
         *
         * "@brackets"or "@brackets.tokenclass
         *     Signifies that brackets were tokenized.
         *     The token class for CSS is determined by the token class defined in the brackets attribute (together with tokenclass if present).
         *     Moreover, bracket attribute is set such that the editor is matches the braces (and does auto indentation).
         *     For example:
         *         [/[{}()\[\]]/, '@brackets']
         *
         * "@rematch"
         *    (Advanced) Backs up the input and re-invokes the tokenizer.
         *    This of course only works when a state change happens too (or we go into an infinite recursion), so this is usually used in combination with the next attribute.
         *    This can be used for example when you are in a certain tokenizer state and want to get out when seeing certain end markers but don't want to consume them while being in that state.
         *    See also nextEmbedded.
         */
        token: string;
        /**
         * If defined it pushes the current state onto the tokenizer stack and makes state the current state.
         * This can be used for example to start tokenizing a block comment: ['/\\*', 'comment', '@comment' ]
         *
         * Note that this is a shorthand for
         *     { regex: '/\\*', action: { token: 'comment', next: '@comment' } }
         *
         * Here the matched /* is given the "comment" token class, and the tokenizer proceeds with matching the input using the rules in state @comment.
         *
         * There are a few special states that can be used for the next attribute:
         *
         *    "@pop"
         *        Pops the tokenizer stack to return to the previous state.
         *        This is used for example to return from block comment tokenizing after seeing the end marker: ['\\*<forward slash>', 'comment', '@pop']
         *
         *    "@push"
         *        Pushes the current state and continues in the current state.
         *        Nice for doing nested block comments when seeing a comment begin marker, i.e.in the @comment state, we can do: ['/\\*', 'comment', '@push']
         *
         *    "@popall"
         *        Pops everything from tokenizer stack and returns to the top state.
         *        This can be used during recovery to 'jump' back to the initial state from a deep nesting level.
         */
        next?: string;
        /**
         * Switch to state without changing the stack.
         */
        switchTo?: string;
        /**
         * Back up the input by number characters.
         */
        goBack?: number;
        /**
         * Advanced bracket kind.
         * The kind can be either '@open' or '@close'.
         * This signifies that a token is either an open or close brace.
         * This attribute is set automatically if the token class is @brackets.
         * The editor uses the bracket information to show matching braces (where an open bracket matches with a close bracket if their token classes are the same).
         * Moreover, when a user opens a new line the editor will do auto indentation on open braces.
         * Normally, this attribute does not need to be set if you are using the brackets attribute and it is only used for complex brace matching.
         */
        bracket?: string;
        /**
         * Signifies to the editor that this token is followed by code in another language specified by the mimeType, i.e. for example text/javascript.
         * Internally, our syntax highlighter keeps tokenizing the source until it finds an an ending sequence.
         * At that point, you can use nextEmbedded with a '@pop' value to pop out of the embedded mode again.
         * Usually, we need to use a next attribute too to switch to a state where we can tokenize the foreign code.
         * As an example, here is how we could support CSS fragments in our language:
         *     root: [
         *         [/<style\s*>/,   { token: 'keyword', bracket: '@open' , next: '@css_block', nextEmbedded: 'text/css' }],
         *         [/<\/style\s*>/, { token: 'keyword', bracket: '@close' }],
         *         ...
         *     ],
         *
         *     css_block: [
         *         [/[^"<]+/, ''],
         *         [/<\/style\s*>/, { token: '@rematch', next: '@pop', nextEmbedded: '@pop' }],
         *         [/"/, 'string', '@string' ],
         *          [/</, '']
         *     ],
         *
         * Note how we switch to the css_block state for tokenizing the CSS source.
         * Also inside the CSS we use the @string state to tokenize CSS strings such that we do not stop the CSS block when we find </style> inside a string.
         * When we find the closing tag, we also "@pop" the state to get back to normal tokenization.
         * Finally, we need to "@rematch" the token (in the root state) since the editor ignores our token classes until we actually exit the embedded mode.
         */
        nextEmbedded?: string;
        /**
         * Debug logging.
         * Logs message to the console window in the browser (press F12 to see it).
         * This can be useful to see if a certain action is executing.
         * For example: [/\d+/, { token: 'number', log: 'found number $0 in state $S0' } ]
         */
        log?: string;
    }
    interface CustomContentTypeTokenizationRuleCasesAction {
        /**
         * The cases for the action.
         */
        cases: {
            [caseName: string]: CustomContentTypeTokenizationRuleAction;
        };
    }
    /**
     * Defines suggestions for code completion in a custom language.
     */
    interface CustomContentTypeSuggestSupport {
        /**
         * Indicates if completions should automatically be provided from the current document contents.
         */
        textualCompletions?: boolean;
        /**
         * Array of characters that will trigger suggestions pop-up.
         */
        triggerCharacters?: string[];
        /**
         * Snippet definitions.
         * This is an array containing snippet definitions or simple text suggestions.
         */
        snippets: (string | CustomContentTypeSuggestSupportSnippet)[];
    }
    /**
     * Defines a code suggestion snippet for a custom language.
     */
    interface CustomContentTypeSuggestSupportSnippet {
        /**
         * The type of snippet.
         */
        type: string;
        /**
         * The label displayed in the suggest support pop up.
         */
        label: string;
        /**
         * The snippet to insert.
         */
        codeSnippet: string;
        /**
         * Documentation to display in the suggest support pop-up.
         */
        documentationLabel?: string;
    }
    /**
     * Auto Complete matcher for custom content type.
     */
    interface CustomContentTypeAutoCompleteMatcher {
        /**
         * The string of characters where autocompletion should be checked.
         */
        triggers: string;
        /**
         * Regular expression that is tested against the current input line when triggred.
         */
        match: string;
        /**
         * On match is appended to the source with captured groups expanded.
         */
        complete: string;
    }
    /**
     * Auto indent matcher for custom content type.
     */
    interface CustomContentTypeAutoIndentMatcher {
        /**
         * Regular expression matched against the current line on an enter to determine indentation.
         */
        match: string;
        /**
         * Regular expression matched against the tokens following the line break to determing block indentation.
         */
        matchAfter: string;
    }
    /**
     * JSON schema
     */
    interface JSONSchema {
        /**
         * Incicates format of file name that schema will be applied to.
         */
        fileMatch: string[];
        /**
         * Obsolete. Please use uri property instead.
         * The url property will be removed after 12/20/2016.
         */
        url?: Obsolete;
        /**
         * Incicates uri from which schema will be loaded.
         */
        uri?: string;
        /**
         * Indicates to validate schema.
         */
        validate?: boolean;
        /**
         * Inline schema definition.
         */
        schema?: any;
    }
    /**
     * JSON configuration.
     */
    interface JSONConfiguration {
        /**
         * JSON schemas.
         */
        schemas?: JSONSchema[];
    }
    /**
     * Defines an extra library for intellisense in the typescript editor.
     */
    interface TypeScriptExtraLib {
        /**
         * The content of the library.
         * For example the content of a library.d.ts file.
         */
        content: string;
        /**
         * The library name.
         * For instance "library.d.ts".
         */
        path: string;
    }
    /**
     * The typescript script target.
     */
    const enum TypeScriptScriptTarget {
        /**
         * ECMAScript 5.
         */
        ES5 = 0,
        /**
         * ECMAScript 6.
         */
        ES6 = 1,
    }
    /**
     * TypeScript compiler options.
     */
    interface TypeScriptCompilerOptions {
        /**
         * The target type for compilation.
         * Defaults to ES5.
         */
        target?: TypeScriptScriptTarget;
    }
    /**
     * TypeScript editor configuration.
     */
    interface TypeScriptConfiguration {
        /**
         * Extra libraries to load for TypeScript intellisense.
         */
        extraLibs?: TypeScriptExtraLib[];
        /**
         * Compiler options for compiling the typescript.
         */
        compilerOptions?: TypeScriptCompilerOptions;
        /**
         * The typescript compiler output.
         * Updated on each save.
         * This is the transpiled javascript content.
         */
        output?: KnockoutObservable<string>;
    }
    /**
     * Editor configuration.
     */
    interface Configuration {
        /**
         * Contains JSON schema configuration.
         */
        json?: JSONConfiguration;
        /**
         * Contains TypeScript configuration.
         */
        typescript?: TypeScriptConfiguration;
    }
    /**
     * Editor view model contract.
     */
    interface Contract extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * The type of the file.
         */
        contentType: KnockoutObservable<ContentType>;
        /**
         * Definition for a custom content type.
         * This definition is used only if 'contentType' is set to 'ContentType.Custom'.
         */
        customContentType: KnockoutObservable<CustomContentType>;
        /**
         * The content of the file.
         */
        content: KnockoutObservable<string>;
        /**
         * Content uri, defines file location and type
         */
        contentUri: KnockoutObservable<string>;
        /**
         * The currently selected content of the file.
         */
        selectedContent: KnockoutObservable<string>;
        /**
         * The currently selected Range in the file.
         */
        selectedRange: KnockoutObservable<EditorRange>;
        /**
         *  Definition for markers in the editor.
         */
        markers: KnockoutObservableArray<EditorMarker>;
        /**
         *  Current position of the cursor in the file.
         */
        position: KnockoutObservable<EditorPosition>;
        /**
         * The editor options.
         */
        options: KnockoutObservable<Options>;
        /**
         * Indicates if the contents have been modified but not yet saved.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * Saves the editor content.
         */
        save: MsPortalFx.ViewModels.Controls.Command.Contract;
        /**
         * Indicates which editor extensions to use.
         */
        extensions?: Extensions;
        /**
         * Indicates options for the specified extensions.
         */
        extensionOptions?: ExtensionOptions;
        /**
         * Configuration options.
        */
        configuration: Configuration;
        /**
         * Indicates if the editor is displayed.
         */
        visible: KnockoutObservable<boolean>;
        /**
         * Refreshes the editor view.
         */
        refresh: MsPortalFx.ViewModels.Controls.Command.Contract;
    }
    /**
     *  A position in the text editor.  Same properties as a Monaco IPosition interface
     */
    interface EditorPosition {
        /**
         * line number (starts at 1)
         */
        lineNumber: number;
        /**
         * column (the first character in a line is between column 1 and column 2)
         */
        column: number;
    }
    /**
     *  Editor marker definition
     */
    enum MarkerSeverity {
        /**
         * Ignored marker
         */
        Ignore = 0,
        /**
         * Information marker
         */
        Info = 1,
        /**
         * Warning marker
         */
        Warning = 2,
        /**
         * Error marker
         */
        Error = 3,
    }
    /**
     *  Editor marker definition
     */
    interface EditorMarker {
        /**
         * The message to show in the tool tip
         */
        message: string;
        /**
         * The severity of the marker
         */
        severity: MarkerSeverity;
        /**
         * The text range to apply the marker to
         */
        range: EditorRange;
    }
    /**
     *  A Range of text in the text editor.  Same properties as a Monaco IRange interface
     */
    interface EditorRange {
        /**
         * Line number on which the range starts (starts at 1).
         */
        startLineNumber: number;
        /**
         * Column on which the range starts in line `startLineNumber` (starts at 1).
         */
        startColumn: number;
        /**
         * Line number on which the range ends.
         */
        endLineNumber: number;
        /**
         * Column on which the range ends in line `endLineNumber`.
         */
        endColumn: number;
    }
    /**
     * Editor view model implementation.
     */
    class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract {
        /**
         * The contents of the document.
         */
        content: KnockoutObservable<string>;
        /**
         * Selected content of the document.  Will be empty if nothing is selected.
         */
        selectedContent: KnockoutObservable<string>;
        /**
         *  Range of selected text in the editor
         */
        selectedRange: KnockoutObservable<EditorRange>;
        /**
         *  Definition for markers in the editor.
         */
        markers: KnockoutObservableArray<EditorMarker>;
        /**
         *  Position of the cursor in the editor
         */
        position: KnockoutObservable<EditorPosition>;
        /**
         * The type of the document.
         */
        contentType: KnockoutObservable<ContentType>;
        /**
         * Definition for a custom content type.
         */
        customContentType: KnockoutObservable<CustomContentType>;
        /**
         * The editor options.
         */
        options: KnockoutObservable<MsPortalFx.ViewModels.Controls.Documents.Editor.Options>;
        /**
         * Indicates if the content has been modified and has not been saved.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * Saves the content of the file.
         */
        save: MsPortalFx.ViewModels.Controls.Command.Contract;
        /**
         * Defines an auto save timeout in millisenconds when it expires the editor changes are saved.
         * The timeout is set each time the user changes the text and if there where no changes until the time expires the changes are saved
         * Zero -or- null means auto save is disabled
         */
        autoSaveTimeout: KnockoutObservable<number>;
        /**
         * Content uri, defines document location and type
         */
        contentUri: KnockoutObservable<string>;
        /**
         * Indicates which editor extensions to use.
         */
        extensions: Extensions;
        /**
         * Indicates options for the specified extensions.
         */
        extensionOptions: ExtensionOptions;
        /**
         * Configuration options.
        */
        configuration: Configuration;
        /**
         * Indicates if the editor is displayed
         */
        visible: KnockoutObservable<boolean>;
        /**
         * Refreshes the editor view.
         */
        refresh: MsPortalFx.ViewModels.Controls.Command.Contract;
        /**
         * Creates an editor view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param contentType The type of document.
         * @param content The contents of the document.
         * @param options The editor options.
         * @param customContentType The editor options.
         * @param extensions List of extensions to use.
         * @param extensionOptions Options for the specified extensions.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, contentType: ContentType, content: string, options?: MsPortalFx.ViewModels.Controls.Documents.Editor.Options, customContentType?: CustomContentType, extensions?: Editor.Extensions, extensionOptions?: Editor.ExtensionOptions, configuration?: Configuration);
        private _setupExtensions();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Documents\Editor.DiscussionExtension.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.Editor {
    enum Extensions {
        /**
        * Extension used to enable code discussion.
        */
        Discussion = 1,
    }
    interface ExtensionOptions {
        /**
        * Options for code discussion. If not specified, code discussion will be disabled.
        */
        discussion?: DiscussionOptions;
    }
    /**
     * Represents the position of the thread in the editor.
     */
    interface EditorThreadPosition {
        /**
         * Determines whether thread should be on modified side or not.
         */
        isModifiedSide: boolean;
        /**
         * Start column of the thread.
         */
        startColumn: number;
        /**
         * End column of the thread.
         */
        endColumn: number;
        /**
         * Start line of the thread.
         */
        startLine: number;
        /**
         * End line of the thread.
         */
        endLine: number;
    }
    interface EditorThread extends MsPortalFx.ViewModels.Controls.Documents.DiscussionThread.DiscussionThread {
        /**
         * Position of the thread used to locate inside the editor.
         */
        position: KnockoutObservable<EditorThreadPosition>;
    }
    class EditorThreadViewModel extends MsPortalFx.ViewModels.Controls.Documents.DiscussionThread.DiscussionThreadViewModel {
        /**
         * Position of the thread used to locate inside the editor.
         */
        position: KnockoutObservable<EditorThreadPosition>;
        /**
         * Creates an editor thread class.
         *
         * @param id Id of the thread.
         * @param comment Comments of the thread.
         * @param position Position of the thread.
         */
        constructor(id?: number, comments?: MsPortalFx.ViewModels.Controls.Documents.DiscussionThread.DiscussionComment[], position?: EditorThreadPosition);
    }
    interface BaseDiscussionOptions<TThread extends DiscussionThread.DiscussionThread> extends BaseExtensionOption {
        /**
         * Author of this discussion.
         */
        author: KnockoutObservable<MsPortalFx.ViewModels.Controls.Documents.DiscussionThread.DiscussionAuthor>;
        /**
         * Threads of this discussion.
         */
        threads: KnockoutObservableArray<TThread>;
        /**
         * Action for adding new thread.
         */
        addThread?: MsPortalFx.ViewModels.Controls.Documents.Editor.ExtensionCommand<EditorThreadPosition, any>;
        /**
         * Save thread delegate.
         */
        saveThread?: (content: string, thread: EditorThread, containerName?: string) => MsPortalFx.Base.PromiseV<DiscussionThread.DiscussionThreadSaveResult>;
        /**
         * Save comment delegate.
         */
        saveComment?: (content: string, comment: DiscussionThread.DiscussionComment) => MsPortalFx.Base.PromiseV<DiscussionThread.DiscussionCommentSaveResult>;
        /**
         * Delete comment delegate.
         */
        deleteComment?: (threadId: number, commentId: number) => MsPortalFx.Base.Promise;
        /**
         * Name of the container of this discussion thread.
         */
        containerName?: string;
    }
    interface DiscussionOptions extends BaseDiscussionOptions<EditorThread> {
    }
    /**
     * A helper class that eases command handling for discussion thread operations
     * like add thread, add comment, save comment, delete comment.
     */
    class DiscussionCommandHandler implements MsPortalFx.Base.Disposable {
        /**
         * Discussion thread options.
         */
        options: DiscussionOptions;
        /**
         * Lifetime manager with the lifetime of this class.
         */
        private _lifetimeManager;
        /**
         * Creates a DiscussionCommandHandler instance.
         *
         * @param Discussion thread options.
         */
        constructor(options: DiscussionOptions);
        /**
         * Cleans up subscriptions.
         */
        dispose(): void;
        private _attachAddThreadHandler();
        private _addThreadHandlers(thread);
        private _attachSaveThreadHandler(thread);
        private _attachAddCommentHandler(thread);
        private _attachDeleteCommentHandler(thread);
        private _attachSaveCommentHandler(comment);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Documents\Editor.Extension.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.Editor {
    import CommandStatus = MsPortalFx.ViewModels.Controls.Command.Status;
    /**
     * Enum for extension availability.
     * Individual extensions will contribute to this.
     */
    enum Extensions {
        /**
        * No extension.
        */
        None = 0,
    }
    /**
     * Detailed options for extensions.
     * Individual extensions will contribute to this.
     */
    interface ExtensionOptions {
    }
    /**
     * Base interface for editor extension options.
     */
    interface BaseExtensionOption {
    }
    /**
     * Handler of the extension command.
     */
    interface ExtensionHandler<TContext, TResult> {
        (context?: TContext): MsPortalFx.Base.PromiseV<TResult>;
    }
    /**
     * Light-weight command used for extension actions.
     */
    class ExtensionCommand<TContext, TResult> {
        /**
         * The latest command status.
         */
        status: KnockoutObservable<CommandStatus>;
        /**
         * The latest command error.
         */
        error: KnockoutObservable<any>;
        /**
         * The latest command error message.
         */
        errorMessage: KnockoutObservable<string>;
        /**
         * Handles the command execution.
         */
        handler: KnockoutObservable<ExtensionHandler<TContext, TResult>>;
        /**
         * Creates an extension command.
         *
         * @handler Handles the command execution.
         */
        constructor(handler?: ExtensionHandler<TContext, TResult>);
        /**
        * Executes the command handler and updates the view model state.
        *
        * @return Callback promise for completion or failure.
        */
        execute(context?: TContext): MsPortalFx.Base.PromiseV<TResult>;
    }
    /**
     * Setup delegate for individual extensions.
     */
    interface ExtensionSetupDelegate {
        (extensions: Extensions, extensionOptions: ExtensionOptions): KnockoutDisposable[];
    }
    /**
     * Enables registering setup delegate for an extension.
     *
     * @param setupDelegate Delegate to run when extensions are initialized.
     */
    function registerExtensionSetup(setupDelegate: ExtensionSetupDelegate): void;
    /**
     * Gets the list of setup delegates for extensions.
     *
     * @return List of setup delegates.
     */
    function getExtensionSetups(): ExtensionSetupDelegate[];
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\EditableControl.d.ts
declare module MsPortalFx.ViewModels.Controls.EditableControl {
    interface Contract<TValue> extends Loadable.Contract {
        /**
         * Name attribute of the control to use with form.
         */
        name: string;
        /**
         * Value held by the control. Can be any type.
         */
        value: KnockoutObservable<TValue>;
        /**
         * Original value of the field. Controls edited state.
         */
        dirty: KnockoutObservableBase<boolean>;
    }
    class ViewModel<TValue> extends Loadable.ViewModel implements Contract<TValue> {
        /**
         * Name attribute of the control to use with form.
         */
        name: string;
        /**
         * Value held by the control. Can be any type.
         */
        value: KnockoutObservable<TValue>;
        /**
         * Original value of the field. Controls edited state.
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * Creates an editable control.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\FileDownload\ViewModels.FileDownload.d.ts
declare module MsPortalFx.ViewModels.Controls.FileDownload {
    import FxNet = MsPortalFx.Base.Net2;
    enum Type {
        /**
         * Download file is a text file
         */
        Text = 1,
        /**
         * Download file is a binary file
         */
        Binary = 2,
    }
    /**
     * File download status with http response codes.
     */
    class Status {
        /**
         * Indicates the file download status category.
         * Status string will have the AJAX response status ("success", "notmodified", "error", "timeout", "abort", or "parsererror").
         */
        status: string;
        /**
         * Indicates the file download status code which are standard http response code.
         */
        statusCode: number;
        /**
         * Indicates the error message returned by the AJAX call.
         */
        errorMessage: string;
        constructor(status: string, statusCode: number, errorMessage?: string);
    }
    interface DownloadProgressDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        downloadProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        downloadProgressText?: string;
    }
    /**
     * Options for a file download.
     */
    interface Options {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod?: KnockoutObservableBase<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers?: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType?: KnockoutObservableBase<string>;
        /**
         * Optionally specify whether to add default authorization tokens or options for getting authorization tokens.
         */
        addDefaultAuthorizationToken?: boolean | FxNet.AuthorizationOptions;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType?: KnockoutObservableBase<Type>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage?: KnockoutObservableBase<string>;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions?: DownloadProgressDialogOptions;
        /**
         * Callback executed on download start
         */
        onStart?: () => void;
        /**
         * Callback executed on download end
         */
        onEnd?: (status: Status) => void;
    }
    /**
     * Contract for a file download control.
     */
    class Context {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod: KnockoutObservableBase<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType: KnockoutObservableBase<string>;
        /**
         * Optionally specify options for getting authorization tokens.
         */
        authorizationOptions: FxNet.AuthorizationOptions;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType: KnockoutObservableBase<Type>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage: KnockoutObservableBase<string>;
        /**
         * File download status with standard http response codes will be updated based on the file download ajax call response.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         */
        downloadStatus: KnockoutObservableBase<Status>;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions: DownloadProgressDialogOptions;
        /**
         * Callback executed on download start
         */
        onStart: () => void;
        /**
         * Callback executed on download end
         */
        onEnd: (status: Status) => void;
        /**
         * FileDownload command constructor.
         *
         * @param options.
         */
        constructor(options: Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\FileDownload\ViewModels.FileDownloadButton.d.ts
declare module MsPortalFx.ViewModels.Controls.FileDownloadButton {
    interface Options {
        /**
         * The file download context of the button
         */
        context: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.FileDownload.Context>;
        /**
         * The button label
         */
        label?: KnockoutObservable<string>;
        /**
         * Indicates whether the button is disabled
         */
        disabled?: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        unauthorizedMessage?: KnockoutObservable<string>;
        /**
         * If control should be a link instead of a button
         */
        asLink?: boolean;
    }
    /**
     * Contract for the download button control.
     */
    class ViewModel extends Loadable.ViewModel implements MsPortalFx.ViewModels.Toolbars.ToolbarButtonContract {
        /**
         * See interface.
         */
        label: KnockoutObservable<string>;
        /**
         * See interface.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * See interface.
         */
        context: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.FileDownload.Context>;
        /**
         * See interface.
         */
        type: MsPortalFx.ViewModels.Toolbars.ToolbarItemType;
        /**
         * See interface.
         */
        disabled: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        unauthorizedMessage: KnockoutObservable<string>;
        /**
         * If control should be a link instead of a button
         */
        asLink: boolean;
        /**
         * FileDownloadButton constructor.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param fileDownloadContext the context of the file download button
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: Options);
        /**
         * See interface.
         */
        unauthorized(message?: string): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Forms\Button.d.ts
declare module MsPortalFx.ViewModels.Controls.Forms.Button {
    /**
     * Mouse states.
     */
    const enum MouseState {
        /**
         * Default state.
         */
        Initial = 0,
        /**
         * Hover state.
         */
        Hover = 1,
        /**
         * Pressed state.
         */
        Active = 2,
    }
    /**
     * Normal and pressed Uri options.
     */
    interface UriOptions {
        /**
         * An object with enabled and disabled properties set to MouseStateImageUris objects.
         */
        normal?: EnabledDisabledUris;
        /**
         * An object with enabled and disabled properties set to MouseStateImageUris objects.
         */
        pressed?: EnabledDisabledUris;
    }
    /**
     * Enabled and disabled Urls.
     */
    interface EnabledDisabledUris {
        /**
         * An object with initial, hover, and active mouse-state properties set to image strings.
         */
        enabled?: MouseStateImageUris;
        /**
         * An object with initial, hover, and active mouse-state properties set to image strings.
         */
        disabled?: MouseStateImageUris;
    }
    /**
     * Images for mouse states.
     */
    interface MouseStateImageUris {
        /**
         * Default state.
         */
        initial?: string;
        /**
         * Hover state.
         */
        hover?: string;
        /**
         * Pressed state.
         */
        active?: string;
    }
    /**
     * Normal and pressed state text options.
     */
    interface TextOptions {
        /**
         * An object with enabled and disabled properties set to EnabledDisabledText objects.
         */
        normal?: EnabledDisabledText;
        /**
         * An object with enabled and disabled properties set to EnabledDisabledText objects.
         */
        pressed?: EnabledDisabledText;
    }
    /**
     * Enabled and disabled text.
     */
    interface EnabledDisabledText {
        /**
         * An object with initial, hover, and active mouse-state properties set to image strings.
         */
        enabled?: MouseStateTexts;
        /**
         * An object with initial, hover, and active mouse-state properties set to image strings.
         */
        disabled?: MouseStateTexts;
    }
    /**
     * Text for mouse states.
     */
    interface MouseStateTexts {
        /**
         * Default state.
         */
        initial?: string;
        /**
         * Hover state.
         */
        hover?: string;
        /**
         * Pressed state.
         */
        active?: string;
    }
    interface Contract extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * Indicates if the button acts as a submit button. If true, when clicked, the button will trigger a submit event.
         */
        submit: boolean;
        /**
         * jQuery selector indicating what tag changes it's image source.
         */
        selector: KnockoutObservable<string>;
        /**
         * Callback function when the button is clicked.
         */
        click: JQueryEventHandler;
        /**
         * Image URIs used in this widget.
         */
        uri: KnockoutObservable<UriOptions>;
        /**
         * Text used in this widget.
         * Same values as the uri option.
         */
        text: KnockoutObservable<TextOptions>;
        /**
         * Shows or hides the button.
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the button is displayed as the default.
         */
        isDefault: KnockoutObservableBase<boolean>;
    }
    class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract {
        /**
         * Indicates if the button acts as a submit button. If true, when clicked, the button will trigger a submit event.
         */
        submit: boolean;
        /**
         * jQuery selector indicating what tag changes it's image source.
         */
        selector: KnockoutObservable<string>;
        /**
         * Callback function when the button is clicked.
         */
        click: JQueryEventHandler;
        /**
         * Image URLs used in this widget.
         */
        uri: KnockoutObservable<UriOptions | EnabledDisabledUris | MouseStateImageUris | string>;
        /**
         * Text used in this widget.
         * Same values as the uri option.
         */
        text: KnockoutObservable<TextOptions | EnabledDisabledText | MouseStateTexts | string>;
        /**
         * Shows or hides the button.
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the button is displayed as the default.
         */
        isDefault: KnockoutObservableBase<boolean>;
        /**
         * Constructs a button view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Forms\CopyableLabel.d.ts
declare module MsPortalFx.ViewModels.Controls.Forms.CopyableLabel {
    import LabelAndBalloon = MsPortalFx.ViewModels.Forms.Base.LabelAndBalloon;
    interface Contract extends Loadable.Contract {
        /**
         * The value of the TextBox.
         */
        value: KnockoutObservableBase<string>;
    }
    interface Options extends LabelAndBalloon.Options {
    }
    class ViewModel extends LabelAndBalloon.ViewModel implements Contract {
        /**
         * The value of the TextBox.
         */
        value: KnockoutObservable<string>;
        /**
         * Contstructs a copyable label view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Forms\DateTimeCombo.d.ts
declare module MsPortalFx.ViewModels.Obsolete.Controls.Forms.DateTimeCombo {
    interface Contract extends MsPortalFx.ViewModels.Controls.Forms.EditableCombo.Contract<Date> {
        /**
         * A valid format string specifier (see date.format polyfill), used to format the value.
         */
        formatString: KnockoutObservable<string>;
    }
    class ViewModel extends MsPortalFx.ViewModels.Controls.Forms.EditableCombo.ViewModel<Date> implements Contract {
        /**
         * See interface.
         */
        formatString: KnockoutObservable<string>;
        /**
         * Creates a date time combo.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Forms\EditableCombo.d.ts
declare module MsPortalFx.ViewModels.Controls.Forms.EditableCombo {
    enum PositioningAlignment {
        /**
         * Left edge for horizontal alignment, top edge for vertical alignment.
         */
        LeftTop = 3,
        /**
         * Right edge for horizontal alignment, top edge for vertical alignment.
         */
        RightTop = 5,
        /**
         * Left edge for horizontal alignment, bottom edge for vertical alignment.
         */
        LeftBottom = 10,
        /**
         * Right edge for horizontal alignment, bottom edge for vertical alignment.
         */
        RightBottom = 12,
    }
    enum DropDownPositioning {
        /**
         * DropDown expand to bottom align on the the right edge.
         */
        BottomRight = 0,
        /**
         * DropDown expand to top align on the the right edge.
         */
        TopRight = 1,
        /**
         * DropDown expand to bottom align on the the left edge.
         */
        BottomLeft = 2,
        /**
         * DropDown expand to top align on the the left edge.
         */
        TopLeft = 3,
    }
    /**
     * Deprecated
     */
    enum DropDownWidth {
        /**
         * Deprecated
         * Width is determined by the content.
         */
        Default = 0,
        /**
         * Deprecated
         * Width is same as widget width.
         */
        Full = 1,
        /**
         * Deprecated
         * Content width if content width is larger than widget width. Otherwise widget width is used.
         */
        MinWidgetMaxContent = 2,
    }
    interface Contract<TValue> extends ValidatableControl.Contract<TValue> {
        /**
         * Alignment used for drop popup.
         */
        popupAlignment: PositioningAlignment;
        /**
         * Alignment used for input.
         */
        inputAlignment: PositioningAlignment;
        /**
         * Position of drop down based on widget.
         */
        dropDownPositioning: KnockoutObservable<DropDownPositioning>;
        /**
         * Deprecated
         * Width behavior of the drop down.
         */
        dropDownWidth: KnockoutObservable<Obsolete>;
    }
    class ViewModel<TValue> extends ValidatableControl.ViewModel<TValue> implements Contract<TValue> {
        /**
         * See interface.
         */
        popupAlignment: PositioningAlignment;
        /**
         * See interface.
         */
        inputAlignment: PositioningAlignment;
        /**
         * See interface.
         */
        dropDownPositioning: KnockoutObservable<DropDownPositioning>;
        /**
         * Deprecated
         * See interface.
         */
        dropDownWidth: KnockoutObservable<Obsolete>;
        /**
         * Creates an editable dropdown.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Forms\FileUpload.d.ts
declare module MsPortalFx.ViewModels.Controls.Forms.FileUpload {
    const enum UploadStatus {
        /**
         * Invalid.
         */
        Invalid = 0,
        /**
         * Pending.
         */
        Pending = 1,
        /**
         * Uploading.
         */
        Uploading = 2,
        /**
         * Paused.
         */
        Paused = 3,
        /**
         * Complete.
         */
        Complete = 4,
    }
    interface UploadTask {
        /**
         * Whether the file associated with the upload task is valid or not.
         */
        valid: boolean;
        /**
         * The current status of the upload task.
         */
        status: UploadStatus;
        /**
         * The percent complete of the upload task.
         */
        progressPercent: number;
        /**
         * The content of the current file chunk as an ArrayBuffer.
         */
        chunk: FileChunk;
    }
    interface SelectedFile {
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Whether or not to continue uploading the file.
         */
        upload: KnockoutObservable<boolean>;
        /**
         * The byte to start from when reading.
         */
        uploadStartByte: number;
        /**
         * The object representing the upload for this file.
         */
        uploadTask: KnockoutObservableBase<UploadTask>;
    }
    interface FileChunk {
        /**
         * The content of the chunk.
         */
        content: any;
        /**
         * The startbyte of the chunk.
         */
        startByte: number;
        /**
         * The endbyte of the chunk.
         */
        endByte: number;
    }
    interface ResourceStrings {
        /**
         * Placeholder text used by the control when no files are selected.
         */
        placeholderText: string;
        /**
         * The message to display when a single file is selected.
         */
        singleFileSelectedMessage: string;
        /**
         * The message to display when multiple files are selected.
         * The token {0} will be replaced by the number of files when rendered.
         */
        multipleFilesSelectedMessage: string;
    }
    /**
     * The view model interface for FileUpload portal control.
     */
    interface Contract extends ValidatableControl.Contract<string> {
        /**
         * A comma-separated list of allowed file mime-types, excluding extensions.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept?: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The limit of the file size in bytes.
         * Default is 200MB.
         */
        sizeLimit?: number;
        /**
         * Show progress bars demonstrating the progress of the file upload.
         * Default is true.
         */
        showProgressBars: KnockoutObservableBase<boolean>;
        /**
         * The currently-selected files (as limited by maxFiles).
         */
        files?: KnockoutObservableBase<SelectedFile[]>;
    }
    /**
     * The view model interface for FileUpload portal control.
     */
    class ViewModel extends ValidatableControl.ViewModel<string> implements Contract {
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles: number;
        /**
         * The limit of the file size in bytes.
         * Default is 200MB.
         */
        sizeLimit: number;
        /**
         * Show progress bars demonstrating the progress of the file upload.
         * Default is true.
         */
        showProgressBars: KnockoutObservableBase<boolean>;
        /**
         * The currently-selected files (as limited by maxFiles).
         */
        files: KnockoutObservableBase<SelectedFile[]>;
        /**
         * Creates a file upload view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Forms\Obsolete.GroupDropDown.d.ts
declare module MsPortalFx.ViewModels.Controls.Forms.GroupDropDown {
    /**
     * Item represents a row.
     */
    interface ItemData {
    }
    /**
    * Interface representing the label for an Value
    */
    interface Label {
        /**
         * Text for list item.
         */
        text: KnockoutObservable<string>;
        /**
         * Item is disabled.
         */
        disabled: KnockoutObservable<boolean>;
    }
    /**
     * Interface representing the properties for an item in item list.
     */
    interface Value<T> extends Label {
        /**
         * Value bound for list item when li is selected.
         */
        value: KnockoutObservable<T>;
        /**
         * Item is selected.
         */
        selected: KnockoutObservable<boolean>;
    }
    /**
     * GroupInfo is the ViewModel for a particular <optGroup>
     */
    interface GroupInfo {
        /**
         * Id for mapping from Item GroupID column to this user friendly GroupInfo.
         */
        key: string;
        /**
         * User friendly label for the grouping. It can be either string or ko.obserable<string>.
         */
        text: any;
        /**
         * Disable state of this group. It can be either boolean or ko.obserable<boolean>.
         */
        disable: any;
    }
    /**
     * ItemSetting is the fields setting to inform the ViewModel given setting how to build up dropdown items.
     */
    interface ItemSetting {
        /**
         * Property used for display item. If it is not set, it uses items[index] to display.
         */
        textKey?: string;
        /**
         * Property used for Value of an item. If it is not set, it uses items[index] as Value.
         */
        valueKey?: string;
        /**
         * Property used for disable state of an item. If it is not set, default to false.
         */
        disableKey?: string;
        /**
         * Property used for select state of an item. If it is not set, default to false.
         */
        selectedKey?: string;
        /**
         * Property used for grouping of an item. If it is not set, there is no grouping for the items.
         */
        groupIdKey?: string;
    }
    interface Contract extends ValidatableControl.Contract<string> {
        /**
         * Group definitions.
         */
        groupInfos?: GroupInfo[];
        /**
         * Items displayed in the table based on the column definitions when selection is disabled.
         */
        itemsDataArray: ItemData[];
        /**
         * Setting for converting itemsDataArray to items.
         */
        itemSetting?: ItemSetting;
        /**
         * Indicate the items should be initialized.
         */
        areItemsInitialized: KnockoutObservableBase<boolean>;
        /**
         * Items for populate the select/options. This is populated by the prior setting if areItemsInitialized() is false.
         */
        items: KnockoutObservableArray<Label>;
    }
    class ViewModel extends ValidatableControl.ViewModel<string> implements Contract {
        /**
         * See Contract interface.
         */
        groupInfos: GroupInfo[];
        /**
         * See Contract interface.
         */
        itemsDataArray: ItemData[];
        /**
         * See Contract interface.
         */
        itemSetting: ItemSetting;
        /**
         * Setting for Item:
         */
        areItemsInitialized: KnockoutObservableBase<boolean>;
        /**
         * See Contract interface.
         */
        items: KnockoutObservableArray<Label>;
        /**
         * Creates a group drop down.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Forms\ProgressOverlay.d.ts
declare module MsPortalFx.ViewModels.Controls.Forms.ProgressOverlay {
    enum Type {
        /**
         * A small, centered spinner.
         */
        SpinnerSmall = 0,
    }
    interface ViewModel extends Loadable.ViewModel {
        /**
         * Visual type of the progress overlay.
         */
        type: KnockoutObservable<Type>;
        /**
         * Control's aria-labelledby setting.
         */
        labelId: string;
        /**
         * Control's aria-describedby setting.
         */
        detailsId: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Forms\Selector.d.ts
declare module MsPortalFx.ViewModels.Obsolete.Controls.Forms.Selector {
    /**
     * Defines the contract for the selector control view model.
     */
    interface ContractBase<T> {
        /**
         * The default value for a specific instance of the selector.
         */
        defaultValue?: KnockoutObservableBase<T>;
        /**
         * True if the value is displayed, else false.
         */
        showValue?: KnockoutObservableBase<boolean>;
        /**
         * True if the current value is the default value; else false. Optional.
         */
        isDefault?: KnockoutObservableBase<boolean>;
        /**
         * The display text for the value in the selector.
         */
        displayText: KnockoutObservableBase<string>;
        /**
         * The icon displayed next to the label and value.
         */
        icon?: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * An instance of MsPortalFx.ViewModels.Selectable which controls whether this control can be selected.
         */
        selectable: Selectable<any>;
        /**
         * True if the control is locked; else false.
         */
        locked: KnockoutObservableBase<boolean>;
        /**
         * Text to display on the balloon shown next to the title.
         */
        infoBalloonText: KnockoutObservableBase<string>;
        /**
         * Text to display on the balloon shown over the locked indicator.
         */
        lockedBalloonText: KnockoutObservableBase<string>;
        /**
         * Link to display within the balloon underneath the text, the balloon is shown next to the label.
         */
        infoBalloonLink?: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Balloon.Link>;
    }
    /**
     * Defines the contract for the selector control view model.
     */
    interface Contract<T> extends ContractBase<T>, MsPortalFx.ViewModels.Controls.ValidatableControl.Contract<T> {
        /**
         * The title of the selector. Used to specify the kind of value being selected.
         */
        label: KnockoutObservableBase<string>;
    }
    class ViewModel<T> extends MsPortalFx.ViewModels.Controls.ValidatableControl.ViewModel<T> implements Contract<T> {
        /**
         * See interface.
         */
        label: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        defaultValue: KnockoutObservableBase<T>;
        /**
         * See interface.
         */
        showValue: KnockoutObservableBase<boolean>;
        /**
         * See interface.
         */
        displayText: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * See interface.
         */
        selectable: Selectable<MsPortalFx.ViewModels.DynamicBladeSelection>;
        /**
         * See interface.
         */
        locked: KnockoutObservableBase<boolean>;
        /**
         * See interface.
         */
        infoBalloonText: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        lockedBalloonText: KnockoutObservableBase<string>;
        /**
         * Link to display within the balloon underneath the text, the balloon is shown next to the label.
         */
        infoBalloonLink: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Balloon.Link>;
        /**
         * Creates the view model for a selector.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param initialState The initial state of the selectable.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, initialState?: any, selectedValue?: MsPortalFx.ViewModels.DynamicBladeSelection);
        dispose(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Forms\TextBox.d.ts
declare module MsPortalFx.ViewModels.Controls.Forms.TextBox {
    /**
     * Enum to indicate when to trigger value updates.
     */
    enum ValueUpdateTrigger {
        /**
         * Trigger value updates after change event. This will typically happen after blur where the entire value will be updated.
         */
        Default = 0,
        /**
         * Trigger value updates as soon as user types a character.
         */
        AfterKeyDown = 1,
        /**
         * Trigger value updates as soon as user types a character (including repeated keys).
         */
        KeyPress = 2,
        /**
         * Trigger value update on blur.
         */
        Blur = 3,
        /**
         * Trigger value update on input Event (IE 9+) .
         */
        Input = 4,
    }
    /**
     * The view model interface for TextBox portal control.
     */
    interface Contract extends TypableControl.Contract<string> {
        /**
         * Placeholder text attribute of the TextBox.
         * If you don't provide placeholder text, the text box will not have placeholder.
         */
        placeholder?: KnockoutObservable<string>;
        /**
         * Events supported by the TextBox control.
         */
        events: Events;
    }
    /**
     * Event callback for TextBox.
     */
    class Events {
        /**
         * Event is triggerred when user presses the enter key.
         */
        enterPressed: (value: string) => void;
    }
    /**
     * The view model interface for TextBox portal control.
     */
    class ViewModel extends TypableControl.ViewModel<string> implements Contract {
        /**
         * Placeholder text attribute of the TextBox.
         * If you don't provide placeholder text, the text box will not have placeholder.
         */
        placeholder: KnockoutObservable<string>;
        /**
         * Events supported by the TextBox control.
         */
        events: Events;
        /**
         * Creates a textbox.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Internal\IFrame.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.Internal.IFrame {
    enum Scroll {
        /**
         * Only when needed.
         */
        Auto = 1,
        /**
         * Always provide a scroll bar.
         */
        Yes = 2,
        /**
         * Never provide a scoll bar.
         */
        No = 3,
    }
    interface Options {
        /**
         * The URL of the page to embed.
         */
        src: string;
        /**
         * Enumerated attribute indicating when the browser should provide a scroll bar.
         */
        scrolling?: Scroll;
        /**
         * Data passed from the shell to the control.
         */
        postMessage?: KnockoutObservable<any>;
        /**
         * Data passed from the control to the shell.
         */
        receiveMessage?: KnockoutObservable<any>;
    }
    class ViewModel extends Base.ViewModel {
        /**
         * The URL of the page to embed.
         */
        src: string;
        /**
         * Enumerated attribute indicating when the browser should provide a scroll bar.
         */
        scrolling: Scroll;
        /**
         * Data passed from the shell to the control.
         */
        postMessage: KnockoutObservable<any>;
        /**
         * Data passed from the control to the shell.
         */
        receiveMessage: KnockoutObservable<any>;
        /**
         * Constructs an IFrame view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options Optional The set of options to configure the IFrame control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: MsPortalFx.ViewModels.Controls.Internal.IFrame.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Internal\IFrameV2.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.Internal.IFrameV2 {
    import FxAppBlade = MsPortalFx.ViewModels.AppBlade;
    import Message = FxAppBlade.Message;
    interface Options {
        /**
         * The URL of the page to embed.
         */
        src: string;
        /**
         * Data passed from the shell to the control.
         */
        postMessage?: KnockoutObservable<Message>;
        /**
         * Data passed from the control to the shell.
         */
        receiveMessage?: KnockoutObservable<Message>;
    }
    class ViewModel extends Base.ViewModel {
        /**
         * The URL of the page to embed.
         */
        src: string;
        /**
         * Data passed from the shell to the control.
         */
        postMessage: KnockoutObservable<Message>;
        /**
         * Data passed from the control to the shell.
         */
        receiveMessage: KnockoutObservable<Message>;
        /**
         * Indicates whether the iframe control has initialized.
         */
        controlIsReady: KnockoutObservable<boolean>;
        /**
         * Constructs an IFrame view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options Optional The set of options to configure the IFrame control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ItemList.d.ts
declare module MsPortalFx.ViewModels.Controls.ItemList {
    /**
     * Interface representing the properties for an item in item list.
     */
    interface ItemValueContract<T> {
        /**
         * Text for list item.
         */
        text: KnockoutObservable<string>;
        /**
         * Value bound for list item when the item is selected.
         */
        value: KnockoutObservable<T>;
        /**
         * Item is selected.
         */
        selected: KnockoutObservable<boolean>;
        /**
         * Item is disabled.
         */
        disabled: KnockoutObservable<boolean>;
    }
    class ItemValue<T> implements MsPortalFx.ViewModels.Controls.ItemList.ItemValueContract<T> {
        /**
         * Text for list item.
         */
        text: KnockoutObservable<string>;
        /**
         * Value bound for list item when the item is selected.
         */
        value: KnockoutObservable<T>;
        /**
         * Item is selected.
         */
        selected: KnockoutObservable<boolean>;
        /**
         * Item is disabled.
         */
        disabled: KnockoutObservable<boolean>;
        /**
         * @param text The text data binding for the item.
         * @param value The value data binding for the item.
         * @param selected The item is selected.
         * @param disabled The item is disabled.
         */
        constructor(text: string, value: T, selected?: boolean, disabled?: boolean);
    }
    /**
     * View model interface representing the properties for item list.
     */
    interface Contract<TValue> extends ValidatableControl.Contract<ItemValue<TValue>> {
        /**
         * Aria label id.
         */
        label: string;
        /**
         * Observable array containing the following array element:
         * * ItemValue.
         */
        values: KnockoutObservableArray<ItemValue<TValue>>;
    }
    class ViewModel<TValue> extends ValidatableControl.ViewModel<ItemValueContract<TValue>> implements Contract<TValue> {
        /**
         * Aria label id.
         */
        label: string;
        /**
         * Observable array containing the following array element:
         * * BaseItemValue.
         */
        values: KnockoutObservableArray<ItemValue<TValue>>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Base\ViewModels.ActionHandlerInterfaces.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Base {
    /**
     * A control that can perform actions when directed by an ActionSource control
     */
    interface ActionHandler {
        /**
         *  Internal use only. Signals that this control can perform filtering actions via ActionSource
         */
        _filterActions: boolean;
    }
    /**
     * A control that can invoke actions on another control
     */
    interface ActionSource {
        /**
         * The handler control that will be manipulated by this control.
         */
        actionHandler: KnockoutObservableBase<ActionHandler> | ActionHandler;
        /**
         * When not enabled, this control will not send events to the handler.
         */
        actionsEnabled: KnockoutObservable<boolean>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Base\ViewModels.Formatters.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    module Formatters {
        enum FormatType {
            /**
             * HTML format, raw HTML is allowed.
             */
            Html = 1,
            /**
             * Text format, HTML gets encoded.
             * The value can also be simple text or a KnockoutObservable object.
             */
            Text = 2,
            /**
             * URI format, outputs a clickable URI.
             * The value can be an URI, or this format: { uri: string; text: string; target?: string } .
             */
            Uri = 107,
            /**
             * Icon format, outputs an icon with optionally text beside it.
             * The value can be an icon URI, or this format: { uri: string; text?: string; } .
             */
            Icon = 108,
            /**
             * Icon Lookup format, outputs an icon based on a dictionary you provide in formatOptions.iconLookup.
             * The value is the key that matches the iconLookup dictionary.
             * The iconLookup dictionary can be { key: iconUri, ... } or { key: { uri: string, text?: string }, ... } .
             * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
             */
            IconLookup = 109,
            /**
             * Text Lookup format, outputs text based on a dictionary you provide in formatOptions.textLookup.
             * The value is the key that matches the textLookup dictionary.
             * The textLookup dictionary is { key: text, ... } .
             */
            TextLookup = 110,
            /**
             * Icon format, outputs an icon with optionally text beside it.
             * The value can be an SVG, or this format: { svg: MsPortalFx.Base.Image; text?: string; } .
             */
            SvgIcon = 111,
            /**
             * Icon Lookup format, outputs an icon based on a dictionary you provide in formatOptions.iconLookup.
             * The value is the key that matches the iconLookup dictionary.
             * The iconLookup dictionary can be { key: MsPortalFx.Base.Image, ... } or { key: { svg: MsPortalFx.Base.Image, text?: string }, ... } .
             * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
             */
            SvgIconLookup = 112,
            /**
             * Date format, outputs the format based on formatOptions.dateFormat
             * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
             */
            Date = 113,
            /**
             * Number format, outputs a globalized number
             * The value can be a number.
             */
            Number = 114,
            /**
             * Html Bindings format, uses a template defined in formatOptions.htmlBindingsTemplate and apply the binding defined in formatOptions.htmlBindingsViewModel.
             * The value can be anything that the view model can understand. See the HtmlBindingsType for more details.
             */
            /**
             * Will return an object containing the following:
             * { value: any, settings?: CellFormatterSettings }
             *
             * The value is the one from your itemKey, the settings vary depending on which plugin is loaded into the grid.
             */
            HtmlTemplate = 1000,
            /**
             * Uses a CheckBox control for the cell.
             */
            CheckBox = 1001,
            /**
             * Uses a TextBox control for the cell.
             */
            TextBox = 1002,
            /**
             * Uses a MultiselectDropDown control for the cell.
             */
            MultiselectDropDown = 1003,
            /**
             * CheckBox ViewModel which maps your data with the state of the row, selected/unselected for checked/unchecked.
             */
            CheckBoxRowSelection = 1004,
            /**
             * Uses a DropDown control for the cell.
             */
            DropDown = 1005,
        }
        interface FormatOptions {
        }
        interface Format {
            type: FormatType;
        }
        class BaseFormat implements Format {
            type: FormatType;
            constructor(type: FormatType);
        }
        interface HtmlFormatOptions extends FormatOptions {
        }
        class Html extends BaseFormat implements HtmlFormatOptions {
            constructor(options?: HtmlFormatOptions);
        }
        interface TextFormatOptions extends FormatOptions {
        }
        class Text extends BaseFormat implements TextFormatOptions {
            constructor(options?: TextFormatOptions);
        }
        interface DateFormatOptions extends FormatOptions {
            /**
             * Date format if using the CustomDate.
             * Accepts any object matching the MsPortalFx.Intl.DateTimeFormatOptions interface.
             */
            dateFormat?: MsPortalFx.Intl.DateTimeFormatOptions;
        }
        class Date extends BaseFormat implements DateFormatOptions {
            /**
             * Date format if using the CustomDate.
             * Accepts any object matching the MsPortalFx.Intl.DateTimeFormatOptions interface.
             */
            dateFormat: MsPortalFx.Intl.DateTimeFormatOptions;
            constructor(options?: DateFormatOptions);
        }
        interface NumberFormatOptions extends FormatOptions {
            /**
             * Date format if using the CustomDate.
             * Accepts any object matching the MsPortalFx.Intl.NumberFormatOptions interface.
             */
            numberFormat?: MsPortalFx.Intl.NumberFormatOptions;
        }
        class Number extends BaseFormat implements NumberFormatOptions {
            /**
             * Date format if using the CustomDate.
             * Accepts any object matching the MsPortalFx.Intl.NumberFormatOptions interface.
             */
            numberFormat: MsPortalFx.Intl.NumberFormatOptions;
            constructor(options?: NumberFormatOptions);
        }
        interface UriFormatOptions extends FormatOptions {
        }
        class Uri extends BaseFormat implements UriFormatOptions {
            constructor(options?: UriFormatOptions);
        }
        interface IconFormatOptions extends FormatOptions {
        }
        class Icon extends BaseFormat implements IconFormatOptions {
            constructor(options?: IconFormatOptions);
        }
        interface IconLookupFormatOptions extends FormatOptions {
            /**
             * Dictionary with key matching the value of the itemKey.
             * The value can be either the iconUri or an object as such { uri: string, text?: string } .
             */
            iconLookup?: any;
        }
        class IconLookup extends BaseFormat implements IconLookupFormatOptions {
            /**
             * Dictionary with key matching the value of the itemKey.
             * The value can be either the iconUri or an object as such { uri: string, text?: string } .
             */
            iconLookup: any;
            constructor(options?: IconLookupFormatOptions);
        }
        interface TextLookupFormatOptions extends FormatOptions {
            /**
             * Dictionary with key matching the value of the itemKey.
             * The value is the text mapped to the value.
             */
            textLookup?: any;
        }
        class TextLookup extends BaseFormat implements TextLookupFormatOptions {
            /**
             * Dictionary with key matching the value of the itemKey.
             * The value is the text mapped to the value.
             */
            textLookup: any;
            constructor(options?: TextLookupFormatOptions);
        }
        interface SvgIconFormatOptions extends FormatOptions {
            /**
             * Css value for height of svg icon.
             */
            height?: string;
            /**
             * Css value for width of svg icon.
             */
            width?: string;
        }
        class SvgIcon extends BaseFormat implements SvgIconFormatOptions {
            /**
             * Css value for height of svg icon.
             */
            height: string;
            /**
             * Css value for width of svg icon.
             */
            width: string;
            constructor(options?: SvgIconFormatOptions);
        }
        interface SvgAndText {
            svg: MsPortalFx.Base.Image;
            text?: string;
        }
        interface SvgIconLookupFormatOptions extends SvgIconFormatOptions {
            /**
             * Dictionary with key matching the value of the itemKey.
             * The value can be either the MsPortalFx.Base.Image or an object as such { svg: MsPortalFx.Base.Image, text?: string } .
             */
            svgIconLookup?: StringMap<MsPortalFx.Base.Image | SvgAndText>;
        }
        class SvgIconLookup extends BaseFormat implements SvgIconLookupFormatOptions {
            /**
             * Dictionary with key matching the value of the itemKey.
             * The value can be either the MsPortalFx.Base.Image or an object as such { svg: MsPortalFx.Base.Image, text?: string } .
             */
            svgIconLookup: StringMap<MsPortalFx.Base.Image | SvgAndText>;
            /**
             * Css value for height of svg icon.
             */
            height: string;
            /**
             * Css value for width of svg icon.
             */
            width: string;
            constructor(options?: SvgIconLookupFormatOptions);
        }
        interface HtmlTemplateFormatOptions extends FormatOptions {
            /**
             * HTML which applyBindings will be executed on.
             * To know which variables will be available, see the HtmlBindingsType.
             */
            template?: string;
        }
        class HtmlTemplate extends BaseFormat implements HtmlTemplateFormatOptions {
            /**
             * HTML which applyBindings will be executed on.
             * To know which variables will be available, see the HtmlBindingsType.
             */
            template: string;
            constructor(options?: HtmlTemplateFormatOptions);
        }
        interface FieldFormatOptions extends FormatOptions {
            /**
             * The label for the form field.
             */
            label?: string;
            /**
             * A list of validations that should be applied to the form field.
             */
            validations?: any;
            /**
             * When changed forces validation on this column of the grid for all rows that are in editing mode.
             */
            validate?: KnockoutObservable<number>;
            /**
             * Specifies text that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonContent?: string;
        }
        class FieldFormat extends BaseFormat implements FieldFormatOptions {
            /**
             * The label for the form field.
             */
            label: string;
            /**
             * A list of validations that should be applied to the form field.
             */
            validations: MsPortalFx.ViewModels.FormValidation[];
            /**
             * When changed forces validation on this column of the grid for all rows that are in editing mode.
             */
            validate: KnockoutObservable<number>;
            /**
             * Specifies text that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonContent: string;
            constructor(type: FormatType, options?: FieldFormatOptions);
        }
        interface CheckBoxFormatOptions extends FieldFormatOptions {
        }
        class CheckBox extends FieldFormat implements CheckBoxFormatOptions {
            constructor(options?: CheckBoxFormatOptions);
        }
        interface TextBoxFormatOptions extends FieldFormatOptions {
            /**
             * Text displayed in the field when the form value is empty.
             */
            emptyValueText?: string;
        }
        class TextBox extends FieldFormat implements TextBoxFormatOptions {
            /**
             * Text displayed in the field when the form value is empty.
             */
            emptyValueText: string;
            constructor(options?: TextBoxFormatOptions);
        }
        interface MultiselectDropDownFormatOptions<T> extends FieldFormatOptions {
            /**
             * A list of groups to categorize the selectable options.
             * Dynamic update of groups array is not yet supported for multiselect dropdown.
             * Consumers must initialize the groups before widget instantiation.
             */
            groups?: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IGroup<T>>;
            /**
            * Turns on or off multiselect.
            */
            multiselect?: KnockoutObservable<boolean>;
            /**
            * Maximum select rows counts.  When max is reached, the control will disable all the unselected item.
            */
            maxSelectAllowed?: KnockoutObservable<number>;
            /**
            * Display Text Format when it is under max allowed.
            * By default. the format string is "{0} selected"
            * The first argument({0}) is the selected rows count, for example, 3.
            * The second argument({1}) is the input value is going to submit, for example, "val1;val2;val3".
            * The third argument({2}) is the display value , for example, "display1;display2;display3".
            */
            multiItemsDisplayFormat?: KnockoutObservableBase<string>;
            /**
            * Display Text Format when max is reached.
            * By default. the format string is "max {0} selected"
            * The first argument({0}) is the selected rows count, for example, 3.
            * The second argument({1}) is the input value is going to submit, for example, "val1;val2;val3".
            * The third argument({2}) is the display value , for example, "display1;display2;display3".
            */
            multiItemsMaxDisplayFormat?: KnockoutObservableBase<string>;
            /**
            * Value Separator for combining the selected item into a <input> value. For example, "val1;val2;val5".
            * We use standard javascript split function.  Can be a string.
            * By default, we use String.fromCharCode(0x1d). 0x1d is the <GS>, group separator, in ascii code which is not visible in the text box.
            * If you need to see this in the display text, change it to different character, or string.
            */
            valueSeparator?: string;
            /**
            * Display Separator for combining the selected item into a displayable string. For example, "display1;display2;display3".
            * We use standard javascript split function.  Can be a string.
            * By default, we use ";" -- since this need to be visible.
            */
            displaySeparator?: string;
        }
        class MultiselectDropDown<T> extends FieldFormat implements MultiselectDropDownFormatOptions<T> {
            /**
             * A list of groups to categorize the selectable options.
             * Dynamic update of groups array is not yet supported for multiselect dropdown.
             * Consumers must initialize the groups before widget instantiation.
             */
            groups: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IGroup<T>>;
            /**
            * Turns on or off multiselect.
            */
            multiselect: KnockoutObservable<boolean>;
            /**
            * Maximum select rows counts.  When max is reached, the control will disable all the unselected item.
            */
            maxSelectAllowed: KnockoutObservable<number>;
            /**
            * Display Text Format when it is under max allowed.
            * By default. the format string is "{0} selected"
            * The first argument({0}) is the selected rows count, for example, 3.
            * The second argument({1}) is the input value is going to submit, for example, "val1;val2;val3".
            * The third argument({2}) is the display value , for example, "display1;display2;display3".
            */
            multiItemsDisplayFormat: KnockoutObservableBase<string>;
            /**
            * Display Text Format when max is reached.
            * By default. the format string is "max {0} selected"
            * The first argument({0}) is the selected rows count, for example, 3.
            * The second argument({1}) is the input value is going to submit, for example, "val1;val2;val3".
            * The third argument({2}) is the display value , for example, "display1;display2;display3".
            */
            multiItemsMaxDisplayFormat: KnockoutObservableBase<string>;
            /**
            * Value Separator for combining the selected item into a <input> value. For example, "val1;val2;val5".
            * We use standard javascript split function.  Can be a string.
            * By default, we use String.fromCharCode(0x1d). 0x1d is the <GS>, group separator, in ascii code which is not visible in the text box.
            * If you need to see this in the display text, change it to different character, or string.
            */
            valueSeparator: string;
            /**
            * Display Separator for combining the selected item into a displayable string. For example, "display1;display2;display3".
            * We use standard javascript split function.  Can be a string.
            * By default, we use ";" -- since this need to be visible.
            */
            displaySeparator: string;
            constructor(options?: MultiselectDropDownFormatOptions<T>);
        }
        interface CheckBoxRowSelectionFormatOptions extends FieldFormatOptions {
        }
        class CheckBoxRowSelection extends FieldFormat implements CheckBoxRowSelectionFormatOptions {
            constructor(options?: CheckBoxRowSelectionFormatOptions);
        }
        interface DropDownFormatOptions<T> extends FieldFormatOptions {
            /**
             * A list of options the use can select the field value from.
             */
            options?: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IDisablableOption<T>>;
        }
        class DropDown<T> extends FieldFormat implements DropDownFormatOptions<T> {
            /**
             * A list of options the use can select the field value from.
             */
            options: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IDisablableOption<T>>;
            constructor(options?: DropDownFormatOptions<T>);
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Base\ViewModels.Lists.Base.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Base {
    import FxcData = FxImpl.Data;
    import Selection2 = MsPortalFx.ViewModels.Internal.Selection2;
    import LifetimeManager = MsPortalFx.Base.LifetimeManager;
    import SelectableSet = Selection2.SelectableSet;
    import SelectableSetOptions = Selection2.SelectableSetOptions;
    import SelectableSetContract = Selection2.SelectableSetContract;
    /**
     * The item.
     */
    interface Item<T, TId> {
        /**
         * The unique identifier of the item.
         */
        id: TId;
        /**
         * The data of the item.
         */
        data: KnockoutObservableBase<T>;
        /**
         * Set to true if this column reads data from supplemental data
         */
        supplementalData: KnockoutObservableBase<any>;
        /**
         * Indicates if disabled when displayed.
         */
        isDisabled: KnockoutObservableBase<boolean>;
    }
    /**
     * Options for list selection.
     */
    interface SelectionOptions<T, TId> extends SelectableSetOptions<T, TId> {
        /**
         * Enables selection.
         * Default is true.
         */
        enabled?: boolean;
        /**
         * The part containing this grid.  Define this property to automatically enable dynamic selection (provided the dynamicSelectionProvider property is defined).
         */
        activationContainer?: MsPortalFx.ViewModels.PartContainerContract;
    }
    /**
     * Options for list selection.
     */
    interface SelectionContract<T, TId> extends SelectableSetContract<T, TId> {
        /**
         * Enables selection.
         * Default is true.
         */
        enabled: boolean;
    }
    interface Contract<T, TId> extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * Provides data for the display.
         */
        dataNavigator: FxcData.Navigator<T, any, TId>;
        /**
         * The selection state.
         */
        selection: SelectionContract<T, TId>;
        /**
         * The settable loading state of the grid.
         */
        loading: KnockoutObservable<boolean>;
    }
    interface Options<T, TId> extends MsPortalFx.ViewModels.Controls.Loadable.Options {
        /**
         * Provides data for the display.
         */
        dataNavigator?: FxcData.Navigator<T, any, TId>;
        /**
         * The selection state.
         */
        selection?: SelectionOptions<T, TId>;
    }
    class SelectionViewModel<T, TId> extends SelectableSet<T, TId> implements SelectionContract<T, TId> {
        /**
         * Enables selection.
         * Default is true.
         */
        enabled: boolean;
        /**
         * Constructs a list base selection view model.
         *
         * @param lifetime Lifetime manager.
         * @param options Selection options.
         */
        constructor(lifetime: LifetimeManager, options: SelectionOptions<T, TId>);
    }
    class ViewModel<T, TId> extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract<T, TId> {
        /**
         * Provides the primary data for the display.
         */
        dataNavigator: FxcData.Navigator<T, any, TId>;
        /**
         * Maintains the selection and activation states of the list items.
         */
        selection: SelectionContract<T, TId>;
        /**
         * The settable loading state of the grid.
         */
        loading: KnockoutObservable<boolean>;
        /**
         * Constructs a list control base viewmodel.
         *
         * @param options: Options for constructing the view model.
         */
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<T, TId>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    class ViewModel<TItem, TSelection> extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract<TItem, TSelection>, MsPortalFx.Base.Disposable {
        /**
         * See interface.
         */
        summary: KnockoutObservable<string>;
        /**
         * See interface.
         */
        showHeader: boolean;
        /**
         * See interface.
         */
        columns: KnockoutObservableArray<Column>;
        /**
         * See interface.
         */
        items: KnockoutObservableArray<TItem>;
        /**
         * See interface.
         */
        noRowsMessage: KnockoutObservable<string>;
        /**
         * See interface.
         */
        extensions: number;
        /**
         * See interface.
         */
        extensionsOptions: ExtensionsOptions<TItem, TSelection>;
        /**
         * See interface.
         */
        sortByList: KnockoutObservableArray<SortBy>;
        /**
         * Row metadata associated to rows in the grid (editState, selected, disabled, groupId).
         * This property doesn't start with underscore since it needs to passed on to shell iframe.
         * The extended contract in the control has this as a property on the interface to consume changes.
         */
        private rowMetadata;
        /**
         * See interface.
         */
        selectableData: MsPortalFx.ViewModels.SelectableSet<TItem, TSelection>;
        /**
         * See interface.
         */
        createdItems: KnockoutObservableArray<TItem>;
        /**
         * See interface.
         */
        rowAdd: JQueryEventHandler;
        /**
         * See interface.
         * This property doesn't start with underscore since it needs to passed on to shell iframe.
         */
        resetCallback: KnockoutObservableBase<GridResetCallback>;
        /**
         * Observable used to add a new empty row to the grid.
         * This property doesn't start with underscore since it needs to passed on to shell iframe.
         * The extended contract in the control has this as a property on the interface to consume changes.
         */
        private addEmptyRow;
        private _addCreatedLocked;
        private _resetHandler;
        private _pendingResetCallbackPromise;
        private _pendingResetCallbackSubscription;
        private _editScope;
        /**
         * Creates the view model that drives the Grid portal control.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param items The observable list of items to be displayed in the grid.
         * @param extensions The bitmask of grid plugins to load.
         * @param extensionsOptions Options for extensions.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, items: KnockoutObservableArray<TItem>, extensions?: number, extensionsOptions?: ExtensionsOptions<TItem, TSelection>);
        /**
         * See interface.
         */
        getRowMetadata(item: TItem): RowMetadata<TItem>;
        /**
         * See interface.
         */
        reset(): MsPortalFx.Base.Promise;
        /**
         * See interface.
         */
        dispose(): void;
        private _createMetadataForItem(metadataLifetime, item);
        private _create(editScope, getItems);
        private _addCreated(editScope, getItems, itemToAdd);
        private _markForDelete(editScope, itemToDelete);
        private _addInitialCreatedRow(editScope, getItems);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Base.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum Extensions {
        /**
         * Plugin to have sortable columns.
         */
        SortableColumn = 1,
        /**
         * Plugin to have selectable rows.
         */
        SelectableRow = 2,
        /**
         * Plugin to have right-clickable row.
         */
        RightClickableRow = 4,
        /**
         * Plugin to group rows by column value.
         */
        Groupable = 8,
        /**
         * Plugin to have editable rows.
         */
        EditableRow = 16,
        /**
         * Plugin to have filterable rows.
         */
        Filterable = 32,
        /**
         * Plugin to have reorder rows.
         */
        ReorderRow = 64,
        /**
         * Plugin to have a shortcut to the item context menu displayed in the row.
         */
        ContextMenuShortcut = 128,
        /**
         * Plugin to handle and display large items in sequential pages.
         */
        Pageable = 256,
        /**
         * Plugin to display hierarchical items.
         */
        Hierarchical = 512,
        /**
         * Plugin to display items with virtual scrolling.
         */
        Scrollable = 1024,
        /**
        * Plugin to enable hover index communication with other parts.
        */
        Hoverable = 2048,
        /**
         * Plugin to have resizable columns.
         */
        ResizableColumn = 4096,
    }
    interface ExtensionsOptions<TItem, TSelection> {
    }
    interface RowMetadata<T> {
        /**
         * One entry representing the item.
         */
        item: T;
        /**
         * Css class associated with the row.
         */
        cssClass?: KnockoutObservable<string>;
    }
    interface Column {
        /**
         * Name of the column displayed in the header.
         */
        name?: KnockoutObservable<string>;
        /**
         * String mapping to the item key.
         */
        itemKey: string;
        /**
         * Formatter used when displaying one cell.
         */
        format?: Format;
        /**
         * Formatter options associated with the formatters.
         */
        formatOptions?: FormatOptions;
        /**
         * Declare this column is activatable.  The control will automatic apply activatable style through this column.
         */
        activatable?: KnockoutObservableBase<boolean>;
        /**
         * Css class associated with the column.
         */
        cssClass?: string;
        /**
         * Width of the column in pixels or percentage.
         */
        width?: KnockoutObservable<string>;
        /**
         * Indicate this column text need to support ellipse
         */
        enableEllipse?: KnockoutObservableBase<boolean>;
        /**
         * Enable cell content to height 100%
         */
        fullHeight?: KnockoutObservableBase<boolean>;
        /**
         * Forward-compat for Grid2.
         * No use in Grid1.
         */
        id?: string;
        /**
         * Hides the column in collapsed state.
         */
        hiddenInCollapsed?: KnockoutObservableBase<boolean>;
    }
    /**
     * Grid reset callback.
     */
    interface GridResetCallback {
        (): MsPortalFx.Base.Promise;
    }
    /**
     * Generic grid callback interface.
     */
    interface GridCallback {
        (): MsPortalFx.Base.Promise;
    }
    interface ExtensionContract extends Loadable.Contract {
        /**
         * The bitmask of plugins to be loaded.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions?: number;
    }
    interface ContractBase<TItem> {
        /**
         * Shows the column header.
         */
        showHeader?: boolean;
        /**
         * Column definitions.
         */
        columns: KnockoutObservableArray<Column>;
        /**
         * Items displayed in the table based on the column definitions when selection is disabled.
         * It is set in the constructor. Do not directly replace it.
         */
        items?: KnockoutObservableArray<TItem>;
    }
    interface Contract<TItem, TSelection> extends ContractBase<TItem>, ExtensionContract {
        /**
         * Summary of the table.
         */
        summary: KnockoutObservable<string>;
        /**
         * No rows message when no items are displayed.
         */
        noRowsMessage?: KnockoutObservable<string>;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionsOptions?: ExtensionsOptions<TItem, TSelection>;
        /**
         * Gets the row metadata for an item.
         *
         * @param item The grid item whose metadata is requested.
         * @return Row metadata associated to the item.
         */
        getRowMetadata(item: TItem): RowMetadata<TItem>;
        /**
         * Option to reset the view model state for rebind scenarios.
         * Extension authors can override this method if Grid's default reset action doesn't meet their requirements.
         * This method will be called when DataNavigator's resetNavigation method is called.
         * The reset() method will internally invoke the resetCallback set by the grid control.
         * For pageable extension, calling reset will set empty array to the items, invoke data navigator's resetLoadByContinuationToken method
         * and invoke loadByContinuationToken method to fetch new data.
         */
        reset(): MsPortalFx.Base.Promise;
        /**
         * The resetCallback will be populated internally by the Grid control.
         */
        resetCallback: KnockoutObservableBase<GridResetCallback>;
        /**
         * The list of sortBy data.
         */
        sortByList: KnockoutObservableArray<SortBy>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.ContextMenuShortcut.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.EditableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum EditableRowPlacement {
        /**
         * Put the editable row at the bottom of the grid.
         */
        Bottom = 0,
        /**
         * Put the editable row at the top of the grid.
         */
        Top = 1,
    }
    interface Column {
        /**
         * Format used when displaying one cell in edit mode.
         */
        editableFormat?: Format;
        /**
         * Format options associated with the editableFormat.
         */
        editableFormatOptions?: FormatOptions;
    }
    interface EditableRowMetadata<T> extends RowMetadata<T> {
        /**
         * The edit state of the entity in the edit scope.
         */
        editState?: KnockoutObservableBase<MsPortalFx.Data.EditState>;
    }
    interface EditScopeModel<T> {
        /**
         * The model for data stored in the edit scope.
         */
        items: KnockoutObservableArray<T>;
    }
    interface EditableRowOptions<T> {
        /**
         * An observable that supplies an edit scope instance. This instance can change as the enclosing Part is
         * rebound to a different master selection. This property will be nulled out when passed to the view model.
         */
        editScope: KnockoutObservable<MsPortalFx.Data.EditScope<any>>;
        /**
         * An optional function that retrieves the 'items' array from an EditScope instance.
         *
         * @param editScope The edit scope from which to get items.
         * @return The items to be displayed in the grid.
         */
        getItems?: (editScope: MsPortalFx.Data.EditScope<any>) => KnockoutObservableArray<T>;
        /**
         * Indicates if the editable row is at the top or bottom.
         * Defaults to Bottom.
         */
        placement?: EditableRowPlacement;
        /**
         * The maximum number of buffered rows at any time.
         */
        maxBufferedRows?: number | KnockoutObservableBase<number>;
        /**
         * If set to true, clicking on an existing row will go in edit mode.
         * Defaults to false.
         */
        allowEditExistingItems?: boolean;
        /**
         * If set to true, clicking on a newly created row will go in edit mode.
         * Defaults to false.
         */
        allowEditCreatedItems?: boolean;
        /**
         * If set to true, an empty row is displayed at the location defined by the placement property.
         * Defaults to true.
         */
        enableRowAdd?: boolean;
        /**
         * If set to true, right-clicking on a newly created row will show the delete command.
         * Defaults to true.
         */
        enableRowDelete?: boolean;
        /**
         * The title to display for the row delete command.
         * Defaults to Delete.
         */
        deleteRowCommandTitle?: string;
        /**
         * Callback function that gets executed when an item is created.
         *
         * @param item The newly created item.
         */
        created?: (item: T) => void;
        /**
         * When changed ensures validation on the entire grid.
         */
        validate?: KnockoutObservable<number>;
        /**
         * When all form fields in the editable rows in editing mode are valid then true; else false.
         */
        valid?: KnockoutObservable<boolean>;
    }
    interface EditableRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the EditableRow grid extension. If null, rows will not be editable.
         */
        editableRow?: EditableRowOptions<TItem>;
    }
    interface EditableRowContract<TItem, TSelection> extends Contract<TItem, TSelection> {
        /**
         * Contains all the created items used by the EditableRow extension.
         */
        createdItems?: KnockoutObservableArray<TItem>;
        /**
         * The callback that is executed when a row is added.
         */
        rowAdd: JQueryEventHandler;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.FieldInfo.d.ts
import GroupDropDown = MsPortalFx.ViewModels.Forms.GroupDropDown;
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    /**
     * View model data required by HtmlBindingsType.TextBox for rendering the text form field.
     */
    interface TextFormFieldInfo extends HtmlBindingsData {
        /**
         * Text displayed in the field when the form value is empty.
         */
        emptyValueText?: string;
    }
    /**
     * View model data required by HtmlBindingsType.CheckBox for rendering the checkbox form field.
     */
    interface CheckBoxFormFieldInfo extends HtmlBindingsData {
    }
    /**
     * View model data required by HtmlBindingsType.MultiselectDropDown
     * for rendering the multi-select dropdown control.
     */
    interface MultiselectDropDownFormFieldInfo<T> extends HtmlBindingsData {
        /**
         * A list of groups to categorize the selectable options.
         * Dynamic update of groups array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        groups: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IGroup<T>>;
        /**
         * Specify the format type and format option for customizing the option display value.
         */
        formatSetting?: FormOptionFormatSetting;
        /**
         * Turns on or off multiselect.
         */
        multiselect?: KnockoutObservable<boolean>;
        /**
         * Maximum select rows counts.  When max is reached, the control will disable all the unselected item.
         */
        maxSelectAllowed?: KnockoutObservable<number>;
        /**
         * Display Text Format when it is under max allowed.
         * By default. the format string is "{0} selected"
         * The first argument({0}) is the selected rows count, for example, 3.
         * The second argument({1}) is the input value is going to submit, for example, "val1;val2;val3".
         * The third argument({2}) is the display value , for example, "display1;display2;display3".
         */
        multiItemsDisplayFormat?: KnockoutObservableBase<string>;
        /**
         * Display Text Format when max is reached.
         * By default. the format string is "max {0} selected"
         * The first argument({0}) is the selected rows count, for example, 3.
         * The second argument({1}) is the input value is going to submit, for example, "val1;val2;val3".
         * The third argument({2}) is the display value , for example, "display1;display2;display3".
         */
        multiItemsMaxDisplayFormat?: KnockoutObservableBase<string>;
        /**
         * Value Separator for combining the selected item into a <input> value. For example, "val1;val2;val5".
         * We use standard javascript split function.  Can be a string.
         * By default, we use String.fromCharCode(0x1d). 0x1d is the <GS>, group separator, in ascii code which is not visible in the text box.
         * If you need to see this in the display text, change it to different character, or string.
         */
        valueSeparator?: string;
        /**
         * Display Separator for combining the selected item into a displayable string. For example, "display1;display2;display3".
         * We use standard javascript split function.  Can be a string.
         * By default, we use ";" -- since this need to be visible.
         */
        displaySeparator?: string;
        /**
        * Indicate value/selection is initialized.
        * If false, it will initialize the value from Items.selected information.
        * If true,  it will honor value and make sure the Items.selected states match current value.
        */
        valueInitialized?: boolean;
    }
    interface DropDownFormFieldInfo<T> extends HtmlBindingsData {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IDisablableOption<T>>;
    }
    interface GroupDropDownFormFieldInfo<T> extends HtmlBindingsData {
        items: KnockoutObservableBase<Array<GroupDropDown.Item<T> | GroupDropDown.Group<T>>>;
        filter?: boolean | KnockoutObservableBase<boolean>;
        /**
        * Sets the filter textbox's placeholder.
        * Default is blank.
        */
        filterPlaceholder?: string | KnockoutObservable<string>;
        /**
         * Callback which will override our simple substring filtering.
         * Return list of items you wish to filter.
         * Doesn't do anything unless filter is true.
         */
        customFilter?: (value: string) => MsPortalFx.Base.PromiseV<T[]>;
        multiselect?: boolean | KnockoutObservableBase<boolean>;
        selectAll?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback which will override our selectAll functionality.
         * Allows you to select any items you wish, we don't do any selecting when you provide this override.
         */
        selectAllOverride?: () => MsPortalFx.Base.PromiseV<any>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Filterable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface Column {
        /**
         * Format used when filtering a grid.
         */
        filterableFormat?: Format;
        /**
         * Format options associated with the filterableFormat.
         */
        filterableFormatOptions?: FormatOptions;
    }
    interface FilterableOptions {
        /**
         * Whether the filter search box close button is visible or not.
         */
        searchBoxCloseButtonVisible?: KnockoutObservableBase<boolean>;
        /**
         * The placeholder text to be shown in the search box.
         */
        searchBoxPlaceholder?: KnockoutObservable<string>;
        /**
         * Whether the filter search box is visible or not.
         */
        searchBoxVisible?: KnockoutObservableBase<boolean>;
        /**
         * The subset of visible column names to search through.
         */
        searchableColumns?: KnockoutObservableArray<string>;
        /**
         * The query string of the searchbox.
         */
        queryString?: KnockoutObservableBase<string>;
        serverFilter?: KnockoutObservableBase<boolean>;
        /**
         * Specify a delay timeout to control when filter value change notification should be done.
         * For server filtering, based on the backend processing capabilities, fine tune this value.
         * For slow backends, have this value higher so that repeated callbacks to backends are not made.
         */
        valueUpdateDelayTimeout?: KnockoutObservableBase<number>;
    }
    interface FilterableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the filterable plugin.
         */
        filterable?: FilterableOptions;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.FocusableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface FocusableRowMetadata<T> extends RowMetadata<T> {
        /**
         * Indicates if the row is disabled.
         */
        disabled?: KnockoutObservable<boolean>;
    }
    interface FocusableOption {
        focusable?: KnockoutObservableBase<boolean>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Formatters.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum Format {
        /**
         * HTML format, raw HTML is allowed.
         */
        Html = 1,
        /**
         * Text format, HTML gets encoded.
         * The value can also be simple text or a KnockoutObservable object.
         */
        Text = 2,
        /**
         * Short time format, outputs something similar to 11:20 AM.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        ShortTime = 100,
        /**
         * Long time format, outputs something similar to 11:20:19 AM.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        LongTime = 101,
        /**
         * Short date format, outputs something similar to 7/18/2013.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        ShortDate = 102,
        /**
         * Long date format, outputs something similar to Thursday, July 18, 2013.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        LongDate = 103,
        /**
         * Month and day format, outputs something similar to July 18.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        MonthDay = 104,
        /**
         * Year and month format, outputs something similar to July, 2013.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        YearMonth = 105,
        /**
         * Custom date format, outputs the format based on formatOptions.dateFormat
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        CustomDate = 106,
        /**
         * URI format, outputs a clickable URI.
         * The value can be an URI, or this format: { uri: string; text: string; target?: string } .
         */
        Uri = 107,
        /**
         * Icon format, outputs an icon with optionally text beside it.
         * The value can be an icon URI, or this format: { uri: string; text?: string; } .
         */
        Icon = 108,
        /**
         * Icon Lookup format, outputs an icon based on a dictionary you provide in formatOptions.iconLookup.
         * The value is the key that matches the iconLookup dictionary.
         * The iconLookup dictionary can be { key: iconUri, ... } or { key: { uri: string, text?: string }, ... } .
         * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
         */
        IconLookup = 109,
        /**
         * Text Lookup format, outputs text based on a dictionary you provide in formatOptions.textLookup.
         * The value is the key that matches the textLookup dictionary.
         * The textLookup dictionary is { key: text, ... } .
         */
        TextLookup = 110,
        /**
         * Svg icon format, outputs an svg icon with optional text beside it.
         * The value can be an SVG, or this format: { svg: MsPortalFx.Base.Image; text?: string; } .
         */
        SvgIcon = 111,
        /**
         * Svg icon lookup format, outputs an icon based on a dictionary you provide in formatOptions.svgIconLookup.
         * The value is the key that matches the svgIconLookup dictionary.
         * The svgIconLookup dictionary can be { key: MsPortalFx.Base.Image, ... } or { key: { svg: MsPortalFx.Base.Image, text?: string }, ... } .
         * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
         */
        SvgIconLookup = 112,
        /**
         * Visually represents a percentage (values between 0-100) with a bar.
         */
        PercentageBar = 113,
        /**
         * Displays globalized numbers
         */
        Number = 114,
        /**
         * Html Bindings format, uses a template defined in formatOptions.htmlBindingsTemplate and apply the binding defined in formatOptions.htmlBindingsViewModel.
         * The value can be anything that the view model can understand. See the HtmlBindingsType for more details.
         */
        HtmlBindings = 1000,
    }
    enum HtmlBindingsType {
        /**
         * Will return an object containing the following:
         * { value: any, settings?: CellFormatterSettings }
         *
         * The value is the one from your itemKey, the settings vary depending on which plugin is loaded into the grid.
         */
        Default = 0,
        /**
         * Uses a CheckBox control for the cell.
         */
        CheckBox = 1,
        /**
         * Uses a TextBox control for the cell.
         */
        TextBox = 2,
        /**
         * Uses a MultiselectDropDown control for the cell.
         */
        MultiselectDropDown = 3,
        /**
         * CheckBox ViewModel which maps your data with the state of the row, selected/unselected for checked/unchecked.
         */
        CheckBoxRowSelection = 4,
        /**
         * Uses a DropDown control for the cell.
         */
        DropDown = 5,
        /**
         * Uses a GroupDropDown control for the cell.
         */
        GroupDropDown = 6,
    }
    /**
     * Controls the location of text in a PercentageBar formatter.
     */
    const enum PercentageBarTextLocation {
        /**
         * Text is not displayed in the formatter.
         */
        None = 0,
        /**
         * Text is displayed above the bar.
         */
        Above = 1,
        /**
         * Text is displayed below the bar.
         */
        Below = 2,
        /**
         * Text is displayed over the bar.
         */
        Overlay = 3,
    }
    interface TextAndSvg {
        /**
         * SVG icon.
         */
        svg: MsPortalFx.Base.Image;
        /**
         * Value representing the text.
         */
        text?: string;
        /**
         * Css value for height of svg icon.
         */
        height?: string;
        /**
         * Css value for width of svg icon.
         */
        width?: string;
    }
    interface PercentageBarOptions {
        /**
         * Determines if a distinct background for the bar is drawn so the user can see exactly where 100% would be.
         * Accepts color codes like "a2" and "f0".  See the color palette style guide for more info.
         * Defaults to null, which is transparent
         */
        backgroundColor?: string;
        /**
         * Sets the default percentage bar color. Accepts color codes like "a2" and "f0".
         * See the color palette style guide for more info.
         */
        barColorDefault?: string;
        /**
         * The location of text in relation to the bar.  by default, text labels are not displayed, equivalent to PercentageBarTextLocation.None.
         */
        textLocation?: PercentageBarTextLocation;
        /**
         * If set, this key is used to specify a label for the bar. If not set, the value from the column is used as the text for the bar.
         * This is similar to how you specify where a column value comes from using Column.itemKey.
         */
        textKey?: any;
        /**
         * Specifies a property name on the row item that will contain a color code like "a2" or "f0" that should be used for the bar on that particular row.
         * This is similar to how you specify where a column value comes from using Column.itemKey.
         */
        barColorKey?: string;
    }
    /**
     * Data required by the specified htmlBindingType for rendering the HtmlBinding.
     */
    interface HtmlBindingsData {
        /**
         * The label for the form field.
         */
        label?: string;
        /**
         * A list of validations that should be applied to the form field.
         */
        validations?: MsPortalFx.ViewModels.FormValidation[];
        /**
         * When changed forces validation on this column of the grid for all rows that are in editing mode.
         */
        validate?: KnockoutObservable<number>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent?: string;
    }
    interface FormatOptions {
        /**
         * Date format if using the CustomDate.
         * Accepts standard javascript formats: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
         * string entries are deprecated.
         * http://msdn.microsoft.com/en-us/library/az4se3k1.aspx
         */
        dateFormat?: string | MsPortalFx.Intl.DateTimeFormatOptions;
        /**
         * Number format.
         * Accepts standard javascript formats: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat
         * Not specifying any format options causes the default globalization formatter to be used.
         */
        numberFormat?: MsPortalFx.Intl.NumberFormatOptions;
        /**
         * Dictionary with key matching the value of the itemKey.
         * The value can be either the iconUri or an object as such { uri: string, text?: string } .
         */
        iconLookup?: any;
        /**
         * Dictionary with key matching the value of the itemKey.
         * The value is the text mapped to the value.
         */
        textLookup?: any;
        /**
         * Dictionary with key matching the value of the itemKey.
         * The value can be either the MsPortalFx.Base.Image or an object as such { uri: MsPortalFx.Base.Image, text?: string } .
         * The svgIconLookup dictionary can be { key: MsPortalFx.Base.Image, ... } or { key: { svg: MsPortalFx.Base.Image, text?: string }, ... } .
         * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
         */
        svgIconLookup?: any;
        /**
        * Can specify the default color and toggle background of the percentage bar.
        */
        percentageBar?: PercentageBarOptions;
        /**
         * HTML which applyBindings will be executed on.
         * To know which variables will be available, see the HtmlBindingsType.
         */
        htmlBindingsTemplate?: string;
        /**
         * ViewModel bound to the htmlBindingsTemplate.
         */
        htmlBindingsType?: HtmlBindingsType;
        /**
         * Data required by the specified htmlBindingType for rendering the HtmlBinding.
         */
        htmlBindingsData?: HtmlBindingsData | TextFormFieldInfo | CheckBoxFormFieldInfo | MultiselectDropDownFormFieldInfo<any> | DropDownFormFieldInfo<any> | GroupDropDownFormFieldInfo<any>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Groupable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum SortFunction {
        /**
         * Uses the built-in Array.sort() function.
         */
        Default = 0,
        /**
         * Uses the getTime() value of Date object to sort.
         */
        DateTime = 1,
        /**
         * Uses the setting list sorting, that ensures some groups are prioritized over others.
         */
        SettingListGroupOrder = 9999,
    }
    interface GroupableRowMetadata<T> extends RowMetadata<T> {
        /**
         * The ID of the group, typically mapping to a unique value in the column being grouped by.
         */
        groupId?: KnockoutObservable<string>;
    }
    interface Group {
        /**
         * The unique value corresponding to the group.
         * This value will be passed to the formatter.
         */
        value: any;
        /**
         * The format used to display the group header.
         * By default, the plain text formatter is used if none is specified.
         */
        format?: Format;
        /**
         * The format used to sort the group header.
         * By default, it matches the group.format.
         */
        sortFormat?: Format;
        /**
         * Format options associated with the chosen format.
         */
        formatOptions?: FormatOptions;
        /**
         * Format options associated with the chosen sortFormat.
         */
        sortFormatOptions?: FormatOptions;
    }
    interface GroupableOptions {
        /**
         * The item field/column in the data set that the groups map to/are created from.
         * When groups are determined automatically, uniqueness is determined by taking the toString() of the
         * value this key maps to for each item.
         */
        groupKey: KnockoutObservable<string>;
        /**
         * Format used when displaying group headers.
         * By default, the plain text formatter is used.
         */
        headerFormat?: Format;
        /**
         * Format options associated with the chosen header format.
         */
        headerFormatOptions?: FormatOptions;
        /**
         * An observable array of Group objects, to be rendered in indexed order.
         * If this array is not provided, it is inferred from the column values mapped to groupKey.
         */
        groups?: KnockoutObservableArray<Group>;
        /**
         * Format used when displaying the group header for groupless items.
         * By default, the plain text formatter is used if none is specified.
         */
        noGroupLabelFormat?: Format;
        /**
         * Format options associated with the chosen format.
         */
        noGroupLabelFormatOptions?: FormatOptions;
        /**
         * Sort order to display groups in (Unsorted, Ascending, or Descending).
         */
        sortOrder?: KnockoutObservableBase<SortOrder>;
        /**
         * Sort function to apply to the group values. Defaults to the built-in sort function.
         */
        sortFunction?: SortFunction;
    }
    interface GroupableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the groupable plugin.
         */
        groupable?: GroupableOptions;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Hierarchical.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface Column {
        /**
         * Indicate that the column should be displayed as a hierarchy with expand/collapse indicators.
         */
        hierarchical?: boolean;
    }
    interface HierarchicalItem {
        /**
         * Depth of item nesting.
         * Zero for top-level items.
         */
        depth: KnockoutObservableBase<number>;
        /**
         * Indicates if the item is expandable.
         * Undefined indicates expandability is unknown yet.
         */
        expandable: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the item is expanded or collapsed.
         */
        expanded: KnockoutObservableBase<boolean>;
    }
    interface Hierarchy<THierarchicalItem extends HierarchicalItem> {
        /**
         * The items to display in the grid.
         */
        items: KnockoutObservableBase<THierarchicalItem[]>;
        /**
         * Expands a hierarchy item.
         * @param item The item to expand.
         */
        expand: (item: THierarchicalItem) => void;
        /**
         * Collapses a hierarchy item.
         * @param item The item to expand.
         */
        collapse: (item: THierarchicalItem) => void;
        /**
         * Expands all hierarchy items.
         */
        expandAll: () => void;
        /**
         * Collapses all hierarchy items.
         */
        collapseAll: () => void;
    }
    interface HierarchicalOptions<THierarchicalItem extends HierarchicalItem> {
        /**
         * Provides the hierarchical data to the grid.
         */
        hierarchy: Hierarchy<THierarchicalItem>;
    }
    interface HierarchicalExtensionOptions<THierarchicalItem extends HierarchicalItem, TSelection> extends ExtensionsOptions<THierarchicalItem, TSelection> {
        /**
         * The options to configure the hierarchical plugin.
         */
        hierarchical?: HierarchicalOptions<THierarchicalItem>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Hoverable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface HoverableOption extends FocusableOption {
        hoverIDKey?: KnockoutObservableBase<string>;
        hoveredID?: KnockoutObservableBase<string>;
    }
    interface FocusableRowHoverExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        hoverable?: HoverableOption;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Pageable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    /**
     * Defines the pageable options.
     */
    enum PageableType {
        /**
         * Sequential will load a "Load more" button.
         */
        Sequential = 0,
        /**
         * Pageable will load a paging control allowing to go on different pages.
         */
        Pageable = 1,
    }
    interface PageableOptions<TItem> {
        /**
         * Type of pager to load with the extension.
         */
        type?: PageableType;
        /**
         * Optionally change the label text that's displayed to load more data for squential pageable type.
         */
        label?: KnockoutObservableBase<string>;
        /**
         * Optionally show or hide the load more display label for squential pageable type.
         */
        showLabel?: KnockoutObservableBase<boolean>;
        /**
         * Specifies the data source which supports pageable data access.
         */
        dataNavigator?: MsPortalFx.Data.DataNavigator<TItem>;
        itemsPerPage?: KnockoutObservable<number>;
        /**
         * Maximum number of expanded pages to show in the pager before collapsing the pager into a textbox.
         */
        pagerMaxPages?: number;
    }
    interface PageableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the pageable plugin.
         */
        pageable?: PageableOptions<TItem>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.ReorderRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface ReorderRowEventObject<T> {
        /**
         * Metadata for moved row items.
         */
        rowMetadata: RowMetadata<T>[];
        /**
         * 0-Index position where the row got dropped.
         */
        position: number;
    }
    interface ReorderRowOptions<TItem> {
        /**
         * Disables the reorder plugin. Defaults to false.
         */
        disabled?: KnockoutObservable<boolean>;
        /**
         * Automatically reorder rows after a drop happened. If set to false, the developer needs to change the inner view model.
         * Defaults to true.
         */
        automaticallyReorderRows?: boolean;
        /**
         * Callback when a row gets reordered.
         *
         * @param evt Event used for the row reordering.
         * @param args Reordered row object.
         */
        rowReorder?: (evt: JQueryEventObject, args: ReorderRowEventObject<TItem>) => void;
    }
    interface ReorderRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ReorderRow grid extension.
         */
        reorderRow?: ReorderRowOptions<TItem>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.ResizableColumn.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface ResizableColumn extends Column {
        /**
         * Disables resizable for a specific column.
         */
        disableResizable?: KnockoutObservable<boolean>;
        /**
         * Column displays a resize handle.
         */
        hasHandle?: KnockoutObservable<boolean>;
    }
    interface ResizableColumnOptions<TItem> {
        /**
         * Indicates if columns are resizable. Defaults to true.
         */
        resizable?: KnockoutObservable<boolean>;
        /**
         * Sets resized column width to percent.
         */
        resizeToPercent?: KnockoutObservable<boolean>;
        /**
         * Sets minimum width for columns.
         */
        minWidth?: number;
    }
    interface ResizableColumnExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ResizableColumn grid extension.
         */
        resizableColumn?: ResizableColumnOptions<TItem>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.RightClickableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface RightClickableRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Commands used for control composition purposes.
         */
        controlCommands: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Command.ViewModel[]>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Scrollable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface ScrollableOptions<TItem> {
        /**
         * Specifies the data source which supports random data access.
         */
        dataNavigator?: MsPortalFx.Data.DataNavigator<TItem>;
    }
    interface ScrollableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the scrollable plugin.
         */
        scrollable?: ScrollableOptions<TItem>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.SelectableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum RowSelectionMode {
        /**
         * Indicates that the user cannot select or unselect rows by clicking.
         */
        Off = 0,
        /**
         * Indicates that the user can select one row at at time by clicking.
         */
        Single = 1,
        /**
         * Indicates that the user can select and unselect multiple rows at at time by clicking and control-clicking.
         */
        Multiple = 2,
        /**
         * Indicates that the user can toggle selection on multiple rows
         */
        MultipleToggle = 3,
    }
    /**
     * NOTE: This enum is OBSOLETE. By default, all grids will have
     * consistent selection experiences that are not configurable.
     */
    enum SelectionStyle {
        /**
         * The default selection style.
         */
        Default = 0,
        /**
         * Selected rows have a right corner check box.
         */
        Checked = 1,
    }
    /**
     * Link data for browser navigation.
     */
    interface Link {
        /**
         * The uri to open when the link is activated.
         */
        uri: string;
        /**
         * The target to use them the link is activated.
         */
        target?: string;
    }
    interface SelectableRowMetadata<T> extends FocusableRowMetadata<T> {
        /**
         * Indicates if the row is selected.
         */
        selected?: KnockoutObservable<boolean>;
        /**
         * Indicates the columnKey if the row is activated. null if deactivated.
         */
        activated?: KnockoutObservableBase<string>;
        /**
         * Additional information for this Activated cell.
         */
        activatedInfo?: KnockoutObservableBase<string>;
        /**
         * Link that is invoked when row is clicked or space bar is pressed instead of blade activation.
         */
        link?: KnockoutObservableBase<Link>;
        /**
         * This can be set to 'false' to suppress the default activation behavior (which is to open a child Blade) for the associated row.
         * This should be used in tandem with the 'SelectableRowExtensionOptions.onRowClicked' callback
         * to supply activation behavior (often, in-place activation) that is custom to the extension.
         */
        useDefaultActivation?: KnockoutObservableBase<boolean>;
    }
    interface SelectableRowEventObject<T> {
        /**
         * Selected row.
         */
        selected?: SelectableRowMetadata<T>;
        /**
         * Unselected row.
         */
        unselected?: SelectableRowMetadata<T>[];
    }
    /**
     * Options for the SelectableRow grid extension.
     */
    interface SelectableRowOptions<TItem, TSelection> {
        /**
         * Specifies what type of selectability is allowed for rows.
         */
        selectionMode: RowSelectionMode;
        /**
         * A function that determines if an item matches a selection.
         *
         * @param item The grid row item to be matched.
         * @param selection The selection to match the item to.
         * @return True if the item matches the selection; else false.
         */
        itemMatchesSelection?: (item: TItem, selection: TSelection) => boolean;
        /**
         * A factory function that creates a selection based on an item.
         *
         * @param item The grid row item for which selection needs to be created.
         * @return The selection for the specified item.
         */
        createSelection?: (item: TItem) => TSelection;
        /**
         * Selection state that has been previously saved as part of view state for this grid.
         */
        initialSelection?: MsPortalFx.ViewModels.SetSelection<TSelection>;
        /**
         * Currently Activated Column Key.
         */
        activatedColumnKey?: KnockoutObservableBase<string>;
        /**
         * Primary Activate Column Key.  This is to support double click, context menu and activateOnSelected.
         */
        primaryActivateColumnKey?: KnockoutObservableBase<string>;
        /**
         * Indicates that the row should activate when selected.
         */
        activateOnSelected?: KnockoutObservableBase<boolean>;
        /**
         * Callback when a row gets selected.
         *
         * @param evt Event used for the row selection.
         * @param args Selected and unselected objects.
         */
        rowSelect?: (evt: JQueryEventObject, args: SelectableRowEventObject<TItem>) => void;
        /**
         * Specifies a selection style for the grid.
         *
         * NOTE: This property is OBSOLETE. By default, all grids will have
         * consistent selection experiences that are not configurable.
         */
        selectionStyle?: SelectionStyle;
        /**
         * Disable require Ctrl or Shift Key for Single Mode mode to toggle selection on Click.
         */
        disableRequireSingleModeAssistKey?: KnockoutObservable<boolean>;
        /**
         * Enable selectable cursor to move to next or previous selected item.
         */
        enableSelectableCursor?: KnockoutObservableBase<boolean>;
        /**
         * Method that may designate links for row items.
         * When a link is returned the link will be opened when clicking on the row instead of blade activation.
         */
        linkProvider?: (litetime: MsPortalFx.Base.LifetimeManager, item: TItem) => KnockoutObservableBase<Link>;
        /**
         * If provided, this method returns the context menu items to be displayed for the selected item.
         */
        supplyCommands?: (dataItem: TItem) => MsPortalFx.ViewModels.Toolbars.ToolbarItemContract[];
        /**
         * If set this will leave activated & selected items in a selected state after they are deactivated.
         * This defaults to true for single select mode & false for multiselect modes.
         */
        leaveSelectionOnDeactivation?: boolean;
    }
    interface SelectableRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the SelectableRow grid extension. If null, rows will not be selectable.
         */
        selectableRow?: SelectableRowOptions<TItem, TSelection>;
        /**
         * Add custom click handler for grid row.
         */
        onRowClicked?: (item: TItem) => void;
    }
    interface SelectableContract<TItem, TSelection> extends Contract<TItem, TSelection> {
        /**
         * Items displayed in the table based on the column definitions when selection is enabled.
         * It is set in the constructor. Do not directly replace it.
         */
        selectableData: MsPortalFx.ViewModels.SelectableSet<TItem, TSelection>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.SortableColumn.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum SortOrder {
        /**
         * Column is unsorted.
         */
        Unsorted = 0,
        /**
         * Column is sorted ascending.
         */
        Ascending = 1,
        /**
         * Column is sorted descending.
         */
        Descending = 2,
    }
    interface SortBy {
        /**
         * The item key to sort by.
         */
        itemKey: string;
        /**
         * The direction of the sort either ascending or descending.
         */
        sortOrder: SortOrder;
    }
    interface Column {
        /**
         * Indicates if the column is sortable.
         */
        sortable?: boolean;
        /**
         * Sort order.
         */
        sortOrder?: KnockoutObservable<SortOrder>;
    }
    interface SortableColumnOptions<TItem> {
        /**
         * The sort callback.
         */
        sortCallback?: (sortByList: SortBy[]) => void;
        /**
         * Specifies the data source.
         */
        dataNavigator?: MsPortalFx.Data.DataNavigator<TItem>;
    }
    interface SortableColumnExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the sortable plugin.
         */
        sortableColumn?: SortableColumnOptions<TItem>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Base.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface Row<T, TId> extends FxImpl.ViewModels.Controls.Lists.Base.Item<T, TId> {
        /**
         * The name of the template for displaying the row.
         */
        template: KnockoutObservableBase<string>;
    }
    interface Column {
        /**
         * The column id.
         */
        id: any;
        /**
         * Name of the column displayed in the header.
         */
        name?: KnockoutObservable<string>;
        /**
         * Formatter used when displaying one cell.
         */
        format?: Formatters.Format;
        /**
         * Width of the column in pixels or percentage.
         */
        width?: KnockoutObservable<string>;
        /**
        * Indicates this column should show the ellipsis mark when truncating text.
        */
        enableEllipsis?: KnockoutObservableBase<boolean>;
        /**
         * Set to true if this column should be hidden when the child blade of a blade pair is open.
         */
        hiddenInCollapsed?: boolean;
    }
    interface Options<T, TId> extends FxImpl.ViewModels.Controls.Lists.Base.Options<T, TId> {
        /**
         * Shows the column header.
         */
        showHeader?: boolean;
        /**
         * Column definitions.
         */
        columns?: KnockoutObservableArray<Column> | Column[];
        /**
         * Summary of the table.
         */
        summary?: KnockoutObservable<string> | string;
        /**
         * No rows message when no items are displayed.
         */
        noRowsMessage?: KnockoutObservable<string> | string;
        /**
         * Message displayed while loading of the table begins.
         * This occurs while retieving the count of items to obtain from the data source.
         */
        loadingMessage?: KnockoutObservable<string> | string;
        /**
         * Row ids of all currently disabled rows.
         */
        disabledRowIds?: KnockoutObservableArray<TId> | TId[];
    }
    interface Contract<T, TId> extends FxImpl.ViewModels.Controls.Lists.Base.Contract<T, TId> {
        /**
         * Shows the column header.
         */
        showHeader: boolean;
        /**
         * Column definitions.
         */
        columns: KnockoutObservableArray<Column>;
        /**
         * Summary of the table.
         */
        summary: KnockoutObservable<string>;
        /**
         * No rows message when no items are displayed.
         */
        noRowsMessage: KnockoutObservable<string>;
        /**
         * Message displayed while loading of the table begins.
         * This occurs while retieving the count of items to obtain from the data source.
         */
        loadingMessage: KnockoutObservable<string>;
        /**
         * Row ids of all currently disabled rows.
         */
        disabledRowIds: KnockoutObservableArray<TId>;
    }
    module Internal {
        interface Plugin {
            initialize(lifetime: MsPortalFx.Base.LifetimeManager, options: Options<any, any>): void;
            isEnabled(): boolean;
            validate(plugins: Plugins): void;
        }
        interface Plugins {
            contextMenu: Plugin;
            demandLoading: Plugin;
            editing: Plugin;
            focus: Plugin;
            grouping: Plugin;
            hierarchical: Plugin;
            hover: Plugin;
            paging: Plugin;
            reordering: Plugin;
            resizing: Plugin;
            scrolling: Plugin;
            search: Plugin;
            selection: Plugin;
            sorting: Plugin;
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.ContextMenu.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface ContextMenuOptions {
        /**
         * Enables context menu shortcuts.
         * Defaults to true.
         */
        enabled?: boolean;
    }
    interface ContextMenuContract {
        /**
         * Enables context menu shortcuts.
         * Defaults to true.
         */
        enabled: boolean;
    }
    interface Options<T, TId> {
        /**
         * The options to configure context menus.
         */
        contextMenu?: ContextMenuOptions;
    }
    interface Contract<T, TId> {
        /**
         * The properties for controlling context menus.
         */
        contextMenu: ContextMenuContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.DemandLoading.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface DemandLoadingOptions {
        /**
         * Enables on demand loading of rows.
         * Default is false.
         */
        enabled?: boolean;
        /**
         * Optionally change the label text that's displayed to load more data.
         */
        label?: KnockoutObservableBase<string>;
        /**
         * Optionally show or hide the load more display label.
         */
        showLabel?: KnockoutObservableBase<boolean>;
        rowCount?: KnockoutObservable<number>;
    }
    interface DemandLoadingContract {
        /**
         * Enables on demand loading of rows.
         * Default is false.
         */
        enabled: boolean;
        /**
         * Optionally change the label text that's displayed to load more data.
         */
        label: KnockoutObservableBase<string>;
        /**
         * Optionally show or hide the load more display label.
         */
        showLabel: KnockoutObservableBase<boolean>;
        rowCount: KnockoutObservable<number>;
    }
    interface Options<T, TId> {
        /**
         * The options to allow the user to load additional rows into the grid.
         */
        demandLoading?: DemandLoadingOptions;
    }
    interface Contract<T, TId> {
        /**
         * The properties to allow the user to load additional rows into the grid.
         */
        demandLoading: DemandLoadingContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Editing.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    const enum ValidationResult {
        /**
         * The row has no error. This is the default result.
         */
        None = 0,
        /**
         * The row has been validated and is correct.
         */
        Success = 1,
        /**
         * The row has been validated and includes errors.
         */
        Error = 2,
    }
    const enum EditingPlacement {
        /**
         * Put the editing row at the bottom of the grid.
         */
        Bottom = 0,
        /**
         * Put the editing row at the top of the grid.
         */
        Top = 1,
    }
    interface Column {
        /**
         * Format used when displaying one cell in edit mode.
         */
        editFormat?: Formatters.Format;
    }
    interface Row<T, TId> {
        /**
         * Current state of a row.
         */
        editState?: KnockoutObservableBase<MsPortalFx.Data.EditState>;
        /**
         * Indicate if the row is being edited.
         */
        editing?: KnockoutObservableBase<boolean>;
        /**
         * Validation result of a row.
         */
        validationResult?: KnockoutObservableBase<ValidationResult>;
        _addedOnce?: boolean;
        /**
         * Convenience property that tells you if the item belongs to the createdItems or items.
         */
        existingItem?: boolean;
        /**
         * Convenience Name/Value pair of all input/select/textarea fetched on the row.
         */
        _data?: {
            name: string;
            value: string;
        }[];
    }
    interface EditScopeModel {
        /**
         * The model for data stored in the edit scope.
         */
        items: KnockoutObservableArray<any>;
    }
    interface EditingOptions {
        /**
         * Enables editing.
         * Default is false.
         */
        enabled?: boolean;
        /**
         * If set to true, clicking on an existing row will go in edit mode.
         * Defaults to false.
         */
        allowEditExistingItems?: boolean;
        /**
         * If set to true, clicking on a newly created row will go in edit mode.
         * Defaults to false.
         */
        allowEditCreatedItems?: boolean;
        /**
         * Indicates if the editable row is at the top or bottom.
         * Defaults to Bottom.
         */
        placement?: EditingPlacement;
        /**
         * An observable that supplies an edit scope instance. This instance can change as the enclosing Part
         * is rebound to a different master selection.
         */
        editScope?: KnockoutObservable<MsPortalFx.Data.EditScope<any>>;
        /**
         * An optional function that retrieves the 'items' array from an EditScope instance.
         *
         * @param editScope The edit scope from which to get items.
         * @return The items to be displayed in the grid.
         */
        getItems?: (editScope: MsPortalFx.Data.EditScope<any>) => KnockoutObservableArray<any>;
        /**
         * The maximum number of buffered rows at any time.
         */
        maxBufferedRows?: number;
        /**
         * If set to true, an empty row is displayed at the location defined by the placement property.
         * Defaults to true.
         */
        enableRowAdd?: boolean;
        /**
         * If set to true, right-clicking on a newly created row will show the delete command.
         * Defaults to true.
         */
        enableRowDelete?: boolean;
        /**
         * The title to display for the row delete command.
         * Defaults to Delete.
         */
        deleteRowCommandTitle?: string;
        /**
         * Callback function that gets executed when an item is created.
         *
         * @param item The newly created item.
         */
        created?: (item: any) => void;
        /**
         * When changed ensures validation on the entire grid.
         */
        validate?: KnockoutObservable<number>;
        /**
         * When all form fields in the editable rows in editing mode are valid then true; else false.
         */
        valid?: KnockoutObservable<boolean>;
        /**
         * Contains all the created items used by the EditableRow extension.
         */
        createdItems?: KnockoutObservableArray<any>;
        /**
         * The callback that is executed when a row is added.
         */
        rowAdd?: JQueryEventHandler;
    }
    interface EditingContract {
        /**
         * Enables editing.
         * Default is false.
         */
        enabled: boolean;
        /**
         * If set to true, clicking on an existing row will go in edit mode.
         * Defaults to false.
         */
        allowEditExistingItems: boolean;
        /**
         * If set to true, clicking on a newly created row will go in edit mode.
         * Defaults to false.
         */
        allowEditCreatedItems: boolean;
        /**
         * Indicates if the editable row is at the top or bottom.
         * Defaults to Bottom.
         */
        placement: EditingPlacement;
        /**
         * An observable that supplies an edit scope instance. This instance can change as the enclosing Part
         * is rebound to a different master selection.
         */
        editScope: KnockoutObservable<MsPortalFx.Data.EditScope<any>>;
        /**
         * An optional function that retrieves the 'items' array from an EditScope instance.
         *
         * @param editScope The edit scope from which to get items.
         * @return The items to be displayed in the grid.
         */
        getItems: (editScope: MsPortalFx.Data.EditScope<any>) => KnockoutObservableArray<any>;
        /**
         * The maximum number of buffered rows at any time.
         */
        maxBufferedRows: number;
        /**
         * If set to true, an empty row is displayed at the location defined by the placement property.
         * Defaults to true.
         */
        enableRowAdd: boolean;
        /**
         * If set to true, right-clicking on a newly created row will show the delete command.
         * Defaults to true.
         */
        enableRowDelete: boolean;
        /**
         * The title to display for the row delete command.
         * Defaults to Delete.
         */
        deleteRowCommandTitle: string;
        /**
         * Callback function that gets executed when an item is created.
         *
         * @param item The newly created item.
         */
        created: (item: any) => void;
        /**
         * When changed ensures validation on the entire grid.
         */
        validate: KnockoutObservable<number>;
        /**
         * When all form fields in the editable rows in editing mode are valid then true; else false.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * Contains all the created items used by the EditableRow extension.
         */
        createdItems: KnockoutObservableArray<any>;
        /**
         * The callback that is executed when a row is added.
         */
        rowAdd: JQueryEventHandler;
    }
    interface Options<T, TId> {
        /**
         * The options to configure the editable row plugin.
         */
        editing?: EditingOptions;
    }
    interface Contract<T, TId> {
        /**
         * The editable row plugin view model.
         */
        editing: EditingContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Focus.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface Row<T, TId> {
        /**
         * Indicates if the row is currently focused.
         */
        isFocused?: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the row is tabbable.
         */
        tabbable?: KnockoutObservableBase<boolean>;
        /**
         * The current tab index of the row.
         */
        tabindex?: KnockoutObservableBase<number>;
    }
    interface FocusOptions {
        /**
         * Enables row focus.
         * The default is true.
         */
        enabled?: boolean;
    }
    interface FocusContract {
        /**
         * Enables focus of rows.
         * The default is true.
         */
        enabled: boolean;
    }
    interface Options<T, TId> {
        /**
         * Options controlling focus within the grid.
         */
        focus?: FocusOptions;
    }
    interface Contract<T, TId> {
        /**
         * Properties controlling focus within the grid.
         */
        focus: FocusContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Grouping.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface Column {
    }
    interface GroupingOptions {
        /**
         * Enables grid grouping.
         * Default is false.
         */
        enabled?: boolean;
        /**
         * Columns with sorting directions in precedence order for determining groups.
         */
        groupColumns?: KnockoutObservableArray<FxImpl.Data.SortOrder>;
        /**
         * Id of column to use for display in the group header.
         */
        /**
         * Format used when displaying group headers.
         * By default, the plain text formatter is used.
         */
        headerFormat?: Formatters.Format;
    }
    interface GroupingContract {
        /**
         * Enables grid grouping.
         * Default is false.
         */
        enabled: boolean;
        /**
         * Columns with sorting directions in precedence order for determining group.
         */
        groupColumns: KnockoutObservableArray<FxImpl.Data.SortOrder>;
        /**
         * Id of column to use for display in the group header.
         */
        /**
         * Format used when displaying group headers.
         * By default, the plain text formatter is used.
         */
        headerFormat: Formatters.Format;
    }
    interface Options<T, TId> {
        /**
         * The options to configure grouping of rows.
         */
        grouping?: GroupingOptions;
    }
    interface Contract<T, TId> {
        /**
         * The properties to control row grouping.
         */
        grouping: GroupingContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Hierarchical.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface Column {
        /**
         * Indicate that the column should be displayed as a hierarchy with expand/collapse indicators.
         */
        hierarchical?: boolean;
    }
    interface Row<T, TId> {
        /**
         * Depth of item nesting.
         * Zero for top-level items.
         */
        depth: KnockoutObservableBase<number>;
        /**
         * Indicates if the item is expandable.
         * Undefined indicates expandability is unknown yet.
         */
        canExpand: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the item is expanded or collapsed.
         */
        isExpanded: KnockoutObservableBase<boolean>;
    }
    interface HierarchicalOptions {
        /**
         * Enables hierarchical grid.
         * Default is false.
         */
        enabled?: boolean;
    }
    interface HierarchicalContract {
        /**
         * Enables hierarchical grid.
         * Default is false.
         */
        enabled: boolean;
    }
    interface Options<T, TId> {
        /**
         * The options to configure the hierarchical plugin.
         */
        hierarchical?: HierarchicalOptions;
    }
    interface Contract<T, TId> {
        /**
         * The hierarchical plugin view model.
         */
        hierarchical: HierarchicalContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Hover.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface Row<T, TId> {
        /**
         * Indicates if the row is hovered over.
         */
        hovered?: KnockoutObservable<boolean>;
    }
    interface HoverOptions {
        /**
         * Enables row hover.
         * Defaults to true.
         */
        enabled?: boolean;
        /**
         * The currently hovered row id.
         */
        hoveredRowId?: KnockoutObservable<any>;
    }
    interface HoverContract {
        /**
         * Enables row hover.
         * Defaults to true.
         */
        enabled: boolean;
        /**
         * The currently hovered row id.
         */
        hoveredRowId: KnockoutObservable<any>;
    }
    interface Options<T, TId> {
        /**
         * The options to configure hover.
         */
        hover?: HoverOptions;
    }
    interface Contract<T, TId> {
        /**
         * The properties that control hover.
         */
        hover: HoverContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Paging.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface PagingOptions {
        /**
         * Enables explicit paging in the grid.
         * Default is false.
         */
        enabled?: boolean;
        pageSize?: KnockoutObservable<number>;
    }
    interface PagingContract {
        /**
         * Enables explicit paging in the grid.
         * Default is false.
         */
        enabled: boolean;
        pageSize: KnockoutObservable<number>;
    }
    interface Options<T, TId> {
        /**
         * The options for paging rows.
         */
        paging?: PagingOptions;
    }
    interface Contract<T, TId> {
        /**
         * The properties for paging rows.
         */
        paging: PagingContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Reordering.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface ReorderEventObject {
        /**
         * Moved rows.
         */
        rows: Row<any, any>[];
        /**
         * 0-Index position where the row got dropped.
         */
        position: number;
        /**
         * X position where the row got dropped.
         */
        clientX: number;
        /**
         * Y position where the row got dropped.
         */
        clientY: number;
    }
    interface ReorderingOptions {
        /**
         * Enables row reordering.
         * Default is false.
         */
        enabled?: boolean;
        /**
         * Automatically reorder rows after a drop happened. If set to false, the developer needs to change the inner view model.
         * Defaults to true.
         */
        automaticallyReorderRows?: boolean;
        /**
         * Callback when a row gets reordered.
         *
         * @param evt Event used for the row reordering.
         * @param args Reordered row object.
         */
        rowReorder?: (evt: JQueryEventObject, args: ReorderEventObject) => void;
    }
    interface ReorderingContract {
        /**
         * Enables row reordering.
         * Default is false.
         */
        enabled?: boolean;
        /**
         * Automatically reorder rows after a drop happened. If set to false, the developer needs to change the inner view model.
         * Defaults to true.
         */
        automaticallyReorderRows: boolean;
        /**
         * Callback when a row gets reordered.
         *
         * @param evt Event used for the row reordering.
         * @param args Reordered row object.
         */
        rowReorder: (evt: JQueryEventObject, args: ReorderEventObject) => void;
    }
    interface Options<T, TId> {
        /**
         * The options to configure the reorderable row plugin.
         */
        reordering?: ReorderingOptions;
    }
    interface Contract<T, TId> {
        /**
         * The reorderable row plugin view model.
         */
        reordering: ReorderingContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Resizing.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface Column {
        /**
         * Disables resizable for a specific column.
         */
        disableResizable?: KnockoutObservable<boolean>;
        /**
         * Column displays a resize handle.
         */
        hasHandle?: KnockoutObservable<boolean>;
    }
    interface ResizingOptions {
        /**
         * Indicates if columns are resizable.
         * Defaults to true.
         */
        enabled?: boolean;
        /**
         * Sets resized column width to percent.
         */
        resizeToPercent?: KnockoutObservable<boolean>;
        /**
         * Sets minimum width in pixels for columns.
         */
        minWidth?: number;
    }
    interface ResizingContract {
        /**
         * Indicates if columns are resizable.
         * Defaults to true.
         */
        enabled: boolean;
        /**
         * Sets resized column width to percent.
         */
        resizeToPercent?: KnockoutObservable<boolean>;
        /**
         * Sets minimum width in pixels for columns.
         */
        minWidth?: number;
    }
    interface Options<T, TId> {
        /**
         * The options to control column resizing..
         */
        resizing?: ResizingOptions;
    }
    interface Contract<T, TId> {
        /**
         * Column resizing properties.
         */
        resizing: ResizingContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Scrolling.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface ScrollingOptions {
        /**
         * Enables scrolling.
         * Default is false.
         */
        enabled?: boolean;
        /**
         * Enables horizontal scrolling.
         * The grid stretches to fill the container width and scrolls horizontally if needed.
         * Default is true.
         */
        horizontal?: boolean;
        /**
         * Enables vertical scrolling.
         * The grid stretches to fill the container height and scrolls vertically if needed.
         * Default is true.
         */
        vertical?: boolean;
    }
    interface ScrollingContract {
        /**
         * Enables scrolling.
         * Default is false.
         */
        enabled: boolean;
        /**
         * Enables horizontal scrolling.
         * The grid stretches to fill the container width and scrolls horizontally if needed.
         * Default is true.
         */
        horizontal: boolean;
        /**
         * Enables vertical scrolling.
         * The grid stretches to fill the container height and scrolls vertically if needed.
         * Default is true.
         */
        vertical: boolean;
    }
    interface Options<T, TId> {
        /**
         * The options to configure scrolling in the grid.
         */
        scrolling?: ScrollingOptions;
    }
    interface Contract<T, TId> {
        /**
         * The grid scrolling properties.
         */
        scrolling: ScrollingContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Search.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface Column {
        /**
         * Format used when search.
         */
        searchFormat?: Formatters.Format;
    }
    interface SearchOptions {
        /**
         * Enables search.
         * Default is false.
         */
        enabled?: boolean;
        /**
         * Whether the filter search box close button is visible or not.
         */
        searchBoxCloseButtonVisible?: KnockoutObservableBase<boolean>;
        /**
         * The placeholder text to be shown in the search box.
         */
        searchBoxPlaceholder?: KnockoutObservable<string>;
        /**
         * Whether the filter search box is visible or not.
         */
        searchBoxVisible?: KnockoutObservableBase<boolean>;
        /**
         * The subset of visible column names to search through.
         */
        searchColumns?: KnockoutObservableArray<string>;
    }
    interface SearchContract {
        /**
         * Enables search.
         * Default is false.
         */
        enabled: boolean;
        /**
         * Whether the filter search box close button is visible or not.
         */
        searchBoxCloseButtonVisible: KnockoutObservableBase<boolean>;
        /**
         * The placeholder text to be shown in the search box.
         */
        searchBoxPlaceholder: KnockoutObservable<string>;
        /**
         * Whether the filter search box is visible or not.
         */
        searchBoxVisible: KnockoutObservableBase<boolean>;
        /**
         * The subset of visible column names to search through.
         */
        searchColumns: KnockoutObservableArray<string>;
    }
    interface Options<T, TId> {
        /**
         * The options to configure search.
         */
        search?: SearchOptions;
    }
    interface Contract<T, TId> {
        /**
         * The properties controlling search.
         */
        search: SearchContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Selection.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    interface Column {
        /**
         * Set to true if this column is the primary activation column
         */
        activatable?: boolean;
        /**
         * Optional override of the grid's dynamicSelectionProvider.  Set this to have different columns launch different blades.
         */
        dynamicSelectionProvider?: (id: any, item: any) => MsPortalFx.Base.PromiseV<MsPortalFx.ViewModels.DynamicSelection>;
    }
    interface Row<T, TId> {
        /**
         * Indicates if the row is activated.
         */
        isActivated?: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the row is selected.
         */
        isSelected?: KnockoutObservableBase<boolean>;
        /**
         * If set, activating this row will not involve selectable set, but rather launch a new tab to the link.
         */
        activationLink?: KnockoutObservableBase<string>;
    }
    /**
     * Options for grid selection.
     */
    interface SelectionOptions extends FxImpl.ViewModels.Controls.Lists.Base.SelectionOptions<any, any> {
        /**
         * The property containing the uri of the website it should open when activated.
         */
        linkUriProperty?: string;
    }
    interface SelectionContract<T, TId> extends FxImpl.ViewModels.Controls.Lists.Base.SelectionContract<T, TId> {
        /**
         * The property containing the uri of the website it should open when activated.
         */
        linkUriProperty?: string;
    }
    interface Options<T, TId> {
        /**
         * The options to configure grid selection.
         */
        selection?: SelectionOptions;
    }
    interface Contract<T, TId> {
        /**
         * The grid selection properties.
         */
        selection: SelectionContract<T, TId>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Grid2\Interfaces.Grid2.Sorting.d.ts
declare module FxImpl.ViewModels.Controls.Lists.Grid2 {
    const enum SortOrder {
        /**
         * Column is unsorted.
         */
        Unsorted = 0,
        /**
         * Column is sorted ascending.
         */
        Ascending = 1,
        /**
         * Column is sorted descending.
         */
        Descending = 2,
    }
    interface Column {
        /**
         * Indicates if the column is sortable.
         */
        sortable?: boolean;
        /**
         * Sort order.
         */
        sortOrder?: KnockoutObservable<SortOrder>;
    }
    interface SortingOptions {
        /**
         * Enables sorting.
         * Default is true.
         */
        enabled?: boolean;
    }
    interface SortingContract {
        /**
         * Enables sorting.
         * Default is true.
         */
        enabled: boolean;
    }
    interface Options<T, TId> {
        /**
         * The options to configure the sortable column plugin.
         */
        sorting?: SortingOptions;
    }
    interface Contract<T, TId> {
        /**
         * The editable row plugin view model.
         */
        sorting: SortingContract;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\List1\Gallery.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Gallery {
    interface Contract extends ListView.Contract {
    }
    class ViewModel extends ListView.ViewModel implements Contract {
        /**
         * Constructs a Gallery view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param extensions Bitmask of extension plugins to be loaded.
         * @param extensionOptions The extension options for the plugins.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, extensions?: number, extensionOptions?: ListView.ExtensionOptions);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\List1\ListView.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.ListView {
    /**
     * The plugin identifiers for the listview.
     */
    enum Extensions {
        /**
         * Plugin to have item selection.
         */
        Selectable = 1,
        /**
         * Plugin to have grouped items.
         */
        Groupable = 2,
        /**
         * Plugin to have context menu items.
         */
        ContextMenu = 4,
        /**
         * Plugin to filter items.
         */
        Filterable = 8,
    }
    /**
     * The group order for grouping items in the listview.
     */
    enum GroupOrder {
        /**
         * Display groups in collection order.
         */
        Collection = 0,
        /**
         * Display groups in ascending order.
         */
        Ascending = 1,
        /**
         * Display groups in descending order.
         */
        Descending = 2,
    }
    /**
     * The selection mode for selecting items in the listview.
     */
    enum SelectionMode {
        /**
         * Indicates that the user can select one item at at time by clicking.
         */
        Single = 0,
        /**
         * Indicates that the user can select and unselect multiple items at at time by clicking and control-clicking.
         */
        Multiple = 1,
    }
    /**
     * A metadata entry corresponding to a single item in the list.
     */
    interface ItemMetadata {
        /**
         * Indicates if the item is disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the item is focused.
         */
        focused?: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the item is selected.
         */
        selected?: KnockoutObservableBase<boolean>;
        /**
         * The ID of the group, typically mapping to a unique value in the item being grouped by.
         */
        groupId?: KnockoutObservableBase<any>;
    }
    interface Item {
        /**
         * Css class specific to this item.
         */
        cssClass?: KnockoutObservableBase<string>;
        /**
         * Metadata information about this item.
         */
        metadata?: ItemMetadata;
    }
    interface SelectableEventObject {
        /**
         * Selected items.
         */
        selected: Item[];
        /**
         * Unselected items.
         */
        unselected: Item[];
    }
    interface GroupableOptions {
        /**
         * The item field/column in the data set that the groups map to/are created from.
         */
        groupKey: KnockoutObservable<string>;
        /**
         * The template to apply to each group headers.
         */
        headerTemplate?: string;
        /**
         * An observable array of Group objects, to be rendered in indexed order.
         * If this array is not provided, it is inferred from the column values mapped to groupKey.
         */
        groups?: KnockoutObservableArray<Group>;
        /**
         * The group name shown for all items that don't have a groupId set.
         */
        noGroupLabel?: string;
        /**
         * Order to display groups in (Collection, Ascending, or Descending).
         */
        order?: KnockoutObservableBase<GroupOrder>;
    }
    interface SelectableOptions {
        /**
         * Indicates selection mode or single or multiple selection (default Single).
         */
        selectionMode?: SelectionMode;
        /**
         * Gets or sets the selected item for single selection backward compatibility.
         */
        selectedItem?: KnockoutObservable<Item>;
        /**
         * Gets or sets the selected items.
         */
        selection?: MsPortalFx.ViewModels.SelectableSet<Item, any>;
        /**
         * Indicates that the item should activate when selected (default true).
         */
        activateOnSelected?: boolean;
    }
    interface FilterableOptions {
        /**
         * Observable text to filter items with.
         */
        filterText: KnockoutObservableBase<string>;
        /**
         * Property to filter items on.
         */
        filterKey: KnockoutObservableBase<string>;
    }
    interface ExtensionOptions {
        /**
         * Grouping options.
         */
        groupable?: GroupableOptions;
        /**
         * Selection options.
         */
        selectable?: SelectableOptions;
        /**
         * Filtering options.
         */
        filterable?: FilterableOptions;
    }
    interface Group {
        /**
         * The unique value corresponding to the group.
         */
        value: any;
    }
    interface Contract extends Loadable.Contract {
        /**
         * Items displayed in the list.
         */
        items: KnockoutObservableArray<Item>;
        /**
         * Important events which the viewModel might want to react.
         */
        events: (type: string, args?: any) => void;
        /**
         * Template used on each item.
         */
        itemTemplate: string;
        /**
         * Message displayed when list is empty.
         */
        noItemsMessage: KnockoutObservableBase<string>;
        /**
         * The bitmask of plugins to be loaded.
         * Use '|' or '+' to specify multiple extensions.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions?: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions: ExtensionOptions;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Items displayed in the list.
         */
        items: KnockoutObservableArray<Item>;
        /**
         * Important events which the viewModel might want to react.
         */
        events: (type: string, args?: any) => void;
        /**
         * The template used on each item.
         */
        itemTemplate: string;
        /**
         * Message displayed when list is empty.
         */
        noItemsMessage: KnockoutObservableBase<string>;
        /**
         * The bitmask of plugins to be loaded.
         * Use '|' or '+' to specify multiple extensions.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions: ExtensionOptions;
        /**
         * Constructs a ListView view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param extensions Bitmask of extension plugins to be loaded.
         * @param extensionOptions The extension options for the plugins.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, extensions?: number, extensionOptions?: ExtensionOptions);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Lists\Tree1\TreeView.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.TreeView {
    /**
     * A query result interface from load by continuation token.
     */
    interface TreeContinuationTokenQueryResult<TItem> {
        /**
         * newly fetched items.
         */
        items: TItem[];
        /**
         * the continuation token that are used to request next chunk of data.
         */
        continuationToken: any;
    }
    /**
     * A metadata entry correspendong to a single item in the tree.
     */
    interface ItemMetadata {
        /**
         * Gets or sets whether the item is expanded or not (effective if the item has child items).
         */
        expanded?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is disabled.
         */
        disabled?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is focused.
         */
        focused?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is selected.
         */
        selected?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is selectable. Observably changing this value will not change selected state of the item.
         */
        selectable?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is on-demand loadable.
         */
        loadable?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is loadable by a continuation token.
         */
        loadableByContinuationToken?: KnockoutObservable<boolean>;
    }
    /**
     * Html template for an item.
     */
    interface ItemTemplate {
        /**
         * Key of this template.
         */
        key: string;
        /**
         * Html template to be used by items.
         */
        html: string;
    }
    enum Extensions {
        /**
         * Plugin to have selectable items.
         */
        Selectable = 1,
        /**
         * Plugin to have on-demand loadable items.
         */
        OnDemandLoadable = 2,
        /**
         * Plugin to have right clickable items.
         */
        RightClickable = 4,
        /**
         * Plugin to have load by continuation token items.
         */
        LoadableByContinuationToken = 8,
    }
    interface LoadableByContinuationTokenOptions<TItem extends Item> {
        loadMoreNode(item: TItem, continuationToken: any): MsPortalFx.Base.PromiseV<TreeContinuationTokenQueryResult<TItem>>;
    }
    /**
     * Options for the Selectable treeView extension.
     */
    interface SelectableOptions<TItem extends Item, TSelection> {
        /**
         * A factory function that creates a selection based on an item.
         */
        createSelection(item: TItem, path: string): TSelection;
        /**
         * Selection state that has been previously saved as part of view state for this treeView.
         */
        initialPath?: string;
    }
    /**
     * Defines the contract about selectable properties.
     */
    interface SelectableData<TSelection> {
        /**
         * Specifies the currently selected item.
         */
        selectedItem: KnockoutObservable<TSelection>;
        /**
         * Specifies the path of the currently selected item.
         * This property is meant to be set only by base widget.
         */
        selectedPath: KnockoutObservable<string>;
    }
    /**
     * Options for the On-Demand Loadable treeView extension.
     */
    interface OnDemandLoadableOptions<TItem extends Item> {
        /**
         * A factory function that notifies a load is required
         */
        loadItem(item: TItem, path: string): void;
    }
    /**
     * Defines the contract about on-demand loadable properties.
     */
    interface OnDemandLoadableData {
        /**
         * Gets the path of the item which is being loaded.
         * This property is meant to be set only by base widget.
         */
        loadingPath: KnockoutObservable<string>;
    }
    interface ExtensionsOptions<TItem extends Item, TSelection> {
        /**
         * Options for the Selectable treeView extension.  If null, items will not be selectable.
         */
        selectable?: SelectableOptions<TItem, TSelection>;
        /**
         * Options for the On-Demand Loadable treeView extension.  If null, items will not be on-demand loadable
         * and all the hierarchy needs to be loaded up-front.
         */
        onDemandLoadable?: OnDemandLoadableOptions<TItem>;
        /**
         * Options for the Loadable by continuation token treeView extension. If null, items will not be loadable by continuation token.
         */
        loadableByContinuationToken?: LoadableByContinuationTokenOptions<TItem>;
    }
    /**
     * A leaf of the tree.
     */
    interface Item {
        /**
         * Text of the item.
         */
        text: KnockoutObservable<string>;
        /**
         * Child items of this item.
         */
        items?: KnockoutObservableArray<Item>;
        /**
         * Icon specified to the item to be displayed with text.
         */
        icon?: KnockoutObservable<string | MsPortalFx.Base.Image>;
        /**
         * Css class specific to this item.
         */
        cssClass?: KnockoutObservable<string>;
        /**
         * Metadata information about this item.
         */
        metadata?: ItemMetadata;
        /**
         * Key of the template for this item.
         */
        templateKey?: KnockoutObservable<string>;
    }
    /**
     * Callback set and used by the framework to expand and collapse nodes.
     */
    interface ToggleNodeCallback {
        (item: Item, expandState: boolean): void;
    }
    interface Contract<TItem extends Item, TSelection> extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * Items displayed in the tree.
         */
        items: KnockoutObservableArray<TItem>;
        /**
         * Amount of child item padding in px.
         */
        padding: KnockoutObservable<number>;
        /**
         * Separator used to build the path of an item.
         */
        pathSeparator: string;
        /**
         * Indicates whether all the items in tree are visible and expand/collapse icons are invisible.
         */
        alwaysExpanded: KnockoutObservable<boolean>;
        /**
         * A list of html templates to be used by the items.
         */
        htmlTemplates: ItemTemplate[];
        /**
         * The bitmask of plugins to be loaded.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions?: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions?: ExtensionsOptions<TItem, TSelection>;
        /**
         * Expands a treeview item.
         *
         * @param item The treeview item to expand
         */
        expandNode(item: Item): void;
        /**
         * Collapses a treeview item.
         *
         * @param item The treeview item to collapses
         */
        collapseNode(item: Item): void;
        /**
         * Toggles the expanded state of a treeview item.
         *
         * @param item The treeview item to collapses
         * @param expanded Optional. The desired expanded state of the treeview item.
         */
        toggleNode(item: Item, expanded?: boolean): void;
        /**
         * Load more nodes by continuation token.
         *
         * @param item The treeview item to be appended (parentNode)
         * @return new continuationToken or null (no data to be fetched)
         */
        loadMoreNode(item: TItem, continuationToken: any): MsPortalFx.Base.PromiseV<TreeContinuationTokenQueryResult<TItem>>;
        /**
         * Sync stored tokens between widget side and viewmodel side.
         * For internal use only.
         *
         * @param path the key of the token which is a node's path in the tree
         * @param continuationToken the unique token value
         */
        syncToken(path: string, continuationToken: any): void;
        /**
         * Callback set and used by the framework to expand and collapse nodes.  Do not modify or set this property.
         */
        toggleNodeCallback: KnockoutObservableBase<ToggleNodeCallback>;
    }
    class ViewModel<TItem extends Item, TSelection> extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract<TItem, TSelection> {
        /**
         * See interface.
         */
        items: KnockoutObservableArray<TItem>;
        /**
         * See interface.
         */
        padding: KnockoutObservable<number>;
        /**
         * See interface.
         */
        pathSeparator: string;
        /**
         * See interface.
         */
        alwaysExpanded: KnockoutObservable<boolean>;
        /**
         * A list of html templates to be used by the items.
         */
        htmlTemplates: ItemTemplate[];
        /**
         * See interface.
         */
        extensions: number;
        /**
         * See interface.
         */
        extensionsOptions: ExtensionsOptions<TItem, TSelection>;
        /**
         * A bridge between the widget and extension viewmodel to reflect control selection changes.
         */
        selectableData: SelectableData<TSelection>;
        /**
         * A bridge between the widget and extension viewmodel to notify items being loaded on-demand.
         */
        onDemandLoadableData: OnDemandLoadableData;
        private _tokenStorage;
        /**
         * Callback set and used by the framework to expand and collapse nodes.  Do not modify or set this property.
         */
        toggleNodeCallback: KnockoutObservableBase<ToggleNodeCallback>;
        /**
         * Creates a treeview.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param items Items for the view model.
         * @param extensions Extensions for the view model.
         * @param extensionsOptions Extension options for the view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, items: KnockoutObservableArray<TItem>, extensions?: number, extensionsOptions?: ExtensionsOptions<TItem, TSelection>);
        loadMoreNode(item: TItem, continuationToken: any): MsPortalFx.Base.PromiseV<TreeContinuationTokenQueryResult<TItem>>;
        syncToken(path: string, continuationToken: any): void;
        getTokenByPath(path: string): any;
        /**
         * Expands a treeview item.
         *
         * @param item The treeview item to expand
         */
        expandNode(item: Item): void;
        /**
         * Collapses a treeview item.
         *
         * @param item The treeview item to collapse
         */
        collapseNode(item: Item): void;
        /**
         * Collapses a treeview item.
         *
         * @param item The treeview item to collapse
         */
        toggleNode(item: Item, expanded?: boolean): void;
        private _selectableExists;
        private _loadableExists;
        private _processCallBack;
        private _processItems(items);
        private _processItem(item);
        private _setupSelectable();
        private _setupOnDemandLoadable();
        private _findItemByPath(items, path, pathSeparator?);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\LogStream.d.ts
declare module MsPortalFx.ViewModels.Controls.LogStream {
    enum LogItemType {
        /**
         * Indicates general information.
         */
        Text = 0,
        /**
         * Indicates important information.
         */
        Information = 1,
        /**
         * Indicates success information
         */
        Success = 2,
        /**
         * Indicates warning information.
         */
        Warning = 3,
        /**
         * Indicates error information.
         */
        Error = 4,
    }
    interface LogItem {
        /**
         * The text to log.
         */
        text: string;
        /**
         * The type of text to log.
         */
        type?: LogItemType;
    }
    interface Contract extends TextStream.Contract {
        /**
         * Controls display updating.
         */
        paused: KnockoutObservable<boolean>;
        /**
         * Current set of log item types to display.
         */
        filters: KnockoutObservableArray<LogItemType>;
        /**
         * Logs text item to the display.
         */
        log: KnockoutObservable<string>;
        /**
         * Logs item to the display.
         */
        logItem: KnockoutObservable<LogItem>;
        /**
         * Logs multiple items to the display.
         */
        logItems: KnockoutObservable<LogItem[]>;
    }
    class ViewModel extends TextStream.ViewModel implements Contract {
        /**
         * Controls display updating.
         */
        paused: KnockoutObservable<boolean>;
        /**
         * Current set of log item types to display.
         */
        filters: KnockoutObservableArray<LogItemType>;
        /**
         * Logs text item to the display.
         */
        log: KnockoutObservable<string>;
        /**
         * Logs item to the display.
         */
        logItem: KnockoutObservable<LogItem>;
        /**
         * Logs multiple items to the display.
         */
        logItems: KnockoutObservable<LogItem[]>;
        /**
         * Constructs a LogStream view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Markdown.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.Markdown {
    interface Options {
        /**
         * markdown Input string containing markdown to be converted to html and displayed.
         */
        markdown?: KnockoutObservableBase<string>;
    }
    class ViewModel extends Base.ViewModel {
        /**
         * markdown Input string containing markdown to be converted to html and displayed.
         */
        markdown: KnockoutObservableBase<string>;
        /**
         * Constructs an Markdown view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options Optional The set of options to configure the Markdown control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: MsPortalFx.ViewModels.Controls.Markdown.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\PartPinner.d.ts
declare module MsPortalFx.ViewModels.Controls.PartPinner {
    import FxBase = MsPortalFx.Base;
    import FxComposition = MsPortalFx.Composition;
    interface Options<TParameters> {
        /**
         * Gets the part reference to be pinned.
         */
        supplyPartReference<TParameters>(): FxComposition.PartReference<TParameters> | FxComposition.PartReference<TParameters>[];
        /**
         * The display text of the part pin.
         */
        text?: KnockoutObservableBase<string>;
        /**
         * The icon of the part pin.
         */
        icon?: KnockoutObservableBase<FxBase.Image>;
        /**
         * Gets or sets if the control is disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    class ViewModel<TParameters> extends Base.ViewModel {
        options: Options<TParameters>;
        /**
         * Constructs an PartPinner view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options The set of options to configure the PartPinner control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: Options<TParameters>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\PreviewTag.d.ts
declare module MsPortalFx.ViewModels.Controls.PreviewTag {
    interface Contract extends Base.Contract {
        /**
         * Whether the preview tag is shown or not.
         */
        show: KnockoutObservable<boolean>;
        /**
         * Whether the preview tag text is shown as dark green or not.
         */
        darkText: KnockoutObservable<boolean>;
    }
    class ViewModel extends Base.ViewModel implements Contract {
        /**
         * See interface.
         */
        show: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        darkText: KnockoutObservable<boolean>;
        /**
         * Constructs a preview tag view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Scrollbar.d.ts
declare module MsPortalFx.ViewModels.Controls.Scrollbar {
    interface Contract extends Loadable.Contract {
        /**
         * Polls the content area at 100 ms intervals to see if the size has changed. If it has, refreshContent is called.
         * Whenever possible, it is recommended to leave this value as false and call refreshContent when the content changes.
         */
        autoRefreshContent: boolean;
        /**
         * If true, refreshContainer will be automatically called if the window is resized.
         */
        refreshContainerOnResize: boolean;
        /**
         * Indicates if scrolling into view should try to scroll vertically.
         */
        scrollIntoViewVertical: boolean;
        /**
         * Indicates if scrolling into view should try to scroll horizontally.
         */
        scrollIntoViewHorizontal: boolean;
        /**
         * Fits the scroll view to the container even if it changes size.
         */
        fitContainer: boolean;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Polls the content area at 100 ms intervals to see if the size has changed. If it has, refreshContent is called.
         * Whenever possible, it is recommended to leave this value as false and call refreshContent when the content changes.
         */
        autoRefreshContent: boolean;
        /**
         * If true, refreshContainer will be automatically called if the window is resized.
         */
        refreshContainerOnResize: boolean;
        /**
         * Indicates if scrolling into view should try to scroll vertically.
         */
        scrollIntoViewVertical: boolean;
        /**
         * Indicates if scrolling into view should try to scroll horizontally.
         */
        scrollIntoViewHorizontal: boolean;
        /**
         * Fits the scroll view to the container even if it changes size.
         */
        fitContainer: boolean;
        /**
         * Creates a scrollbar.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\SearchBox.d.ts
declare module MsPortalFx.ViewModels.Controls.SearchBox {
    interface Options {
        /**
         * The update callback. Returns maximum of five results.
         * When you close the dropdown or have no value. We fire the update function but don't open a dropdown or do anything with the results.
         */
        update: UpdateHandler;
        /**
         * The submit callback.
         */
        submit: SubmitHandler;
        /**
         * The delay after you finish typing to trigger the update callback in milliseconds. (default: 400 ms)
         */
        updateFrequency?: number;
        /**
         * The default placeholder text.
         */
        placeholder?: KnockoutObservable<string>;
        /**
         * Default search text, does not trigger an update or submit callback.
         */
        defaultText?: string;
    }
    /**
     * The update callback interface.
     */
    interface UpdateHandler {
        (value: string): MsPortalFx.Base.PromiseV<string[]>;
    }
    /**
     * The submit callback interface.
     * @param value user selected value.
     * @param typedValue value user typed into textbox (may be different if user clicked on dropdown) for telemetry.
     */
    interface SubmitHandler {
        (value: string, typedValue: string): MsPortalFx.Base.PromiseV<boolean>;
    }
    class ViewModel extends Base.ViewModel implements Options {
        /**
         * The default placeholder text.
         */
        placeholder: KnockoutObservable<string>;
        /**
         * The delay after you finish typing to trigger the update callback in milliseconds.
         */
        updateFrequency: number;
        /**
         * The update callback. Returns maximum of five results.
         */
        update: UpdateHandler;
        /**
         * The submit callback.
         */
        submit: SubmitHandler;
        /**
         * Default search text, does not trigger an update or submit callback.
         */
        defaultText: string;
        _msPortalFxresetTrigger: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Constructs a simple search view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options The options for the search view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
        /**
         * A helper function for that removes all items, closes dropdown & clears textbox.
         * @return A promise that is resolved when the reset has been completed.
         */
        reset(): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Settings.d.ts
declare module MsPortalFx.ViewModels.Controls.Settings {
    enum Size {
        /**
         * Optimize display in small tiles.
         */
        Small = 2,
        /**
         * Optimize display for large tiles.
         */
        Large = 3,
    }
    interface Contract extends Loadable.Contract {
        /**
         * The list of settings and values.
         * Each item in the array is an object with two properties label and value.
         * The label and value properties could either be a string or an object with a property named "url".
         */
        items: KnockoutObservableArray<any>;
        /**
         * The maximum number of items rendered.
         */
        maxItems: KnockoutObservable<number>;
        /**
         * Indicates if the size of the area for display is small or large.
         */
        size: KnockoutObservable<Size>;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * The list of settings and values.
         * Each item in the array is an object with two properties label and value.
         * The label and value properties could either be a string or an object with a property named "url".
         */
        items: KnockoutObservableArray<any>;
        /**
         * The maximum number of items rendered.
         */
        maxItems: KnockoutObservable<number>;
        /**
         * Indicates if the size of the area for display is small or large.
         */
        size: KnockoutObservable<Size>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\SimpleButton.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.SimpleButton {
    interface Options {
        /**
         * Button onClick that can be configured for the Button control.
         */
        onClick?: KnockoutObservableBase<Function> | Function;
        /**
         * Button displayed text that can be configured for the Button control.
         */
        text?: KnockoutObservableBase<string> | string;
        /**
         * Button disabled boolean that can be configured for the Button control.
         */
        disabled?: KnockoutObservableBase<boolean> | boolean;
        /**
         * Button primary boolean that can be configured for the Button control.
         */
        primary?: KnockoutObservableBase<boolean> | boolean;
    }
    class ViewModel extends Base.ViewModel {
        /**
         * onClick The onClick that is executed onClick().
         */
        onClick: KnockoutObservableBase<Function> | Function;
        /**
         * text The text that is displayed.
         */
        text: KnockoutObservableBase<string> | string;
        /**
         * disabled The state of the button.
         */
        disabled: KnockoutObservableBase<boolean> | boolean;
        /**
         * primary The style of the button.
         */
        primary: KnockoutObservableBase<boolean> | boolean;
        /**
         * Constructs an Button view model.
         *
         * @param lifetime Lifetime manager for this view model.
         * @param options Optional The set of options to configure the Button control.
         */
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\SingleSetting.d.ts
declare module MsPortalFx.ViewModels.Controls.SingleSetting {
    interface Contract extends Loadable.Contract {
        /**
         * The value of the setting.
         */
        value: KnockoutObservable<string>;
        /**
         * The unit of the setting.
         */
        unit: KnockoutObservable<string>;
        /**
         * The caption of the setting.
         */
        caption: KnockoutObservable<string>;
        /**
         * The info balloon of the setting.
         */
        infoBalloon?: KnockoutObservable<MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        hideInfoBalloon: KnockoutObservableBase<boolean>;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * The value of the setting.
         */
        value: KnockoutObservable<string>;
        /**
         * The unit of the setting.
         */
        unit: KnockoutObservable<string>;
        /**
         * The caption of the setting.
         */
        caption: KnockoutObservable<string>;
        /**
         * The info balloon of the setting.
         */
        infoBalloon: KnockoutObservable<DockedBalloon.ViewModel>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        hideInfoBalloon: KnockoutObservableBase<boolean>;
        /**
         * Creates a single setting view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\SpecComparisonTable.d.ts
declare module MsPortalFx.ViewModels.Controls.SpecComparisonTable {
    interface Options {
        /**
         * Table headers.
         */
        headers?: KnockoutObservableArray<Header>;
        /**
         * Table rows.
         */
        rows?: KnockoutObservableArray<Row>;
    }
    /**
     * Header background colors
     */
    enum Colors {
        Orange = 0,
        DarkOrchid = 1,
        YellowGreen = 2,
        MediumBlue = 3,
    }
    /**
     * Table header
     */
    interface Header {
        /**
         * Text displayed as a colum header
         */
        title: string;
        /**
         * Header cell background color.
         */
        color: Colors;
    }
    /**
     * Table row
     */
    interface Row {
        /**
         * Row label
         */
        label: string;
        /**
         * Row values for each column.
         */
        values: string[];
    }
    class ViewModel extends Base.ViewModel {
        /**
         * Table headers.
         */
        headers: KnockoutObservableArray<Header>;
        /**
         * Table rows.
         */
        rows: KnockoutObservableArray<Row>;
        /**
         * Constructs a spec comparison table view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: MsPortalFx.ViewModels.Controls.SpecComparisonTable.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\TerminalEmulator.d.ts
/**
* The Public ViewModel.
*/
declare module MsPortalFx.ViewModels.Controls.Unsupported.TerminalEmulator {
    /**
     * Columns and Rows for the TerminalEmulator control
     */
    interface Size {
        cols: number;
        rows: number;
    }
    /**
     * The set of options to configure the TerminalEmulator control.
     */
    interface Options {
        resize?: KnockoutObservableBase<Size>;
    }
    class ViewModel extends Base.ViewModel {
        /**
         * Write to terminal.
         */
        write: KnockoutObservableBase<string>;
        /**
         * Resize Terminal
         */
        resize: KnockoutObservableBase<Size>;
        /**
         * Terminal input
         */
        input: KnockoutObservableBase<string>;
        /**
         * Constructs a TerminalEmulator view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options Optional The set of options to configure the TerminalEmulator control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: MsPortalFx.ViewModels.Controls.Unsupported.TerminalEmulator.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\TextBlock.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.TextBlock {
    interface Options {
        /**
         * TextBlock's text.
         */
        text?: KnockoutObservableBase<string> | string;
    }
    class ViewModel extends Base.ViewModel {
        /**
         *text The string that is displayed.
         */
        text: KnockoutObservableBase<string> | string;
        /**
         * Constructs an TextBlock view model.
         *
         * @param lifetime Lifetime manager for this view model.
         * @param options Optional The set of options to configure the TextBlock control.
         */
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\TextStream.d.ts
declare module MsPortalFx.ViewModels.Controls.TextStream {
    enum Emphasis {
        /**
         * General text.
         */
        Normal = 0,
        /**
         * Important text.
         */
        Emphasized = 1,
        /**
         * Very important text.
         */
        Strong = 2,
    }
    interface TextInfo {
        /**
         * The text to display.
         */
        text: string;
        /**
         * The class of information in the text.
         */
        classifier?: string;
        /**
         * The emphasis of the infomation in the text.
         */
        emphasis?: Emphasis;
    }
    interface Contract extends Loadable.Contract {
        /**
         * The maximum text size to display.
         */
        max: KnockoutObservable<number>;
        /**
         * Wrap the lines of the display.
         */
        wrap: KnockoutObservable<boolean>;
        /**
         * Callback function when the text stream is clicked.
         */
        click: JQueryEventHandler;
        /**
         * Writes data to the display.
         */
        write: KnockoutObservable<string>;
        /**
         * Writes data to the display with a trailing line feed.
         */
        writeLine: KnockoutObservable<string>;
        /**
         * Writes styled data to the display.
         */
        writeText: KnockoutObservable<TextInfo>;
        /**
         * Writes styled data to the display with a trailing linefeed.
         */
        writeTextLine: KnockoutObservable<TextInfo>;
        /**
         * Writes multiple styled data to the display.
         */
        writeTextArray: KnockoutObservable<TextInfo[]>;
        /**
         * Clears the the display.
         */
        clear: MsPortalFx.ViewModels.Controls.Command.Contract;
        /**
         * Indicates if the text area should display scrollbars as needed.
         */
        scrollbars: boolean;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * The maximum text size to display.
         */
        max: KnockoutObservable<number>;
        /**
         * Wrap the lines of the display.
         */
        wrap: KnockoutObservable<boolean>;
        /**
         * Callback function when the text stream is clicked.
         */
        click: JQueryEventHandler;
        /**
         * Writes data to the display.
         */
        write: KnockoutObservable<string>;
        /**
         * Writes data to the display with a trailing line feed.
         */
        writeLine: KnockoutObservable<string>;
        /**
         * Writes styled data to the display.
         */
        writeText: KnockoutObservable<TextInfo>;
        /**
         * Writes styled data to the display with a trailing linefeed.
         */
        writeTextLine: KnockoutObservable<TextInfo>;
        /**
         * Writes multiple styled data to the display.
         */
        writeTextArray: KnockoutObservable<TextInfo[]>;
        /**
         * Clears the the display.
         */
        clear: MsPortalFx.ViewModels.Controls.Command.Contract;
        /**
         * Indicates if the text area should display scrollbars as needed.
         */
        scrollbars: boolean;
        /**
         * Constructs a TextStream view model.
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\TypableControl.d.ts
declare module MsPortalFx.ViewModels.Controls.TypableControl {
    /**
     * By default the number of milliseconds the portal will wait for typing to stop
     * before running validation.
     */
    var DefaultValidationDelay: number;
    interface Contract<TValue> extends ValidatableControl.Contract<TValue> {
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservableBase<number>;
        /**
         *  Updates the value view model based on enum option.
         */
        valueUpdateTrigger: ValueUpdateTrigger;
    }
    class ViewModel<TValue> extends ValidatableControl.ViewModel<TValue> implements Contract<TValue> {
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         *  Updates the value view model based on enum option.
         */
        valueUpdateTrigger: ValueUpdateTrigger;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ValidatableControl.d.ts
declare module MsPortalFx.ViewModels.Controls.ValidatableControl {
    var DefaultDelayValidationTimeout: number;
    interface Contract<TValue> extends EditableControl.Contract<TValue>, MsPortalFx.ViewModels.Controls.Validators.Validatable<TValue> {
    }
    class ViewModel<TValue> extends EditableControl.ViewModel<TValue> implements Contract<TValue> {
        /**
         * Indicates if validation should be skipped or not.
         */
        enableValidation: KnockoutObservable<boolean>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         * Indicates the current validation state. The validation state is useful when there are async validators and
         * validation completion should be notified.
         */
        validationState: KnockoutObservable<MsPortalFx.ViewModels.Controls.Validators.ValidationState>;
        /**
         * Indicates if the value was valid the last time validate was called.
         */
        valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Validators to apply to the value when validating.
         */
        validators: KnockoutObservableArray<MsPortalFx.ViewModels.Controls.Validators.Validator<TValue>>;
        /**
         * Creates a validatable control.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ValidationPlacements.d.ts
declare module MsPortalFx.ViewModels.Controls.ValidationPlacements {
    /**
     * ValidationPlacementBase<TValue> is the portal equivalent base class supporting validation placement.
     */
    class ValidationPlacementBase<TValue> implements MsPortalFx.ViewModels.Controls.Validators.ValidationPlacement<TValue> {
        _element: JQuery;
        _validatable: MsPortalFx.ViewModels.Controls.Validators.Validatable<TValue>;
        _subscriptions: KnockoutSubscription<any>[];
        _errorMessage: KnockoutComputed<string>;
        private _destroyIds;
        /**
         * _checkExistsOrRegisterDestroyId.  This is utility function for the destroy method to avoid recursive
         *
         * @param destroyId Unique identifier for the destroy to identify itself.  In the javascript inheritance, this.destroy is always the same.
         *                  But super.dispose is unique since super is function scope.  Typically, use super.dispose as id. For root object, use null as Id.
         * @return whether this destroyMethod is already on the executed. If true, mean it is already been executed.
         */
        _checkExistsOrRegisterDestroyId(destroyId: any): boolean;
        /**
         * See interface.
         */
        isDestroyed(): boolean;
        /**
         * See interface.
         */
        dispose(): void;
        /**
         * See interface.
         */
        initialize(element: JQuery, validatable: MsPortalFx.ViewModels.Controls.Validators.Validatable<TValue>): void;
        /**
         * See interface.
         */
        onErrorMessageChanged(newValue: string): void;
        /**
         * See interface.
         */
        onValidationStateChanged(newValue: MsPortalFx.ViewModels.Controls.Validators.ValidationState): void;
        /**
         * Initializes the subscriptions property.
         */
        _initializeSubscriptions(): void;
        /**
         * Disposes the subscriptions property.
         */
        _disposeSubscriptions(): void;
    }
    /**
     * Css<TValue> provides out of the box validation placement support by adding validation specific class and attributes which can be used for CSS styling.
     */
    class Css<TValue> extends ValidationPlacementBase<TValue> {
        private _input;
        private _valid;
        /**
         * See interface.
         */
        dispose(): void;
        /**
         * See interface.
         */
        initialize(element: JQuery, validatable: MsPortalFx.ViewModels.Controls.Validators.Validatable<TValue>): void;
        /**
         * See interface.
         */
        onValidationStateChanged(newValue: MsPortalFx.ViewModels.Controls.Validators.ValidationState): void;
        private _setValidationAttribute(validationState);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Validators.d.ts
declare module MsPortalFx.ViewModels.Controls.Validators {
    import FxBase = MsPortalFx.Base;
    /**
     * ValidationState represents the current validation state when list of validators are run.
     */
    const enum ValidationState {
        /**
         * Default validation state.
         */
        None = 0,
        /**
         * Validation failed.
         */
        Invalid = 1,
        /**
         * Validation succeeded.
         */
        Valid = 2,
        /**
         * Validation pending during async validation calls.
         */
        Pending = 3,
    }
    interface Validatable<TValue> {
        /**
         * Indicates if validation should be skipped or not.
         */
        enableValidation: KnockoutObservable<boolean>;
        /**
         * Indicates if the value was valid the last time validate was called.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * Indicates the current validation state. The validation state is useful when there are async validators and
         * validation completion should be notified.
         */
        validationState: KnockoutObservable<ValidationState>;
        /**
         * Validators to apply to the value when validating.
         */
        validators: KnockoutObservableArray<Validator<TValue>>;
    }
    interface ValidationPlacement<TValue> {
        /**
         * Initializes the ValidationPlacement.
         *
         * @param element The widget element.
         * @param validatable Interface containing validation specific validators and valid flag.
         */
        initialize(element: JQuery, validatable: Validatable<TValue>): void;
        /**
         * Destroys the artifacts related to the validation placement.
         */
        dispose(): void;
        /**
         * Dispose() has been called.
         */
        isDestroyed(): boolean;
        /**
         * Triggers when the errorMessages ViewModel property changes.
         *
         * @param newValue Array of validation error messages.
         */
        onErrorMessageChanged(newValue: string): void;
        /**
         * Triggers when the validationState ViewModel property changes.
         *
         * @param newValue Current ValidationState value.
         */
        onValidationStateChanged(newValue: ValidationState): void;
    }
    interface ErrorPlacement<TValue> {
        /**
         * List of placements that display validation status.
         */
        validationPlacements: KnockoutObservableArray<ValidationPlacement<TValue>>;
    }
    /**
     * Validator base class. Used to define validators that can be attached to an
     * validatable control view model to validate the value.
     */
    class Validator<TValue> {
        private _sub;
        /**
         * Validation rule error message.
         */
        message: KnockoutObservable<string>;
        /**
         * Indicates if the value was valid the last time validate was called.
         */
        valid: KnockoutComputed<boolean>;
        /**
         * Indicates if the current validation state.
         */
        validationState: KnockoutObservable<ValidationState>;
        /**
         * Evaluates if the value is valid (works cross IFRAME).
         */
        validate: KnockoutObservable<TValue>;
        /**
         * Indicates whether an empty value is valid or not.
         */
        isEmptyValid: KnockoutObservable<boolean>;
        /**
         * Constructs a validator.
         *
         * @param message Describes the validation rule.
         */
        constructor(message?: string);
        /**
         * Releases resources held by the validator.
         */
        dispose(): void;
        /**
         * Determines if the value is valid.
         * Should be overridden in derived classes.
         *
         * @param value The value to check.
         * @return Indicates the current validation state.
         */
        _validate(value: TValue): ValidationState;
    }
    /**
     * Escapes regular expression special characters -[]/{}()*+?.\^$|
     *
     * @param str The string to escape.
     * @return The escaped string.
     */
    function escapeRegExpOperators(str: string): string;
    class Match extends Validator<string> {
        private _expression;
        /**
         * Constructs a validator that checks if the value matches a regular expression.
         *
         * @param message Validation rule error message.
         */
        constructor(expression: RegExp, message?: string);
        /**
         * See base.
         */
        _validate(value: string): ValidationState;
    }
    class NotMatch extends Validator<string> {
        private _expression;
        /**
         * Constructs a validator that checks if the value does not match a regular expression.
         *
         * @param message Validation rule error message.
         */
        constructor(expression: RegExp, message?: string);
        /**
         * See base.
         */
        _validate(value: string): ValidationState;
    }
    class Contains extends Match {
        /**
         * Constructs a validator that checks that the value contains at least one case insensitive match of a search string.
         *
         * @param search The search string to match.
         * @param message Validation rule error message.
         */
        constructor(search: string, message?: string);
    }
    class NotContains extends NotMatch {
        /**
         * Constructs a validator that checks that the value does not contain a case insensitive match of a search string.
         *
         * @param search The search string to match.
         * @param message Validation rule error message.
         */
        constructor(search: string, message?: string);
    }
    class ContainsCharacters extends Match {
        /**
         * Constructs a validator that checks that the value contains at least one character from a character set.
         *
         * @param characters One or more characters to search for.
         * @param message Validation rule error message.
         */
        constructor(characters: string, message?: string);
    }
    class NotContainsCharacters extends NotMatch {
        /**
         * Constructs a validator that checks that the value does not contain any characters from a character set.
         *
         * @param characters One or more characters to search for.
         * @param message Validation rule error message.
         */
        constructor(characters: string, message?: string);
    }
    class HasDigit extends Match {
        /**
         * Constructs a validator that checks that the value has at least one digit from 0 to 9.
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
    class HasLetter extends Match {
        /**
         * Constructs a validator that checks that the value has at least one upper or lower case letter from A to Z or a to z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
    class HasUpperCaseLetter extends Match {
        /**
         * Constructs a validator that checks that the value has at least one upper case letter from A to Z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
    class HasLowerCaseLetter extends Match {
        /**
         * Constructs a validator that checks that the value has at least one lower case letter from a to z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
    class HasPunctuation extends ContainsCharacters {
        /**
         * Constructs a validator that checks that the value contains at least one punctuation character from:
         * ! @ # $ % ^ & * ( ) _ + - = { } | [ ] \ : " ; ' < > , . ? / ~ `
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
    class Compare<TValue> extends Validator<TValue> {
        private _compareTo;
        /**
         * Base class for comparison validators. Not to be used directly.
         *
         * @param compareTo The value or accessor to get the value to compare to.
         * @param message Validation rule error message.
         */
        constructor(compareTo: any, message?: string);
        /**
         * See base.
         */
        _validate(value: TValue): ValidationState;
        /**
         * Compares two values.
         * (Derived classes must override.)
         *
         * @param value The control value.
         * @param compareTo The value to compare to.
         * @return Result of comparison.
         */
        _compare(value: TValue, compareTo: TValue): boolean;
    }
    class Equals<TValue> extends Compare<TValue> {
        /**
         * Constructs a validator that compares if the value is equal to a provided value.
         *
         * @param compareTo The value or accessor to get the value to compare to.
         * @param message Validation rule error message.
         */
        constructor(compareTo: TValue, message?: string);
        constructor(compareTo: () => TValue, message?: string);
        /**
         * Compares two values for strict equality.
         *
         * @param value The control value.
         * @param compareTo The value to compare to.
         * @return Result of equality comparison.
         */
        _compare(value: TValue, compareTo: TValue): boolean;
    }
    class CaseInsensitiveCompare extends Compare<string> {
        /**
         * Constructs a validator that uses toLowerCase() to compare two values.
         *
         * @param compareTo The value or accessor to get the value to compare to.
         * @param message Validation rule error message.
         */
        constructor(compareTo: string, message?: string);
        constructor(compareTo: () => string, message?: string);
        /**
         * Compares two values for strict equality.
         *
         * @param value The control value.
         * @param compareTo The value to compare to.
         * @return Result of equality comparison.
         */
        _compare(value: string, compareTo: string): boolean;
    }
    class LocaleAwareCaseInsensitiveCompare extends Compare<string> {
        /**
         * Constructs a validator that uses toLocaleLowerCase() to compare two values.
         *
         * @param compareTo The value or accessor to get the value to compare to.
         * @param message Validation rule error message.
         */
        constructor(compareTo: string, message?: string);
        constructor(compareTo: () => string, message?: string);
        /**
         * Compares two values for strict equality.
         *
         * @param value The control value.
         * @param compareTo The value to compare to.
         * @return Result of equality comparison.
         */
        _compare(value: string, compareTo: string): boolean;
    }
    class LengthRange extends Validator<string> {
        private _min;
        private _max;
        /**
         * Constructs a validator that checks that the value length is between min and max.
         *
         * @param min The minimum number of characters to be valid. May be null if there is no min.
         * @param max The maximum number of characters to be valid. May be null if there is no max.
         * @param message Validation rule error message.
         */
        constructor(min: number, max: number, message?: string);
        /**
         * See base.
         */
        _validate(value: string): ValidationState;
    }
    class MinLength extends LengthRange {
        /**
         * Constructs a validator that checks that the value length is at least min.
         *
         * @param min The minimum number of characters to be valid.
         * @param message Validation rule error message.
         */
        constructor(min: number, message?: string);
    }
    class MaxLength extends LengthRange {
        /**
         * Constructs a validator that checks that the value length is less than or equal to the max.
         *
         * @param max The maximum number of characters to be valid.
         * @param message Validation rule error message.
         */
        constructor(max: number, message?: string);
    }
    class Required extends MinLength {
        /**
         * Constructs a validator that checks whether the value is empty.
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
    class NotNull<TValue> extends Validator<TValue> {
        /**
         * Constructs a validator that checks whether the value is null or not.
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
        /**
         * See base.
         */
        _validate(value: TValue): ValidationState;
    }
    class Numeric extends Validator<string> {
        /**
         * Constructs a validator that checks whether the value is a number.
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
        /**
         * See base.
         */
        _validate(value: string): ValidationState;
    }
    class ValueRange extends Validator<any> {
        private min;
        private max;
        /**
         * Constructs a validator that checks whether the value is within the range defined by min and max number.
         *
         * @param min Minimum range value to get the value.
         * @param max Maximum range value to get the value.
         * @param message Validation rule error message.
         */
        constructor(min: number, max: number, message?: string);
        /**
         * Constructs a validator that checks whether the value is within the range defined by min and max number.
         *
         * @param min Minimum range accessor to get the value.
         * @param max Maximum range accessor to get the value.
         * @param message Validation rule error message.
         */
        constructor(min: () => number, max: () => number, message?: string);
        /**
         * See base.
         */
        _validate(value: any): ValidationState;
    }
    class MinValue extends ValueRange {
        /**
         * Constructs a validator that checks whether the value is greater than or equal to the specified minimum number.
         *
         * @param min Minimum range value.
         * @param message Validation rule error message.
         */
        constructor(min: number, message?: string);
    }
    class MaxValue extends ValueRange {
        /**
         * Constructs a validator that checks whether the value is less than or equal to the specified maximum number.
         *
         * @param max Maximum range value.
         * @param message Validation rule error message.
         */
        constructor(max: number, message?: string);
    }
    class CustomAsyncValidator<TValue> extends Validator<TValue> {
        private _validationHandler;
        private _context;
        private _pendingAsyncRequests;
        private _latestValidationAsyncRequestId;
        /**
         * Constructs a validator that invokes an async handler to check whether the given value is valid or not.
         * The async validation is provided by the user and can have any custom validation logic.
         *
         * @param message Validation rule error message.
         * @param validationHandler Validation function that takes in a value and an optional context object and returns a jquery promise object.
         * @param context Validation context that will be passed on when the validationHandler is invoked.
         */
        constructor(message: string, validationHandler: (value: TValue, context?: any) => FxBase.PromiseV<string>, context?: any);
        /**
         * For custom async validation we need to handle few important scenarios to make sure the validation result is consistent.
         *          1) Cuncurrent async validation request are possible and it must be handled.
         *          2) The result of async validation can race and can overwrite with an inconsistent result.
         *          3) Syncronous completion of the async request.
         *
         * Custom async validator will keep track of all pending request and will honor only the last validation request and update the validation state.
         *
         * @param value The current value that needs to be validated.
         *
         * @return The current validation state after evaluating the validation logic.
         */
        _validate(value: TValue): ValidationState;
        private _updateResult(message, validationState);
        private _updateValidationResult(promise, message, validationState);
        private _removePendingAsyncRequest(promise);
    }
    class Invalid extends Validator<any> {
        /**
         * Constructs a validator that always return invalid result.
         *
         * @param message Validation rule error message.
         */
        constructor(message: string);
        /**
         * See base.
         */
        _validate(value: any): ValidationState;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ValueUpdateTrigger.d.ts
declare module MsPortalFx.ViewModels.Controls {
    /**
     * Enum to indicate when to trigger value updates.
     */
    enum ValueUpdateTrigger {
        /**
         * Maps to one of the other value update trigger values. Which one is up to the controls code to decide.
         */
        Default = 0,
        /**
         * Trigger value updates as soon as user types a character.
         */
        AfterKeyDown = 1,
        /**
         * Trigger value updates as soon as user types a character (including repeated keys).
         */
        KeyPress = 2,
        /**
         * Trigger value update on blur.
         */
        Blur = 3,
        /**
         * Trigger value update on input Event (IE 9+) .
         */
        Input = 4,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ViewModels.BaseHotspot.d.ts
declare module MsPortalFx.ViewModels.Controls.HotSpot {
    /**
     * View model for Base hotspots.
     */
    class BaseViewModel extends MsPortalFx.ViewModels.Controls.Base.ViewModel {
        /**
         * Creates a HotSpot ViewModel.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ViewModels.BaseInfoBox.d.ts
declare module MsPortalFx.ViewModels.Controls.InfoBox {
    import Base = MsPortalFx.Base;
    /**
     * The size options for info box
     */
    enum Size {
        Small = 0,
        Normal = 1,
    }
    /**
     * The base view model for info box.
     */
    class BaseViewModel extends Loadable.ViewModel {
        /**
         * The image to display in the control.
         */
        image: KnockoutObservableBase<Base.Image>;
        /**
         * The text or html to display in the control.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Size of the infobox
         */
        size: KnockoutObservableBase<Size>;
        /**
         * Constructs and instance of a view model.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options view model properties.
         */
        constructor(lifetimeManager: Base.LifetimeManager, options?: BaseInfoBoxOptions);
    }
    /**
     * The view model options for info box.
     */
    interface BaseInfoBoxOptions {
        /**
         * The image to display in the control.
         */
        image: KnockoutObservableBase<Base.Image>;
        /**
         * The text or html to display in the control.
         */
        text: KnockoutObservableBase<string>;
        /**
         * The clickableLink used to launch a link from info box.
         */
        clickableLink: KnockoutObservableBase<MsPortalFx.ViewModels.ClickableLink>;
        /**
         * Size of the infobox
         */
        size?: KnockoutObservableBase<Size>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ViewModels.DeleteAssetConfirmation.d.ts
declare module MsPortalFx.ViewModels.Controls.DeleteAssetConfirmation {
    /**
     * The options of the grid.
     */
    interface GridOptions<TItem, TSelection> {
        /**
         * The items of the grid.
         */
        items: KnockoutObservableArray<TItem>;
        /**
         * The columns of the grid.
         */
        columns: KnockoutObservableArray<MsPortalFx.ViewModels.Controls.Lists.Grid.Column>;
        /**
         * The message displayed when the grid has no data.
         */
        noRowsMessage: KnockoutObservable<string>;
        /**
         * Shows the header of the grid.
         */
        showHeader?: boolean;
        /**
         * The options of the selectable row extensions.
         */
        selectableRowExtensionOptions?: MsPortalFx.ViewModels.Controls.Lists.Grid.SelectableRowExtensionOptions<TItem, TSelection>;
    }
    /**
     * The options of the view model.
     */
    interface Options<TItem, TSelection> {
        /**
         * The display name of the asset type. It will be overwritten if it is also provided via input binding.
         */
        assetTypeDisplayName: string;
        /**
         * The options of the grid.
         */
        grid?: GridOptions<TItem, TSelection>;
    }
    /**
     * View model for the DeleteAssetConfirmation control.
     */
    class ViewModel<TItem, TSelection> extends Loadable.ViewModel {
        /**
         * Gets if it is valid.
         */
        valid: KnockoutComputed<boolean>;
        selectedItems: KnockoutObservableArray<TSelection>;
        /**
         * Gets or sets the grid items.
         */
        _gridItems: KnockoutObservableArray<TItem>;
        /**
         * Gets the options of the view model.
         */
        _options: Options<TItem, TSelection>;
        /**
          * Gets the asset name.
          */
        _assetName: KnockoutObservable<string>;
        /**
        * Gets the display name of the asset type.
        */
        _assetTypeDisplayName: KnockoutObservable<string>;
        private grid;
        private confirmationEditor;
        private warning;
        private confirmationLabel;
        private affectedItemsLabel;
        /**
         * Instantiates a view model.
         *
         * @param options The view model options.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: Options<TItem, TSelection>);
        /**
         * Updates the warning text.
         * Subclass can provide its own warning text by overriding this method.
         *
         * @param assetName The asset name.
         * @return the warning text.
         */
        _onUpdateWarningText(assetName: string): string;
        /**
         * Updates the confirmation label.
         * Subclass can provide its own confirmation label by overriding this method.
         *
         * @param assetTypeDisplayName The display name of the asset type.
         * @return the confirmation label.
         */
        _onUpdateConfirmationLabel(assetTypeDisplayName: string): string;
        /**
         * Selects all the items in the grid.
         */
        _selectAll(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ViewModels.HeroBanner.d.ts
declare module MsPortalFx.ViewModels.Controls.HeroBanner {
    /**
     * View model for the hero banner control.
     */
    class ViewModel extends Loadable.ViewModel {
        /**
         * The hero gallery item.
        */
        galleryItem: KnockoutObservable<MsPortalFx.Services.Gallery.GalleryItem>;
        /**
         * The dynamic blade selection of the blade to launch when create is clicked.
         */
        bladeSelection: KnockoutObservable<DynamicBladeSelection>;
        /**
         * A flag indicating when the banner is clicked.
         */
        bannerClicked: KnockoutObservable<boolean>;
        /**
         * A flag indicating when the create button is clicked.
         */
        createClicked: KnockoutObservable<boolean>;
        /**
         * A callback that returns the create blade when the create button is clicked.
         */
        getCreateBladeSelection: () => MsPortalFx.Base.PromiseV<MsPortalFx.ViewModels.DynamicBladeSelection>;
        /**
         *  Internal Use only.
         */
        cloudName: string;
        /**
         * Creates a hero banner.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ViewModels.Hotspot.d.ts
declare module MsPortalFx.ViewModels.Controls.HotSpot {
    import BaseViewModel = MsPortalFx.ViewModels.Controls.HotSpot.BaseViewModel;
    /**
     * View model for hotspots
     */
    class ViewModel extends BaseViewModel implements SelectableSource {
        /**
         * Selectable that tracks if hotspot selection state
         */
        selectable: Selectable<any>;
        /**
         * If the hotspot should be clickable during Customize mode
         */
        clickableDuringCustomize: boolean;
        /**
         * Creates a HotSpot ViewModel.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ViewModels.InfoBox.d.ts
declare module MsPortalFx.ViewModels.Controls.InfoBox {
    class ViewModel extends InfoBox.BaseViewModel {
        /**
         * The selectable used in launching another blade.
         */
        selectable: MsPortalFx.ViewModels.Selectable<any>;
        /**
         * Constructs and instance of a view model.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param loading Default loading state.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, initialState: any, loading?: boolean, options?: BaseInfoBoxOptions);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ViewModels.LinkHotspot.d.ts
declare module MsPortalFx.ViewModels.Controls.HotSpot {
    /**
     * View model for Clickable hotspots
     */
    class LinkViewModel extends MsPortalFx.ViewModels.Controls.HotSpot.BaseViewModel {
        /**
         * Link that can be launched from the hotspot.
         */
        clickableLink: KnockoutObservableBase<MsPortalFx.ViewModels.ClickableLink>;
        /**
         * Creates a HotSpot ViewModel.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: LinkHotSpotOptions);
    }
    /**
    * View model options for hotspots.
    */
    interface LinkHotSpotOptions {
        /**
         * Link that can be launched from the hotspot.
         */
        clickableLink: KnockoutObservableBase<MsPortalFx.ViewModels.ClickableLink>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ViewModels.LinkInfoBox.d.ts
declare module MsPortalFx.ViewModels.Controls.InfoBox {
    class LinkViewModel extends InfoBox.BaseViewModel {
        /**
         * The clickableLink used to launch a link from info box.
         */
        clickableLink: KnockoutObservableBase<MsPortalFx.ViewModels.ClickableLink>;
        /**
         * Constructs and instance of a view model.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Info box options.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: BaseInfoBoxOptions);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ViewModels.Notice.d.ts
declare module MsPortalFx.ViewModels.Controls.Notice {
    /**
     * Types of images for the notice control.
     */
    enum ImageType {
        /**
         * Default image.
         */
        Default = 0,
        /**
         * Image for coming soon.
         */
        ComingSoon = 1,
        /**
         * Image for no subscription.
         */
        NoSubscription = 2,
        /**
         * Image for unauthorized.
         */
        Unauthorized = 3,
    }
    /**
     * Contract for the notice control.
     */
    class ViewModel extends Loadable.ViewModel {
        /**
        * See interface.
        */
        header: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        title: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        description: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        callToActionText: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        callToActionUri: KnockoutObservableBase<string>;
        /**
        * See interface.
        */
        callToSecondaryActionText: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        callToSecondaryActionUri: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        imageType: KnockoutObservableBase<ImageType>;
        /**
         * Creates a balloon.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\ViewModels.Wizard.d.ts
declare module MsPortalFx.ViewModels.Controls.Wizard {
    enum WizardMode {
        /**
         * Indicates that the wizard consists of a sequence of steps.
         */
        Sequential = 0,
        /**
         * Indicates that the wizard consists of a set of steps accessible in any order.
         */
        NonSequential = 1,
    }
    enum StepType {
        /**
         * Indicates a step that contains a form.
         */
        Form = 0,
        /**
         * Indicates a step that selects a single value or entity.
         */
        Selector = 1,
    }
    interface WizardStepSelection extends DynamicBladeSelection {
        /**
         * The ID that uniquely identifies the step.
         */
        stepId: string;
    }
    interface StepState {
        /**
         * The ID that uniquely identifies the step.
         */
        stepId: string;
        /**
         * The status of the step.
         */
        status: ActionBars.Base.Status;
    }
    interface StepInput extends StepState {
        /**
         * A value indicating whether this is the first step.
         */
        isFirstStep: boolean;
        /**
         * A value indicating whether this is the last step.
         */
        isLastStep: boolean;
        /**
         * A value indicating whether the step is optional.
         */
        isOptional: boolean;
        /**
         * A value indicating whether or not the step is disabled.
         * This value specifies whether or not there are any prerequisite steps that have not been completed.
         */
        disabled: boolean;
        /**
         * True, if user can choose whether provisioning happens on blade or startboard part.
         * Else false.
         */
        allowToggleProvisioningLocation?: boolean;
        /**
         * True if the master part that opened the create blade is a provisioning part; else false.
         */
        masterIsProvisioningPart?: boolean;
    }
    interface StepOutput extends StepState {
        /**
         * The action to perform.
         */
        action: ActionBars.Base.Action;
    }
    interface WizardState {
        /**
         * The current statuses of all steps in the wizard.
         */
        stepStatuses: StepState[];
        /**
         * The ID of the currently selected step.
         */
        selectedStepId?: string;
    }
    interface Contract extends Loadable.Contract {
        /**
         * The mode in which the wizard is currently operating.
         */
        mode: WizardMode;
        /**
         * The observable set of steps for the Wizard.
         */
        steps: KnockoutObservableArray<WizardStep>;
        /**
         * The selection instance corresponding to the current step.
         */
        selection: KnockoutObservable<WizardStepSelection>;
        /**
         * The previously saved state of the wizard.
         */
        savedState: KnockoutObservable<WizardState>;
        /**
         * The current state of the wizard to be saved.
         */
        currentState: KnockoutObservable<WizardState>;
        /**
         * Output of the current step propagated from it's details blade.
         */
        stepOutput: KnockoutObservable<StepOutput>;
        /**
         * A value used to indicate to the consumer to start executing the wizard command.
         */
        beginExecuteCommand: KnockoutObservable<boolean>;
        /**
         * Invoked when a step is complete. Optional.
         */
        complete?: () => MsPortalFx.Base.Promise;
    }
    class WizardStepBase {
        /**
         * Creates a new wizard step.
         *
         * @param stepId The ID that uniquely identifies the step.
         * @param stepType The type of the step.
         * @param title The title for the wizard step.
         * @param formBlade The blade contianing the form for the wizard step.
         * @param extension The extension that hosts the blade contianing the form for the wizard step.
         */
        constructor(stepId: string, stepType: StepType, title: string, formBlade: string, extension?: string);
        /**
         * See interface.
         */
        stepType: StepType;
        /**
         * See interface.
         */
        stepId: string;
        /**
         * See interface.
         */
        title: KnockoutObservable<string>;
        /**
         * See interface.
         */
        description: KnockoutObservable<string>;
        /**
         * See interface.
         */
        iconUri: KnockoutObservable<string>;
        /**
         * See interface.
         */
        status: KnockoutObservable<ActionBars.Base.Status>;
        /**
         * See interface.
         */
        isOptional: boolean;
        /**
         * See interface.
         */
        formBlade: string;
        /**
         * See interface.
         */
        extension: string;
        /**
         * Invoked just prior to a step being loaded.
         */
        stepLoad: (step: WizardStep) => JQueryDeferred;
        /**
         * Invoked when a step is complete.
         */
        stepComplete: (step: WizardStep) => JQueryDeferred;
    }
    class ViewModel extends Loadable.ViewModel {
        /**
         * See interface.
         */
        mode: WizardMode;
        /**
         * See interface.
         */
        steps: KnockoutObservableArray<WizardStep>;
        /**
         * See interface.
         */
        selection: KnockoutObservable<WizardStepSelection>;
        /**
         * See interface.
         */
        savedState: KnockoutObservable<WizardState>;
        /**
         * See interface.
         */
        currentState: KnockoutObservable<WizardState>;
        /**
         * See interface.
         */
        stepOutput: KnockoutObservable<StepOutput>;
        /**
         * See interface.
         */
        beginExecuteCommand: KnockoutObservable<boolean>;
        /**
         * Invoked when a step is complete.
         */
        complete: () => JQueryDeferred;
        private _autoOpenFirstStep;
        /**
         * Creates the view model for a wizard.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param initialState The initial state of the wizard. Properties on this object will be used to initialize properties on the view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, initialState?: any);
        /**
         * Initializes the wizard and auto-selects the first step if no initial state and not already selected.
         */
        initialize(): void;
    }
    class WizardStep extends WizardStepBase {
        /**
         * Creates a new wizard step.
         *
         * @param stepId The ID that uniquely identifies the step.
         * @param title The title for the wizard step.
         * @param formBlade The blade contianing the form for the wizard step.
         * @param status The status for the step.
         * @param isOptional A value indicating whether or not the step is optional. Defaults to false.
         * @param extension The extension that hosts the blade contianing the form for the wizard step.
         */
        constructor(stepId: string, title: string, formBlade: string, status?: ActionBars.Base.Status, isOptional?: boolean, extension?: string);
    }
    class SelectorStep<T> extends WizardStepBase {
        /**
         * Creates a new selector step.
         *
         * @param stepId The ID that uniquely identifies the step.
         * @param title The title for the wizard step.
         * @param formBlade The blade contianing the form for the wizard step.
         * @param extension The extension that hosts the blade contianing the form for the wizard step.
         */
        constructor(stepId: string, title: string, formBlade: string, extension?: string);
        /**
         * See interface.
         */
        value: KnockoutObservableBase<T>;
        /**
         * See interface.
         */
        defaultValue: KnockoutObservableBase<T>;
        /**
         * See interface.
         */
        isDefault: KnockoutObservableBase<boolean>;
        /**
         * See interface.
         */
        displayText: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        locked: KnockoutObservableBase<boolean>;
        /**
         * See interface.
         */
        infoBalloonText: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        lockedBalloonText: KnockoutObservableBase<string>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\Chart.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Chart {
    import DockedBalloon = MsPortalFx.ViewModels.Controls.DockedBalloon;
    /**
    * Defines chart types.
    */
    enum ChartType {
        /**
         * Line chart type.
         */
        Line = 0,
        /**
         * Area chart type.
         */
        Area = 1,
        /**
         * Scatter chart type.
         */
        Scatter = 2,
        /**
         * Stacked bar chart type.
         */
        StackedBar = 3,
        /**
         * Grouped bar chart type.
         */
        GroupedBar = 4,
        /**
         * Split bar chart type.
         */
        SplitBar = 5,
        /**
         * Stacked area chart type.
         */
        StackedArea = 6,
    }
    /**
     * Defines interpolation of lines of the line chart.
     */
    enum Interpolation {
        /**
         * The series interpolation when data points are connected by straight lines.
         */
        Linear = 0,
        /**
         * The series interpolation when data points are connected by smooth curves. The monotone is a mode of D3 interpolation style.
         */
        Monotone = 1,
        /**
         * The series interpolation when series are connected by two lines: the first one (from the left side) is horizontal and the second one is vertical.
         */
        StepAfter = 2,
    }
    /**
     * Defines line styles of the line chart.
     */
    enum LineStyle {
        /**
         * The series line is solid.
         */
        Solid = 0,
        /**
         * The series line is dotted.
         */
        Dotted = 1,
        /**
         * The series line is dashed.
         */
        Dashed = 2,
        /**
         * The series line is a trendline.
         */
        Trendline = 3,
        /**
          * The series line is a usage threshold.
          */
        UsageThreshold = 4,
        /**
         * The series line is a warning threshold.
         */
        WarningThreshold = 5,
    }
    /**
     * Display type for optional line and coordinate plots for stacked area charts.
     */
    enum LineState {
        /**
         * Display stacked area chart line with coordinate points. Use this for old api behavior showLines(true).
         */
        ShowLineWithPoints = 0,
        /**
         * Hide stacked area chart line. Use this for old api behavior showLines(false).
         */
        HideLine = 1,
        /**
         * Display stacked area chart line with the point nearest to x slider only.
         */
        ShowLineWithXHoverPoint = 2,
    }
    /**
     * Defines hatching patterns of the area chart.
     */
    enum AreaHatchingPattern {
        /**
         * The series area is solid.
         */
        Solid = 0,
        /**
         * The series area is cross hatched.
         */
        CrossHatching = 1,
        /**
         * The series area is diagonal hatched.
         */
        DiagonalHatching = 2,
        /**
         * The area is hatched horizontally like a dotted line.
         */
        DottedHatching = 3,
    }
    /**
     * Defines the various sub-types for bar chart.
     */
    enum BarChartType {
        /**
         * The data series will be rendered as stacked bars for each x value.
         */
        Stacked = 0,
        /**
         * The data series will be rendered as grouped bars for each x value.
         */
        Grouped = 1,
        /**
         * The data series which has positive and negative values will be rendered with axis in the center of the chart.
         */
        Split = 2,
    }
    /**
     * Indicates where the chart axis should be visually positioned on the chart.
     */
    enum AxisPosition {
        /**
         * The axis should not be displayed in the chart.
         */
        None = 0,
        /**
         * The axis should be displayed horizontally above the chart.
         */
        Top = 1,
        /**
         * The axis should be displayed vertically and aligned right of the chart.
         */
        Right = 2,
        /**
         * The axis should be displayed horizontally below chart.
         */
        Bottom = 3,
        /**
         * The axis should be displayed vertically and aligned left of the chart.
         */
        Left = 4,
    }
    enum InteractionBehavior {
        /**
         * All Interaction is enabled
         */
        All = 0,
        /**
         * Opt out XSlider behavior
         */
        XSlider_Off = 1,
        /**
         * Opt out XSlider callout Text. Not Yet Implemented.
         */
        XSlider_noCallout = 2,
        /**
         * Opt out any interaction in ChartArea.
         */
        ChartArea_Off = 4,
        /**
         * Opt out any ChartArea Click-select behavior. Not Yet Implemented.
         */
        ChartArea_noClick = 8,
        /**
         * Opt out any ChartArea hover behavior. Not Yet Implemented.
         */
        ChartArea_noHover = 16,
    }
    /**
     * Indicates where the chart legend should be visually positioned on the chart.
     */
    enum LegendPosition {
        /**
         * The chart legend should not be displayed in the chart.
         */
        None = 0,
        /**
         * The legend should be displayed horizontally above the chart.
         */
        Top = 1,
        /**
         * The legend should be displayed vertically and aligned right of the chart.
         */
        Right = 2,
        /**
         * The legend should be displayed horizontally below chart.
         */
        Bottom = 3,
        /**
         * The legend should be displayed vertically and aligned left of the chart.
         */
        Left = 4,
    }
    /**
     * Specifies the data label context.
     */
    enum DataLabelContext {
        /**
         * The data label should be displayed near the max value of the series.
         */
        Max = 0,
        /**
         * The data label should be displayed near the min value of the series.
         */
        Min = 1,
        /**
         * The data label should be displayed near the first value of the series.
         */
        First = 2,
        /**
         * The data label should be displayed near the last value of the series.
         */
        Last = 3,
        /**
         * The data label should be displayed near every value of the series.
         */
        Every = 4,
        /**
         * The data label should be displayed near custom points.
         */
        Custom = 5,
    }
    /**
     * Specifies the data label style.
     */
    enum DataLabelStyle {
        /**
         * The data label should be displayed as a callout.
         */
        Callout = 0,
        /**
         * The data label should be displayed as a badge.
         */
        Badge = 1,
    }
    /**
     * Specifies the scale used on the axis.
     */
    enum Scale {
        /**
         * Specify this scale for discrete values where the values will be mapped 1:1 on the axis.
         */
        Ordinal = 0,
        /**
         * Specify this scale for continuous values like numeric values in the series which may or may not be sorted.
         */
        Linear = 1,
        /**
         * Specify this scale for date / time values in the series which may or may not be sorted.
         */
        Time = 2,
    }
    /**
     * Specifies where the axis label should be displayed.
     */
    enum AxisLabelPosition {
        /**
         * The labels are not displayed.
         */
        None = 0,
        /**
         * The labels are displayed at the low end of the axis.
         */
        Low = 1,
        /**
         * The labels are displayed at the high end of the axis.
         */
        High = 2,
    }
    /**
     * Specifies conditions checked on rendering a series view.
     */
    enum ConditionOperator {
        /**
         * The view should be rendered for series segments exceeding the argument of the condition.
         */
        GreaterThan = 0,
        /**
         * The view should be rendered for series segments not exceeding the argument of the condition.
         */
        LessThan = 1,
    }
    /**
     * Specifies series type.
     */
    enum SeriesType {
        /**
         * The series is defined as a set of pairs of x and y values.
         */
        General = 0,
        /**
         * The series is used to draw a horizontal line and is defined as with the y value.
         */
        HorizontalLine = 1,
        /**
         * The series is used to draw a vertical line and is defined as with the x value.
         */
        VerticalLine = 2,
        /**
         * The series has uniform intervals between x-values. It is defined by the start x-value, the grain and the array of y-values.
         */
        Uniform = 3,
    }
    /**
     * Specifies the scope of metrics rules.
     */
    enum MetricRuleScope {
        /**
         * The default scope if other rules are not specified.
         */
        Default = 0,
        /**
         * A single data point is in the scope.
         */
        Point = 2,
        /**
         * Multiple data points from the same series are in the scope.
         */
        MultiplePointsSingleSeries = 3,
        /**
         * Multiple data points from multiple series are in the scope.
         */
        MultiplePointsMultipleSeries = 4,
    }
    /**
     * Specifies the aggregation scope of a metric rule.
     */
    enum MetricRuleAggregationScope {
        /**
         * All selected series should be aggregated into a common metric.
         */
        AllTogether = 0,
        /**
         * All selected series should be aggregated separate metrics.
         */
        AllSeparately = 1,
        /**
         * A metric should be aggregated over a single series.
         */
        SingleSeries = 2,
    }
    /**
     * Specifies the aggregation type of a metric rule.
     */
    enum MetricRuleAggregationType {
        /**
         * An x-value of the point selected.
         */
        CurrentXValue = 0,
        /**
         * An y-value of the point selected.
         */
        CurrentYValue = 1,
        /**
         * Min of y-value of points selected.
         */
        MinY = 2,
        /**
         * Max of y-value of points selected.
         */
        MaxY = 3,
        /**
         * Average of y-value of points selected.
         */
        AverageY = 4,
        /**
         * Sum of y-value of points selected.
         */
        SumY = 5,
        /**
         * Count of points selected.
         */
        Count = 6,
        /**
         * Custom value.
         */
        CustomValue = 7,
    }
    /**
     * Defines the event data associated with chart event notifications.
     */
    interface EventData<TX, TY> {
        /**
         * Name of the series.
         */
        seriesName: string;
        /**
         * The value of the current target element.
         */
        value: ChartItem<TX, TY>;
    }
    /**
     * This interface specifies data label properties.
     */
    interface DataLabelContract<TX, TY> {
        /**
         * Defines the data label context.
         */
        context: KnockoutObservable<DataLabelContext>;
        /**
         * Defines the data label style.
         */
        style: KnockoutObservable<DataLabelStyle>;
        /**
         * Defines the data label formatter. {0} for series name, {1} for the x-value, {2} for the y-value. X and y values are formatted (date / number) the same way as the corresponding axis tick labels are.
         */
        formatter: KnockoutObservable<string>;
    }
    /**
     * This interface specifies data label properties.
     */
    class DataLabel<TX, TY> implements DataLabelContract<TX, TY> {
        /**
         * Defines the data label context.
         */
        context: KnockoutObservable<DataLabelContext>;
        /**
         * Defines the data label style.
         */
        style: KnockoutObservable<DataLabelStyle>;
        /**
         * Defines the data label formatter. {0} for series name, {1} for the x-value, {2} for the y-value. X and y values are formatted (date / number) the same way as the corresponding axis tick labels are.
         */
        formatter: KnockoutObservable<string>;
    }
    /**
     * This class specifies custom data label properties.
     */
    interface CustomDataLabelContract<TX, TY> extends DataLabelContract<TX, TY> {
        /**
         * Defines the chart items for the data label.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
    }
    /**
     * This class specifies custom data label properties.
     */
    class CustomDataLabel<TX, TY> extends DataLabel<TX, TY> implements CustomDataLabelContract<TX, TY> {
        /**
         * Defines the chart items for the data label.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Defines the data label context.
         */
        context: KnockoutObservable<DataLabelContext>;
    }
    /**
     * This interface specifies the chart axis properties.
     */
    interface AxisOptions<T> {
        /**
         * Defines the type of the axis label.
         */
        scale?: Chart.Scale | KnockoutObservable<Chart.Scale>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        reverseDomain?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        ticks?: number | KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        showAxis?: boolean | KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to auto scale Unit
         */
        autoScaleUnit?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the padding size for axis labels.
         */
        labelPadding?: number | KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        showTickMarks?: boolean | KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        showGridLines?: boolean | KnockoutObservable<boolean>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * Note: outputFormat will be deprecated as we move towards using standard APIs for globalization.
         */
        outputFormat?: string | KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        formatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[];
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        xSliderFormatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[];
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        displayLabelFormatter?: string | KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        min?: T | KnockoutObservableBase<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        max?: T | KnockoutObservableBase<T>;
        /**
         * Specify the unit of the axis.
         */
        unit?: UnitConversion.Unit | KnockoutObservable<UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        displaySIUnit?: boolean | KnockoutObservable<boolean>;
        /**
         * The default padding of the axis.
         */
        defaultAxisPadding?: number;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        customAxisPadding?: number;
    }
    /**
     * This interface specifies the chart axis properties.
     */
    interface AxisContract<T> {
        /**
         * Name of the axis.
         */
        name: KnockoutObservable<string>;
        /**
         * Defines the type of the axis label.
         */
        scale: KnockoutObservable<Scale>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        reverseDomain?: KnockoutObservableBase<boolean>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        ticks: KnockoutObservable<number>;
        /**
         * Defines the position for the axis.
         */
        position: KnockoutObservable<AxisPosition>;
        /**
         * Defines the position index for the placement of the axis when multiple axes should be displayed on the same side.
         * A value of 0 will be placed inner most close to the chart area and value of 1 will be placed further away from
         * the chart area based on the axis label padding.
         */
        positionIndex: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        showAxis: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to auto scale Unit
         */
        autoScaleUnit: KnockoutObservableBase<boolean>;
        /**
         * Show the axis name.
         */
        showName: KnockoutObservable<boolean>;
        /**
         * Defines the position at which to show the axis labels.
         */
        showLabel: KnockoutObservable<AxisLabelPosition>;
        /**
         * Defines the padding size for axis labels.
         */
        labelPadding: KnockoutObservable<number>;
        /**
         * Defines the rotation angle. By default the labels will be shown horizontally.
         * Typical rotation angle used is from 0 (horizontal) to -90 (vertically down).
         */
        rotateLabel: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the line for the axis.
         */
        showAxisLine: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        showTickMarks: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        showGridLines: KnockoutObservable<boolean>;
        /**
         * Defines the format to parse the string typed data.
         * The string value can either be a date or a number representation and the specified format will be used to parse the string value to the respective date or number type.
         */
        inputFormat: KnockoutObservable<string>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * Note: outputFormat will be deprecated as we move towards using standard APIs for globalization.
         */
        outputFormat: KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * The formatter will use xSliderOutputFormat.date if data is instanceof Date.  It use the basic mechanism as Multi-Time Axis formatting as in
         * http://bl.ocks.org/mbostock/4149176 except for consistency. Please use the DataUtil format.
         * If it is a type of value, it will use the first element of the array.
         */
        xSliderOutputFormat: KnockoutObservable<string[]>;
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        xSliderFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        displayLabelFormatter: KnockoutObservableBase<string>;
        /**
         * Specify the axis xSlider label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be tranformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        xSliderCalloutDisplayFormatter: KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        min: KnockoutObservableBase<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        max: KnockoutObservableBase<T>;
        /**
         * Specify the unit of the axis.
         */
        unit: KnockoutObservable<UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        displaySIUnit?: KnockoutObservable<boolean>;
        /**
         * The default padding of the axis.
         */
        defaultAxisPadding: KnockoutObservable<number>;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        customAxisPadding: KnockoutObservable<number>;
    }
    /**
     * This class specifies the chart axis properties.
     */
    class Axis<T> implements AxisContract<T> {
        /**
         * Name of the axis.
         */
        name: KnockoutObservable<string>;
        /**
         * Defines the type of the axis label.
         */
        scale: KnockoutObservable<Scale>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        reverseDomain: KnockoutObservable<boolean>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        ticks: KnockoutObservable<number>;
        /**
         * Defines the position for the axis.
         */
        position: KnockoutObservable<AxisPosition>;
        /**
         * Defines the position index for the placement of the axis when multiple axes should be displayed on the same side.
         * A value of 0 will be placed inner most close to the chart area and value of 1 will be placed further away from
         * the chart area based on the axis label padding.
         */
        positionIndex: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        showAxis: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        autoScaleUnit: KnockoutObservableBase<boolean>;
        /**
         * Show the axis name.
         */
        showName: KnockoutObservable<boolean>;
        /**
         * Defines the position at which to show the axis labels.
         */
        showLabel: KnockoutObservable<AxisLabelPosition>;
        /**
         * Defines the padding size for axis labels.
         * Temporary changed to 50px to fit 1000.0A/BC"
         */
        labelPadding: KnockoutObservable<number>;
        /**
         * Defines the rotation angle. By default the labels will be shown horizontally.
         * Typical rotation angle used is from 0 (horizontal) to -90 (vertically down).
         */
        rotateLabel: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the line for the axis.
         */
        showAxisLine: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        showTickMarks: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        showGridLines: KnockoutObservable<boolean>;
        /**
         * Defines the format to parse the string typed data.
         * The string value can either be a date or a number representation and the specified format will be used to parse the string value to the respective date or number type.
         */
        inputFormat: KnockoutObservable<string>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * Note: outputFormat will be deprecated as we move towards using standard APIs for globalization.
         */
        outputFormat: KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * The formatter will use xSliderOutputFormat.date if data is instanceof Date.  It use the basic mechanism as Multi-Time Axis formatting as in
         * http://bl.ocks.org/mbostock/4149176 except for consistency. Please use the DataUtil format.
         * If it is a type of value, it will use the first element of the array.
         */
        xSliderOutputFormat: KnockoutObservable<string[]>;
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        xSliderFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        displayLabelFormatter: KnockoutObservable<string>;
        /**
         * Specify the axis xSlider label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be tranformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        xSliderCalloutDisplayFormatter: KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        min: KnockoutObservable<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        max: KnockoutObservable<T>;
        /**
         * Specify the unit of the axis.
         */
        unit: KnockoutObservable<UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        displaySIUnit: KnockoutObservable<boolean>;
        /**
         * The default padding of the axis.
         */
        defaultAxisPadding: KnockoutObservable<number>;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        customAxisPadding: KnockoutObservable<number>;
        constructor(position?: AxisPosition, scale?: Scale);
    }
    /**
     * Defines a contract for spans such as time spans or number spans. It is used to provide a uniform subtraction operation for numbers and for dates used in uniform series.
     */
    interface SpanContract<T> {
    }
    /**
     * Defines the date span used for subtraction date/time intervals from dates.
     */
    class DateSpan implements SpanContract<Date> {
        /**
         * The number of years in the span.
         */
        years: number;
        /**
         * The number of months in the span.
         */
        months: number;
        /**
         * The number of days in the span.
         */
        days: number;
        /**
         * The number of hours in the span.
         */
        hours: number;
        /**
         * The number of minutes in the span.
         */
        minutes: number;
        /**
         * The number of seconds in the span.
         */
        seconds: number;
        /**
         * The number of milliseconds in the span.
         */
        milliseconds: number;
        /**
         * Creates a new instance of the DateSpan.
         *
         * @param years The number of years in the span.
         * @param months The number of months in the span.
         * @param days The number of dates in the span.
         * @param hours The number of hours in the span.
         * @param minutes The number of minutes in the span.
         * @param seconds The number of seconds in the span.
         * @param milliseconds The number of milliseconds in the span.
         */
        constructor(years: number, months: number, days?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number);
    }
    /**
     * Defines the date span used for subtraction numbers from numbers. Need to provide a uniform interface of setting spans at uniform series.
     */
    class NumberSpan implements SpanContract<number> {
        /**
         * The span value.
         */
        value: number;
        /**
         * Creates a new instance of the NumberSpan.
         *
         * @param value The span value.
         */
        constructor(value: number);
    }
    /**
     * This base class defines the chart input data for a single series and its associated axis.
     */
    interface SeriesBaseContract {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The name of the series.
         */
        name: KnockoutObservable<string>;
    }
    /**
     * This base class defines the chart input data for a single series and its associated axis.
     */
    class SeriesBase implements SeriesBaseContract {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The name of the series.
         */
        name: KnockoutObservable<string>;
    }
    /**
     * This interface defines the chart input data for a single series and its associated axis.
     */
    interface SeriesContract<TX, TY> extends SeriesBaseContract {
        /**
         * The data source for the chart.
         */
        values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a single series and its associated axis.
     */
    class Series<TX, TY> extends SeriesBase implements SeriesContract<TX, TY> {
        /**
         * The data source for the chart.
         */
        values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a single uniform series and its associated axis.
     */
    interface UniformSeriesContract<TX, TY> extends SeriesBase {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The start (smallest) x-value of the series.
         */
        startXValue: KnockoutObservable<TX>;
        /**
         * The span between two x neighbor x values. It is a number if TX is number and a number of milliseconds is TX is DateTime.
         */
        span: KnockoutObservable<SpanContract<TX>>;
        /**
         * The array of y-values.
         */
        yValues: KnockoutObservableArray<TY>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a single uniform series and its associated axis.
     */
    class UniformSeries<TX, TY> extends SeriesBase implements UniformSeriesContract<TX, TY> {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The start (smallest) x-value of the series.
         */
        startXValue: KnockoutObservable<TX>;
        /**
         * The span between two x neighbor x values. It is a number if TX is number and a number of milliseconds is TX is DateTime.
         */
        span: KnockoutObservable<SpanContract<TX>>;
        /**
         * The array of y-values.
         */
        yValues: KnockoutObservableArray<TY>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This interface defines the chart input data for a line series and its associated axis.
     */
    interface LineSeriesContract<T> extends SeriesBase {
        /**
         * The data source for the line.
         */
        value: KnockoutObservable<T>;
        /**
         * Name of axis associated with the data series' value.
         */
        axisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a line series and its associated axis.
     */
    class LineSeries<T> extends SeriesBase implements LineSeriesContract<T> {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The data source for the line.
         */
        value: KnockoutObservable<T>;
        /**
         * Name of axis associated with the data series' value.
         */
        axisName: KnockoutObservable<string>;
    }
    /**
    * Specifies a chart item selection within a metric.
    */
    interface MetricRuleContract {
        /**
         * Specifies the scope of the rule.
         */
        scope: MetricRuleScope | KnockoutObservable<MetricRuleScope>;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        scopeSeriesName: string | KnockoutObservable<string>;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        metrics: MetricRuleMetricContract[] | KnockoutObservableArray<MetricRuleMetricContract>;
    }
    /**
     * Specifies a chart item selection within a metric.
     */
    interface MetricRuleOptions {
        /**
         * Specifies the scope of the rule.
         */
        scope?: MetricRuleScope | KnockoutObservable<MetricRuleScope>;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        scopeSeriesName?: string | KnockoutObservable<string>;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        metrics?: MetricRuleMetricContract[] | KnockoutObservableArray<MetricRuleMetricContract>;
    }
    interface MetricRuleMetricContract {
        /**
         * Specifies the aggregation scope of the rule.
         */
        aggregationScope: MetricRuleAggregationScope | KnockoutObservable<MetricRuleAggregationScope>;
        /**
         * Specifies the aggregation of the rule.
         */
        aggregationType: MetricRuleAggregationType | KnockoutObservable<MetricRuleAggregationType>;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        aggregationSeriesName: string | KnockoutObservable<string>;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        showBarColor: boolean | KnockoutObservable<boolean>;
        /**
         * Specifies the color code of the rule. If nothing is specified, tries to get the color code from the current aggregation series.
         */
        colorCode: string | KnockoutObservable<string>;
        /**
         * Specifies the hatching pattern of the rule. If nothing is specified, tries to get the hatching pattern from the current aggregation series.
         */
        hatchingPattern: AreaHatchingPattern | KnockoutObservable<AreaHatchingPattern>;
        /**
         * Specifies the output formatter of the rule.
         * Note: This option will be deprecated. Please use the globalized date time format.
         */
        outputFormat: string | KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values, if DateFormatOptions is not specified, the charts default multi-formatter for the date's resolution will be used.
         * For number values, if NumberFormatOptions is not specified, a default format option with a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions>;
        /**
         * Specifies the metric title of the rule.
         */
        title: string | KnockoutObservable<string>;
        /**
         * Specifies the metric unit of the rule.
         */
        unit: string | KnockoutObservable<string>;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        customValue: string | KnockoutObservable<string>;
        /**
         * The default info balloon of the metric rule.
         */
        defaultInfoBalloon?: DockedBalloon.ViewModel | KnockoutObservable<DockedBalloon.ViewModel>;
    }
    interface MetricRuleMetricOptions {
        /**
         * Specifies the aggregation scope of the rule.
         */
        aggregationScope?: MetricRuleAggregationScope | KnockoutObservable<MetricRuleAggregationScope>;
        /**
         * Specifies the aggregation of the rule.
         */
        aggregationType?: MetricRuleAggregationType | KnockoutObservable<MetricRuleAggregationType>;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        aggregationSeriesName?: string | KnockoutObservable<string>;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        showBarColor?: boolean | KnockoutObservable<boolean>;
        /**
         * Specifies the color code of the rule. If nothing is specified, tries to get the color code from the current aggregation series.
         */
        colorCode?: string | KnockoutObservable<string>;
        /**
         * Specifies the hatching pattern of the rule. If nothing is specified, tries to get the hatching pattern from the current aggregation series.
         */
        hatchingPattern?: AreaHatchingPattern | KnockoutObservable<AreaHatchingPattern>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values, if DateFormatOptions is not specified, the charts default multi-formatter for the date's resolution will be used.
         * For number values, if NumberFormatOptions is not specified, a default format option with a min fraction 0 and max fraction 2 is used.
         */
        formatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions>;
        /**
         * Specifies the metric title of the rule.
         */
        title?: string | KnockoutObservable<string>;
        /**
         * Specifies the metric unit of the rule.
         */
        unit?: string | KnockoutObservable<string>;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        customValue?: string | KnockoutObservable<string>;
        /**
         * The default info balloon of the metric rule.
         */
        defaultInfoBalloon?: DockedBalloon.ViewModel | KnockoutObservable<DockedBalloon.ViewModel>;
    }
    /**
     * Specifies a chart item selection within a metric.
     * Note: "any" in the union type is added as a workaround to avoid compiletime ton of compile time breaks due to union between standard type and observable (function).
     * Retaining the actual union types matching the signature of the contract/options.
    */
    class MetricRule implements MetricRuleContract {
        /**
         * Specifies the scope of the rule.
         */
        scope: any | MetricRuleScope | KnockoutObservable<MetricRuleScope>;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        scopeSeriesName: any | string | KnockoutObservable<string>;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        metrics: any | MetricRuleMetricContract[] | KnockoutObservableArray<MetricRuleMetricContract>;
        /**
         * Creates an instance of metric rule.
         *
         * @param options Specify the properties on MetricRule that extension author will be using to set / get / update.
         *                If the view model property needs to be observably updated then initialize with observable.
         *                If the view model property needs to be statically set one time, use non observable.
         *                If the view model property is not touched and default behavior is fine, don't initialize the property. That will avoid sending it across iframe boundary.
         */
        constructor(options?: MetricRuleOptions);
        private _initOptions(options);
        private _initLegacyDefaults();
    }
    /**
     * ViewModel for metric rule.
     * Note: "any" in the union type is added as a workaround to avoid ton of compile time breaks due to union between standard type and observable (function).
     * Retaining the actual union types matching the signature of the contract/options.
     */
    class MetricRuleMetric implements MetricRuleMetricContract {
        /**
         * Specifies the aggregation scope of the rule.
         */
        aggregationScope: any | MetricRuleAggregationScope | KnockoutObservable<MetricRuleAggregationScope>;
        /**
         * Specifies the aggregation of the rule.
         */
        aggregationType: any | MetricRuleAggregationType | KnockoutObservable<MetricRuleAggregationType>;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        aggregationSeriesName: any | string | KnockoutObservable<string>;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        showBarColor: any | boolean | KnockoutObservable<boolean>;
        /**
         * Specifies the color code of the rule. If nothing is specified, tries to get the color code from the current aggregation series.
         */
        colorCode: any | string | KnockoutObservable<string>;
        /**
         * Specifies the hatching pattern of the rule. If nothing is specified, tries to get the hatching pattern from the current aggregation series.
         */
        hatchingPattern: any | AreaHatchingPattern | KnockoutObservable<AreaHatchingPattern>;
        /**
         * Specifies the output formatter of the rule.
         * Note: This option will be deprecated. Please use the globalized date time format.
         */
        outputFormat: any | string | KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values, if DateFormatOptions is not specified, the charts default multi-formatter for the date's resolution will be used.
         * For number values, if NumberFormatOptions is not specified, a default format option with a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: any | MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions>;
        /**
         * Specifies the metric title of the rule.
         */
        title: any | string | KnockoutObservable<string>;
        /**
         * Specifies the metric unit of the rule.
         */
        unit: any | string | KnockoutObservable<string>;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        customValue: any | string | KnockoutObservable<string>;
        /**
         * The default info balloon of the metric rule.
         */
        defaultInfoBalloon: any | DockedBalloon.ViewModel | KnockoutObservable<DockedBalloon.ViewModel>;
        /**
         * Creates an instance of metric rule metrics.
         *
         * @param options Specify the properties on MetricRuleMetric that extension author will be using to set / get / update.
         *                If this needs to be observably updated then initialize with observable.
         *                If a view model property needs to be statically set one time, use non observable.
         *                if the view model property is not touched and default behavior is fine, don't initialize the property. That will avoid sending it across iframe boundary.
         */
        constructor(options?: MetricRuleMetricOptions);
        private _initOptions(options);
        private _initLegacyDefaults();
    }
    /**
     * Identifies a series.
     */
    interface SeriesIdContract {
        /**
         * Specifies the view index.
         */
        chartViewIndex: KnockoutObservable<number>;
        /**
         * Specifies the series view index.
         */
        seriesViewIndex: KnockoutObservable<number>;
    }
    /**
     * Identifies a series.
    */
    class SeriesId implements SeriesIdContract {
        /**
         * Specifies the view index.
         */
        chartViewIndex: KnockoutObservable<number>;
        /**
         * Specifies the series view index.
         */
        seriesViewIndex: KnockoutObservable<number>;
    }
    /**
     * Specifies a chart item selection within a series.
     */
    interface SeriesSubsetContract<TX, TY> extends SeriesId {
        /**
         * Specifies an array of chart items selected.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
    }
    /**
     * Specifies a chart item selection within a series.
     */
    class SeriesSubset<TX, TY> extends SeriesId implements SeriesSubsetContract<TX, TY> {
        /**
         * Specifies an array of chart items selected.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
    }
    /**
     * Chart Event call back.
     *
     * @param x The number of x coordinate
     * @param y The number of y coordinate.
     */
    interface ChartEventCallBack {
        (x?: number, y?: number): void;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Line and bar chart can provide additional events by extending the base events.
     * Users should provide a handler for each of the event notification hooks defined here.
     */
    interface EventsContract<TX, TY> {
        /**
         * MouseEnter on the plot area.
         */
        plotAreaMouseEnter: ChartEventCallBack;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaMouseLeave: ChartEventCallBack;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaClick: ChartEventCallBack;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Line and bar chart can provide additional events by extending the base events.
     * Users should provide a handler for each of the event notification hooks defined here.
     */
    class Events<TX, TY> implements EventsContract<TX, TY> {
        /**
         * MouseEnter on the plot area.
         */
        plotAreaMouseEnter: ChartEventCallBack;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaMouseLeave: ChartEventCallBack;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaClick: ChartEventCallBack;
    }
    /**
     * Defines the event notification supported by line / area / scatter plot charts.
     * Users should provide a handler for each of the event notification hooks defined here.
     */
    interface SeriesChartEventsContract<TX, TY> {
        /**
         * Click on a point.
         */
        pointClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a point.
         */
        pointMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a point.
         */
        pointMouseLeave: (data: EventData<TX, TY>) => any;
        /**
         * Click on a series.
         */
        seriesClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a series.
         */
        seriesMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a series.
         */
        seriesMouseLeave: (data: EventData<TX, TY>) => any;
    }
    /**
     * Defines the event notification supported by line / area / scatter plot charts.
     * Users should provide a handler for each of the event notification hooks defined here.
     */
    class SeriesChartEvents<TX, TY> implements SeriesChartEventsContract<TX, TY> {
        /**
          * Click on a point.
          */
        pointClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a point.
         */
        pointMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a point.
         */
        pointMouseLeave: (data: EventData<TX, TY>) => any;
        /**
         * Click on a series.
         */
        seriesClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a series.
         */
        seriesMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a series.
         */
        seriesMouseLeave: (data: MsPortalFx.ViewModels.Controls.Visualization.Chart.EventData<TX, TY>) => any;
    }
    /**
     * Defines the event notification supported by bar chart.
     * Users should provide a handler for each of the event notification hooks defined here.
     */
    interface BarChartEventsContract<TX, TY> {
        /**
         * Click on a bar.
         */
        barClick: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseEnter on a bar.
         */
        barMouseEnter: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseLeave on a bar.
         */
        barMouseLeave: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
    }
    /**
     * Defines the event notification supported by bar chart.
     * Users should provide a handler for each of the event notification hooks defined here.
     */
    class BarChartEvents<TX, TY> implements BarChartEventsContract<TX, TY> {
        /**
         * Click on a bar.
         */
        barClick: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseEnter on a bar.
         */
        barMouseEnter: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseLeave on a bar.
         */
        barMouseLeave: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
    }
    /**
     * Specifies the condition used on rendering a series view.
     */
    interface RenderingConditionContract {
        /**
         * The name of the series to be compared with.
         */
        seriesName: KnockoutObservable<string>;
        /**
         * The condition operator.
         */
        conditionOperator: KnockoutObservable<ConditionOperator>;
        /**
         * The interpolation for the series.
         */
        interpolation: KnockoutObservable<Interpolation>;
    }
    /**
     * Specifies the condition used on rendering a series view.
     */
    class RenderingCondition implements RenderingConditionContract {
        /**
         * The name of the series to be compared with.
         */
        seriesName: KnockoutObservable<string>;
        /**
         * The condition operator.
         */
        conditionOperator: KnockoutObservable<ConditionOperator>;
        /**
         * The interpolation for the series.
         */
        interpolation: KnockoutObservable<Interpolation>;
    }
    /**
     * This base interface defines the how a series should be rendered on the chart.
     */
    interface SeriesViewContract<TX, TY> {
        /**
         * The name of the series.
         */
        seriesName: KnockoutObservableBase<string>;
        /**
         * The display name of the series.
         */
        displayName: KnockoutObservable<string>;
        /**
         * The name of the "CSS" class for the series.
         */
        cssClass: KnockoutObservable<string>;
        /**
         * Data labels for the series.
         */
        dataLabels: KnockoutObservableArray<DataLabelContract<TX, TY>>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
        /**
         * Specify the display formatter to show the value in the tooltip.
         * Formatter by default will add the x, y value and the associated series name. Eg, "Series: '{0}' Point: {1} Value: {2}".
         * The default formatter is borrowed from Microsoft Excel and seems to be valuable.
         * {0} will be populated with the series name.
         * {1} will be populated with the x value.
         * {2} will be populated the y value.
         */
        tooltipFormatter: KnockoutObservable<string>;
        /**
         * Specifies an array of rendering conditions to be checked for rendering the view.
         */
        renderingConditions: KnockoutObservableArray<RenderingConditionContract>;
        /**
         * Indicates if the series is selectable.
         */
        selectable: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is hidden from the legend.
         */
        hideFromLegend: KnockoutObservable<boolean>;
    }
    /**
     * This base class defines the how a series should be rendered on the chart.
     */
    class SeriesView<TX, TY> implements SeriesViewContract<TX, TY> {
        /**
         * The name of the series.
         */
        seriesName: KnockoutObservable<string>;
        /**
         * The display name of the series.
         */
        displayName: KnockoutObservable<string>;
        /**
         * The name of the "CSS" class for the series.
         */
        cssClass: KnockoutObservable<string>;
        /**
         * Data labels for the series.
         */
        dataLabels: KnockoutObservableArray<DataLabel<TX, TY>>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
        /**
         * Specify the display formatter to show the value in the tooltip.
         * Formatter by default will add the x, y value and the associated series name. Eg, "Series: '{0}' Point: {1} Value: {2}".
         * The default formatter is borrowed from Microsoft Excel and seems to be valuable.
         * {0} will be populated with the series name.
         * {1} will be populated with the x value.
         * {2} will be populated the y value.
         */
        tooltipFormatter: KnockoutObservable<string>;
        /**
         * Specifies an array of rendering conditions to be checked for rendering the view.
         */
        renderingConditions: KnockoutObservableArray<RenderingCondition>;
        /**
         * Indicates if the series is selectable.
         */
        selectable: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is hoverable.
         */
        hoverable: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is hidden from the legend
         */
        hideFromLegend: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is autoGenerated
         */
        autoGenerated: boolean;
    }
    /**
     * This interface defines the how a line chart series should be rendered on the chart.
     */
    interface LineChartSeriesViewContract<TX, TY> {
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the line type for the series in the current view.
         */
        lineStyle: KnockoutObservable<LineStyle>;
        /**
         * Optionally show a circle for the data point.
         */
        showDataPoints: KnockoutObservable<boolean>;
    }
    /**
     * This class defines the how a line chart series should be rendered on the chart.
     */
    class LineChartSeriesView<TX, TY> extends SeriesView<TX, TY> implements LineChartSeriesViewContract<TX, TY> {
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the line type for the series in the current view.
         */
        lineStyle: KnockoutObservable<LineStyle>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
        /**
         * Optionally show a circle for the data point.
         */
        showDataPoints: KnockoutObservable<boolean>;
    }
    /**
      * This base interface defines the how an area chart series should be rendered on the chart.
      */
    interface AreaChartSeriesViewContract<TX, TY> extends SeriesViewContract<TX, TY> {
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the hatching pattern type for the series in the current view.
         */
        areaHatchingPattern: KnockoutObservable<AreaHatchingPattern>;
    }
    /**
      * This base class defines the how an area chart series should be rendered on the chart.
      */
    class AreaChartSeriesView<TX, TY> extends SeriesView<TX, TY> implements AreaChartSeriesViewContract<TX, TY> {
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the hatching pattern type for the series in the current view.
         */
        areaHatchingPattern: KnockoutObservable<AreaHatchingPattern>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
    }
    /**
     * This base class defines the how a stacked area chart series should be rendered on the chart.
     */
    class StackedAreaChartSeriesView<TX, TY> extends AreaChartSeriesView<TX, TY> {
    }
    /**
     * This base interface defines the how a scatter chart series should be rendered on the chart.
     */
    interface ScatterChartSeriesViewContract<TX, TY> extends SeriesViewContract<TX, TY> {
        /**
         * Defines the radius of circles.
         */
        radius: KnockoutObservable<number>;
    }
    /**
     * This base class defines the how a scatter chart series should be rendered on the chart.
     */
    class ScatterChartSeriesView<TX, TY> extends SeriesView<TX, TY> implements ScatterChartSeriesViewContract<TX, TY> {
        /**
         * Defines the radius of circles.
         */
        radius: KnockoutObservable<number>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
    }
    /**
     * This interface defines the how a chart view should be rendered on the chart.
     */
    interface ViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<SeriesView<TX, TY>>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): SeriesView<TX, TY>;
    }
    /**
     * This class defines the how a chart view should be rendered on the chart.
     */
    class View<TX, TY> implements ViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<SeriesView<TX, TY>>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): SeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a line chart view should be rendered on the chart.
     */
    interface LineChartViewContract<TX, TY> extends ViewContract<TX, TY> {
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<LineChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEventsContract<TX, TY>;
    }
    /**
     * This class defines the how a line chart view should be rendered on the chart.
     */
    class LineChartView<TX, TY> extends View<TX, TY> implements LineChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<LineChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): LineChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how an area chart view should be rendered on the chart.
     */
    interface AreaChartViewContract<TX, TY> extends ViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<AreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEventsContract<TX, TY>;
    }
    /**
     * This interface defines the how an area chart view should be rendered on the chart.
     */
    class AreaChartView<TX, TY> extends View<TX, TY> implements AreaChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<AreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): AreaChartSeriesView<TX, TY>;
    }
    interface StackedChartViewContract<TX, TY> extends View<TX, TY> {
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
    }
    class StackedChartView<TX, TY> implements StackedChartViewContract<TX, TY> {
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<SeriesView<TX, TY>>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): SeriesView<TX, TY>;
    }
    interface StackedAreaChartViewContract<TX, TY> extends StackedChartViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<StackedAreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Whether to show StackedLine charts for the StackedArea charts.
         */
        lineState: KnockoutObservableBase<LineState>;
    }
    class StackedAreaChartView<TX, TY> implements StackedAreaChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<StackedAreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Whether to show stacked lines for the stacked areas.
         */
        lineState: KnockoutObservable<LineState>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): StackedAreaChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a scatter chart view should be rendered on the chart.
     */
    interface ScatterChartViewContract<TX, TY> extends ViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<ScatterChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEventsContract<TX, TY>;
    }
    /**
     * This class defines the how a scatter chart view should be rendered on the chart.
     */
    class ScatterChartView<TX, TY> extends View<TX, TY> implements ScatterChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<ScatterChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): ScatterChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a bar chart view should be rendered on the chart.
     */
    interface BarChartViewContract<TX, TY> extends StackedChartViewContract<TX, TY> {
        /**
         * A padding ratio which is relative to bar size. The ratio will be used as padding between two bars.
         */
        barPaddingRatio: KnockoutObservable<number>;
        /**
         * Defines the type of bar chart that needs to be rendered.
        */
        barChartType: KnockoutObservable<BarChartType>;
        /**
         * The span for the x-axis.
         */
        xAxisSpan: KnockoutObservable<SpanContract<TX>>;
        /**
         * Specify the event handlers for this view.
         */
        events: BarChartEventsContract<TX, TY>;
    }
    /**
     * This class defines the how a bar chart view should be rendered on the chart.
     */
    class BarChartView<TX, TY> extends View<TX, TY> implements BarChartViewContract<TX, TY> {
        /**
         * A padding ratio which is relative to bar size. The ratio will be used as padding between two bars.
         */
        barPaddingRatio: KnockoutObservable<number>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
        /**
         * Defines the type of bar chart that needs to be rendered.
        */
        barChartType: KnockoutObservable<BarChartType>;
        /**
         * The span for the x-axis.
         */
        xAxisSpan: KnockoutObservable<SpanContract<TX>>;
        /**
         * Specify the event handlers for this view.
         */
        events: BarChartEvents<TX, TY>;
        constructor(barChartType: BarChartType);
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): SeriesView<TX, TY>;
    }
    /**
     * This interface defines a single data point for the chart.
     */
    interface ChartItemContract<TX, TY> {
        /**
         * The X value for an item.
         */
        xValue: TX;
        /**
         * The Y values for an item for all series.
         */
        yValue: TY;
    }
    /**
     * This class defines a single data point for the chart.
     */
    class ChartItem<TX, TY> implements ChartItemContract<TX, TY> {
        /**
         * The X value for an item.
         */
        xValue: TX;
        /**
         * The Y values for an item for all series.
         */
        yValue: TY;
        constructor(xValue: TX, yValue: TY);
    }
    /**
     * This class defines the input data for the chart, axes and its properties.
     */
    interface Contract<TX, TY> extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * The title of the chart.
         */
        title: KnockoutObservable<string>;
        /**
         * Optionally show the title of the chart.
         * The property is temporary ignored.
         */
        showTitle: KnockoutObservable<boolean>;
        /**
         * The width of the chart. If width is 0 then the chart will pick up container's width.
         */
        width: KnockoutObservable<number>;
        /**
         * The height of the chart. If height is 0 then the chart will pick up container's height.
         */
        height: KnockoutObservable<number>;
        /**
         * The message to display when there is no chart data.
         */
        noDataMessage: string;
        /**
         * Provide an array of data series.
         */
        series: KnockoutObservableArray<SeriesBaseContract>;
        /**
         * The X-axis of the chart. This will be the primary X-axis for the chart.
         */
        xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart. This will be the primary Y-axis for the chart.
         */
        yAxis: Axis<TY>;
        /**
         * An array of secondary X-axis that can be optionally disabled.
         */
        secondaryXAxes: KnockoutObservableArray<AxisContract<TX>>;
        /**
         * An array of secondary Y-axis that can be optionally disabled.
         */
        secondaryYAxes: KnockoutObservableArray<AxisContract<TY>>;
        /**
         * An array of views that should be rendered on the chart.
         */
        views: KnockoutObservableArray<ViewContract<TX, TY>>;
        /**
         * The position where the legend should be placed. None option will not display the legend.
         */
        legendPosition: KnockoutObservable<LegendPosition>;
        /**
         * the interaction behavior
         */
        interactionBehavior: KnockoutObservable<InteractionBehavior>;
        /**
         * A value indicating whether or not to auto generate SeriesViews when there is no SeriesViews provided
         */
        autogenerateSeriesViews: KnockoutObservableBase<boolean>;
        /**
         * Events supported by the control.
         */
        events: EventsContract<TX, TY>;
        /**
         * Metrics used by the control.
         */
        metrics: MsPortalFx.ViewModels.Controls.Visualization.Metrics.Contract;
        /**
         * Specifies selections on the chart.
         */
        seriesSelections: KnockoutObservableArray<SeriesSubsetContract<TX, TY>>;
        /**
         * Specifies all the items related to hover on the chart.
         */
        seriesHovers: KnockoutObservableArray<SeriesSubsetContract<TX, TY>>;
        /**
         * Specifies the items being hovered on the chart.
         */
        hoveredID: KnockoutObservableArray<SeriesIdContract>;
        /**
         * Metric rules used by the control
         */
        metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Enable Track XSlider coordination.
         */
        enableTrackXSlider: KnockoutObservableBase<boolean>;
        /**
         * If enableTrackXSlider() is true, the xSliderCoordinate is reported in this variable.
         */
        xSliderCoordinate: KnockoutObservableBase<number>;
        /**
         * If xSlider is enabled, Distance from the nearest datapoint in your chart that will trigger the hover animation as a ratio (xSliderFilterHover) of the width of the chart.
         * For example, .05 means that the distance between the selected chartData can't be bigger than 0.05 * width of the chart.
         * This number can't be bigger than .5 or less than 0.  It will fall back to default behavior.
         */
        xSliderFilterHoverThreshold: KnockoutObservableBase<number>;
        /**
         * Tells the chart to display the 'No data message'.
         */
        noData: KnockoutObservableBase<boolean>;
    }
    /**
     * This class defines the input data for the chart, axes and its properties.
     */
    class ViewModel<TX, TY> extends Loadable.ViewModel implements Contract<TX, TY> {
        /**
         * The title of the chart.
         */
        title: KnockoutObservable<string>;
        /**
         * Optionally show the title of the chart.
         * The property is temporary ignored.
         */
        showTitle: KnockoutObservable<boolean>;
        /**
         * The width of the chart.
         */
        width: KnockoutObservable<number>;
        /**
         * The height of the chart.
         */
        height: KnockoutObservable<number>;
        /**
         * The message to display when there is no chart data.
         */
        noDataMessage: string;
        /**
         * Provide an array of data series.
         */
        series: KnockoutObservableArray<SeriesBase>;
        /**
         * The X-axis of the chart. This will be the primary X-axis for the chart.
         */
        xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart. This will be the primary Y-axis for the chart.
         */
        yAxis: Axis<TY>;
        /**
         * An array of secondary X-axis that can be optionally disabled.
         */
        secondaryXAxes: KnockoutObservableArray<Axis<TX>>;
        /**
         * An array of secondary Y-axis that can be optionally disabled.
         */
        secondaryYAxes: KnockoutObservableArray<Axis<TY>>;
        /**
         * An array of views that should be rendered on the chart.
         */
        views: KnockoutObservableArray<View<TX, TY>>;
        /**
         * The position where the legend should be placed. None option will not display the legend.
         */
        legendPosition: KnockoutObservable<LegendPosition>;
        /**
         * the interaction behavior
         */
        interactionBehavior: KnockoutObservable<InteractionBehavior>;
        /**
         * A value indicating whether or not to auto generate SeriesViews when there is no SeriesViews provided
         */
        autogenerateSeriesViews: KnockoutObservableBase<boolean>;
        /**
         * Events supported by the control.
         */
        events: Events<TX, TY>;
        /**
         * Metrics used by the control
         */
        metrics: MsPortalFx.ViewModels.Controls.Visualization.Metrics.ViewModel;
        /**
         * Specifies selections on the chart.
         */
        seriesSelections: KnockoutObservableArray<SeriesSubset<TX, TY>>;
        /**
         * Specifies all the items related to hover on the chart.
         */
        seriesHovers: KnockoutObservableArray<SeriesSubset<TX, TY>>;
        /**
         * Specifies the item being hovered on the chart.
         */
        hoveredID: KnockoutObservableArray<SeriesId>;
        /**
         * Metric rules used by the control.
         */
        metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Enable Track XSlider coordination.
         */
        enableTrackXSlider: KnockoutObservableBase<boolean>;
        /**
         * If enableTrackXSlider() is true, the xSliderCoordinate is reported in this variable.
         */
        xSliderCoordinate: KnockoutObservableBase<number>;
        /**
         * If xSlider is enabled, Distance from the nearest datapoint in your chart that will trigger the hover animation as a ratio (xSliderFilterHover) of the width of the chart.
         * For example, .05 means that the distance between the selected chartData can't be bigger than 0.05 * width of the chart.
         * This number can't be bigger than .5 or less than 0.  It will fall back to default behavior.
         */
        xSliderFilterHoverThreshold: KnockoutObservableBase<number>;
        static defaultYAxisLabelPadding: number;
        static getDefaultSeriesViewCreator<TX, TY>(chartType: ChartType): (dataSeries: SeriesBaseContract, view: View<TX, TY>) => SeriesView<TX, TY>;
        /**
         * Tells the chart to display the 'No data message'.
         */
        noData: KnockoutObservableBase<boolean>;
        /**
         * Creates a chart.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\CsmTopology.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.CsmTopology {
    /**
     * Overflow node Ids used for selection.
     */
    var RelatedBandOverflowId: string;
    var DependantBandOverflowId: string;
    var InternalBandOverflowId: string;
    var LinkedBandOverflowId: string;
    var SmallSizeOverflowId: string;
    /**
     * Supported sizes for the topology control.
     */
    enum Size {
        /**
         * Small or medium icon size will be used to support 4 x 2 part.
         */
        Small = 0,
        /**
         * Medium or large icon size will be used to support HeroWide part.
         */
        Large = 1,
    }
    /**
     * Resource type enumeration to associate a resource icon for each resource.
     */
    enum ResourceIconType {
        /**
         * Internal type for representing empty placeholder nodes.
         */
        None = 0,
        /**
         * A default resource type which will be represented with default resource icon.
         */
        Default = 1,
        /**
         * Internal type for representing information.
         */
        Info = 2,
        /**
         * Internal type for representing overflow icon.
         */
        Overflow = 3,
        /**
         * Represents a new resource whose icon uri's will be provided by the user.
         */
        Resource = 4,
        /**
         * Represents a resource group.
         */
        ResourceGroup = 5,
        /**
         * Represents website resource.
         */
        Website = 6,
        /**
         * Represents scale group resource.
         */
        ScaleGroup = 7,
        /**
         * Represents sites resource.
         */
        Sites = 8,
        /**
         * Represents database server resource.
         */
        DatabaseServer = 9,
        /**
         * Represents database resource.
         */
        Database = 10,
        /**
         * Represents TFS project resource.
         */
        TFSProject = 11,
        /**
         * Represents TFS account resource.
         */
        TFSAccount = 12,
        /**
         * Represents virtual machine resource.
         */
        VirtualMachine = 13,
        /**
         * Represents nics resource.
         */
        Disks = 14,
        /**
         * Represents nics resource.
         */
        Nics = 15,
        /**
         * Represents IP address resource.
         */
        IPAddress = 16,
        /**
         * Represents availability set resource.
         */
        AvailabilitySet = 17,
        /**
         * Represents AD account resource.
         */
        ADAccount = 18,
    }
    /**
     * Enumeration to specify the logical topology layout band for a resource.
     */
    enum ResourceBand {
        /**
         * Empty placeholder.
         */
        None = 0,
        /**
         * Resource belongs to first topology layout band.
         */
        ResourceGroup = 1,
        /**
         * Resource belongs to second topology layout band.
         */
        Related = 2,
        /**
         * Resource belongs to third topology layout band.
         */
        Dependant = 3,
        /**
         * Resource belongs to fourth topology layout band.
         */
        Internal = 4,
        /**
         * Resource belongs to fifth topology layout band.
         */
        Linked = 5,
    }
    /**
     * Enum to indicate the current resource status.
     */
    enum ResourceStatus {
        /**
         * Resource status is being fetched.
         */
        None = 0,
        /**
         * Resource is available.
         */
        Success = 1,
        /**
         * Resource has encountered a non fatal errors.
         */
        Warning = 2,
        /**
         * Resource has encountered a fatal errors.
         */
        Error = 3,
        /**
         * Resource has additional information about its current status.
         */
        Information = 4,
        /**
         * Resource provider or service is stopped.
         */
        Stopped = 5,
        /**
         * Resource provider or service is canceled.
         */
        Canceled = 6,
        /**
         * Resource provider or service is critical.
         */
        Critical = 7,
        /**
         * Resource provider or service is disabled.
         */
        Disabled = 8,
        /**
         * Resource provider or service is failed.
         */
        Failed = 9,
        /**
         * Resource provider or service is pending.
         */
        Pending = 10,
        /**
         * Resource status is unknown.
         */
        Unknown = 11,
    }
    /**
     * Resource selection item contract.
     * The serialized information about current resource selection should implement this interface.
     */
    interface ResourceSelectionItem {
        /**
         * Id of a contract.
         */
        id?: string;
    }
    /**
     * Resource selection item contract.
     * The serialized information about current resource selection should implement this interface.
     */
    interface ResourceSelectionItemContract {
        /**
         * Id of a contract.
         */
        id?: string;
    }
    /**
     * Resource item contract.
     */
    interface ResourceItem {
        /**
         * Name of the current resource.
         */
        name: KnockoutObservable<string>;
        /**
         * Unique id of the resource.
         */
        id: KnockoutObservable<string>;
        /**
         * Additional information about the resource.
         */
        description: KnockoutObservable<string>;
        /**
         * Specify the resource type.
         */
        type: KnockoutObservable<string>;
    }
    /**
     * Selection option for SelectableSet callbacks.
     */
    interface SelectionOptionContract<TContract extends ResourceSelectionItemContract> {
        /**
         * A function that determines if an item matches a selection.
         *
         * @param item Resource item uniquely identifies a rendered resource.
         * @param selection The selection to match the item to.
         * @return True if the item matches the selection; else false.
         */
        itemMatchesSelection(item: ResourceItem, selection: TContract): boolean;
        /**
         * A factory function that creates a selection based on an item.
         *
         * @param item The resource item for which selection needs to be created.
         * @return The selection for the specified item.
         */
        createSelection(item: ResourceItem): TContract;
        /**
         * Selection state that has been previously saved as part of view state for resource map.
         */
        initialSelection?: MsPortalFx.ViewModels.SetSelection<TContract>;
    }
    /**
     * Right click context menu option.
     */
    interface ContextMenuOption {
        /**
         * The command group.
         */
        commandGroup: string;
        /**
         * The command group owner.
         */
        commandGroupOwner?: string;
    }
    /**
     * Resource hover/click event notification data contract.
     */
    interface EventDataContract {
        /**
         * Name of the current resource.
         */
        name: string;
        /**
         * Unique id of the resource.
         */
        id: string;
        /**
         * Additional information about the resource.
         */
        description: string;
        /**
         * Type of the current resource.
         */
        type: string;
        /**
         * Icon type of the current resource.
         */
        iconType: ResourceIconType;
        /**
         * Number of resources of the given type.
         */
        count: number;
        /**
         * Resource group name of the current resource.
         */
        resourceGroupName: string;
        /**
         * Current resource status.
         */
        status: ResourceStatus;
        /**
         * Additional information about the current status.
         */
        statusMessage: string;
    }
    /**
     * Resource overflow event notification data contract.
     */
    interface ResourceOverflowEventDataContract {
        /**
         * For Resource view, the name of the current resource in focus will be shown.
         */
        name: string;
        /**
         * For Resource view, the id of the current resource in focus will be shown.
         */
        id: string;
        /**
         * Resource group name of the current resource in focus.
         */
        resourceGroupName: string;
        /**
         * For Resource view, the type of the current resource in focus will be shown.
         */
        type: string;
        /**
         * For Resource view, the icon type of the current resource in focus will be shown.
         */
        iconType: ResourceIconType;
        /**
         * Indicates the layout band of overflow resources that needs to be shown.
         */
        resourceBand: ResourceBand;
    }
    /**
     * Widget view model contract.
     */
    interface Contract<TContract extends ResourceSelectionItemContract> extends Loadable.Contract {
        /**
         * Specify the resource group information.
         */
        resourceGroup: KnockoutObservable<ResourceGroup>;
        /**
         * Specify whether resource group view or resource view should be displayed.
         */
        showResourceView: KnockoutObservable<boolean>;
        /**
         * Specify the primary resource in focus.
         */
        resourceInFocus: KnockoutObservable<string>;
        /**
         * Specify SelectableSet to associate resource selection and its associated blades.
         */
        selection: MsPortalFx.ViewModels.SelectableSet<ResourceItem, TContract>;
        /**
         * Internal representation of the resource items for SelectableSet.
         * The items array is populated by merging all resources in each resource band and / or overflow nodes.
         */
        items: KnockoutObservableArray<ResourceItem>;
        /**
         * Optional context menu option specifing the command group to show on right click context menu.
         */
        contextMenuOption?: ContextMenuOption;
        /**
         * Specify the size of the topology control. The size property will determine the icon size for the resources.
         */
        size: KnockoutObservable<Size>;
        /**
         * Specify the width of the topology chart.
         */
        width: KnockoutObservable<number>;
        /**
         * Specify the height of the topology chart.
         */
        height: KnockoutObservable<number>;
        /**
         * Specify the event handlers for the topology chart.
         */
        events: Events;
    }
    /**
     * Abstraction for CSM Resource.
     */
    class Resource implements ResourceItem {
        /**
         * Name of the current resource.
         */
        name: KnockoutObservable<string>;
        /**
         * Unique id of the resource.
         */
        id: KnockoutObservable<string>;
        /**
         * Additional information about the resource.
         */
        description: KnockoutObservable<string>;
        /**
         * Optionally specify an external uri. If a value is provided the description will be treated as a link.
         */
        descriptionUri: KnockoutObservable<string>;
        /**
         * Specify the resource type.
         */
        type: KnockoutObservable<string>;
        /**
         * Type of the current resource.
         */
        iconType: KnockoutObservable<ResourceIconType>;
        /**
         * Number of resources of the given type.
         */
        count: KnockoutObservable<number>;
        /**
         * Resource group name of the current resource.
         */
        resourceGroupName: KnockoutObservable<string>;
        /**
         * Current resource status.
         */
        status: KnockoutObservable<ResourceStatus>;
        /**
         * Additional information about the current status.
         */
        statusMessage: KnockoutObservable<string>;
        /**
         * Related resources belonging to the same resource group and same resource provider.
         */
        relatedResources: KnockoutObservableArray<Resource>;
        /**
         * Nested resources for the current resource.
         */
        dependantResources: KnockoutObservableArray<Resource>;
        /**
         * Sibling resources belonging to the same resource group, internally referenced by current resource and marked as primary resource.
         */
        internalResources: KnockoutObservableArray<Resource>;
        /**
         * Linked resources belonging to the different resource group.
         */
        linkedResources: KnockoutObservableArray<Resource>;
        /**
         * Icon for the resource.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
    }
    /**
     * Specify the properties of a resource group node and its dependant resources.
     */
    class ResourceGroup {
        /**
         * Name of the resource group.
         */
        name: KnockoutObservable<string>;
        /**
         * Unique id of the resource group.
         */
        id: KnockoutObservable<string>;
        /**
         * Optionally specify the type for resource group. The type information is hint for the control to associate a resource group icon and not a CSM type.
         */
        iconType: KnockoutObservable<ResourceIconType>;
        /**
         * Optionally override the default icon for the resource group.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * Nested resources marked as primary resource.
         */
        resources: KnockoutObservableArray<Resource>;
        /**
         * External linked resources which are part of a different resource group and marked as primary resource.
         */
        linkedResources: KnockoutObservableArray<Resource>;
    }
    /**
     * Defines the event notification supported by topology chart.
     * Users should provide a handler for each of the event notification hooks defined here.
     */
    class Events {
        /**
         * Event handler is invoked on click event on the resource icon.
         */
        resourceClick: (eventData: EventDataContract) => void;
        /**
         * Event handler is invoked on mouseenter event on the resource icon.
         */
        resourceMouseEnter: (eventData: EventDataContract) => void;
        /**
         * Event handler is invoked on mouseleave event on the resource icon.
         */
        resourceMouseLeave: (eventData: EventDataContract) => void;
        /**
         * Event handler is invoked on click event on the overflow resource icon.
         */
        resourceOverflowClick: (eventData: ResourceOverflowEventDataContract) => void;
        /**
         * Event handler is invoked when control background plot area is clicked.
         */
        plotAreaClick: () => void;
    }
    /**
     * Resource hover/click event notification data.
     */
    class EventData implements EventDataContract {
        /**
         * Name of the current resource.
         */
        name: string;
        /**
         * Unique id of the resource.
         */
        id: string;
        /**
         * Additional information about the resource.
         */
        description: string;
        /**
         * Type of the current resource.
         */
        type: string;
        /**
         * Type of the current resource.
         */
        iconType: ResourceIconType;
        /**
         * Number of resources of the given type.
         */
        count: number;
        /**
         * Resource group name of the current resource.
         */
        resourceGroupName: string;
        /**
         * Current resource status.
         */
        status: ResourceStatus;
        /**
         * Additional information about the current status.
         */
        statusMessage: string;
    }
    /**
     * Resource overflow event notification data.
     * For Resource view, the information about current resource in focus will be shown.
     * For ResourceGroup view, the information about ResourceGroup will be shown.
     */
    class ResourceOverflowEventData implements ResourceOverflowEventDataContract {
        /**
         * For Resource view, the name of the current resource in focus will be shown.
         */
        name: string;
        /**
         * For Resource view, the id of the current resource in focus will be shown.
         */
        id: string;
        /**
         * Resource group name of the current resource in focus.
         */
        resourceGroupName: string;
        /**
         * For Resource view, the type of the current resource in focus will be shown.
         */
        type: string;
        /**
         * For Resource view, the icon type of the current resource in focus will be shown.
         */
        iconType: ResourceIconType;
        /**
         * Indicates the layout band of overflow resources that needs to be shown.
         */
        resourceBand: ResourceBand;
    }
    /**
     * View model properties for the topology control.
     */
    class ViewModel<TContract extends ResourceSelectionItemContract> extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract<TContract> {
        /**
         * Specify the resource group information.
         */
        resourceGroup: KnockoutObservable<ResourceGroup>;
        /**
         * Specify whether resource group view or resource view should be displayed.
         */
        showResourceView: KnockoutObservable<boolean>;
        /**
         * Specify the primary resource in focus.
         */
        resourceInFocus: KnockoutObservable<string>;
        /**
         * SelectableSet to associate resource selection and its associated blades.
         */
        selection: MsPortalFx.ViewModels.SelectableSet<ResourceItem, TContract>;
        /**
         * Internal representation of the resource items for SelectableSet.
         * The items array is populated by merging all resources in each resource band and / or overflow nodes.
         */
        items: KnockoutObservableArray<ResourceItem>;
        /**
         * Optional context menu option specifing the command group to show on right click context menu.
         */
        contextMenuOption: ContextMenuOption;
        /**
         * Specify the size of the topology control. The size property will determine the icon size for the resources.
         */
        size: KnockoutObservable<Size>;
        /**
         * Specify the width of the topology chart.
         */
        width: KnockoutObservable<number>;
        /**
         * Specify the height of the topology chart.
         */
        height: KnockoutObservable<number>;
        /**
         * Specify the event handlers for the topology chart.
         */
        events: Events;
        /**
         * Creates a csm topology view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, selectionOption?: SelectionOptionContract<TContract>);
        /**
         * See interface.
         */
        dispose(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\Donut.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Donut {
    enum GaugeSize {
        /**
         * Default Automatically adjust size base on current Div size.
         * Currently, it is determind by Min(width, hight).
         * If less than 100px, display QuotaGaugeSize.CenterOnly.
         * else if less than 254px, display QuotaGaugeSize.Small.
         * else display QuotaGaugeSize.Large.
         */
        Auto = 0,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlySmall = 1,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyMedium = 2,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyLarge = 3,
        /**
         * Small 100px square size of donut shape gauge with center.
         */
        Small = 4,
        /**
         * Medium 146px square size of donut shape gauge with center.
         */
        Medium = 5,
        /**
         * MediumLarge 220px square size of donut shape gauge with center.
         */
        MediumLarge = 6,
        /**
         * Small 254px square size of donut shape gauge with center.
         */
        Large = 7,
    }
    /**
    * Item represents a row.
    */
    interface ItemData {
    }
    /**
    * GroupInfo is the ViewModel for a particular <optGroup>
    */
    interface GroupInfo extends MsPortalFx.ViewModels.Controls.Forms.GroupDropDown.GroupInfo {
    }
    /**
     * ItemSetting is the fields setting to inform the ViewModel given setting how to build up dropdown items.
     */
    interface ItemSetting extends MsPortalFx.ViewModels.Controls.Forms.GroupDropDown.ItemSetting {
        /**
         * Data key used to identify the color.  This is optional, if not provided, it will use default color wheel.
         */
        colorKey?: string;
        /**
         * Data key used to identify the row.  Data have to be string, we use it on the object map to quickly identify item's element.
         */
        rowIdKey?: string;
        /**
         * Data key used to label the row for display purpose.  Data have to be string, we use to show center caption for quick indication of the item.
         */
        labelKey?: string;
        /**
         * RowId of current hovered slice in donut.
         */
        hoveredIndex?: KnockoutObservable<string>;
    }
    interface Contract extends Loadable.Contract {
        /**
         * Gauge Size for display. See enum QuotaGaugeSize.
         */
        gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * Group definitions. See interface.
         */
        groupInfos?: KnockoutObservableArray<GroupInfo>;
        /**
         * Items displayed in the table based on the column definitions when selection is disabled.
         */
        itemsDataArray: KnockoutObservableArray<ItemData>;
        /**
         * ItemSetting is the fields setting to inform the ViewModel given setting how to build up dropdown items.
         */
        itemSetting?: KnockoutObservableBase<ItemSetting>;
        /**
         * Indicate value/selection is initialized.
         * If false, it will initialize the value from Items.selected states.
         * If true,  it will honor value and make sure the Items.selected states match current value.
         */
        valueInitialized?: boolean;
        /**
         * Indicates whether the widget should regenerate the Items from itemsDataArray & itemSetting.
         * This property is deprecated. Please invoke render() method to re-render the donut.
         */
        resetItems: Obsolete;
        /**
         * total value. The total value of all value.
         */
        total: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * Display Text in the center.
         * By default the format string is "{0}".
         * {0}: current value.
         * {1}: maximum value.
         */
        totalFormat: KnockoutObservableBase<string>;
        /**
         * Display Unit in the center. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * By default the format string is "".
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center will not be auto scaled and the raw total value and specified unit string will be displayed.
         */
        unitFormat: KnockoutObservableBase<string | UnitConversion.Unit>;
        /**
         * Specify the globalized number precision format options for the center and hovered value.
         * By default we will have 1 floating point precision due to space contraints in the center of the Donut.
         */
        numberFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions>;
        /**
         * Display info in the center. (Caption)
         * This is used when there is no selected nor hover on the donut.
         */
        infoFormat: KnockoutObservableBase<string>;
        /**
         * Display info in the center during the hover. (Caption)
         * This is used when hover on the text.
         * {0}: current label ("" if not available).
         * {1}: current value (or percentage).
         * {2}: current unit (or %).
         */
        hoverInfoFormat: KnockoutObservableBase<string>;
        /**
         * Display info in the center when there is a selected and no hover. (Caption)
         * {0}: current selected total.
         * {1}: current total().
         * {2}: current unitFormat().
         */
        selectedInfoFormat: KnockoutObservableBase<string>;
        /**
         * Display Unit for Hovered/Selected. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * If it is "%" or undefined, by default it shows percentange.
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value and caption value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center and hovered values will not be auto scaled and the raw item value and specified unit string will be displayed.
         */
        hoveredUnit: KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * Disable selected change on click.
         */
        disableSelectOnClick: KnockoutObservableBase<boolean>;
        /**
         * Show center content.
         */
        showCenter: KnockoutObservableBase<boolean>;
        _msPortalFxRerenderTrigger: KnockoutObservableBase<number>;
        render: () => void;
        /**
         * Tells the donut to display the 'No data message'.
         */
        noData: KnockoutObservableBase<boolean>;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Gauge Size for display. See enum QuotaGaugeSize.
         */
        gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * See Contract interface.
         */
        groupInfos: KnockoutObservableArray<GroupInfo>;
        /**
         * See Contract interface.
         */
        itemsDataArray: KnockoutObservableArray<ItemData>;
        /**
         * See Contract interface.
         */
        itemSetting: KnockoutObservableBase<ItemSetting>;
        /**
         * Indicates whether the widget should regenerate the dropdown Items from itemsDataArray & itemSetting.
         * This property is deprecated. Please invoke render() method to re-render the donut.
         */
        resetItems: Obsolete;
        /**
         * See Contract interface.
         */
        valueInitialized: boolean;
        /**
         * Total value. The total value of all donut.
         */
        total: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * Display Text in the center.
         * By default the format string is "{0}".
         * {0}: current value.
         * {1}: maximum value.
         */
        totalFormat: KnockoutObservableBase<string>;
        /**
         * Display Unit in the center. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * By default the format string is "".
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center will not be auto scaled and the raw total value and specified unit string will be displayed.
         */
        unitFormat: KnockoutObservableBase<string | UnitConversion.Unit>;
        /**
         * Display info in the center. (Caption)
         * This is used when there is no selected nor hover on the donut.
         */
        infoFormat: KnockoutObservableBase<string>;
        /**
         * Specify the globalized number precision format options for the center and hovered value.
         * By default we will have 1 floating point precision due to space contraints in the center of the Donut.
         */
        numberFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions>;
        /**
         * Display info in the center during the hover. (Caption)
         * This is used when hover on the text.
         * {0}: current label ("" if not available).
         * {1}: current value (or percentage).
         * {2}: current unit (or %).
         */
        hoverInfoFormat: KnockoutObservableBase<string>;
        /**
         * Display info in the center when there is a selected and no hover. (Caption)
         * {0}: current selected total.
         * {1}: current total().
         * {2}: current unitFormat().
         */
        selectedInfoFormat: KnockoutObservableBase<string>;
        /**
         * Display Unit for Hovered/Selected. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * If it is "%" or undefined, by default it shows percentange.
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value and caption value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center and hovered values will not be auto scaled and the raw item value and specified unit string will be displayed.
         */
        hoveredUnit: KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * Disable selected change on click.
         */
        disableSelectOnClick: KnockoutObservableBase<boolean>;
        /**
         * Show center content.
         */
        showCenter: KnockoutObservableBase<boolean>;
        /**
         * Tells the donut to display the 'No data message'.
         */
        noData: KnockoutObservableBase<boolean>;
        _msPortalFxRerenderTrigger: KnockoutObservableBase<number>;
        /**
         * Creates a donut.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
        render(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\Gauge.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Gauge {
    class Threshold {
        /**
         * The limit of this threshold.
         */
        limit: KnockoutObservableBase<number>;
        /**
         * The custom CssClass for this threshold.
         */
        cssClass: KnockoutObservableBase<string>;
        constructor(limit: number);
    }
    interface Contract extends MsPortalFx.ViewModels.Controls.SingleSetting.Contract {
        /**
         * The value of the footer setting.
         */
        footerValue: KnockoutObservable<string>;
        /**
         * The unit of the footer setting.
         */
        footerUnit: KnockoutObservable<string>;
        /**
         * The caption of the footer setting.
         */
        footerCaption: KnockoutObservable<string>;
        /**
         * The value of the gauge (from 0 to gaugeMaxValue).
         */
        gaugeValue: KnockoutObservable<number>;
        /**
         * The max value of the setting.
         */
        gaugeMaxValue: KnockoutObservable<number>;
        /**
         * The Arc in degree of the gauge that is present.
         */
        gaugePresentationArc: KnockoutObservable<number>;
        gaugeThresholds: KnockoutObservableArray<Threshold>;
    }
    class ViewModel extends MsPortalFx.ViewModels.Controls.SingleSetting.ViewModel implements Contract {
        /**
         * The value of the center setting.
         */
        value: KnockoutObservable<string>;
        /**
         * The unit of the center setting.
         */
        unit: KnockoutObservable<string>;
        /**
         * The caption of the center setting.
         */
        caption: KnockoutObservable<string>;
        /**
         * The value of the footer setting.
         */
        footerValue: KnockoutObservable<string>;
        /**
         * The unit of the footer setting.
         */
        footerUnit: KnockoutObservable<string>;
        /**
         * The caption of the footer setting.
         */
        footerCaption: KnockoutObservable<string>;
        /**
         * The value of the gauge (from 0 to gaugeMaxValue).
         */
        gaugeValue: KnockoutObservable<number>;
        /**
         * The max value of the setting.
         */
        gaugeMaxValue: KnockoutObservable<number>;
        /**
         * The Arc in degree of the gauge that is present.
         */
        gaugePresentationArc: KnockoutObservable<number>;
        /**
         * The Arc in degree of the gauge that is present.
         */
        gaugeThresholds: KnockoutObservableArray<Threshold>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\Graph.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Graph {
    import Internal = MsPortalFx.Base.Internal;
    import ObservableMap = Internal.ObservableMap;
    /**
     * Scroll-bars enabled for the control. Flags enum, literals can be combined.
     */
    enum GraphScrollBars {
        /**
         * No scroll-bars.
         */
        None = 0,
        /**
         * Horizontal scroll-bar.
         */
        Horizontal = 1,
        /**
         * Vertical scroll-bar.
         */
        Vertical = 2,
    }
    /**
     * Modes of scroll-bars appearance.
     */
    enum GraphScrollBarsVisibilityMode {
        /**
         * Scroll-bars are visible all the time when mouse pointer is on the graph canvas.
         */
        AlwaysVisible = 0,
        /**
         * Scroll-bars are hidden all the time.
         */
        AlwaysHidden = 1,
        /**
         * Scroll-bars are only visible when some node(s) are not fully inside the view rectangle.
         */
        AppearWhenNodesOutsideOfTheView = 2,
    }
    /**
     * Skin styles of the graph editor.
     */
    enum GraphEditorSkinStyle {
        /**
         * Canvas and node background colors are consistent with typical blade and parts background colors.
         */
        Blade = 0,
        /**
         * Canvas background color is strictly white or black (depending on main color theme), node background color is a tint of blue.
         */
        Document = 1,
        /**
         * Canvas background color is strictly white or black (depending on main color theme), node background color is a more bright tint of blue, node shape has borders stroke.
         */
        Document2 = 2,
        /**
         * Canvas background color is strictly white or black (depending on main color theme), node background color is grey-ish, node shape has borders stroke.
         */
        Document3 = 3,
    }
    /**
     * Strategies defining how edges connect to nodes and how they follow the nodes' moves.
     */
    enum EdgeConnectionStrategy {
        /**
         * Edge line is a ray originating at the center of the start node and going to the center of the end node.
         */
        NodeCenter = 0,
        /**
         * Edge path is a Bezier curve originating at the output port of the start node and going to the input port of the end node.
         */
        NodePort = 1,
    }
    /**
     * Capabilities of the graph editor. Flags enum, literals can be combined.
     */
    enum GraphEditorCapabilities {
        /**
         * No editor capabilities. Only viewing, panning and zooming-in/-out allowed on the graph.
         */
        None = 0,
        /**
         * Capability to move nodes (connected edges move accordingly).
         */
        MoveEntities = 1,
        /**
         * Capability to update lists of nodes and edges.
         */
        AddRemoveEntities = 2,
    }
    /**
    * Defines how graph entities are rendered.
    */
    enum EntityRenderMode {
        /**
        * When a graph entity is added or removed, all entities are rebuilt and re-rendered on the DOM.
        */
        Rebuild = 0,
        /**
        * When a graph entity is added or removed, existing entities are not re-rendered. Node bindings
        * will be updated for existing nodes, but only the changed (added or removed) entities are
        * modified in the DOM structure of the graph.
        */
        Incremental = 1,
    }
    /**
     * OBSOLETE, DEPRECATED. To be removed in one of the next releases.
     * Used to be a limited enumeration of edge line strength grades.
     * Now strength/thickness is set using a number from the range [1; 6] - where 1 represents the weakest (the thinnest) and 6 - the strongest (the thickest) connection.
     */
    enum EdgeStrength {
        /**
         * Normal strength grade.
         */
        Normal = 1,
        /**
         * Strong connection grade.
         */
        Strong = 2,
    }
    /**
     * Definition of edge line types.
     */
    enum EdgeType {
        /**
         * Single line/curve.
         */
        Single = 1,
        /**
         * 2 parallel lines/curves.
         */
        Double = 2,
    }
    /**
     * Definition of edge line styles.
     */
    enum EdgeStyle {
        /**
         * Solid line/curve.
         */
        Solid = 1,
        /**
         * Dotted line/curve.
         */
        Dotted = 2,
        /**
         * Dashed line/curve.
         */
        Dashed = 3,
    }
    /**
     * Definition of edge markers.
     */
    enum EdgeMarker {
        /**
         * None.
         */
        None = 1,
        /**
         * Arrow.
         */
        Arrow = 2,
        /**
         * Circle.
         */
        Circle = 3,
    }
    /**
     * The Edge end contract.
     */
    interface IEdgeEnd {
        /**
         * The identifier of the edge end.
         */
        id: KnockoutObservable<string>;
    }
    /**
     * Enum for type of graph entity.
     */
    enum GraphEntityType {
        GraphNode = 0,
        GraphEdge = 1,
    }
    /**
     * Represents the selected entity in the selectableSet
     */
    class SelectedGraphEntity implements MsPortalFx.ViewModels.DynamicBladeSelection {
        id: string;
        entityType: GraphEntityType;
        detailBlade: string;
        detailBladeInputs: Object;
        extension: string;
        constructor(id: string, entityType: GraphEntityType, detailBlade: string, detailBladeInputs: Object, extension?: string);
    }
    /**
     * An abstract class that holds common elements for things that go in the graph.
     * Don't instantiate this.
     */
    class GraphEntity {
        /**
         * Whether this entity allows being selected by a user or not.
         */
        selectable: KnockoutObservable<boolean>;
        /**
         * Whether this entity is selected or not.
         */
        selected: KnockoutObservable<boolean>;
        /**
         * The id of this entity. Used for referring to other graph nodes. You may need to
         * overwrite the default one when loading existing graphs.
         */
        id: KnockoutObservable<string>;
        /**
         * Set whether the entity should be dimmed (i.e. reduce the opacity).
         */
        dimmed: KnockoutObservable<boolean>;
        /**
         * CommandGroup to display in the context menu of node.
         */
        commandGroup: KnockoutObservable<string>;
        /**
         * Creates a graph entity.
         *
         * @param id The object's id.
         */
        constructor(id?: string);
    }
    /**
     * A graph edge. Put these in Graph.ViewModel's edge array.
     */
    class GraphEdge extends GraphEntity {
        /**
         * The id of the start node for the edge. Do not change this after adding the edge to the
         * graph. This is set automatically by the constructor, and you should never need to change it.
         */
        startNodeId: KnockoutObservable<string>;
        /**
         * The id of the end node for the edge. Do not change this after adding the edge to the graph.
         * This is set automatically by the constructor, and you should never need to change it.
         */
        endNodeId: KnockoutObservable<string>;
        /**
         * The edge line thickness (in pixels). Limited to values in the range [1; 6].
         */
        strength: KnockoutObservable<number>;
        /**
         * The compound type characteristics of the edge line.
         */
        type: KnockoutObservable<EdgeType>;
        /**
         * The style of the edge line.
         */
        style: KnockoutObservable<EdgeStyle>;
        /**
         * The start marker of the edge.
         */
        startMarker: KnockoutObservable<EdgeMarker>;
        /**
         * The end marker of the edge.
         */
        endMarker: KnockoutObservable<EdgeMarker>;
        /**
         * The padding (in pixels) value used to float the edge ray a bit off the start node bounding rectangle. Only applied when graph EdgeConnectionStrategy is NodeCenter. Default value is 7px.
         */
        startNodePadding: KnockoutObservable<number>;
        /**
         * The padding (in pixels) value used to float the edge ray a bit off the end node bounding rectangle. Only applied when graph EdgeConnectionStrategy is NodeCenter. Default value is 7px.
         */
        endNodePadding: KnockoutObservable<number>;
        /**
         * Create a graph edge.
         *
         * @param startNode The node the edge eminates from.
         * @param endNode the node the edge ends on.
         */
        constructor(startNode: IEdgeEnd, endNode: IEdgeEnd);
    }
    /**
     * An interface for optionally updating a rectangle.
     */
    interface IUpdateRect {
        /**
         * The X coordinate of the node's top-left corner.
         */
        x?: number;
        /**
         * The Y coordinate of the node's top-left corner.
         */
        y?: number;
        /**
         * The height of the node.
         */
        height?: number;
        /**
         * The width of the node.
         */
        width?: number;
    }
    /**
     * A cartesian point interface defintion.
     */
    interface IPoint {
        /**
         * The x coordinate of the point.
         */
        x: number;
        /**
         * The y coordinate of the point.
         */
        y: number;
    }
    /**
     * A rectangle interface definition.
     */
    interface IRect {
        /**
         * The x coordinate of the rectangle.
         */
        x: number;
        /**
         * The y coordinate of the rectangle.
         */
        y: number;
        /**
         * The height of the rectangle.
         */
        height: number;
        /**
         * The width of the rectangle.
         */
        width: number;
    }
    /**
     * A graph node. Put these in Graph.ViewModel's graphNodes array.
     */
    class GraphNode extends GraphEntity implements MsPortalFx.ViewModels.DynamicBladeSelection {
        /**
         * The view model to use for displaying the graph node's content.
         */
        extensionViewModel: any;
        /**
         * A Knockout template describing what the graph node looks like.
         */
        extensionTemplate: string;
        /**
         * The name of the blade to launch when the user activates this node.
         */
        detailBlade: string;
        /**
         * Inputs to the blade to launch when the user activates this node.
         */
        detailBladeInputs: Object;
        /**
         * The extension to which the blade specified in detailBlade belongs.
         */
        extension: string;
        /**
         * Only used for constructor purposes. Shouldn't be touched by the extension.
         * We would make this protected, but it need to be proxied over, so we can't.
         */
        private initialRect;
        constructor(initialRect?: IUpdateRect);
    }
    /**
     * Configuratble options for the setNodeRects function call.
     */
    interface ISetNodeRectOptions {
        /**
         * When true, clears the existing undo/redo stack.
         * Default: false;
         */
        clearUndo?: boolean;
    }
    /**
     * The contract that defines a graph for the pcGraph binding.
     */
    interface Contract extends Loadable.Contract {
        /**
         * The scroll-bars enabled for the graph instance. Make sure to set .scrollBarsVisibilityMode property as needed as well.
         */
        scrollBars: KnockoutObservable<GraphScrollBars>;
        /**
         * The mode of scroll-bars appearance/visibility. Make sure to set .scrollBars property as needed as well.
         */
        scrollBarsVisibilityMode: KnockoutObservable<GraphScrollBarsVisibilityMode>;
        /**
         * The strategy defining how edges connect to nodes and how they follow the nodes' moves.
         */
        edgeConnectionStrategy: KnockoutObservable<EdgeConnectionStrategy>;
        /**
         * The editing capabilities the graph editor exposes.
         */
        editorCapabilities: KnockoutObservable<GraphEditorCapabilities>;
        /**
         * A collection of all the graph nodes in the graph.
         */
        graphNodes: MsPortalFx.Base.Internal.IObservableMap<GraphNode>;
        /**
         * A collection of all the edges in the graph.
         */
        edges: MsPortalFx.Base.Internal.IObservableMap<GraphEdge>;
        /**
         * How many pixels tall and wide each grid cell is. Used in snap to grid.
         */
        gridResolution: KnockoutObservable<number>;
        /**
         * The currently selected nodes and edges.
         */
        selectableSet: MsPortalFx.ViewModels.SelectableSet<SelectedGraphEntity, SelectedGraphEntity>;
        /**
         * When true, the user can multi-select by clicking in the background and dragging. When false, clicking and dragging in the background pans.
         * Default is false.
         */
        rectSelectionMode: KnockoutObservable<boolean>;
        /**
        * The strategy that determines how graph entities are rendered when the list of nodes or edges is updated. Default is
        * EdgeRenderingStrategy.Rebuild, but performance gains may be seen when adding or removing entities by setting this
        * to EntityRenderMode.Incremental.
        */
        entityRenderMode: KnockoutObservable<EntityRenderMode>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom and center the graph in the viewport.
         */
        zoomToFit: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Padding (in pixels) around the graph bounds when zoomToFit is called. Takes effect for zoomToFit() calls made AFTER zoomToFitPadding observable value change. Default value is 100.
         */
        zoomToFitPadding: KnockoutObservable<number>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom in.
         */
        zoomIn: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom out.
         */
        zoomOut: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom to 100%.
         */
        zoomTo100Percent: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Once the widget has loaded, causes the graph widget to select the node and bring it into the view with animation.
         */
        focusOnNode: KnockoutObservable<(id: string) => MsPortalFx.Base.Promise>;
        /**
         * Once the widget has loaded, causes the graph widget to select the edge and bring it into the view with animation.
         */
        focusOnEdge: KnockoutObservable<(id: string) => MsPortalFx.Base.Promise>;
        /**
         * Bring a rectangle into the view with animation.
         */
        bringRectIntoView: KnockoutObservable<(rect: IRect) => MsPortalFx.Base.Promise>;
        /**
         * Adds the specified GraphEdge instance to the list of the view model edges.
         * To be overriden in custom ViewModel implementation to customize the edge that is being created when user drags it from source to destination node.
         *
         * @param edgeToAdd The edge instance to add.
         * @return JQuery promise object that is resolved when the operation completes or fails.
         */
        addEdge(edgeToAdd: IGraphEdgeForAddition): JQueryPromise;
        /**
         * Deletes the specified graph entities (nodes and edges).
         *
         * @param nodesToDelete The array of nodes to delete.
         * @param edgesToDelete The array of edges to delete.
         * @return JQuery promise object that is resolved when the operation completes or fails.
         */
        deleteEntities(nodesToDelete: IGraphNodeForDeletion[], edgesToDelete: IGraphEdgeForDeletion[]): JQueryPromise;
        /**
         * Whether or not the widget has been attached yet.
         */
        widgetAttached: KnockoutObservable<boolean>;
        /**
         * Notifies subscribers when the a layout change has been committed to the graph. The number given has no useful meaning but is used to trigger
         * the notification to the extension.
         */
        layoutChanged: KnockoutObservable<number>;
        /**
         * Returns a new candidate layout without overlaps, given a proposed movement of some nodes.
         * The returned candidade layout is used to preview the change and, if the user commits the change,
         * to update the committed locations of nodes.
         * This should be specified by the extension. If it's set null, no automatic layout will occur.
         *
         * @param changedNodes The nodes with explicitly changed positions.
         * @param rootId The node under the user's cursor (which should not move).
         * @return The nodes with implicitly changed positions.
         */
        getLayoutNoOverlaps: KnockoutObservable<(changedNodes: StringMap<IPoint>, rootId: string) => MsPortalFx.Base.PromiseV<StringMap<IPoint>>>;
        /**
         * Sets the rects for specified graph nodes.
         *
         * All calls to this function will result in animation, so best practice is to initialize nodes with
         * their starting rects (per the optional constructor).
         * This API is used to allow the widget to track animated and comitted state, as well as allow for batch updates.
         *
         * @param rects Map of rects.
         * @param options Configuratble options (ex: undo/redo stack).
         * @return A promise that resolves once the changes have been applied.
         */
        setNodeRects: KnockoutObservable<(rects: StringMap<IUpdateRect>, options?: ISetNodeRectOptions) => MsPortalFx.Base.Promise>;
        /**
         * Returns all rects for every graph node, or a specified list of graph node ids.
         *
         * This can only be called after widgetAttached() is true, otherwise it will throw an exception.
         *
         * @param ids The list of ids from which to return corresponding gaphNodes.
         * @return A promise that resolves with a string map of committed rects.
         */
        getNodeRects: KnockoutObservable<(ids?: string[]) => MsPortalFx.Base.PromiseV<StringMap<IRect>>>;
        /**
         * A flag to disable zoom in/out behavior on mouse wheel events. If not provided, default to false.
         *
         * @return A value indicating whether zoom in/out behavior on mouse wheel events is disabled.
         */
        disableMouseWheelZoom: KnockoutObservable<boolean>;
        /**
         * A flag to enable lineage display for graphs (i.e. dim [reduce opacity] all the nodes except the selected and nodes in
         * its upstream and downstream).
         *
         * @return A boolean indicating if lineage display should be enabled.
         */
        enableLineage: KnockoutObservable<boolean>;
    }
    /**
     * The view model for pcGraph. Contains the representation of a graph.
     */
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * See contract.
         */
        scrollBars: KnockoutObservable<GraphScrollBars>;
        /**
         * See contract.
         */
        scrollBarsVisibilityMode: KnockoutObservable<GraphScrollBarsVisibilityMode>;
        /**
         * See contract.
         */
        edgeConnectionStrategy: KnockoutObservable<EdgeConnectionStrategy>;
        /**
         * See contract.
         */
        editorCapabilities: KnockoutObservable<GraphEditorCapabilities>;
        /**
         * See contract.
         */
        graphNodes: ObservableMap<GraphNode>;
        /**
         * See contract.
         */
        edges: ObservableMap<GraphEdge>;
        /**
         * See contract.
         */
        gridResolution: KnockoutObservable<number>;
        /**
         * See contract.
         */
        selectableSet: MsPortalFx.ViewModels.SelectableSet<SelectedGraphEntity, SelectedGraphEntity>;
        /**
         * See contract.
         */
        widgetAttached: KnockoutObservable<boolean>;
        /**
         * See contract.
         */
        layoutChanged: KnockoutObservable<number>;
        /**
         * See contract.
         */
        getLayoutNoOverlaps: KnockoutObservable<(changedNodes: StringMap<IPoint>, rootId: string) => MsPortalFx.Base.PromiseV<StringMap<IPoint>>>;
        /**
         * See contract.
         */
        setNodeRects: KnockoutObservable<(rects: StringMap<IUpdateRect>, options?: ISetNodeRectOptions) => MsPortalFx.Base.Promise>;
        /**
         * See contract.
         */
        getNodeRects: KnockoutObservable<(ids?: string[]) => MsPortalFx.Base.PromiseV<StringMap<IRect>>>;
        /**
         * See contract.
         */
        rectSelectionMode: KnockoutObservable<boolean>;
        /**
        * See contract.
        */
        entityRenderMode: KnockoutObservable<EntityRenderMode>;
        /**
         * See contract.
         */
        zoomToFit: KnockoutObservable<() => JQueryPromise>;
        /**
         * See contract.
         */
        zoomToFitPadding: KnockoutObservable<number>;
        /**
         * See contract.
         */
        zoomIn: KnockoutObservable<() => JQueryPromise>;
        /**
         * See contract.
         */
        zoomOut: KnockoutObservable<() => JQueryPromise>;
        /**
         * See contract.
         */
        zoomTo100Percent: KnockoutObservable<() => JQueryPromise>;
        /**
         * See contract.
         */
        focusOnNode: KnockoutObservable<(id: string) => MsPortalFx.Base.Promise>;
        /**
         * See contract.
         */
        focusOnEdge: KnockoutObservable<(id: string) => MsPortalFx.Base.Promise>;
        /**
         * See contract.
         */
        bringRectIntoView: KnockoutObservable<(rect: IRect) => MsPortalFx.Base.Promise>;
        /**
         * See contract.
         */
        addEdge: (edgeToAdd: IGraphEdgeForAddition) => JQueryPromise;
        /**
         * See contract.
         */
        deleteEntities: (nodesToDelete: IGraphNodeForDeletion[], edgesToDelete: IGraphEdgeForDeletion[]) => JQueryPromise;
        /**
         * See contract.
         */
        disableMouseWheelZoom: KnockoutObservable<boolean>;
        /**
         * See contract.
         */
        enableLineage: KnockoutObservable<boolean>;
        /**
         * Used by selectable set to determine if a graph node is part of the selected set. Extension authors
         * should never need to call this.
         *
         * @param selectedGraphEntity the SelectedGraphEntity to compare.
         * @param selectionItem the selected item to compare.
         * @return boolean whether the selected item is the graph entity or not.
         */
        static itemMatchesSelection(selectedGraphEntity: SelectedGraphEntity, selectionItem: SelectedGraphEntity): boolean;
        /**
         * Transforms a graph entity into a selection contract. Extension authors should never need to call this.
         *
         * @param graphEntity the graph node to transform.
         * @return the graph node that manages selection state.
         */
        static createSelection(selectedGraphEntity: SelectedGraphEntity): SelectedGraphEntity;
        /**
         * The style skin applied to the graph editor defining canvas and entities styling (mostly colors).
         * Only used for constructor purposes. Shouldn't be touched by the extension.
         * We would make this protected, but it need to be proxied over, so we can't.
         */
        private styleSkin;
        /**
         * Creates a graph view model
         * @param lifetimeManager Lifetime manager object dealing with proper resources disposal.
         * @param styleSkin Style skin for the graph editor. Default to GraphEditorSkinStyle.Blade.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, styleSkin?: GraphEditorSkinStyle);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\GraphEntitiesAddition.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Graph {
    /**
     * The contract definition of Graph edge interface for the purposes of addition logic.
     */
    interface IGraphEdgeForAddition {
        /**
         * The identifier of the node the edge starts from.
         */
        startNodeId: string;
        /**
         * The identifier of the node the edge ends at.
         */
        endNodeId: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\GraphEntitiesDeletion.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Graph {
    /**
     * The contract definition of Graph node interface for the purposes of deletion logic.
     */
    interface IGraphNodeForDeletion {
        /**
         * The identifier of the node.
         */
        id: string;
    }
    /**
     * The contract definition of Graph edge interface for the purposes of deletion logic.
     */
    interface IGraphEdgeForDeletion {
        /**
         * The identifier of the edge.
         */
        id: string;
    }
    /**
     * Utility class encapsulates deletion functionality.
     */
    class GraphEntitiesDeletion {
        /**
         * Performs deletion of the specified nodes and edges from the specified graph model.
         * @param model ViewModel instance to run the deletion on.
         * @param nodesToDelete List of nodes to delete.
         * @param edgesToDelete List of edges to delete.
         */
        static run(model: Graph.ViewModel, nodesToDelete: IGraphNodeForDeletion[], edgesToDelete: IGraphEdgeForDeletion[]): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\Map.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Map {
    /**
     * Extension for Map
     */
    enum Extensions {
        /**
         * Plugin to HexagonLayout UX
         */
        HexagonLayout = 1,
    }
    /**
     * Location for Map Item
     */
    class Location {
        /**
         * Latitude coordinate for the map item.
         */
        latitude: number;
        /**
         * Longitude coordinate for the map item.
         */
        longitude: number;
        /**
         * @param latitude The latitude of the location
         * @param longitude The longitude of the location
         */
        constructor(latitude: number, longitude: number);
    }
    /**
     * The links that represents HexagonLayout link
     */
    interface Link {
        /**
         * Source of the link
         */
        source: Item;
        /**
         * Target of the link
         */
        target: Item;
        /**
         * Type of the link
         */
        linkType: LinkType;
    }
    /**
     * The enum for HexagonLayout Link type
     */
    enum LinkType {
        /**
         * The Link is solid line
         */
        Solid = 0,
        /**
         * Dashed line with animation
         */
        AnimatedDashed = 1,
    }
    /**
     * Map Item contract
     */
    interface ItemContract {
        /**
         * Id for the item.
         */
        id: string;
        /**
         * Location for the item.
         */
        location: Location;
        /**
         * Metadata for the item.
         */
        metadata: ItemMetadataContract;
    }
    /**
     * Map Item contract
     */
    class Item implements ItemContract {
        /**
         * Id for the item.
         */
        id: string;
        /**
         * Location for the item.
         */
        location: Location;
        /**
         * Metadata for the item.
         */
        metadata: ItemMetadataContract;
    }
    /**
     * The enum for HexagonLayout link
     */
    enum ItemType {
        /**
         * The primary in a HexagonLayout link relationship
         */
        Source = 0,
        /**
         * The secondary in a HexagonLayout link relationship
         */
        Target = 1,
        /**
         * The hexagon only has icon displayed.
         */
        IconOnly = 2,
    }
    /**
     * A metadata entry corresponding to a single item in the list.
     */
    interface ItemMetadataContract {
        /**
         * Icon displayed on the hexagon.
         */
        icon?: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * The width of the icon
         */
        iconWidth?: KnockoutObservable<number>;
        /**
         * The height of the icon
         */
        iconHeight?: KnockoutObservable<number>;
    }
    /**
     * A metadata entry corresponding to a single item in the list for HexagonLayout
     */
    interface HexagonLayoutItemMetadataContract extends ItemMetadataContract {
        /**
         * Type in HexagonLayout relationship
         */
        type?: ItemType;
        /**
         * Text to show for the item
         */
        text?: KnockoutObservable<string>;
        /**
         * Indicates whether to fill the polygon
         */
        hasFill?: KnockoutObservable<boolean>;
        /**
         * The icon displayed on the hexagon.
         */
        icon?: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * Scale the item based on hexagon size. 1.0 means the size is the same as hexagon grid.
         */
        itemScale?: KnockoutObservable<number>;
    }
    /**
     * A metadata entry corresponding to a single item in the list.
     */
    class ItemMetadata implements ItemMetadataContract {
        /**
         * The icon displayed on the hexagon.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * The width of the icon
         */
        iconWidth: KnockoutObservable<number>;
        /**
         * The height of the icon
         */
        iconHeight: KnockoutObservable<number>;
    }
    /**
     * A metadata entry corresponding to a single item in the list for HexagonLayout
     */
    class HexagonLayoutItemMetadata extends ItemMetadata implements HexagonLayoutItemMetadataContract {
        /**
         * Type in HexagonLayout link relationship
         */
        type: ItemType;
        /**
         * Text to show for the item
         */
        text: KnockoutObservable<string>;
        /**
         * Indicates whether to fill the polygon
         */
        hasFill: KnockoutObservable<boolean>;
        /**
         * Scale the item based on hexagon size. 1.0 means the size is the same as hexagon grid.
         */
        itemScale: KnockoutObservable<number>;
    }
    /**
     * Defines HexagonLayout Extension options
     */
    interface HexagonLayoutOptions {
        /**
         * Indicates whether to show links on the map.
         */
        showLinks?: KnockoutObservable<boolean>;
        /**
         * Links among the items on the Map control.
         */
        links?: KnockoutObservable<Link[]>;
        /**
         * Number of rows for the hexagon grid
         */
        rows?: KnockoutObservable<number>;
        /**
         * Number of columns for the hexagon grid
         */
        columns?: KnockoutObservable<number>;
    }
    /**
     * Options for Extension
     */
    interface ExtensionOptions {
        /**
         * HexagonLayout options.
         */
        hexagonLayout?: HexagonLayoutOptions;
    }
    /**
     * Event callback for Map items.
     */
    class Events {
        /**
         * Click on an item.
         */
        itemClick: (item: Item) => void;
        /**
         * Mouse enter on an item.
         */
        itemMouseEnter: (item: Item) => void;
        /**
         * Mouse leave on an item.
         */
        itemMouseLeave: (item: Item) => void;
    }
    /**
     * View model contract for the map widget.
     */
    interface Contract extends Loadable.Contract {
        /**
         * Map items to be displayed.
         */
        items: KnockoutObservable<Item[]>;
        /**
         * Events supported by the map control.
         */
        events: Events;
        /**
         * The width of the control.
         */
        width: KnockoutObservable<number>;
        /**
         * The height of the control.
         */
        height: KnockoutObservable<number>;
        extensions?: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions?: ExtensionOptions;
    }
    /**
     * View model for the map widget.
     */
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Map items to be displayed.
         */
        items: KnockoutObservable<Item[]>;
        /**
         * Events supported by the map control.
         */
        events: Events;
        /**
         * The width of the map control
         */
        width: KnockoutObservable<number>;
        /**
         * The height of the map control
         */
        height: KnockoutObservable<number>;
        extensions: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions: ExtensionOptions;
        /**
         * Constructs a Map view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param items map items to be displayed.
         * @param extensions Bitmask of extension plugins to be loaded.
         * @param extensionOptions The extension options for the plugins.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, items?: KnockoutObservable<Item[]>, extensions?: number, extensionOptions?: ExtensionOptions);
        dispose(): void;
        private _getDefaultOptions();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\MapV2.d.ts
/**
* The Public ViewModel.
*/
declare module MsPortalFx.ViewModels.Controls.Visualization.Unsupported.MapV2 {
    /**
     * The types that can be drawn on the map
     */
    enum EntityType {
        /**
         * The Circle Entity
         */
        Circle = 1,
    }
    /**
     * The base class for all entities that can be drawn on the map
     */
    class Entity {
        /**
         * The type of the entity for example Circle
         */
        entityType: EntityType;
        /**
         * @param entityType the entity type of this
         */
        constructor(entityType: EntityType);
    }
    /**
     * Location for MapV2 entities
     */
    interface Location {
        /**
         * Latitude coordinate for the map item.
         */
        latitude: number;
        /**
         * Longitude coordinate for the map item.
         */
        longitude: number;
    }
    /**
     * The options
     */
    interface CircleOptions {
        /**
         * The number of accesses at the geoLocation of circle
         * More accesses has a positive linear correlation to circle radius
         */
        accesses: number;
        /**
         * The center (lat, long) of the circle
         */
        location: Location;
        /**
         * The city of the circle
         */
        city: string;
        /**
         * Specifies the color code of the metric.
         */
        cssColorClass: string;
        /**
         * The country of the circle
         */
        country: string;
    }
    /**
     * A Circle that can be drawn on the map
     * Is a sub class of Entity
     */
    class Circle extends Entity {
        /**
         * The number of accesses at the geoLocation of circle
         * More accesses has a positive linear correlation to circle radius
         */
        accesses: number;
        /**
         * The center (lat, long) of the circle
         */
        location: Location;
        /**
         * Specifies the color code of the metric.
         */
        cssColorClass: string;
        /**
         * The city of the circle
         */
        city: string;
        /**
         * The country of the circle
         */
        country: string;
        /**
         * @param options The CircleOptions used to construct this
         */
        constructor(options: MapV2.CircleOptions);
    }
    /**
     * The Options used to construct a MapV2
     */
    interface Options {
        /**
         * Collection of entities to display
         */
        entities?: KnockoutObservableArray<Entity>;
        /**
         * Boolean for if metrics should be shown
         */
        showMetrics?: KnockoutObservable<boolean>;
    }
    /**
     * The public ViewModel for this
     * Is a sub class of Base.ViewModel
     */
    class ViewModel extends Base.ViewModel {
        /**
         * Collection of entities to display on this
         */
        entities: KnockoutObservableArray<Entity>;
        /**
         * Boolean for if metrics should be shown
         */
        showMetrics: KnockoutObservable<boolean>;
        /**
         * Constructs an MapV2 view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param options Optional The set of options to configure the MapV2 control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: MapV2.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\Metrics.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Metrics {
    /**
     * Size of the metrics.
     */
    enum Size {
        /**
         * Shows small metrics - Font: 20px, Height: 32px, Margin: 14px.
         */
        Small = 0,
        /**
         * Shows medium metrics - Font: 40px, Height: 35px, Margin: 30px.
         */
        Medium = 1,
        /**
         * Shows large metrics - Font: 40px, Height: 45px, Margin: 22px.
         */
        Large = 2,
        /**
         * Shows Xlarge metrics - Font: 40px, Height: 45px, Margin: 25px.
         */
        XLarge = 3,
        /**
         * Shows extra small metrics - Font: 20px, Height: 30px, Margin: 12px.
         */
        ExtraSmall = 4,
    }
    /**
     * Orientation of the metrics.
     */
    enum Orientation {
        /**
         * Metrics will be displayed horizontally.
         */
        Horizontal = 0,
        /**
         * Metrics will be displayed vertically.
         */
        Vertical = 1,
    }
    enum Alignment {
        /**
         * Top edge for vertical alignment.
         */
        Top = 1,
        /**
         * Left edge for horizontal alignment.
         */
        Left = 2,
        /**
         * Right edge for horizontal alignment.
         */
        Right = 4,
        /**
         * Bottom edge for vertical alignment.
         */
        Bottom = 8,
    }
    /**
     * Defines hatching patterns.
     */
    enum HatchingPattern {
        /**
         * The area is solid.
         */
        Solid = 0,
        /**
         * The area is cross hatched.
         */
        CrossHatching = 1,
        /**
         * The area is diagonal hatched.
         */
        DiagonalHatching = 2,
        /**
         * The area is hatched horizontally like a dotted line.
         */
        DottedHatching = 3,
    }
    interface SingleMetricContract extends MsPortalFx.ViewModels.Controls.SingleSetting.Contract {
        /**
         * Color of the vertical bar beside the metric.
         */
        barCssClass: KnockoutObservable<string>;
        /**
         * Show the vertical bar besides the metric.
         */
        showBarColor: KnockoutObservable<boolean>;
        /**
         * Defines the hatching pattern.
         */
        hatchingPattern?: KnockoutObservable<MsPortalFx.ViewModels.Controls.Visualization.Metrics.HatchingPattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        unitAlignment: KnockoutObservableBase<Alignment>;
        /**
         * The hide of the metric.
         */
        hide: KnockoutObservableBase<boolean>;
        /**
        * Indicates if this metric should be prioritized.
        * For example if it represents a series that is currently hovered by the user.
        */
        prioritized: KnockoutObservable<boolean>;
    }
    class SingleMetric extends MsPortalFx.ViewModels.Controls.SingleSetting.ViewModel implements SingleMetricContract {
        /**
         * Color of the vertical bar beside the metric.
         */
        barCssClass: KnockoutObservable<string>;
        /**
         * Show the vertical bar besides the metric.
         */
        showBarColor: KnockoutObservable<boolean>;
        /**
         * Defines the hatching pattern.
         */
        hatchingPattern: KnockoutObservable<HatchingPattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        unitAlignment: KnockoutObservableBase<Alignment>;
        /**
         * Caption alignment. Currently only support Top or Bottom.
         * Defaults to Top.
         */
        captionAlignment: KnockoutObservableBase<Alignment>;
        /**
         * The hide of the metric.
         */
        hide: KnockoutObservableBase<boolean>;
        /**
        * Indicates if this metric should be prioritized.
        * For example if it represents a series that is currently hovered by the user.
        */
        prioritized: KnockoutObservable<boolean>;
    }
    interface VisualContract extends Loadable.Contract {
        /**
         * The orientation of the items in the metrics.
         */
        orientation: KnockoutObservable<Orientation>;
        /**
         * The size of the items in the metrics.
         */
        size: KnockoutObservable<Size>;
        /**
         * The visibility of the metrics.
         */
        visible: KnockoutObservable<boolean>;
    }
    interface Contract extends VisualContract {
        /**
         * Metrics items to display
         */
        items: KnockoutObservableArray<SingleMetric>;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Metrics items to display
         */
        items: KnockoutObservableArray<SingleMetric>;
        /**
         * The orientation of the items in the metrics.
         */
        orientation: KnockoutObservable<Orientation>;
        /**
         * The size of the items in the metrics.
         * This is deprecated. The parent control is responsible for styling the metrics in accordance with the size.
         */
        size: KnockoutObservable<Size>;
        /**
         * The visibility of the metrics.
         */
        visible: KnockoutObservable<boolean>;
        /**
         * Creates a metric view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\PairedTimeline.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.PairedTimeline {
    import Controls = MsPortalFx.ViewModels.Controls;
    import Visualization = Controls.Visualization;
    import Chart = Visualization.Chart;
    import Metrics = Visualization.Metrics;
    import RangeSelection = Visualization.RangeSelection;
    import PairedTimelineBadges = Visualization.PairedTimelineBadges;
    import ListView = Controls.Lists.ListView;
    /**
     * Contract container for the Chart and Metrics controls
     */
    interface PairedTimelineChartContract<TX, TY> extends Loadable.Contract {
        /**
         * Identifier of chart
         */
        id: string;
        /**
         * Chart control contract
         */
        chart: Chart.Contract<TX, TY>;
        /**
         * Chart height in number of units(integer). Each unit is 45 px.
         */
        chartHeight: KnockoutObservableBase<number>;
        /**
         * The message to display when chart is un-configured or there is no chart data.
         */
        noDataMessage: KnockoutObservableBase<string>;
        /**
         * CSS class to be applied to the List View item
         */
        cssClass: KnockoutObservableBase<string>;
        /**
         * Selectable for the buttons in the PT
         */
        buttonSelectables: MsPortalFx.ViewModels.Selectable<string>[];
    }
    /**
     * Container for the Chart and Metrics controls
     */
    class PairedTimelineChart<TX, TY> extends Loadable.ViewModel implements PairedTimelineChartContract<TX, TY> {
        /**
         * Identifier of chart
         */
        id: string;
        /**
         * Chart control
         */
        chart: Chart.ViewModel<TX, TY>;
        /**
         * Chart height in number of units(integer). Each unit is 45 px.
         */
        chartHeight: KnockoutObservableBase<number>;
        /**
         * The message to display when the chart is un-configured or there is no chart data.
         */
        noDataMessage: KnockoutObservableBase<string>;
        /**
         * CSS class to be applied to the List View item
         */
        cssClass: KnockoutObservableBase<string>;
        /**
         * Selectable for the buttons in the PT
         */
        buttonSelectables: MsPortalFx.ViewModels.Selectable<string>[];
        /**
         * Creates a paired timeline.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param id Id of this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, id: string);
        dispose(): void;
    }
    const enum PairedTimelineButtonVisibilityOptions {
        ShowOnHover = 1,
        AlwaysShow = 2,
    }
    interface PairedTimelineButtonOptions {
        /**
         * Whether the Edit buttons should be shown.
         */
        enabled: KnockoutObservable<boolean>;
        /**
         * Text to use for the edit button, default is "Edit"
         */
        text: KnockoutObservable<string>;
        /**
         * Controls the visibility of the buttons. (always vs onhover)
         */
        visibility: KnockoutObservable<PairedTimelineButtonVisibilityOptions>;
    }
    interface Contract<TX, TY> extends Loadable.Contract {
        /**
         * The collection of Paired Timeline charts.
         */
        ptCharts: KnockoutObservableArray<PairedTimeline.PairedTimelineChart<TX, TY>>;
        /**
         * Options used to configure the loaded plugins for selection.
         * Updating this property after the widget is initialized will have no effect.
        * A null or undefined value disables selection.
         */
        extensionOptions: ListView.ExtensionOptions;
        /**
         * Enable metrics rules.
         */
        enableMetricsRules: KnockoutObservableBase<boolean>;
        /**
         * Metrics options
         */
        metricsOptions: Metrics.VisualContract;
        /**
         * Enables sliders to select a range on the x axis.
         */
        enableRangeSelection: KnockoutObservableBase<boolean>;
        /**
         * Range selection view model.
         */
        rangeSelectionViewModel: RangeSelection.ViewModel<TX>;
        /**
         * Options for the buttons defined in the PT.
         */
        buttonOptions: PairedTimelineButtonOptions[];
        /**
         * Badges View model
         */
        badgesViewModel: PairedTimelineBadges.ViewModel<TX>;
    }
    class ViewModel<TX, TY> extends Loadable.ViewModel implements Contract<TX, TY> {
        /**
         * The collection of Paired Timeline charts.
         */
        ptCharts: KnockoutObservableArray<PairedTimeline.PairedTimelineChart<TX, TY>>;
        /**
         * Options used to configure the loaded plugins for selection.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions: ListView.ExtensionOptions;
        /**
         * Enable Metrics Rules
         */
        enableMetricsRules: KnockoutObservableBase<boolean>;
        /**
         * MetricsOptions
         */
        metricsOptions: Metrics.VisualContract;
        /**
         * Enables sliders to select a range on the x axis.
         */
        enableRangeSelection: KnockoutObservableBase<boolean>;
        /**
         * Range selection view model.
         */
        rangeSelectionViewModel: RangeSelection.ViewModel<TX>;
        /**
         * Badges View model
         */
        badgesViewModel: PairedTimelineBadges.ViewModel<TX>;
        /**
         * Options for the buttons defined in the PT.
         */
        buttonOptions: PairedTimelineButtonOptions[];
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, ptCharts: KnockoutObservableArray<PairedTimeline.PairedTimelineChart<TX, TY>>, extensionOptions: ListView.ExtensionOptions, rangeSelectionOptions?: RangeSelection.Options<TX>, pairedTimelineBadgesOptions?: PairedTimelineBadges.Options<TX>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\PairedTimelineBadges.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.PairedTimelineBadges {
    import DockedBalloon = MsPortalFx.ViewModels.Controls.DockedBalloon;
    /**
     * Contract for an individual displayable badge.
     */
    interface BadgeContract<TX> {
        /**
         * Badge Identifier
         */
        id: string;
        /**
         * Unique class name for this badge.
         */
        className: KnockoutObservableBase<string>;
        /**
         * The badge text
         */
        text: string;
        /**
         * The x value corresponding to the event this badge is reporting.
         */
        xValue: TX;
        /**
         * The coordinate where the badge is rendered.
         */
        coordinate?: KnockoutObservableBase<number>;
        /**
         * The icon to display for the badge.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * Whether the badge is displayed.
         */
        visible?: KnockoutObservableBase<boolean>;
    }
    /**
     * Class for an individual Badge.
     */
    class Badge<TX> extends MsPortalFx.ViewModels.Controls.Base.ViewModel implements BadgeContract<TX> {
        /**
         * Badge Identifier
         */
        id: string;
        /**
         * Unique class name for this badge.
         */
        className: KnockoutObservableBase<string>;
        /**
         * The badge text
         */
        text: string;
        /**
         * The x value corresponding to the event this badge is reporting.
         */
        xValue: TX;
        /**
         * The icon to display for the badge.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * Whether the badge is displayed.
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * The coordinate where the badge is rendered.
         */
        coordinate: KnockoutObservableBase<number>;
        /**
         * Creates a paired timeline.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param id Id of this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: BadgeContract<TX>);
    }
    interface Options<TX> {
        /**
         * The collection of badges
         */
        badges: KnockoutObservableArray<BadgeContract<TX>>;
        /**
         * Height of the badges when displayed on the paired timeline
         */
        height: KnockoutObservableBase<number>;
        /**
         * Balloon for displaying badge information.
         */
        balloon: KnockoutObservableBase<DockedBalloon.ViewModel>;
        /**
         * Enables badges that will be displayed at top of paired timeline
         */
        visible: KnockoutObservableBase<boolean>;
    }
    class ViewModel<TX> extends MsPortalFx.ViewModels.Controls.Base.ViewModel {
        /**
         * The collection of badges
         */
        badges: KnockoutObservableArray<BadgeContract<TX>>;
        /**
         * Height of the badges when displayed on the paired timeline
         */
        height: KnockoutObservableBase<number>;
        /**
         * Balloon for displaying badge information.
         */
        balloon: KnockoutObservableBase<DockedBalloon.ViewModel>;
        /**
         * Enables badges that will be displayed at top of paired timeline
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * An optional selectableSet to make the badges selectable
        */
        selectableSet: KnockoutObservableBase<MsPortalFx.ViewModels.SelectableSet<any, any>>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options<TX>);
        /**
         * Set the viewmodel's array of badges to the incoming badges. Optionally set up a selectableSet on these badges with the given callbacks.
         */
        pushAllBadges(newBadges: BadgeContract<TX>[], useSelectableSet?: boolean, itemMatchesSelection?: (item: BadgeContract<TX>, selection: any) => boolean, createSelection?: (item: BadgeContract<TX>) => any): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\ProgressBar.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.ProgressBar {
    enum StatusType {
        /**
         * In progress style.
         */
        InProgress = 0,
        /**
         * Error style.
         */
        Error = 1,
        /**
         * Warning style.
         */
        Warning = 2,
        /**
         * Success style.
         */
        Success = 3,
        /**
         * Indeterminate style.
         */
        Indeterminate = 4,
        /**
         * Vertical indeterminate style.
         */
        IndeterminateVertical = 5,
    }
    interface Contract extends Loadable.Contract {
        /**
         * Value percentage of the current progress.
         */
        valuePercentage: KnockoutObservable<number>;
        /**
         * Status of the progress indicator.
         */
        status: KnockoutObservable<StatusType>;
        /**
         * Control's aria-labelledby setting.
         */
        labelId: string;
        /**
         * Control's aria-describedby setting.
         */
        detailsId: string;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Value percentage of the current progress.
         */
        valuePercentage: KnockoutObservable<number>;
        /**
         * Status of the progress indicator.
         */
        status: KnockoutObservable<StatusType>;
        /**
         * Control's aria-labelledby setting.
         */
        labelId: string;
        /**
         * Control's aria-describedby setting.
         */
        detailsId: string;
        /**
         * Creates a progress bar.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\QuotaGauge.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.QuotaGauge {
    enum ErrorWarningShape {
        /**
         * Default triangle warning/error.
         */
        Triangle = 0,
        /**
         * Circle warning/error.
         */
        Circle = 1,
    }
    enum GaugeSize {
        /**
         * Default Automatically adjust size base on current Div size.
         * Currently, it is determind by Min(width, height).
         * If less than 100px, display QuotaGaugeSize.CenterOnly.
         * else if less than 254px, display QuotaGaugeSize.Small.
         * else display QuotaGaugeSize.Large.
         */
        Auto = 0,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlySmall = 1,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyMedium = 2,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyLarge = 3,
        /**
         * Small 100px square size of donut shape gauge with center.
         */
        Small = 4,
        /**
         * Medium 146px square size of donut shape gauge with center.
         */
        Medium = 5,
        /**
         * MediumLarge 220px square size of donut shape gauge with center.
         */
        MediumLarge = 6,
        /**
         * Small 254px square size of donut shape gauge with center.
         */
        Large = 7,
    }
    interface Contract extends Loadable.Contract {
        /**
         * Toggle the css style for warning/error. True for triangle or false for circle.
         */
        errorWarningShape: KnockoutObservableBase<ErrorWarningShape>;
        /**
         * Gauge Size for display. See enum QuotaGaugeSize.
         */
        gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * The current tracking instance value. For example, CPU/Memory/Website instance.
         */
        instance: KnockoutObservableBase<number>;
        /**
         * The quota for current instance.
         */
        instanceQuota: KnockoutObservableBase<number>;
        /**
         * The total value of all instances. For example, all CPU/Memory/Websites usage.
         */
        total: KnockoutObservableBase<number>;
        /**
         * The quota for total value of all instances.
         */
        totalQuota: KnockoutObservableBase<number>;
        /**
        * Caption.
        *  {0} is instance
        *  {1} is instanceQuota,
        *  {2} is total
        *  {3} is totalQuota
        */
        totalCaption: KnockoutObservableBase<string>;
        /**
         * Show center content.
         */
        showCenter: KnockoutObservableBase<boolean>;
        /**
         * Omit Total bar.
         */
        omitTotal: KnockoutObservableBase<boolean>;
        /**
         * No quota verification.
         */
        noQuota: KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         *  Center text unit.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * Center Text value display format.
         *  {0} is intance value
         *  {1} is instance Quota,
         *  {2} is total
         *  {3} is total Quota
         *  {4} is maximum
         */
        valueDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Hide the current tick mark.
         */
        hideTick: KnockoutObservableBase<boolean>;
    }
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * See interface.
         */
        errorWarningShape: KnockoutObservableBase<ErrorWarningShape>;
        /**
         * See interface.
         */
        gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * See interface.
         */
        instance: KnockoutObservableBase<number>;
        /**
         * See interface.
         */
        instanceQuota: KnockoutObservableBase<number>;
        /**
         * See interface.
         */
        total: KnockoutObservableBase<number>;
        /**
         * See interface.
         */
        totalQuota: KnockoutObservableBase<number>;
        /**
         * See interface.
         */
        totalCaption: KnockoutObservableBase<string>;
        /**
         * Show center content.
         */
        showCenter: KnockoutObservableBase<boolean>;
        /**
         * Omit Total bar.
         */
        omitTotal: KnockoutObservableBase<boolean>;
        /**
         * No quota verification.
         */
        noQuota: KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         *  Center text unit.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * Center Text value display format.
         *  {0} is intance value
         *  {1} is instance Quota,
         *  {2} is total
         *  {3} is total Quota
         *  {4} is maximum
         */
        valueDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Hide the current tick mark.
         */
        hideTick: KnockoutObservableBase<boolean>;
        /**
         * Creates a quota gauge.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\RangeSelection.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.RangeSelection {
    enum LabelPosition {
        /**
         * Range selection labels will be oriented on the inside of the selection range
         */
        Inside = 0,
        /**
         * Range selection labels will be oriented on the outside of the selection range
         */
        Outside = 1,
    }
    interface Range<T> {
        /**
         * The beginning of the range selection.  May be null to indicate open beginning of range.
         */
        start: T;
        /**
         * The end of the range selection.  May be null to indicate open ended range.
         */
        end: T;
    }
    interface Options<T> {
        /**
         * Specifies position of range selection labels.
         */
        labelPosition?: KnockoutObservableBase<LabelPosition>;
        /**
         * The range selected if enableRangeSelection was enabled.
         */
        rangeSelection?: KnockoutObservableBase<Range<T>>;
    }
    class ViewModel<T> extends Base.ViewModel {
        /**
         * Specifies position of range selection labels.
         */
        labelPosition: KnockoutObservableBase<LabelPosition>;
        /**
         * The range selected if enableRangeSelection was enabled.
         */
        rangeSelection: KnockoutObservableBase<Range<T>>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\SimpleChart.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.SimpleChart {
    import Chart = MsPortalFx.ViewModels.Controls.Visualization.Chart;
    /**
     * This base interface defines the how a series should be rendered on the chart.
     */
    interface SeriesViewOptions<TX, TY> {
        /**
         * The display name of the series.
         */
        displayName?: string | KnockoutObservable<string>;
        /**
         * The name of the "CSS" class for the series.
         */
        cssClass?: string | KnockoutObservable<string>;
    }
    /**
     * This interface defines the chart input data for a single series and its associated axis.
     */
    interface SeriesOptions<TX, TY> {
        /**
         * The name of the series.
         */
        name?: string | KnockoutObservable<string>;
        /**
         * The data source for the chart.
         */
        values?: KnockoutObservableArray<Chart.ChartItem<TX, TY>>;
        /**
         * Optional display options for the series.
         */
        viewOptions?: SeriesViewOptions<TX, TY>;
    }
    /**
     * This base class defines the chart input data for a single series and its associated axis.
     */
    class Series<TX, TY> {
        /**
         * The name of the series.
         */
        name: string | KnockoutObservable<string>;
        /**
         * The data source for the chart.
         */
        values: KnockoutObservableArray<Chart.ChartItem<TX, TY>>;
        /**
         * Optional display options for the series.
         */
        viewOptions: SeriesViewOptions<TX, TY>;
        constructor(options?: SeriesOptions<TX, TY>);
        private _getDefaultOptions();
        private _initOptions(options);
    }
    interface SimpleChartOptions<TX, TY> {
        /**
         * Provide an array of data series.
         */
        series?: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart. This will be the primary X-axis for the chart.
         * The properties are opt-in. Provide only the properties that will be consumed by extension.
         */
        xAxis?: Chart.AxisOptions<TX>;
        /**
         * The Y-axis of the chart. This will be the primary Y-axis for the chart.
         * The properties are opt-in. Provide only the properties that will be consumed by extension.
         */
        yAxis?: Chart.AxisOptions<TY>;
        /**
         * Specify the chart type to render. By default line chart will be rendered.
         */
        chartType?: Chart.ChartType | KnockoutObservableBase<Chart.ChartType>;
        /**
         * Metric rules used by the control.
         */
        metricsRules?: KnockoutObservableArray<Chart.MetricRule>;
    }
    /**
     * This class defines the input data for the chart, axes and its properties.
     */
    class ViewModel<TX, TY> extends Loadable.ViewModel {
        /**
         * Provide an array of data series.
         */
        series: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart. This will be the primary X-axis for the chart.
         */
        xAxis: Chart.AxisOptions<TX>;
        /**
         * The Y-axis of the chart. This will be the primary Y-axis for the chart.
         */
        yAxis: Chart.AxisOptions<TY>;
        /**
         * Specify the chart type to render. By default line chart will be rendered.
         */
        chartType: Chart.ChartType | KnockoutObservableBase<Chart.ChartType>;
        /**
         * Metric rules used by the control.
         */
        metricsRules: KnockoutObservableArray<Chart.MetricRule>;
        /**
         * Creates a chart.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: SimpleChartOptions<TX, TY>);
        private _getDefaultOptions();
        private _initOptions(options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\SingleValueGauge.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.SingleValueGauge {
    enum GaugeSize {
        /**
         * Default Automatically adjust size base on current Div size.
         * Currently, it is determind by Min(width, hight).
         * If less than 100px, display QuotaGaugeSize.CenterOnly.
         * else if less than 254px, display QuotaGaugeSize.Small.
         * else display QuotaGaugeSize.Large.
         */
        Auto = 0,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlySmall = 1,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyMedium = 2,
        /**
         * No outer donut gauge. Center only
         */
        CenterOnlyLarge = 3,
        /**
         * Icon 21px square size of donut shape gauge with center.
         */
        Icon = 4,
        /**
         * Tiny 30px square size of donut shape gauge with center.
         */
        Tiny = 5,
        /**
         * Small 100px square size of donut shape gauge with center.
         */
        Small = 6,
        /**
         * Medium 146px square size of donut shape gauge with center.
         */
        Medium = 7,
        /**
         * MediumLarge 220px square size of donut shape gauge with center.
         */
        MediumLarge = 8,
        /**
         * Small 254px square size of donut shape gauge with center.
         */
        Large = 9,
    }
    interface Contract extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * Gauge Size for display. See enum QuotaGaugeSize.
         */
        gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * Hide the current tick mark.
         */
        hideTick: KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * Center text unit.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * Current value.
         */
        current: KnockoutObservableBase<number>;
        /**
         * captionDisplayFormat value.
         *  {0} is current
         */
        captionDisplayFormat: KnockoutObservableBase<string>;
        /**
         * valueDisplayFormat value.
         *  {0} is current
         */
        valueDisplayFormat: KnockoutObservableBase<string>;
    }
    class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract {
        /**
         * Gauge Size for display. See enum QuotaGaugeSize.
         */
        gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * Hide the current tick mark.
         */
        hideTick: KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * Center text unit.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * Current value.
         */
        current: KnockoutObservableBase<number>;
        /**
         * captionDisplayFormat value.
         *  {0} is current
         */
        captionDisplayFormat: KnockoutObservableBase<string>;
        /**
         * valueDisplayFormat value.
         *  {0} is current
         */
        valueDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Creates a single value gauge.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Controls\Visualization\StepGauge.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.StepGauge {
    enum GaugeSize {
        /**
         * Default Automatically adjust size base on current Div size.
         * Currently, it is determind by Min(width, hight).
         * If less than 100px, display QuotaGaugeSize.CenterOnly.
         * else if less than 254px, display QuotaGaugeSize.Small.
         * else display QuotaGaugeSize.Large.
         */
        Auto = 0,
        /**
         * No outer donut gauge.  Center only
         */
        CenterOnlySmall = 1,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyMedium = 2,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyLarge = 3,
        /**
         * Small 100px square size of donut shape gauge with center.
         */
        Small = 4,
        /**
         * Medium 146px square size of donut shape gauge with center.
         */
        Medium = 5,
        /**
         * MediumLarge 220px square size of donut shape gauge with center.
         */
        MediumLarge = 6,
        /**
         * Small 254px square size of donut shape gauge with center.
         */
        Large = 7,
    }
    interface Contract extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * gaugeSize for display. See enum QuotaGaugeSize.
         */
        gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * The number represents step size.
         * Note if this number is too small, widget will throw.
         * To check the minimum step value required, which is depends on maximum, call getRequiredMinimumStep().
         */
        step: KnockoutObservableBase<number>;
        /**
         * The number represents the whole gauge value.
         */
        maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * Current value.
         */
        current: KnockoutObservableBase<number>;
        /**
         * Display Text in the center.
         * By default the format string is "{0}".
         * The first argument({0}) is current, for example, 3.
         * The second argument({1}) is maximum().
         */
        centerDisplayFormat: KnockoutObservableBase<string>;
        /**
         * The first argument({0}) is current, for example, 3.
         * The second argument({1}) is maximum().
         */
        captionDisplayFormat: KnockoutObservableBase<string>;
    }
    class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract {
        /**
         * gaugeSize for display. See enum QuotaGaugeSize.
         */
        gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * The number represents step size.
         * Note if this number is too small, widget will throw.
         * To check the minimum step value required, which is depends on maximum, call getRequiredMinimumStep().
         */
        step: KnockoutObservableBase<number>;
        /**
         * The number represents the whole gauge value.
         */
        maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * Current value.
         */
        current: KnockoutObservableBase<number>;
        /**
         * Display Text in the center.
         * By default the format string is "{0}".
         * The first argument({0}) is current, for example, 3.
         * The second argument({1}) is maximum().
         */
        centerDisplayFormat: KnockoutObservableBase<string>;
        /**
         * The first argument({0}) is current, for example, 3.
         * The second argument({1}) is maximum().
         */
        captionDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Creates a step gauge.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Dialogs\Dialog.d.ts
declare module MsPortalFx.ViewModels.Dialogs {
    /**
     * Defines the options to configure dialog.
     */
    interface DialogContract {
        /**
         * The type of dialog to display.
         */
        type: DialogType;
        /**
         * Title shown at the top of the dialog.
         */
        title: string;
    }
    /**
     * See interface.
     */
    class Dialog implements DialogContract {
        /**
         * See interface.
         */
        type: DialogType;
        /**
         * See interface.
         */
        title: string;
        /**
         * Do not use. Dialog is an abstract class and should not
         * be instantiated directly.
         */
        constructor(title: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Dialogs\DialogResult.d.ts
declare module MsPortalFx.ViewModels.Dialogs {
    const enum DialogResult {
        /**
         * The abort button.
         */
        Abort = 0,
        /**
         * The cancel button.
         */
        Cancel = 1,
        /**
         * The ignore button.
         */
        Ignore = 2,
        /**
         * The no button.
         */
        No = 3,
        /**
         * The ok button.
         */
        Ok = 4,
        /**
         * The retry button.
         */
        Retry = 5,
        /**
         * The yes button.
         */
        Yes = 6,
    }
    interface DialogResultCallback {
        (result: MsPortalFx.ViewModels.Dialogs.DialogResult): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Dialogs\DialogType.d.ts
declare module MsPortalFx.ViewModels.Dialogs {
    const enum DialogType {
        /**
         * Invalid value for a dialog type. Used on base class types that are not meant to be passed to the framework.
         * Derived types will assign valid dialog types.
         */
        Invalid = 0,
        /**
         * Dialog is a message box.
         */
        MessageBox = 1,
        /**
         * Dialog is a progress box.
         */
        ProgressBox = 2,
        /**
         * Dialog is a form.
         */
        Form = 3,
        /**
         * Dialog for selecting one item out of a list.
         */
        List = 4,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\DynamicSelection.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Selection that provides information about the detail blade to open dynamically.
     */
    interface DynamicSelection {
        /**
         * Object that maps to the blade inputs of the detail blade.
         */
        detailBladeInputs: Object;
        /**
         * Name of extension that contains the blade. Defaults to same extension as part that uses this selection.
         */
        extension?: string;
        /**
         * If true the blade should be opened in the context pane
         */
        openInContextPane?: boolean;
        /**
         * if the blade will be opened in the context pane, true open as context, false open as detail blade
         */
        persistentContextPane?: boolean;
    }
    /**
     * Selection that provides detail blade name to open.
     */
    interface DynamicBladeSelection extends DynamicSelection {
        /**
         * Name of the detail blade to open.
         */
        detailBlade: string;
    }
    /**
     * Gets a dynamic blade selection with an ID in the input.
     *
     * @param extensionName The name of the extension.
     * @param detailBlade The name of the blade.
     * @param inputs The blade inputs.
     * @returns The dynamic blade selection.
     */
    function getBladeSelection(extensionName: string, detailBlade: string, inputs: any): DynamicBladeSelection;
    /**
     * Selection that provides asset type to use to resolve detail blade to open.
     */
    interface DynamicAssetSelection extends DynamicSelection {
        /**
         * Name of asset used to retrieve the detail blade.
         */
        assetType: string;
    }
    /**
     * Gets a dynamic asset selection with an ID in the input.
     *
     * @param extensionName The name of the extension.
     * @param assetType The name of the asset type.
     * @param inputs The blade inputs.
     * @returns The dynamic asset selection.
     */
    function getAssetSelection(extensionName: string, assetType: string, inputs: any): DynamicAssetSelection;
    /**
     * Selection that provides resource ID to use to resolve detail blade to open.
     */
    interface DynamicResourceSelection extends DynamicSelection {
        /**
         * Resource ID for the selection used to retrieve the detail blade.
         */
        resourceId: string;
    }
    /**
     * A helper type pointing to all functional implementation of DynamicSelection interface.
     */
    type DynamicSelectionImpl = DynamicSelection | DynamicBladeSelection | DynamicAssetSelection | DynamicResourceSelection;
    /**
     * Compares DynamicSelection instances.
     * @param selection1 The first selection
     * @param selection2 The second selection
     * @return A boolean value reflecting whether the two selections are equal.
     */
    function equalDynamicSelections(selection1: DynamicSelection, selection2: DynamicSelection): boolean;
}
declare module FxImpl.ViewModels {
    interface DynamicSelection extends MsPortalFx.ViewModels.DynamicSelection {
        cloudName?: string;
    }
    /**
     *  Cloud aware selection that provides resource ID to use to resolve detail blade to open.
     */
    interface DynamicResourceSelection extends MsPortalFx.ViewModels.DynamicResourceSelection {
        cloudName?: string;
    }
    /**
     *  Cloud aware selection that provides asset type to use to resolve detail blade to open.
     */
    interface DynamicAssetSelection extends MsPortalFx.ViewModels.DynamicAssetSelection {
        cloudName?: string;
    }
    /**
     * Gets a dynamic asset selection with an ID in the input.
     *
     * @param cloudName The name of the cloud.
     * @param extensionName The name of the extension.
     * @param assetType The name of the asset type.
     * @param inputs The blade inputs.
     * @returns The dynamic asset selection.
     */
    function getAssetSelection(cloudName: string, extensionName: string, assetType: string, inputs: any): DynamicAssetSelection;
    /**
     *  Cloud aware selection that provides information about the detail blade to open dynamically.
     */
    interface DynamicBladeSelection extends MsPortalFx.ViewModels.DynamicBladeSelection {
        cloudName?: string;
    }
    /**
     * Gets a dynamic blade selection with an ID in the input.
     *
     * @param cloudName The name of the cloud.
     * @param extensionName The name of the extension.
     * @param detailBlade The name of the blade.
     * @param inputs The blade inputs.
     * @returns The dynamic blade selection.
     */
    function getBladeSelection(cloudName: string, extensionName: string, detailBlade: string, inputs: any): DynamicBladeSelection;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Base\ControlType.d.ts
declare module MsPortalFx.ViewModels {
    enum ControlType {
        /**
         * Value indicates field has not been set to an appropriate control type.
         */
        Invalid = 0,
        /**
         * Control is a section.
         */
        Section = 1,
        /**
         * Control is a text box.
         */
        TextBox = 2,
        /**
         * Control is a drop down field.
         */
        DropDown = 3,
        /**
         * Control is an options group field.
         */
        OptionsGroup = 4,
        /**
         * Control is a password field.
         */
        Password = 5,
        /**
         * Control is a slider.
         */
        Slider = 6,
        /**
         * Control is a check box.
         */
        CheckBox = 7,
        /**
         * Control is a multiselect drop down field.
         */
        MultiselectDropDown = 8,
        /**
         * Control is a range slider.
         */
        RangeSlider = 9,
        /**
         * Control is a numeric text box.
         */
        NumericTextBox = 10,
        /**
         * Control is a selector field.
         */
        Selector = 11,
        /**
         * Control is a filter combo.
         */
        FilterCombo = 12,
        /**
         * Control is multi-line text box.
         */
        MultiLineTextBox = 13,
        /**
         * Control is a date time combo box.
         */
        DateTimeCombo = 14,
        /**
         * Control is a dynamic section.
         */
        DynamicSection = 15,
        /**
         * Control is an attachment control.
         */
        Attachment = 16,
        /**
         * Control is a string list.
         */
        StringList = 17,
        /**
         * Control is a html editor.
         */
        HtmlEditor = 18,
        /**
         * Control is a history control.
         */
        History = 19,
        /**
         * Control is an artifact links control (used by VSO).
         */
        ArtifactLinks = 20,
        /**
         * Control is a splitter control.
         */
        Splitter = 21,
        /**
         * Control is a tri state check box.
         */
        TriStateCheckBox = 22,
        /**
         * Control is a custom html.
         */
        CustomHtml = 23,
        /**
         * Control is a time picker.
         */
        TimePicker = 24,
        /**
         * Control is a date picker.
         */
        DatePicker = 25,
        /**
         * Control is a date/time picker.
         */
        DateTimePicker = 26,
        /**
         * Control is a date/time range picker.
         */
        DateTimeRangePicker = 27,
        /**
         * Control is a file upload control.
         */
        FileUpload = 28,
        /**
         * Control is an OAuth button.
         */
        OAuthButton = 29,
        /**
         * Form element is a token combo box control.
         */
        TokenComboBox = 30,
        /**
         * QueryBuilder control.
         */
        QueryBuilder = 31,
        /**
         * DockedBalloon control.
         */
        DockedBalloon = 32,
        /**
         * DiffEditor control.
         */
        DiffEditor = 33,
        /**
         * DiffList control.
         */
        DiffList = 34,
        /**
         * DiffView control.
         */
        DiffView = 35,
        /**
         * DiscussionTimeline control.
         */
        DiscussionTimeline = 36,
        /**
         * Editor control.
         */
        Editor = 37,
        /**
         * Button control.
         */
        Button = 38,
        /**
         * pcCheckBox control.
         */
        pcCheckBox = 39,
        /**
         * CopyableLabel control.
         */
        CopyableLabel = 40,
        /**
         * pcDateTimeCombo control.
         */
        pcDateTimeCombo = 41,
        /**
         * pcDropDown control.
         */
        pcDropDown = 42,
        /**
         * pcFilterCombo control.
         */
        pcFilterCombo = 43,
        /**
         * pcGroupDropDown control.
         */
        pcGroupDropDown = 44,
        /**
         * pcMultiLineTextBox control.
         */
        pcMultiLineTextBox = 45,
        /**
         * pcMultiselectDropDown control.
         */
        pcMultiselectDropDown = 46,
        /**
         * pcNumericTextBox control.
         */
        pcNumericTextBox = 47,
        /**
         * pcOptionPicker control.
         */
        pcOptionPicker = 48,
        /**
         * pcPassword control.
         */
        pcPassword = 49,
        /**
         * pcRangeSlider control.
         */
        pcRangeSlider = 50,
        /**
         * pcSelector control.
         */
        pcSelector = 51,
        /**
         * pcSlider control.
         */
        pcSlider = 52,
        /**
         * pcTextBox control.
         */
        pcTextBox = 53,
        /**
         * pcGrid control.
         */
        pcGrid = 54,
        /**
         * Gallery control.
         */
        Gallery = 55,
        /**
         * pcListView control.
         */
        pcListView = 56,
        /**
         * pcTreeView control.
         */
        pcTreeView = 57,
        /**
         * LogStream control.
         */
        LogStream = 58,
        /**
         * Scrollbar control.
         */
        Scrollbar = 59,
        /**
         * Settings control.
         */
        Settings = 60,
        /**
         * SingleSetting control.
         */
        SingleSetting = 61,
        /**
         * Toolbar control.
         */
        Toolbar = 62,
        /**
         * Chart control.
         */
        Chart = 63,
        /**
         * CsmTopology control.
         */
        CsmTopology = 64,
        /**
         * Donut control.
         */
        Donut = 65,
        /**
         * Gauge control.
         */
        Gauge = 66,
        /**
         * Graph control.
         */
        Graph = 67,
        /**
         * Map control.
         */
        Map = 68,
        /**
         * Metrics control.
         */
        Metrics = 69,
        /**
         * PairedTimeline control.
         */
        PairedTimeline = 70,
        /**
         * ProgressBar control.
         */
        ProgressBar = 71,
        /**
         * QuotaGauge control.
         */
        QuotaGauge = 72,
        /**
         * SingleValueGauge control.
         */
        SingleValueGauge = 73,
        /**
         * StepGauge control.
         */
        StepGauge = 74,
        /**
         * Console control.
         */
        Console = 75,
        /**
         * DeleteAssetConfirmation control.
         */
        DeleteAssetConfirmation = 76,
        /**
         * HeroBanner control.
         */
        HeroBanner = 77,
        /**
         * InfoBox control.
         */
        InfoBox = 78,
        /**
         * Notice control.
         */
        Notice = 79,
        /**
         * Picker control.
         */
        Picker = 80,
        /**
         * FileUploadWidget control.
         */
        FileUploadWidget = 81,
        /**
         * FileDownloadButton control.
         */
        FileDownloadButton = 82,
        /**
         * CreatorAndSelector control.
         */
        CreatorAndSelector = 83,
        /**
         * HotSpot control (pcHotSpot)
         */
        HotSpot = 84,
        /**
         * CreatorAndSelectorV2 control.
         */
        CreatorAndSelectorV2 = 85,
        /**
         * RangeSelection control.
         */
        RangeSelection = 86,
        /**
         * Link InfoBox control.
         */
        LinkInfoBox = 87,
        /**
         * Link HotSpot control.
         */
        LinkHotSpot = 88,
        /**
         * Preview tag control.
         */
        PreviewTag = 89,
        /**
         * ConsoleV2 control.
         */
        ConsoleV2 = 90,
        /**
         * CustomValueSlider control.
         */
        CustomValueSlider = 91,
        /**
         * DayPicker control.
         */
        DayPicker = 92,
        /**
         * Search control.
         */
        SearchBox = 93,
        /**
         * Paired timeline badge control
         */
        PairedTimelineBadges = 94,
        /**
         * Spec Comparison Table
         */
        SpecComparisonTable = 95,
        /**
         * MapV2 Control
         */
        MapV2 = 96,
        /**
         * Simple chart
         */
        SimpleChart = 97,
        /**
         * GroupDropDown control.
         */
        GroupDropDown = 98,
        /**
         * DurationPicker control
         */
        DurationPicker = 99,
        /**
         * Simple button
         */
        SimpleButton = 100,
        /**
         * Text Block
         */
        TextBlock = 101,
        /**
         * Terminal Emulator
         */
        TerminalEmulator = 102,
        /**
         * Grid 2
         */
        Grid2 = 103,
        /**
         * List 2
         */
        List2 = 104,
        /**
         * Tree 2
         */
        Tree2 = 105,
        /**
         * Async FileUpload
         */
        AsyncFileUpload = 106,
        /**
         * Wizard
         */
        Wizard = 107,
        /**
         * IFrame control.
         */
        IFrame = 108,
        /**
         * Media Player control
         */
        MediaPlayer = 109,
        /**
         * Markdown control.
         */
        Markdown = 110,
        /**
         * Custom Range Slider
         */
        CustomRangeSlider = 111,
        /**
         * PartPinner control.
         */
        PartPinner = 112,
        /**
         * IFrame control.
         */
        IFrameV2 = 113,
        /**
         * Resource filter control.
         */
        ResourceFilter = 114,
        /**
         * Menu control.
         */
        Menu = 115,
        /**
         * Video control.
         */
        Video = 116,
        /**
         * Custom control.
         */
        CustomControl = 117,
        /**
         * Legend control.
         */
        Legend = 118,
        /**
         * Menu control.
         */
        HeatMap = 119,
        /**
         * Essentials control.
         */
        Essentials = 120,
        /**
         * Intune application file control.
         */
        IntuneAppFileUpload = 121,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Base\EditableComboField.d.ts
declare module MsPortalFx.ViewModels {
    import EditableCombo = MsPortalFx.ViewModels.Controls.Forms.EditableCombo;
    import PositioningAlignment = EditableCombo.PositioningAlignment;
    interface EditableComboFormField<T> extends EditableFormField<T> {
    }
    /**
     * Base class for combo fields using EditableCombo.
     */
    class EditableComboField<T> extends EditableField<T> implements EditableComboFormField<T> {
        /**
         * Text displayed in the field when the form value is empty.
         */
        emptyValueText: KnockoutObservable<string>;
        /**
         * Alignment used for drop popup.
         */
        popupAlignment: PositioningAlignment;
        /**
         * Alignment used for input.
         */
        inputAlignment: PositioningAlignment;
        /**
         * Deprecated
         * Width behavior of the drop popup.
         */
        dropDownWidth: KnockoutObservable<Obsolete>;
        /**
         * Constructs and instance of an editable combo field.
         * (Base class for other combo fields)
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         * @param emptyValueText Optional. Watermark text to display over the form field when it's empty.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], emptyValueText?: string, infoBalloonContent?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Base\Field.d.ts
declare module MsPortalFx.ViewModels {
    interface FormField<T> extends FormElement {
        /**
         * Label for the field.
         */
        label?: KnockoutObservable<string>;
        /**
         * Label position for the field.
         */
        labelPosition?: KnockoutObservable<MsPortalFx.ViewModels.Forms.LabelPosition>;
        /**
         * Initial value for the field.
         */
        initialValue?: KnockoutObservableBase<T>;
        /**
         * Current value of the field.
         */
        value?: KnockoutObservableBase<T>;
        /**
         * Turns validation on and off for the form field.
         */
        enableValidation?: KnockoutObservableBase<boolean>;
        /**
         * A list of validations that should be applied to the form field.
         */
        validations?: KnockoutObservableArray<FormValidation>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout?: KnockoutObservable<number>;
        /**
         * Whether the field is enabled or not.
         */
        enabled?: KnockoutObservable<boolean>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent?: KnockoutObservable<string>;
        /**
         * Whether validation should be performed on a control. Switching to true will trigger immediate validation.
         */
        performValidation?: KnockoutObservable<boolean>;
        /**
         * When changed triggers validation on the field if it has not been run.
         */
        ensureValidation?: KnockoutObservable<number>;
        /**
         * A function through which the enclosing form will dispose this field.  The field's 'initialValue' and 'value'
         * observables should be disposed if they are disposable.
         */
        dispose(): void;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue?: KnockoutObservableBase<T>;
    }
    class Field<T> extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements FormField<T> {
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutComputed<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * Turns validation on and off for the form field.
         */
        enableValidation: KnockoutObservableBase<boolean>;
        /**
         * When changed this signals to the control validation should occur.
         */
        validate: KnockoutObservable<number>;
        /**
         * Label for the field.
         */
        label: KnockoutObservable<string>;
        /**
         * Label for the field.
         */
        labelPosition: KnockoutObservable<MsPortalFx.ViewModels.Forms.LabelPosition>;
        /**
         * Current value of the field.
         */
        value: KnockoutObservableBase<T>;
        /**
         * Initial value for the field.
         */
        initialValue: KnockoutObservableBase<T>;
        /**
         * A list of validations that should be applied to the form field.
         */
        validations: KnockoutObservableArray<FormValidation>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         * Whether the field is enabled or not.
         */
        enabled: KnockoutObservable<boolean>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent: KnockoutObservable<string>;
        /**
         * Whether validation should be performed on a control. Switching to true will trigger immediate validation.
         */
        performValidation: KnockoutObservable<boolean>;
        /**
         * When changed triggers validation on the field if it has not been run.
         */
        ensureValidation: KnockoutObservable<number>;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue: KnockoutObservableBase<T>;
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        _msPortalFxTriggerValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        _enableValidationReactor: KnockoutComputed<void>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         * @param defaultValue An optional, default value of type T, used when the EditScope underlying the enclosing Form isn't
         * yet loaded.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string, defaultValue?: T);
        dispose(): void;
        /**
         * Clears validation on the field.
         * @return A promise that is resolved when the validation has been cleared.
         */
        clearValidation(): MsPortalFx.Base.Promise;
        /**
          * Triggers validation on the field.
          * @return A promise that is resolved when the validation has been triggered.
          */
        triggerValidation(): MsPortalFx.Base.Promise;
    }
    interface NullableFormField<T> extends FormField<T> {
        /**
         * Whether the field is empty.
         */
        empty: KnockoutObservableBase<boolean>;
    }
    class NullableField<T> extends Field<T> implements NullableFormField<T> {
        /**
         * Whether the field is empty.
         */
        empty: KnockoutComputed<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string);
        dispose(): void;
    }
    interface EditableFormField<T> extends NullableFormField<T> {
        /**
         * Whether the field is currently being edited.
         */
        editing: KnockoutObservableBase<boolean>;
    }
    class EditableField<T> extends NullableField<T> implements EditableFormField<T> {
        /**
         * Whether the field is currently being edited.
         */
        editing: KnockoutObservable<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface GroupsFormField<T> extends FormField<T> {
        /**
         * A list of groups to categorize the selectable options.
         * Dynamic update of groups array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        groups: KnockoutObservableArray<Forms.IGroup<T>>;
    }
    class GroupsField<T> extends Field<T> implements GroupsFormField<T> {
        /**
         * A list of groups to categorize the selectable options.
         */
        groups: KnockoutObservableArray<Forms.IGroup<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param values A list of groups to categorize the options field value.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, values: Forms.IGroup<T>[], validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface OptionsFormField<T> extends FormField<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<Forms.IDisablableOption<T>>;
    }
    class OptionsField<T> extends Field<T> implements OptionsFormField<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<Forms.IDisablableOption<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param values A list of options the user will choose the field value from.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, values: Forms.IDisablableOption<T>[], validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface SliderBaseFormField<T> extends FormField<T> {
        /**
         * Minimum value of the slider.
         */
        min: KnockoutObservableBase<number>;
        /**
         * Maximum value of the slider.
         */
        max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step: KnockoutObservableBase<number>;
        /**
         * Displays a marker for each step.
         */
        showStepMarkers: KnockoutObservableBase<boolean>;
    }
    class SliderBaseField<T> extends Field<T> implements SliderBaseFormField<T> {
        /**
         * Minimum value for the field.
         */
        min: KnockoutObservableBase<number>;
        /**
         * Maximum value for the field.
         */
        max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step: KnockoutObservableBase<number>;
        /**
         * Whether to show step markers on the slider field.
         */
        showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Constructs an instance of a slider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param minValue Minimum value for the field.
         * @param maxValue Maximum value for the field.
         * @param validations A list of validations to be applied to the field.
         * @param showStepMarkers If true step markers will be shown on the slider.
         * @param defaultValue An optional, default value of type T, used when the EditScope underlying the enclosing Form isn't
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors?: any, label?: string, minValue?: number, maxValue?: number, validations?: FormValidation[], showStepMarkers?: boolean, infoBalloonContent?: string, defaultValue?: T, step?: number);
    }
    interface TypableFormField<T> extends NullableFormField<T> {
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
    }
    class TypableField<T> extends EditableField<T> implements TypableFormField<T> {
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Base\FormElement.d.ts
declare module MsPortalFx.ViewModels {
    interface FormElement extends MsPortalFx.ViewModels.Controls.Base.Contract {
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * When changed forces validation on the field.
         */
        validate: KnockoutObservable<number>;
        /**
         * Clears validations on the control.
         */
        clearValidation(): MsPortalFx.Base.Promise;
        /**
         * Triggers validations on the control.
         */
        triggerValidation(): MsPortalFx.Base.Promise;
        /**
         * Internal view model properties.
         */
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Base\FormGroup.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface IGroup<T> {
        /**
         * Id specifying the groupby key for a group of options.
         */
        key: string;
        /**
         * User friendly label for the grouping.
         */
        text: KnockoutObservable<string>;
        /**
         * Disable state of this group.
         */
        disabled: KnockoutObservable<boolean>;
        /**
         * Selectable state of this group.
         */
        selected?: KnockoutObservable<boolean>;
        /**
         * A list of options the use can select the field value from.
         * Dynamic update of options array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        options: KnockoutObservableArray<ISelectableOption<T>>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Base\FormOption.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface IOption<T> {
        /**
         * Text for the drop down option.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Value for the drop down option.
         */
        value: T;
    }
    interface IDisablableOption<T> extends IOption<T> {
        /**
       * Dropdown option can be disabled.
       */
        disabled?: KnockoutObservableBase<boolean>;
    }
    class Option<T> implements IOption<T> {
        /**
         * Text for list item.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Value bound for list item when the item is selected.
         */
        value: T;
        /**
         * @param text The text data binding for the item.
         * @param value The value data binding for the item.
         */
        constructor(text: string, value: T);
        constructor(text: KnockoutObservableBase<string>, value: T);
    }
    class DisablableOption<T> extends Option<T> implements IDisablableOption<T> {
        /**
         * Item is disabled.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * @param text The text data binding for the item.
         * @param value The value data binding for the item.
         * @param disabled The item is disabled.
         */
        constructor(text: string, value: T, disabled?: boolean);
        constructor(text: KnockoutObservableBase<string>, value: T, disabled?: KnockoutObservableBase<boolean>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Base\FormOptionFormatSetting.d.ts
declare module MsPortalFx.ViewModels {
    interface FormOptionFormatSetting {
        /**
         * Formatter used when displaying the drop down option.
         */
        format?: MsPortalFx.ViewModels.Controls.Lists.Grid.Format;
        /**
         * Formatter options associated with the formatters.
         */
        formatOptions?: MsPortalFx.ViewModels.Controls.Lists.Grid.FormatOptions;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Base\FormSelectableOption.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface ISelectableOption<T> extends IDisablableOption<T> {
        /**
         * Option is selected. Recommended to use manipulate value to update selection.
         * NOTE: Updates active selected for OptionsGroup control only.
         */
        selected?: KnockoutObservableBase<boolean>;
    }
    class SelectableOption<T> extends DisablableOption<T> implements ISelectableOption<T> {
        /**
         * Option is selected. Recommended to use manipulate value to update selection.
         * NOTE: Updates active selected for OptionsGroup control only.
         */
        selected: KnockoutObservableBase<boolean>;
        /**
         * @param text The text data binding for the item.
         * @param value The value data binding for the item.
         * @param disabled The item is disabled.
         * @param selected The item is selected.
         */
        constructor(text: string, value: T, disabled?: boolean, selected?: boolean);
        constructor(text: KnockoutObservableBase<string>, value: T, disabled?: KnockoutObservableBase<boolean>, selected?: KnockoutObservableBase<boolean>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\CaseInsensitiveComparisonValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface CaseInsensitiveComparisonFormValidation extends StaticMessageFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
    }
    class CaseInsensitiveComparisonValidation extends StaticMessageValidation implements CaseInsensitiveComparisonFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
        /**
         * Validation that uses toLowerCase() to compare two values.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(compareTo: string, message: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\ContainsCharactersValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface ContainsCharactersFormValidation extends StaticMessageFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
    }
    class ContainsCharactersValidation extends StaticMessageValidation implements ContainsCharactersFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
        /**
         * Constructs a validator that checks that the value contains at least one character from a character set.
         *
         * @param characters One or more characters to search for.
         * @param message Validation rule error message.
         */
        constructor(characters: string, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\ContainsValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface ContainsFormValidation extends StaticMessageFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
    }
    class ContainsValidation extends StaticMessageValidation implements ContainsFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
        /**
          * Constructs a validator that checks that the value contains at least one case insensitive match of a search string.
          *
          * @param search The search string to match.
          * @param message Validation rule error message.
          */
        constructor(searchString: string, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\CustomValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface CustomFormValidation extends FormValidation {
        /**
         * Function that returns whether the data is valid or not.
         *
         * @param value The field value to validate.
         * @return The promise to validate the value.
         */
        validate: (value: any) => MsPortalFx.Base.PromiseV<ValidationResult>;
        /**
         *  The message that is shown to the user if a message is not included as part of the validation result.
         */
        message: string;
    }
    class CustomValidation extends Validation implements CustomFormValidation {
        /**
         * Function that returns whether the data is valid or not.
         */
        validate: (value: any) => MsPortalFx.Base.PromiseV<ValidationResult>;
        /**
         *  The message that is shown to the user if a message is not included as part of the validation result.
         */
        message: string;
        constructor(message: string, validate: (value: any) => MsPortalFx.Base.PromiseV<ValidationResult>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\EqualsValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface EqualsFormValidation<T> extends StaticMessageFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: T;
    }
    class EqualsValidation<TValue> extends StaticMessageValidation implements EqualsFormValidation<TValue> {
        /**
         * The value the field value will be compared to.
         */
        compareTo: TValue;
        /**
         * Constructs a validator that compares if the value is equal to a provided value.
         *
         * @param compareTo The value or accessor to get the value to compare to.
         * @param message Validation rule error message.
         */
        constructor(compareTo: TValue, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\FormValidationType.d.ts
declare module MsPortalFx.ViewModels {
    enum FormValidationType {
        /**
         * Value indicates field has not been set to an appropriate validation type.
         */
        Invalid = 0,
        /**
         * Validation is a value required validation.
         */
        Required = 1,
        /**
         * Validation is a regular expression validation.
         */
        RegExMatch = 2,
        /**
         * Validator that checks if the value does not match a regular expression.
         */
        NotRegExMatch = 3,
        /**
         * Constructs a validator that checks that the value contains at least one case insensitive match of a search string.
         */
        Contains = 4,
        /**
         * Constructs a validator that checks that the value does not contain a case insensitive match of a search string.
         */
        NotContains = 5,
        /**
         * Constructs a validator that checks that the value contains at least one character from a character set.
         */
        ContainsCharacters = 6,
        /**
         * Constructs a validator that checks that the value does not contain any characters from a character set.
         */
        NotContainsCharacters = 7,
        /**
         * Constructs a validator that checks that the value has at least one digit from 0 to 9.
         */
        HasDigit = 8,
        /**
         * Constructs a validator that checks that the value has at least one upper or lower case letter from A to Z or a to z.
         * (Not Unicode)
         */
        HasLetter = 9,
        /**
         * Constructs a validator that checks that the value has at least one upper case letter from A to Z.
         * (Not Unicode)
         */
        HasUpperCaseLetter = 10,
        /**
         * Constructs a validator that checks that the value has at least one lower case letter from a to z.
         * (Not Unicode)
         */
        HasLowerCaseLetter = 11,
        /**
         * Constructs a validator that checks that the value contains at least one punctuation character from:
         * ! @ # $ % ^ & * ( ) _ + - = { } | [ ] \ : " ; ' < > , . ? / ~ `
         */
        HasPunctuation = 12,
        /**
         * Constructs a base comparison validator that compares the control value to a provided value.
         */
        Equals = 13,
        /**
         * Constructs a validator that checks that the value length is between min and max.
         */
        LengthRange = 14,
        /**
         * Constructs a validator that checks that the value length is at least min.
         */
        MinLength = 15,
        /**
         * Constructs a validator that checks that the value length is less than or equal to the max.
         */
        MaxLength = 16,
        /**
         * Constructs a validator that checks whether the value is a number.
         */
        Numeric = 17,
        /**
         * Constructs a validator that checks whether the value is within the range defined by min and max number.
         */
        Range = 18,
        /**
         * Constructs a validator that checks whether the value is greater than or equal to the specified minimum number.
         */
        MinValue = 19,
        /**
         * Constructs a validator that checks whether the value is less than or equal to the specified maximum number.
         */
        MaxValue = 20,
        /**
         * Validation is implemented by extension author.
         */
        Custom = 21,
        /**
         * Constructs a validator that uses toLowerCase() to compare two values.
         */
        CaseInsensitiveComparison = 22,
        /**
         * Constructs a validator that uses toLocaleLowerCase() to compare two values.
         */
        LocaleAwareCaseInsensitiveComparison = 23,
        /**
         * Contructs a validator that validates an absolute http/https URI.
         */
        Uri = 24,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\HasDigitValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasDigitFormValidation extends StaticMessageFormValidation {
    }
    class HasDigitValidation extends StaticMessageValidation implements HasDigitFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one digit from 0 to 9.
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\HasLetterValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasLetterFormValidation extends StaticMessageFormValidation {
    }
    class HasLetterValidation extends StaticMessageValidation implements HasLetterFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one upper or lower case letter from A to Z or a to z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\HasLowerCaseLetterValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasLowerCaseLetterFormValidation extends StaticMessageFormValidation {
    }
    class HasLowerCaseLetterValidation extends StaticMessageValidation implements HasLowerCaseLetterFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one lower case letter from a to z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\HasPunctuationValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasPunctuationFormValidation extends StaticMessageFormValidation {
    }
    class HasPunctuationValidation extends StaticMessageValidation implements HasPunctuationFormValidation {
        /**
         * Constructs a validator that checks that the value contains at least one punctuation character from:
         * ! @ # $ % ^ & * ( ) _ + - = { } | [ ] \ : " ; ' < > , . ? / ~ `
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\HasUpperCaseLetterValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasUpperCaseLetterFormValidation extends StaticMessageFormValidation {
    }
    class HasUpperCaseLetterValidation extends StaticMessageValidation implements HasUpperCaseLetterFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one upper case letter from A to Z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\InvalidValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface InvalidFormValidation extends StaticMessageFormValidation {
    }
    class InvalidValidation extends StaticMessageValidation implements InvalidFormValidation {
        /**
         * Constructs an instance of the invalid validation which is used to force invalid validation state.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\LengthRangeValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface LengthRangeFormValidation extends StaticMessageFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
    }
    class LengthRangeValidation extends StaticMessageValidation implements LengthRangeFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
        /**
         * Constructs a validator that checks that the value length is between min and max.
         *
         * @param min The minimum number of characters to be valid. May be null if there is no min.
         * @param max The maximum number of characters to be valid. May be null if there is no max.
         * @param message Validation rule error message.
         */
        constructor(min: number, max: number, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\LocaleAwareCaseInsensitiveComparisonValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface LocaleAwareCaseInsensitiveComparisonFormValidation extends StaticMessageFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
    }
    class LocaleAwareCaseInsensitiveComparisonValidation extends StaticMessageValidation implements LocaleAwareCaseInsensitiveComparisonFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
        /**
         * Validation that uses toLocaleLowerCase() to compare two values.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(compareTo: string, message: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\MaxLengthValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MaxLengthFormValidation extends StaticMessageFormValidation {
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
    }
    class MaxLengthValidation extends StaticMessageValidation implements MaxLengthFormValidation {
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
        /**
         * Constructs a validator that checks that the value length is less than or equal to the max.
         *
         * @param max The maximum number of characters to be valid.
         * @param message Validation rule error message.
         */
        constructor(max: number, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\MaxValueValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MaxValueFormValidation extends StaticMessageFormValidation {
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
    }
    class MaxValueValidation extends StaticMessageValidation implements MaxValueFormValidation {
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
        /**
         * Constructs a validator that checks whether the value is less than than or equal to the specified maximum number.
         *
         * @param max Maximum field value.
         * @param message Validation rule error message.
         */
        constructor(max: number, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\MinLengthValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MinLengthFormValidation extends StaticMessageFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
    }
    class MinLengthValidation extends StaticMessageValidation implements MinLengthFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
        /**
         * Constructs a validator that checks that the value length is at least min.
         *
         * @param min The minimum number of characters to be valid.
         * @param message Validation rule error message.
         */
        constructor(min: number, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\MinValueValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MinValueFormValidation extends StaticMessageFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
    }
    class MinValueValidation extends StaticMessageValidation implements MinValueFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
        /**
         * Constructs a validator that checks whether the value is greater than or equal to the specified minimum number.
         *
         * @param min Minimum field value.
         * @param message Validation rule error message.
         */
        constructor(min: number, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\NotContainsCharactersValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NotContainsCharactersFormValidation extends StaticMessageFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
    }
    class NotContainsCharactersValidation extends StaticMessageValidation implements NotContainsCharactersFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
        /**
         * Constructs a validator that checks that the value does not contain any characters from a character set.
         *
         * @param characters One or more characters to search for.
         * @param message Validation rule error message.
         */
        constructor(characters: string, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\NotContainsValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NotContainsFormValidation extends StaticMessageFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
    }
    class NotContainsValidation extends StaticMessageValidation implements NotContainsFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
        /**
         * Constructs a validator that checks that the value does not contain a case insensitive match of a search string.
         *
         * @param search The search string to match.
         * @param message Validation rule error message.
         */
        constructor(searchString: string, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\NotRegExMatchValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NotRegExMatchFormValidation extends StaticMessageFormValidation {
        /**
         * The regular expression that if matched will cause the field value to fail validation.
         */
        pattern: string;
    }
    class NotRegExMatchValidation extends StaticMessageValidation implements NotRegExMatchFormValidation {
        /**
         * The regular expression that if matched will cause the field value to fail validation.
         */
        pattern: string;
        /**
         * Constructs a validator that checks if the value does not match a regular expression.
         *
         * @param pattern Regular expression to test the value against.
         * @param message Validation rule error message.
         */
        constructor(pattern: string, message: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\NumericValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NumericFormValidation extends StaticMessageFormValidation {
    }
    class NumericValidation extends StaticMessageValidation implements NumericFormValidation {
        /**
         * Constructs a validator that checks whether the value is a number.
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\RangeValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface RangeFormValidation extends StaticMessageFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
    }
    class RangeValidation extends StaticMessageValidation implements RangeFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
        constructor(min: number, max: number, message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\RegExMatchValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface RegExMatchFormValidation extends StaticMessageFormValidation {
        /**
         * The regular expression field value must match to pass validation.
         */
        pattern: string;
    }
    class RegExMatchValidation extends StaticMessageValidation implements RegExMatchFormValidation {
        /**
         * The regular expression field value must match to pass validation.
         */
        pattern: string;
        /**
         * Constructs and instance of the regular expression validation which ensure value matches regular expression.
         *
         * @param pattern Regular expression pattern to match.
         * @param message The message to show the user when validation fails.
         */
        constructor(pattern: string, message: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\RequiredValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface RequiredFormValidation extends StaticMessageFormValidation {
    }
    class RequiredValidation extends StaticMessageValidation implements RequiredFormValidation {
        /**
         * Constructs and instance of the required validation which will ensure value is non-empty.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(message?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\StaticMessageValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface StaticMessageFormValidation extends FormValidation {
        /**
         * The message to be displayed when validation fails.
         */
        message: string;
        /**
         * Indicates whether an empty value is valid or not.
         */
        isEmptyValid?: KnockoutObservable<boolean>;
    }
    class StaticMessageValidation extends Validation implements StaticMessageFormValidation {
        /**
         * The message to be displayed when validation fails.
         */
        message: string;
        /**
         * Indicates whether an empty value is valid or not.
         */
        isEmptyValid: KnockoutObservable<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(type: FormValidationType, message: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\UriValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface UriValidationOptions {
        /**
         * The url must be an https address.
         */
        requireHttps?: boolean;
    }
    class UriValidation extends StaticMessageValidation {
        /**
         * The regular expression field value must match to pass validation.
         */
        options: UriValidationOptions;
        /**
         * Constructs and instance of the regular expression validation which ensure value matches regular expression.
         *
         * @param message The message to show the user when validation fails.
         * @param options Options for the uri validator.
         */
        constructor(message: string, options?: UriValidationOptions);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\Validation.d.ts
declare module MsPortalFx.ViewModels {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * Retuns a ValidationResult.
     * If the error message is not a string, returns a success result.
     * Else returns an invalid result with the error message.
     */
    function getValidationResult(err?: string): ValidationResult;
    /**
     * Returns a validation result wrapped in a resolved Q promise.
     * If the error message is not a string, returns a success result.
     * Else returns an invalid result with the error message.
     */
    function getValidationResultPromise(err?: string): FxBase.PromiseV<FxViewModels.ValidationResult>;
    interface FormValidation {
        /**
         * The type of validation to be performed.
         */
        type: FormValidationType;
    }
    class Validation implements FormValidation {
        /**
         * The type of validation to be performed.
         */
        type: FormValidationType;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param type The validation type.
         */
        constructor(type: FormValidationType);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Fields\Validation\ValidationResult.d.ts
declare module MsPortalFx.ViewModels {
    interface ValidationResult {
        /**
         * Whether or not the field is valid.
         */
        valid: boolean;
        /**
         * The message to show when the field is invalid.
         */
        message: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\FileDownload\FileDownload.d.ts
declare module MsPortalFx.ViewModels.FileDownload {
    import FxNet = MsPortalFx.Base.Net;
    enum Type {
        /**
         * Download file is a text file
         */
        Text = 1,
        /**
         * Download file is a binary file
         */
        Binary = 2,
    }
    /**
     * File download status with http response codes.
     */
    class Status extends MsPortalFx.ViewModels.Controls.FileDownload.Status {
        constructor(status: string, statusCode: number, errorMessage?: string);
    }
    interface DownloadProgressDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        downloadProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        downloadProgressText?: string;
    }
    /**
     * Options for a file download.
     */
    interface Options {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod?: KnockoutObservableBase<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers?: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType?: KnockoutObservableBase<string>;
        /**
         * Optionally specify whether to add default authorization tokens or options for getting authorization tokens.
         */
        addDefaultAuthorizationToken?: boolean | FxNet.AuthorizationOptions;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType?: KnockoutObservableBase<Type>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage?: KnockoutObservableBase<string>;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions?: DownloadProgressDialogOptions;
        /**
         * Callback executed on download start
         */
        onStart?: () => void;
        /**
         * Callback executed on download end
         */
        onEnd?: (status: Status) => void;
    }
    /**
     * Contract for a file download control.
     */
    class Context {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod: KnockoutObservableBase<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify a request body. Valid only for POST requests.
         */
        httpRequestContent: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType: KnockoutObservableBase<string>;
        /**
         * Optionally specify options for getting authorization tokens.
         */
        authorizationOptions: FxNet.AuthorizationOptions;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType: KnockoutObservableBase<Type>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage: KnockoutObservableBase<string>;
        /**
         * File download status with standard http response codes will be updated based on the file download ajax call response.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         */
        downloadStatus: KnockoutObservableBase<Status>;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions: DownloadProgressDialogOptions;
        /**
         * Callback executed on download start
         */
        onStart: () => void;
        /**
         * Callback executed on download end
         */
        onEnd: (status: Status) => void;
        /**
         * FileDownload command constructor.
         *
         * @param options.
         */
        constructor(options: Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\FileUpload\FileUpload.d.ts
declare module MsPortalFx.ViewModels.FileUpload {
    import FxPromise = MsPortalFx.Base.Promise;
    import FxPromiseV = MsPortalFx.Base.PromiseV;
    import DynamicBladeSelection = MsPortalFx.ViewModels.DynamicBladeSelection;
    const defaultFullFileUploadMaxSize: number;
    const defaultFullFileUploadChunkSize: number;
    const defaultStreamFileUploadMaxSize: number;
    const defaultStreamFileUploadChunkSize: number;
    const defaultBlobStoreUploadMaxSize: number;
    const defaultBlobStoreUploadChunkSize: number;
    const pageBlobPageSize: number;
    const defaultResumableTrackingChunkSize: number;
    /**
     *  Specifies how the file content should be uploaded.
     */
    const enum UploadType {
        /**
         *  Full file content will be read. Use this option only for small file sizes less than 2 MB.
         */
        Full = 0,
        /**
         * File content will be read in chunks and provided to user in chunks.
         * Use this option to read large files and if user wants control over where to post the content.
         */
        Stream = 1,
        /**
         *  File upload to block blob store.
         */
        BlockBlobStore = 2,
        /**
         *  File upload to page blob store.
         */
        PageBlobStore = 3,
        /**
         *  File upload to append blob store.
         */
        AppendBlobStore = 4,
        /**
         *  File upload to Azure file service.
         */
        FileService = 5,
    }
    /**
     * Specifies how the file content should be read and encoded in memory.
     * These options mimics the html5 file reader options to read the file content.
     */
    const enum ContentType {
        /**
         * By default, file content will be read and stored as binary data in an ArrayBuffer.
         */
        Default = 0,
        /**
         * The file content will be read as plain text.
         * By default the string is encoded in 'UTF-8' format. Use the optional encoding parameter to specify a different format.
         */
        Text = 1,
        /**
         * The file content will be available in an ArrayBuffer.
         */
        ArrayBuffer = 2,
        /**
         * The file content will be encoded in the data uri scheme. Use this option for images and if those need to be directly shown in img tag.
         */
        DataUri = 3,
    }
    /**
     * File upload status.
     */
    const enum UploadStatus {
        /**
         * Invalid.
         */
        Invalid = 0,
        /**
         * Pending.
         */
        Pending = 1,
        /**
         * Uploading.
         */
        Uploading = 2,
        /**
         * Paused.
         */
        Paused = 3,
        /**
         * Complete.
         */
        Complete = 4,
        /**
         * Canceled.
         */
        Canceled = 5,
        /**
         * Aborted.
         */
        Aborted = 6,
    }
    /**
     * Upload action performed on upload task. This enum is used internally by upload framework.
     */
    const enum UploadAction {
        /**
         * No-op.
         */
        None = 0,
        /**
         * Pause the current upload task.
         */
        Pause = 1,
        /**
         * Resume the current upload task.
         */
        Resume = 2,
        /**
         * Cancel the current upload task
         */
        Cancel = 3,
        /**
         * Dispose the current upload task.
         */
        Dispose = 4,
        /**
         * Add selected file to upload task array.
         */
        AddUploadTasks = 5,
        /**
         * Reset Upload task array.
         */
        ResetUploadTasks = 6,
        /**
         * Complete the current upload task.
         * This action is used for streaming file upload to indicate the completion of the upload.
         */
        Complete = 7,
        /**
         * Abort the current upload task.
         * This action is used for aborting the current upload due to runtime errors.
         */
        Abort = 8,
        /**
         * Gets the next file chunk for streaming upload.
         * This action is used for streaming file upload to get the next file chunk.
         */
        GetNextChunk = 9,
    }
    enum ObsoleteUploadAction {
        None = 0,
        Pause = 1,
        Resume = 2,
        Cancel = 3,
        Dispose = 4,
        AddUploadTasks = 5,
        ResetUploadTasks = 6,
        Complete = 7,
        Abort = 8,
        GetNextChunk = 9,
    }
    /**
     * The file upload context options around how/where to upload and size limits.
     */
    interface UploadContext {
        /**
         * Specify how/where the file should be uploaded.
         */
        type: UploadType;
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
    }
    /**
     * Defines how the uploaded file content will be available for the user.
     */
    interface UploadContent {
        /**
         * File upload type. The content will be different for each file upload type.
         */
        type: UploadType;
        /**
         * Specifies how the content will be represented in memory.
         */
        contentType: ContentType;
    }
    /**
     * Holds the full file uploaded content.
     */
    interface FullFileUploadContent extends UploadContent {
        /**
         * The full file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
    }
    /**
     * Holds the streamed file chunks and start/end bytes.
     */
    interface StreamFileUploadContent extends UploadContent {
        /**
         * The chunked file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
        /**
         * The startbyte of the chunk.
         */
        startByte: number;
        /**
         * The endbyte of the chunk.
         */
        endByte: number;
    }
    /**
     * File upload result will hold the upload status, current progress and upload content.
     */
    interface UploadResult {
        /**
         * The current status of the upload task.
         */
        status: UploadStatus;
        /**
         * The percent complete of the upload task.
         */
        progressPercent: number;
        /**
         * File upload content will be available in memory based on the specified upload type and content type.
         */
        data: UploadContent;
        /**
         * Error messages to indicate the runtime errors.
         */
        errorMessage?: string;
    }
    /**
     * Each file upload task is represented by a unique key. This is used for all management operations to locate the uploads.
     */
    interface UploadKey {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
    }
    /**
     * Context info sent as part of various upload task actions.
     */
    interface ActionContext {
    }
    /**
     * Resumable context needed to resume uploads across browser session.
     * This is an optional property in ResumeContext and presence of this property in ResumeContext indicates the intent to resume an upload after browser refresh/crash/close.
     */
    interface ResumableContext {
        /**
         * Upload key of the initial upload which was stopped due to browser refresh/crash/close.
         * The upload id is used to lookup the persisted/tracked uploaded byte resumable information.
         */
        originalUploadKey: UploadKey;
    }
    /**
     * Optional context information passed to the resume API.
     * Resume is called to start a new upload, start a new upload overriding upload context, resume an in-memory paused upload and resume an upload across browser session.
     * Resume context provides adequate context to enable above resume scenarios.
     */
    interface ResumeContext extends ActionContext {
        /**
         * Optional upload context information to override the default upload context specified in the view model.
         * For multi-select scenarios the default context will be applied to all uploads.
         * If upload type or content type needs to be overridden for a particular upload,
         * a new upload context information can be sent as part of resume context.
         */
        uploadContext?: UploadContext;
        /**
         * For resuming the upload across browser refresh/crash/close scenario, pass in the resumableContext with the upload key for the paused upload.
         * A list of paused uploads due to browser refresh/crash/close will be made avaiable via getResumableUploadInfo API which will have all necessary information including the upload key.
         */
        resumableContext?: ResumableContext;
    }
    /**
     * Optional abort context information sent when upload is aborted.
     */
    interface AbortContext extends ActionContext {
        /**
         * An error message / reason for aborting the file upload.
         */
        reason?: string;
    }
    /**
     *  Optional dispose context information sent when upload is disposed.
     */
    interface DisposeContext extends ActionContext {
        /**
         * Optional flag to indicate if resumable info needs to be deleted.
         * Setting it to true will cleanup both in-memory resumable info as well as persisted/tracked resumable info unless there is an ongoing upload with that upload key.
         */
        resumable?: boolean;
    }
    /**
     * Optional chunk context sent when fetching the next file chunk via GetNextChunk API.
     */
    interface ChunkContext extends ActionContext {
        /**
         * Optionally specify the start byte offset.
         */
        startByte?: number;
        /**
         * Optionally specify the chunk size otherwise the default 2 MB will be used.
         */
        chunkSize?: number;
    }
    /**
     * Upload action callback interface used by the upload widget.
     */
    interface UploadActionCallback {
        /**
         * Upload action callback interface used by the upload widget.
         *
         * @param uploadKeys Array of unique identifier for the each upload task.
         * @param action Upload action that needs to be performed like resume/pause/cancel/dispose.
         */
        (uploadKeys: UploadKey[], action: UploadAction, context?: ActionContext): FxPromise;
    }
    /**
     * Streaming upload callback interface used by the upload widget.
     */
    interface GetNextChunkCallback {
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param uploadKeys Array of unique identifier for the each upload task.
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @return Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        (uploadKey: UploadKey, startByte?: number, chunkSize?: number): FxPromiseV<StreamFileUploadContent>;
    }
    /**
     * File information.
     */
    interface FileInfoContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
    }
    /**
     * SelectedFile is the extension representation of the user selected file via browse dialog.
     * The actual file handles cannot be passed back and forth across iframe and widget / global upload manager will retain the actual handles.
     */
    interface SelectedFileContract extends FileInfoContract {
        /**
         * Selected file can be uploaded if valid is true.
         * valid flag can be set by the control if any of the standard validations around file size and permission issues fails. The corresponding upload task status will be set to Invalid.
         * valid flag can be set by extension based on the custom validation added by the extension.
         * If extension sets the flag to false, the corresponding upload task status will be marked as Invalid.
         */
        valid: KnockoutObservableBase<boolean>;
    }
    /**
     * Upload information.
     */
    interface UploadInfoContract {
        /**
         * Unique id for each upload task.
         */
        id: KnockoutReadOnlyObservableBase<string>;
        /**
         * Upload category tag provided by extension.
         */
        category: KnockoutReadOnlyObservableBase<string>;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Upload type.
         */
        type: KnockoutReadOnlyObservableBase<UploadType>;
        /**
         * Upload destination like target blob store uri .
         */
        target: KnockoutReadOnlyObservableBase<string>;
        /**
         * The current status of the upload task.
         */
        status: KnockoutReadOnlyObservableBase<UploadStatus>;
        /**
         * The total bytes that have been uploaded/streamed.
         */
        uploadedBytes: KnockoutReadOnlyObservableBase<number>;
        /**
         * The percent complete of the upload task. The values will be in 0-100 range.
         */
        progressPercent: KnockoutReadOnlyObservableBase<number>;
        /**
         * Error messages to indicate the runtime errors.
         */
        errorMessage?: KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * File upload details, status and content.
     */
    interface UploadTaskContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * The object representing the uploaded status/content for this file.
         */
        uploadResult: KnockoutObservableBase<UploadResult>;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         */
        resume: () => void;
        /**
         * Method to dispose the current file upload. Dispose will cacel the ongoing upload and will do the needed cleanup.
         */
        dispose: () => void;
        /**
         * Method to cancel the current file upload.
         */
        cancel: () => void;
        /**
         * Method to pause the current file upload.
         */
        pause?: () => void;
    }
    /**
     * Async file upload task with upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     */
    interface AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @return Promise indicating the success or failure or the operation.
         */
        resume: (context?: ResumeContext) => FxPromise;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        pause?: () => FxPromise;
        /**
         * Method to cancel the current file upload.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        cancel: () => FxPromise;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        complete: () => FxPromise;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @return Promise indicating the success or failure or the operation.
         */
        abort: (context?: AbortContext) => FxPromise;
        /**
         * Method to dispose the current file upload. Dispose will cancel the ongoing upload and will do the needed cleanup.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        dispose: () => FxPromise;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @return Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk: (startByte?: number, chunkSize?: number) => FxPromiseV<StreamFileUploadContent>;
    }
    /**
     * View model contract for file upload.
     */
    interface UploadContract {
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept?: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext: KnockoutObservableBase<UploadContext>;
        /**
         * Cancel all uploads that are in progress and clears the files list array.
         */
        cancelAllUploads: KnockoutObservableBase<boolean>;
        /**
         * When file input is clicked, if set to true,  the upload command/widget will cancel all uploads that are in progress and clears the uploadTasks array.
         * If set to false, the new file will be added to the uploadTasks and extension author should dispose it off when upload completes.
         * Default is set to true and each time a new file is selected, existing uploadTasks will be canceled and removed from uploadTasks observable array.
         */
        cancelAllUploadsOnFileSelection: KnockoutObservableBase<boolean>;
        /**
         * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress and content.
         * UploadTask is used to initiate the file upload, resume steaming uploads, cancel and dispose the file upload.
         */
        uploadTasks: KnockoutObservableArray<UploadTaskContract>;
    }
    /**
     * API to get the list of upload information for given set of upload keys and/or category id.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return A promise which contains the array of upload information.
     */
    function getUploadInfos(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: UploadKey[], category?: string): MsPortalFx.Base.PromiseV<UploadInfoContract[]>;
    /**
     * API to get the list of resumable upload information for given set of upload keys and/or category id.
     * In the event of browser refresh or close/open, list of ongoing / crashed uploads can be fetched by the getResumableUploadInfos API.
     * An opt-in resumable option should be enabled to track file upload information across browser session/refresh.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the resumable upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return A promise which contains the array of resumable upload information.
     */
    function getResumableUploadInfos(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: UploadKey[], category?: string): MsPortalFx.Base.PromiseV<UploadInfoContract[]>;
    /**
     * API to get the list of AsyncUploadTask for given set of upload keys and/or category id.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return Promise which contains the array of AsyncUploadTask objects.
     */
    function getAsyncUploadTasks(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: UploadKey[], category?: string): MsPortalFx.Base.PromiseV<AsyncUploadTaskContract[]>;
    /**
     * API to perform Resume/Pause/Cancel/Dispose action on an existing async upload task in shell.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param action Management operation like Resume/Pause/Cancel/Dispose.
     * @param context Optionally pass in action specific context like ResumeContext, AbortContext, DisposeContext or ChunkContext.
     * @return A promise indicating success or failure of the management operation.
     */
    function invokeUploadAction<TResult>(uploadKey: UploadKey, action: UploadAction, context?: ActionContext): MsPortalFx.Base.PromiseV<TResult>;
    /**
     * API to get next file chunk for asyncronous streaming upload.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param startByte  Optionally specify the start byte offset.
     * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
     * @return A promise indicating success or failure of the operation.
     */
    function getNextChunk(uploadKey: UploadKey, startByte?: number, chunkSize?: number): MsPortalFx.Base.PromiseV<StreamFileUploadContent>;
    /**
     * Full file upload context.
     */
    class FullFileUploadContext implements UploadContext {
        /**
         * Full file will be read and the entire content will be available in memory.
         */
        type: UploadType;
        /**
         * File content will be stored by default in an array buffer.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding: string;
        /**
         * Specify the maximum file size that can be uploaded.
         * Recommended max file is less than 2 MB for this upload type.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded.
         * Default chunk size should be same as maxFileSize for fill file download.
         */
        chunkSize: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications: boolean;
    }
    /**
     * Stream file upload context. File will be read in chunks and chunked content will be available in memory.
     */
    class StreamFileUploadContext extends FullFileUploadContext implements UploadContext {
        /**
         * Initialize default properties for stream file upload context.
         */
        constructor();
    }
    /**
     * BlobStore file upload context. File will be uploaded directly to blob store specified by the SAS uri.
     */
    class BlobStoreFileUploadContext<T> extends FullFileUploadContext implements UploadContext {
        /**
         * Sas uri command context that will be passed to the execute method of the sasUriCommand.
         * User can optionally set the needed context before starting the file upload.
         */
        context: KnockoutObservableBase<T>;
        /**
        * If this property is set to true, FileInfoContract object will be passed to Sas uri command.
        * In a multi-select sceanrio, extension authors may want to generate unique file level SAS uri and can use the file name provided in the context.
        * If this property is set to false, user provided context information will be passed.
        * By default this options is set to true and FileInfoContract object will be passed.
        */
        useDefaultFileInfoContext: KnockoutObservableBase<boolean>;
        /**
         * Specify the command to fetch the SAS uri for the target blob store where file will be uploaded.
         * Execute method on the command should provide the SAS uri with correct permissions and calculate the expiration time from the time it was invoked.
         */
        sasUriCommand: KnockoutObservableBase<MsPortalFx.ViewModels.Commands.Command<T>>;
        /**
         * Optionally specify if SAS uri should be updated with selected file name.
         * By default, the unique blob SAS uri is expected. If the extension provides container SAS uri or account SAS uri and
         * need to include the selected filename, set this property to be true.
         */
        addFilenameToSasUri: KnockoutObservable<boolean>;
        /**
         * Initialize default properties for blob store file upload context.
         */
        constructor();
    }
    /**
     * UploadTask represent the file details, status, upload progress and content.
     */
    class UploadTask implements UploadTaskContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * The object representing the uploaded status/content for this file.
         */
        uploadResult: KnockoutObservableBase<UploadResult>;
        /**
         * An internal enum to track the upload action.
         */
        _msPortalFxUploadAction: KnockoutObservableBase<UploadAction>;
        /**
         * An internal counter to track the upload action.
         */
        _msPortalFxActionTrigger: KnockoutObservableBase<number>;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         */
        resume(): void;
        /**
         * Method to pause the current file upload.
         */
        pause(): void;
        /**
         * Method to cancel the current file upload.
         */
        cancel(): void;
        /**
         * Method to dispose the current file upload. Dispose will cacel the ongoing upload and will do the needed cleanup.
         */
        dispose(): void;
    }
    /**
     * AsyncUploadTask represent the upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     * AsyncUploadTask instance will be returned when getAsyncUploadTasks is called by extension.
     * AsyncUploadTask interacts directly with the shell APIs exposed to interact with global file upload manager.
     */
    class AsyncUploadTask implements AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Creates and instance of AsyncUploadTask.
         *
         * @param uploadInfo Upload information.
         */
        constructor(uploadInfo: UploadInfoContract);
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @return Promise indicating the success or failure or the operation.
         */
        resume(context?: ResumeContext): FxPromise;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        pause(): FxPromise;
        /**
         * Method to cancel the current file upload.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        cancel(): FxPromise;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        complete(): FxPromise;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @return Promise indicating the success or failure or the operation.
         */
        abort(context?: AbortContext): FxPromise;
        /**
         * Method to dispose the current file upload. Dispose will cancel the ongoing upload and will do the needed cleanup.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        dispose(): FxPromise;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @return Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk(startByte?: number, chunkSize?: number): FxPromiseV<StreamFileUploadContent>;
    }
    /**
     * AsyncUploadWidgetTask represent the upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     * AsyncUploadWidgetTask is used by the upload widget to manage temprorary UX interaction around file selection.
     * The management operations supported by AsyncUploadWidgetTask will go through the widget and widget will delegate the call to global upload manager.
     */
    class AsyncUploadWidgetTask implements AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Callback to handle upload management operations. The callback is populated by the upload widget which will then delegate the needed action to the global upload manager.
         */
        _msPortalFxActionCallback: KnockoutObservableBase<UploadActionCallback>;
        /**
         * Callback to handle streaming uploads to fetch the next file chunk.
         */
        _msPortalFxGetNextChunkCallback: KnockoutObservableBase<GetNextChunkCallback>;
        /**
         * Creates and instance of AsyncUploadTask.
         *
         * @param uploadInfo Upload information.
         * @param uploadActionCallback Callback to invoke management operation on the upload widget.
         */
        constructor(uploadInfo: UploadInfoContract, uploadActionCallback: UploadActionCallback, getNextChunkCallback: GetNextChunkCallback);
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @return Promise indicating the success or failure of the operation.
         */
        resume(context?: ResumeContext): FxPromise;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        pause(): FxPromise;
        /**
         * Method to cancel the current file upload.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        cancel(): FxPromise;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        complete(): FxPromise;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @return Promise indicating the success or failure or the operation.
         */
        abort(context?: AbortContext): FxPromise;
        /**
         * Method to dispose the current file upload. Dispose will abort the ongoing upload and will do the needed cleanup.
         *
         * @return Promise indicating the success or failure or the operation.
         */
        dispose(): FxPromise;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @return Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk(startByte?: number, chunkSize?: number): FxPromiseV<StreamFileUploadContent>;
        private _invoke(action, context?);
    }
    /**
     * SelectedFile is the extension representation of the user selected file via browse dialog.
     * The SelectedFile has the core file properties that will be surfaced to the extension.
     * The actual file handles cannot be passed back and forth across iframe and widget / global upload manager will retain the actual handles.
     */
    class SelectedFile implements SelectedFileContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Selected file can be uploaded if valid is true.
         * valid flag can be set by the control if any of the standard validations around file size and permission issues fails. The corresponding upload task status will be set to Invalid.
         * valid flag can be set by extension based on the custom validation added by the extension.
         * If extension sets the flag to false, the corresponding upload task status will be marked as Invalid.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * Creates and instance of SelectedFile.
         *
         * @param fileInfo File information.
         */
        constructor(fileInfo: FileInfoContract);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\FileUpload\Internal\Internal.FileUpload.UploadManager.d.ts
declare module FxImpl.FileUpload {
    import FxFileUpload = MsPortalFx.ViewModels.FileUpload;
    import Rpc = MsPortalFx.Base.Rpc.Internal;
    import FxLifetime = MsPortalFx.Base.LifetimeManager;
    /**
     * Upload info params used in shell APIs to get the list of uploads.
     */
    interface UploadInfoParams {
        /**
         * Array of upload keys.
         */
        uploadKeys: FxFileUpload.UploadKey[];
        /**
         * Upload category tag provided by extension.
         */
        category?: string;
        /**
         * Get resumable upload information. This is a optional param and when set to true will get the resumable uplaod information.
         */
        resumable?: boolean;
    }
    /**
     * Upload info list.
     */
    interface UploadInfoList {
        /**
         * Array of upload infos.
         */
        uploads: FxFileUpload.UploadInfoContract[];
    }
    /**
     * Upload action params is used to specify what management operation to perform on file uploads.
     */
    interface UploadActionParams {
        /**
         * Unique upload identifier to lookup the async upload task.
         */
        uploadKey: FxFileUpload.UploadKey;
        /**
         * Upload management operation enum.
         */
        action: FxFileUpload.UploadAction;
        /**
         * Upload management action specific context information.
         */
        context?: FxFileUpload.ActionContext;
    }
    /**
     * Rpc endpoint for communicating with the shell's global file upload manager.
     * ProxiedObjectTypeDefinition is used so that upload info with observable properties can be proxied across via the acquireObject call.
     * The enpoint is used to get the list of upload information for a given set of upload keys.
     */
    var getUploadInfosEndPoint: Rpc.ProxiedObjectTypeDefinition<UploadInfoParams, UploadInfoList>;
    /**
     * Rpc endpoint for communicating with the shell's global file upload manager to perform upload management operations.
     * The endpoint is used to perform Resume/Pause/Cancel/Dispose action on an existing async upload in shell.
     */
    var uploadActionEndPoint: Rpc.ActionEndPointDefinition<UploadActionParams>;
    /**
     * API to perform Resume/Pause/Cancel/Dispose action on an existing async upload task in shell.
     * This API uses Rpc uploadActionEndPoint to communicate with the shell's global file upload manager.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param action Management operation like Resume/Pause/Cancel/Dispose.
     * @param context Optionally pass in action specific context like ResumeContext, AbortContext, DisposeContext or ChunkContext.
     * @return A promise indicating success or failure of the management operation.
     */
    function invokeUploadAction(uploadKey: FxFileUpload.UploadKey, action: FxFileUpload.UploadAction, context?: FxFileUpload.ActionContext): MsPortalFx.Base.Promise;
    /**
     * API to get the list of upload information for given set of upload keys.
     * This API uses Rpc getUploadInfosEndPoint to communicate with the shell's global file upload manager.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return A promise which contains the array of upload information.
     */
    function getUploadInfos(lifetime: FxLifetime, uploadKeys: FxFileUpload.UploadKey[], category?: string): MsPortalFx.Base.PromiseV<FxFileUpload.UploadInfoContract[]>;
    /**
     * API to get the list of resumable upload information for given set of upload keys and/or category id.
     * In the event of browser refresh or close/open, list of ongoing / crashed uploads can be fetched by the getResumableUploadInfos API.
     * An opt-in resumable option should be enabled to track file upload information across browser session/refresh.
     * This API uses Rpc getUploadInfosEndPoint to communicate with the shell's global file upload manager.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the resumable upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return A promise which contains the array of resumable upload information.
     */
    function getResumableUploadInfos(lifetime: FxLifetime, uploadKeys: FxFileUpload.UploadKey[], category?: string): MsPortalFx.Base.PromiseV<FxFileUpload.UploadInfoContract[]>;
    /**
     * API to get the list of AsyncUploadTask for given set of upload keys.
     * This API uses Rpc getUploadInfosEndPoint to communicate with the shell's global file upload manager.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @return Promise which contains the array of AsyncUploadTask objects.
     */
    function getAsyncUploadTasks(lifetime: FxLifetime, uploadKeys: FxFileUpload.UploadKey[], category?: string): MsPortalFx.Base.PromiseV<FxFileUpload.AsyncUploadTaskContract[]>;
    /**
     * API to get next file chunk for asyncronous streaming upload.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param startByte  Optionally specify the starting byte offset.
     * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
     * @return A promise indicating success or failure of the operation.
     */
    function getNextChunk(uploadKey: FxFileUpload.UploadKey, startByte?: number, chunkSize?: number): MsPortalFx.Base.PromiseV<FxFileUpload.StreamFileUploadContent>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\Base.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface TelemetryKeys {
        /**
         * Key used in focus logging
         */
        focus: string;
    }
}
declare module MsPortalFx.ViewModels.Forms.Base.Input {
    interface Options<T> extends LabelAndBalloon.Options {
        /**
         * A list of validations that should be applied to the form field.
         */
        validations?: KnockoutObservableArray<MsPortalFx.ViewModels.FormValidation>;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue?: KnockoutObservableBase<T>;
        /**
         * Keys used in telemetry logging.
         */
        telemetryKeys?: TelemetryKeys;
    }
    class ViewModel<T> extends LabelAndBalloon.ViewModel {
        /**
         * A list of validations that should be applied to the form field.
         */
        validations: KnockoutObservableArray<MsPortalFx.ViewModels.FormValidation>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent: KnockoutObservable<string>;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue: KnockoutObservableBase<T>;
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutComputed<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * Turns validation on and off for the form field.
         */
        enableValidation: KnockoutObservableBase<boolean>;
        /**
         * When changed this signals to the control validation should occur.
         */
        validate: KnockoutObservable<number>;
        /**
         * Current value of the field.
         */
        value: KnockoutObservableBase<T>;
        /**
         * Initial value for the field.
         */
        initialValue: KnockoutObservableBase<T>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         * Whether the field is enabled or not.
         */
        enabled: KnockoutObservable<boolean>;
        /**
         * Whether validation should be performed on a control. Switching to true will trigger immediate validation.
         */
        performValidation: KnockoutObservable<boolean>;
        /**
         * When changed triggers validation on the field if it has not been run.
         */
        ensureValidation: KnockoutObservable<number>;
        /**
         * Keys used in telemetry logging
         */
        telemetryKeys: TelemetryKeys;
        /**
         * ****** DEPRECATED ******
         * Pass in the EditScopeAccessor into the constructor of your field instead of calling this method.  This method will be internal in the future.
         * ************************
         */
        setFieldValueAccessors: Obsolete;
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        _msPortalFxTriggerValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        _enableValidationReactor: KnockoutComputed<void>;
        _options: Base.Input.Options<T>;
        private _editScopeAccessors;
        private _form;
        private _previousEditScope;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the Field is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the Field control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, formOrOptions: Form.ViewModel<any>, pathOrAccessor: any, options?: Options<T>);
        /**
         * Set the EditScopeAccessors used to integrate with EditScope for original and edited values.
         * Note: In most cases, it's best to use the observablePath parameter when instantiating a field, which
         *  will automatically configure the field with EditScopeAccessors. Use this override only if you know what you're doing.
         *
         * @param editScopeAccessors The EditScopeAccessors instance to be used for the original and edited values of this field.
         * @param form Optional. The form whose edit scope drives the editScopeAccessors (if one exists).
         */
        _setEditScopeAccessors(editScopeAccessors: EditScopeAccessors<T>, form?: Form.ViewModel<T>): void;
        /**
         * Clears validation on the field.
         * @return A promise that is resolved when the validation has been cleared.
         */
        clearValidation(): MsPortalFx.Base.Promise;
        /**
         * A helper function for triggering validation of the control.
         * @return A promise that is resolved when the validation has been completed.
         */
        triggerValidation(): MsPortalFx.Base.Promise;
        private _initializeFieldStateObservables();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\Editable.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Editable {
    interface Options<T> extends Input.Options<T> {
        /**
            * Text displayed in the field when the form value is empty.
            */
        emptyValueText?: KnockoutObservable<string>;
    }
    class ViewModel<T> extends Nullable.ViewModel<T> {
        /**
         * Text displayed in the field when the form value is empty.
         */
        emptyValueText: KnockoutObservable<string>;
        /**
         * Whether the field is currently being edited.
         */
        editing: KnockoutObservable<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the EditableField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the EditableField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Editable.Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\EditableComboBox.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.EditableComboBox {
    import EditableCombo = MsPortalFx.ViewModels.Controls.Forms.EditableCombo;
    import PositioningAlignment = EditableCombo.PositioningAlignment;
    interface Options<T> extends Editable.Options<T> {
        /**
         * Alignment used for drop popup.
         */
        popupAlignment?: PositioningAlignment;
        /**
         * Alignment used for input.
         */
        inputAlignment?: PositioningAlignment;
        /**
         * Deprecated
         * Width behavior of the drop popup.
         */
        dropDownWidth?: KnockoutObservable<Obsolete>;
    }
    /**
     * Base class for combo fields using EditableCombo.
     */
    class ViewModel<T> extends Editable.ViewModel<T> {
        /**
         * Alignment used for drop popup.
         */
        popupAlignment: PositioningAlignment;
        /**
         * Alignment used for input.
         */
        inputAlignment: PositioningAlignment;
        /**
         * Deprecated
         * Width behavior of the drop popup.
         */
        dropDownWidth: KnockoutObservable<Obsolete>;
        /**
         * Constructs and instance of an editable combo field.
         * (Base class for other combo fields)
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the EditableField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the EditableComboField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: EditableComboBox.Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\EditScopeAccessors.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface EditScopeAccessors<TValue> extends MsPortalFx.Data.EditScopeAccessors<TValue> {
    }
    module EditScopeAccessors {
        /**
          * Describes how to read and write values on an edit scope.
          */
        interface Options<TEditScope, TValue> {
            /**
             * Reads data from an edit scope.
             *
             * @param editScopeData The root data object held by the edit scope.
             * @return The value that this edit scope accessor supplies.
             */
            readFromEditScope: (editScopeData: TEditScope) => TValue;
            /**
             * Writes data to an edit scope.
             *
             * @param editScopeData The root data object held by the edit scope. This method should write the new value to this object.
             * @param newValue The value to be written. Typically this comes from a UI element whose value has changed.
             */
            writeToEditScope: (editScopeData: TEditScope, newValue: TValue) => void;
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\Form.d.ts
declare module MsPortalFx.ViewModels.Forms.Form {
    enum EditScopeObservableType {
        Original = 0,
        Editable = 1,
    }
    /**
     * ****** DEPRECATED ******
     * Instead use EditScopeObservableType.
     * This type will be removed in the future.
     * ************************
     */
    type FieldValueAccessorType = EditScopeObservableType;
    interface InternalEditScopeAccessors extends EditScopeAccessors<any>, FxImpl.Data.InternalEditScopeAccessors {
        createdByBaseFormClass: boolean;
    }
    /**
     * The function type for those lambdas that are passed to Form's 'createEditScopeAccessor' and 'createCustomEditScopeAccessor'.
     * See Form.createEditScopeAccessor and Form.createCustomEditScopeAccessor.
     */
    interface ObservableAccessorFunction<T, TValue> {
        (data: T, lifetimeManager: MsPortalFx.Base.LifetimeManager, type: EditScopeObservableType): KnockoutObservableBase<TValue>;
    }
    /**
     * A view model representing a form.
     */
    class ViewModel<T> implements MsPortalFx.Base.Disposable {
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutComputed<boolean>;
        /**
         * The list of form sections contained in the form.
         */
        sections: KnockoutObservableArray<Base.Section>;
        /**
         * ****** DEPRECATED ******
         * Instead use createEditScopeAccessor when calling constructors of form fields.
         * This method will be removed in the future.
         * ************************
         *
         * Creates accessor functions used by a form field to retrieve observables that reflect original and editable
         * values for the field.
         *
         * @param observableAccessor A function which accesses the observable for the field value.
         * @return FormFieldValueAccessors Accessor functions used by a form field.
         */
        createFieldValueAccessor: Obsolete;
        private _editScope;
        private _getNestedData;
        private _lifetimeManager;
        /**
         * Creates a Form instance.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param editScope An optional observable that supplies an EditScope to the form (for instance, as master
         * selection changes for this details form).  If not supplied here, then the 'editScope' property should be set
         * before using this view model.
         * @param getNestedData An optional function that returns a nested object from which fields will be retrieved,
         * given either the original or editable root object of the EditScope.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, editScope?: KnockoutObservable<MsPortalFx.Data.EditScope<any>>, getNestedData?: (data: any) => T);
        /**
         * Gets the view model's edit scope observable.
         *
         * @return The view model's edit scope observable.
         */
        /**
         * Sets the view model's edit scope observable.
         *
         * @param editScope An observable that supplies an EditScope to the form (for instance, as master selection
         * changes for this details form).
         */
        editScope: KnockoutObservable<MsPortalFx.Data.EditScope<any>>;
        /**
         * See interface.
         */
        dispose(): void;
        _createEditScopeAccessorFromPath<TValue>(observablePath: string): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is used by both forms fields and collectors.
         *
         * @param options Methods for reading and writing to an edit scope.
         * @return EditScopeAccessors instance used by a form field and/or by collectors.
         */
        createEditScopeAccessor<TValue>(options: EditScopeAccessors.Options<T, TValue>): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is used by both forms fields and collectors.
         *
         * @param observableAccessor A function which accesses a property on the edit scope.  ie: (data) => { return data.myProperty }
         * @return EditScopeAccessors instance used by a form field and/or by collectors.
         */
        createEditScopeAccessor<TValue>(observableAccessor: ObservableAccessorFunction<T, TValue>): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is an advanced option without runtime validation of the options passed in.
         * Use createEditScopeAccessor instead of this method wherever possible.
         *
         * @param options Methods for reading and writing to an edit scope.
         * @return EditScopeAccessors instance used by a form field.
         */
        createCustomEditScopeAccessor<TValue>(options: EditScopeAccessors.Options<T, TValue>): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is an advanced option without runtime validation of the observableAccessor lambda.
         * Use createEditScopeAccessor instead of this method wherever possible
         *
         * @param observableAccessor A function which accesses the observable.
         * @return EditScopeAccessors instance used by a form field.
         */
        createCustomEditScopeAccessor<TValue>(observableAccessor: ObservableAccessorFunction<T, TValue>): EditScopeAccessors<TValue>;
        _sanitizeAccessorFunction<TValue>(accessor: ObservableAccessorFunction<T, TValue>): ObservableAccessorFunction<T, TValue>;
        _sanitizeAccessorOptions<TValue>(options: EditScopeAccessors.Options<T, TValue>): EditScopeAccessors.Options<T, TValue>;
        _sanitizeAccessorLambda(lambda: Function): any;
        private static _logEditScopeAccessorError(message);
        private _createEditScopeAccessorFromAccessorFunction<TValue>(observableAccessor, returnsObservablesFromEditScope);
        private _createEditScopeAccessorFromOptions<TValue>(options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\Groups.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Groups {
    interface Options<T> extends Input.Options<T> {
        /**
         * A list of groups to categorize the selectable options.
         * Dynamic update of groups array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        groups: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IGroup<T>>;
    }
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * A list of groups to categorize the selectable options.
         * Dynamic update of groups array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        groups: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IGroup<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the GroupsField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the GroupsField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Groups.Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\LabelAndBalloon.d.ts
declare module MsPortalFx.ViewModels.Forms {
    import FxVM = MsPortalFx.ViewModels;
    import FxForms = FxVM.Forms;
    /**
     * The position of the label in a form element.
     * Note: Only works within Sections. Check samples here: http://localhost:55555/Portal/#blade/SamplesExtension/LabelPositionFormsBlade
     */
    enum LabelPosition {
        /**
         * A top aligned label. Default.
         */
        Top = 0,
        /**
         * A left aligned label.
         */
        Left = 1,
        /**
         * An invisible label.
         */
        Hidden = 2,
    }
    /**
     * The position of the sublabel in a form element.
     */
    enum SubLabelPosition {
        /**
         * A Bottom aligned sublabel. Default.
         */
        Bottom = 0,
        /**
         * A right aligned sublabel.
         */
        Right = 1,
    }
    module Base.LabelAndBalloon {
        /**
         * Options to render a form element with a label and info balloon.
         */
        interface Options {
            /**
             * Label for the field.
             */
            label?: KnockoutObservable<string>;
            /**
             * Label position for the field.
             */
            labelPosition?: KnockoutObservable<FxForms.LabelPosition>;
            /**
             * SubLabel position for the field.
             */
            subLabelPosition?: KnockoutObservable<FxForms.SubLabelPosition>;
            /**
             * SubLabel for the field.
             */
            subLabel?: KnockoutObservableBase<string> | string;
            /**
             * Specifies sanitized HTML that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonContent?: KnockoutObservable<string>;
            /**
             * Specifies Link object that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonLinkContent?: KnockoutObservable<MsPortalFx.ViewModels.Controls.Balloon.Link>;
            /**
              * Specifies whether to hide the validation check marks.
              */
            hideValidationCheck?: KnockoutObservableBase<boolean> | boolean;
        }
        /**
         * Implements LabelAndBalloonContract.
         */
        class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel {
            /**
             * Label for the field.
             */
            label: KnockoutObservable<string>;
            /**
             * Label for the field.
             */
            labelPosition: KnockoutObservable<FxForms.LabelPosition>;
            /**
             * SubLabel for the field.
             */
            subLabelPosition: KnockoutObservable<FxForms.SubLabelPosition>;
            /**
             * SubLabel for the field.
             */
            subLabel: KnockoutObservableBase<string> | string;
            /**
             * Specifies text that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonContent: KnockoutObservable<string>;
            /**
             * Specifies Link object that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonLinkContent: KnockoutObservable<MsPortalFx.ViewModels.Controls.Balloon.Link>;
            /**
             * Specifies whether to hide the validation check marks.
             */
            hideValidationCheck: KnockoutObservableBase<boolean> | boolean;
            /**
             * Abstract base class. Do not use this class directly.
             *
             * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
             * @param label Optional. Text for the label for this form field.
             * @param infoBalloonContent Optional. A list of validations to be applied to the field.
             */
            constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: LabelAndBalloon.Options);
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\Nullable.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Nullable {
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * Whether the field is empty.
         */
        empty: KnockoutComputed<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the NullableField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the NullableField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Editable.Options<T>);
        dispose(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\Options.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Options {
    interface Options<T> extends Input.Options<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options?: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IDisablableOption<T>>;
    }
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IDisablableOption<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OptionsField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the OptionsField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Options.Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\SectionBase.d.ts
declare module MsPortalFx.ViewModels.Forms.Base {
    interface Section extends FormElement {
        /**
         * Indicates if the sections or controls within the widget are currently valid.
         */
        valid: KnockoutObservableBase<boolean>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\SliderBase.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Slider {
    interface Options<T> extends Base.Input.Options<T> {
        /**
        * Minimum value of the slider.
        */
        min?: KnockoutObservableBase<number>;
        /**
         * Maximum value of the slider.
         */
        max?: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step?: KnockoutObservableBase<number>;
        /**
         * Displays a marker for each step.
         */
        showStepMarkers?: KnockoutObservableBase<boolean>;
    }
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * Minimum value for the field.
         */
        min: KnockoutObservableBase<number>;
        /**
         * Maximum value for the field.
         */
        max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step: KnockoutObservableBase<number>;
        /**
         * Whether to show step markers on the slider field.
         */
        showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Constructs an instance of a slider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SliderBaseField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the SliderBaseField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Base\Typable.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Typable {
    interface Options<T> extends Editable.Options<T> {
        /**
         * When value update trigger is set to fire on every keypress this is the timeout between value updates before validation runs.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout?: KnockoutObservable<number>;
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger?: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
    }
    class ViewModel<T> extends Editable.ViewModel<T> {
        /**
         * When value update trigger is set to fire on every keypress this is the timeout between value updates before validation runs.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the EditableField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the EditableField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Typable.Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\CheckBox.d.ts
declare module MsPortalFx.ViewModels.Forms.CheckBox {
    interface Options extends Base.Input.Options<boolean> {
        /**
         * Display the label inline with the checkbox.
         */
        inlineLabel?: boolean;
    }
    class ViewModel extends Base.Input.ViewModel<boolean> {
        /**
         * Display the label inline with the checkbox.
         */
        inlineLabel: boolean;
        /**
         * Constructs a standalone instance of a CheckBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: CheckBox.Options);
        /**
         * Constructs an instance of a CheckBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CheckBoxField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: CheckBox.Options);
        /**
         * Constructs an instance of a CheckBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CheckBoxField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<boolean>, options?: CheckBox.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\CreatorAndComboBox.d.ts
declare module FxImpl.ViewModels.Forms.CreatorAndComboBox {
    import FxForms = MsPortalFx.ViewModels.Forms;
    import FxOptionsGroup = FxForms.OptionsGroup;
    import FxFilterComboBox = FxForms.FilterComboBox;
    import FxSection = FxForms.Section;
    /**
     * The mode of the dropdown
     */
    enum Mode {
        UseExisting = 0,
        CreateNew = 1,
    }
    /**
     * The allowed mode of the dropdown
     */
    enum AllowedMode {
        UseExisting = 0,
        CreateNew = 1,
        Both = 2,
    }
    /**
     * Options for the CreatorAndComboBox control viewmodel
     */
    interface Options extends FxSection.Options {
        /**
         * Options for the filter combo box
         */
        filterComboOptions: FxFilterComboBox.Options;
        /**
         * The form for the control
         */
        form?: FxForms.Form.ViewModel<any>;
        /**
         * Value accessor to place the value into.
         */
        accessor?: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>;
        /**
         * The mode allowed for the resource group dropdown
         */
        allowedMode?: KnockoutObservableBase<AllowedMode>;
    }
    /**
     * A filter ComboBox combined with a create form and an extra option inserted into the options
     * to activate that create section
     */
    class ViewModel extends FxSection.ViewModel {
        /**
         * The dropdown control
         */
        control: FxFilterComboBox.ViewModel;
        /**
         * The Options group control
         */
        createOrSelectControl: FxOptionsGroup.ViewModel<boolean>;
        /**
         * Specifies if you can create new or use existing resource groups, or both in this control
         */
        allowedMode: KnockoutObservableBase<AllowedMode>;
        private _newSection;
        private _selectSection;
        private _options;
        /**
         * Constructs an instance of a CreatorAndComboBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the FilterComboField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
        /**
         * Switch the control between create new and use existing
         * @param createNew parameter to directly set the option selected instead of toggle.
         */
        toggleNewOrExisting(mode?: Mode): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\CreatorAndSelector.d.ts
declare module MsPortalFx.ViewModels.Forms.CreatorAndSelector {
    enum Mode {
        /**
         * Shows text box only.
         */
        CreateOnly = 0,
        /**
         * Shows selector only.
         */
        SelectOnly = 1,
        /**
         * Shows textbox or selector along with toggle link.
         */
        CreateOrSelect = 2,
    }
    interface Options<T> extends Selector.Options<T> {
        /**
        * True if displaying creator, false for selector
        */
        createNew?: KnockoutObservableBase<boolean>;
        /**
         * Textbox label: label displayed with the textbox in creator mode
         */
        textBoxLabel?: KnockoutObservableBase<string>;
        /**
         * Link text for select existing option
         */
        selectExistingLinkDisplayText?: KnockoutObservableBase<string>;
        /**
         * Link text for create new option
         */
        createNewLinkDisplayText?: KnockoutObservableBase<string>;
        /**
         * Display mode
         */
        displayMode?: KnockoutObservableBase<Mode>;
        /**
         * Value update mode
         */
        valueUpdateTrigger?: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
    }
    class ViewModel<T> extends Selector.ViewModel<T> {
        /**
         * True if displaying creator, false for selector
         */
        createNew: KnockoutObservableBase<boolean>;
        /**
         * Textbox label: label displayed with the textbox in creator mode
         */
        textBoxLabel: KnockoutObservableBase<string>;
        /**
         * Link text for select existing option
         */
        selectExistingLinkDisplayText: KnockoutObservableBase<string>;
        /**
         * Link text for create new option
         */
        createNewLinkDisplayText: KnockoutObservableBase<string>;
        /**
         * Display mode
         */
        displayMode: KnockoutObservableBase<Mode>;
        /**
         * Value update trigger for underlying textbox.
         */
        valueUpdateTrigger: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
        /**
         * Constructs a standalone instance of a CreatorAndSelector form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: CreatorAndSelector.Options<T>);
        /**
         * Constructs an instance of a CreatorAndSelector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: CreatorAndSelector.Options<T>);
        /**
         * Constructs an instance of a CreatorAndSelector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<T>, options?: CreatorAndSelector.Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\CreatorAndSelectorV2.d.ts
declare module MsPortalFx.ViewModels.Forms.CreatorAndSelectorV2 {
    interface CreatorAndSelectorValue {
        /**
         * Text box value or selected value
         */
        value: any;
        /**
         * True if displaying creator, false for selector
         */
        createNew: boolean;
    }
    enum Mode {
        /**
         * Shows text box only.
         */
        CreateOnly = 0,
        /**
         * Shows selector only.
         */
        SelectOnly = 1,
        /**
         * Shows textbox or selector along with toggle link.
         */
        CreateOrSelect = 2,
    }
    interface Options extends Selector.Options<CreatorAndSelectorValue> {
        /**
         * Textbox label: label displayed with the textbox in creator mode
         */
        textBoxLabel?: KnockoutObservableBase<string>;
        /**
         * Link text for select existing option
         */
        selectExistingLinkDisplayText?: KnockoutObservableBase<string>;
        /**
         * Link text for create new option
         */
        createNewLinkDisplayText?: KnockoutObservableBase<string>;
        /**
         * Display mode
         */
        displayMode?: KnockoutObservableBase<Mode>;
        /**
         * Value update mode
         */
        valueUpdateTrigger?: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
    }
    class ViewModel extends Selector.ViewModel<CreatorAndSelectorValue> {
        /**
         * Textbox label: label displayed with the textbox in creator mode
         */
        textBoxLabel: KnockoutObservableBase<string>;
        /**
         * Link text for select existing option
         */
        selectExistingLinkDisplayText: KnockoutObservableBase<string>;
        /**
         * Link text for create new option
         */
        createNewLinkDisplayText: KnockoutObservableBase<string>;
        /**
         * Display mode
         */
        displayMode: KnockoutObservableBase<Mode>;
        /**
         * Value update trigger for underlying textbox.
         */
        valueUpdateTrigger: MsPortalFx.ViewModels.Controls.ValueUpdateTrigger;
        /**
         * Constructs a standalone instance of a CreatorAndSelector form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: CreatorAndSelectorV2.Options);
        /**
         * Constructs an instance of a CreatorAndSelector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: CreatorAndSelectorV2.Options);
        /**
         * Constructs an instance of a CreatorAndSelector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<CreatorAndSelectorValue>, options?: CreatorAndSelectorV2.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\CustomHtml.d.ts
declare module MsPortalFx.ViewModels.Forms.CustomHtml {
    /**
     * Options describing the behavior of custom html form elements.
     */
    interface Options extends Base.LabelAndBalloon.Options {
        /**
         * The html template to display as the body of the form.
         */
        htmlTemplate: KnockoutObservable<string> | string;
        /**
         * The object to bind to the template.
         */
        innerViewModel?: any;
        /**
         * Uses a new binding context for the template such that $root is innerViewModel instead of the part view model.
         * Defaults to true.
         */
        isolated?: boolean;
    }
    /**
     * CustomHtml form element view model.
     */
    class ViewModel extends Base.LabelAndBalloon.ViewModel {
        /**
         * An html template.  value is the object that is bound to this template.
         */
        htmlTemplate: KnockoutObservable<string>;
        /**
         * The object to bind to the template.
         */
        innerViewModel: any;
        /**
         * Uses a new binding context for the template such that $root is innerViewModel instead of the part view model.
         */
        isolated: boolean;
        /**
         * Validity of entries in this form element.  This is set to true if all child form elements are valid, and false otherwise.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * Determines if the field is currently loading.  Defaults to false.
         */
        loading: KnockoutObservable<boolean>;
        /**
         * The type of the form element.
         */
        type: MsPortalFx.ViewModels.ControlType;
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * When changed forces validation on the field.
         */
        validate: KnockoutObservable<number>;
        /**
         * Internal view model property.
         */
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        _msPortalFxTriggerValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Constructs a standalone instance of a CustomHtml form element.
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the CustomHtmlField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: CustomHtml.Options);
        /**
         * Clears validation on the field.
         * @return A promise that is resolved when the validation has been cleared.
         */
        clearValidation(): MsPortalFx.Base.Promise;
        /**
         * Triggers validation on the field.
         * @return A promise that is resolved when the validation has been triggered.
         */
        triggerValidation(): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\CustomRangeSlider.d.ts
declare module MsPortalFx.ViewModels.Forms.CustomRangeSlider {
    interface Options extends Base.Input.Options<string> {
        /**
         * Displays a marker for each step.
         */
        showStepMarkers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Custom slider clickstop values.
         */
        customValues: number[] | KnockoutObservableBase<number[]>;
    }
    class ViewModel extends Base.Input.ViewModel<string> {
        /**
       * Value separator for combining the range into a single string value. For example, "2;6". Default is ";".
       */
        valueSeparator: string;
        /**
         * Whether to show step markers on the slider field.
         */
        showStepMarkers: boolean | KnockoutObservableBase<boolean>;
        /**
         * Custom slider clickstop values.
         */
        customValues: number[] | KnockoutObservableBase<number[]>;
        /**
         * Start value of the range.
         */
        start: KnockoutObservableBase<number>;
        /**
         * End value of the range.
         */
        end: KnockoutObservableBase<number>;
        /**
         * Constructs a standalone instance of a CustomValueSlider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the CustomValueSlider control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: CustomRangeSlider.Options);
        /**
         * Constructs an instance of a CustomValueSlider form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CustomValueSlider is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the CustomValueSlider control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: CustomRangeSlider.Options);
        /**
         * Constructs an instance of a CustomValueSlider form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CustomValueSlider is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the CustomValueSlider control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: CustomRangeSlider.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\CustomValueSlider.d.ts
declare module MsPortalFx.ViewModels.Forms.CustomValueSlider {
    interface Options extends Base.Input.Options<number> {
        /**
         * Displays a marker for each step.
         */
        showStepMarkers?: KnockoutObservableBase<boolean>;
        /**
         * Custom slider clickstop values.
         */
        customValues?: KnockoutObservableBase<Array<number>>;
    }
    class ViewModel extends Base.Input.ViewModel<number> {
        /**
         * Whether to show step markers on the slider field.
         */
        showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Custom slider clickstop values.
         */
        customValues: KnockoutObservableBase<number[]>;
        /**
         * Constructs a standalone instance of a CustomValueSlider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the CustomValueSlider control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: CustomValueSlider.Options);
        /**
         * Constructs an instance of a CustomValueSlider form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CustomValueSlider is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the CustomValueSlider control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: CustomValueSlider.Options);
        /**
         * Constructs an instance of a CustomValueSlider form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CustomValueSlider is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the CustomValueSlider control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<number>, options?: CustomValueSlider.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\DatePicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DatePicker {
    import FxLifetimeManager = MsPortalFx.Base.LifetimeManager;
    interface Options extends Base.EditableComboBox.Options<Date> {
        /**
         * A valid format string specifier (see DateUtil format), used to format the value.
         */
        formatString?: KnockoutObservable<string>;
        /**
         * Date/time range in which user is able to select date.
         */
        enabledDateTimeRange?: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
        * Whether the control should allow empty(null) value as valid.
        */
        allowEmpty?: boolean;
    }
    class ViewModel extends Base.EditableComboBox.ViewModel<Date> {
        /**
         * Date/time range in which user is able to select date.
         */
        enabledDateTimeRange: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty: boolean;
        /**
         * Constructs a standalone instance of a DatePicker form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DatePicker control.
         */
        constructor(lifetimeManager: FxLifetimeManager, options?: DatePicker.Options);
        /**
         * Constructs an instance of a DatePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DatePicker is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DatePicker control.
         */
        constructor(lifetimeManager: FxLifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: DatePicker.Options);
        /**
         * Constructs an instance of a DatePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DatePicker is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DatePicker control.
         */
        constructor(lifetimeManager: FxLifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<Date>, options?: DatePicker.Options);
        _setEditScopeAccessors(fieldValueAccessors: EditScopeAccessors<Date>): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\DateTimeComboBox.d.ts
declare module MsPortalFx.ViewModels.Obsolete.Forms.DateTimeComboBox {
    interface Options extends MsPortalFx.ViewModels.Forms.Base.EditableComboBox.Options<Date> {
        /**
         * A valid format string specifier (see date.format polyfill), used to format the value.
         */
        formatString?: KnockoutObservable<string>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange?: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
    }
    class ViewModel extends MsPortalFx.ViewModels.Forms.Base.EditableComboBox.ViewModel<Date> {
        /**
         * A valid format string specifier (see date.format polyfill), used to format the value.
         */
        formatString: KnockoutObservable<string>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Constructs a standalone instance of a DateTimeComboBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DateTimeComboField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: DateTimeComboBox.Options);
        /**
         * Constructs an instance of a DateTimeComboBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DateTimeComboField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DateTimeComboField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: MsPortalFx.ViewModels.Forms.Form.ViewModel<any>, observablePath: string, options?: DateTimeComboBox.Options);
        /**
         * Constructs an instance of a DateTimeComboBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DateTimeComboField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DateTimeComboField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: MsPortalFx.ViewModels.Forms.Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<Date>, options?: DateTimeComboBox.Options);
        _setEditScopeAccessors(fieldValueAccessors: MsPortalFx.ViewModels.Forms.EditScopeAccessors<Date>, form?: MsPortalFx.ViewModels.Forms.Form.ViewModel<Date>): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\DateTimePicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DateTimePicker {
    interface Options extends Base.EditableComboBox.Options<Date> {
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange?: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        showTimezoneDropdown?: KnockoutObservable<boolean>;
        /**
         * Timezone offset.
         */
        timezoneOffset?: KnockoutObservable<number>;
        /**
        * Whether the control should allow empty(null) value as valid.
        */
        allowEmpty?: boolean;
        /**
         * Empty value text for time.
         */
        emptyTimeValueText?: KnockoutObservable<string>;
        /**
         * If true displays hours, minutes, and seconds. If false displays only hours and minutes.
         */
        showSeconds?: boolean;
    }
    class ViewModel extends Base.EditableComboBox.ViewModel<Date> {
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        showTimezoneDropdown: KnockoutObservable<boolean>;
        /**
         * Dropdown for timezones.
         */
        timezoneOffset: KnockoutObservable<number>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty: boolean;
        /**
         * Empty value text for time.
         */
        emptyTimeValueText: KnockoutObservable<string>;
        /**
         * If true displays hours, minutes, and seconds. If false displays only hours and minutes.
         */
        showSeconds: boolean;
        /**
         * Constructs a standalone instance of a DateTimePicker form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DateTimePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: DateTimePicker.Options);
        /**
         * Constructs an instance of a DateTimePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DateTimePicker is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DateTimePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: DateTimePicker.Options);
        /**
         * Constructs an instance of a DateTimePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DateTimePicker is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DateTimePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<Date>, options?: DateTimePicker.Options);
        _setEditScopeAccessors(fieldValueAccessors: EditScopeAccessors<Date>): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\DateTimeRangePicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DateTimeRangePicker {
    interface Options extends Base.EditableComboBox.Options<DateUtil.DateTimeRange> {
        /**
         * Enabled range for start date/time
         */
        startDateTimeEnabledRange?: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Enabled range for end date/time
         */
        endDateTimeEnabledRange?: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        showTimezoneDropdown?: KnockoutObservable<boolean>;
        /**
         * Timezone offset.
         */
        timezoneOffset?: KnockoutObservable<number>;
        /**
         * Display start/end date/time fields inline (false by default).
         */
        displayFieldsInline?: KnockoutObservable<boolean>;
    }
    class ViewModel extends Base.EditableComboBox.ViewModel<DateUtil.DateTimeRange> {
        /**
         * Enabled range for start date/time
         */
        startDateTimeEnabledRange: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Enabled range for end date/time
         */
        endDateTimeEnabledRange: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        showTimezoneDropdown: KnockoutObservable<boolean>;
        /**
         * Dropdown for timezones.
         */
        timezoneOffset: KnockoutObservable<number>;
        /**
         * Display start/end date/time fields inline (false by default).
         */
        displayFieldsInline: KnockoutObservable<boolean>;
        /**
         * Constructs a standalone instance of a DateTimeRangePicker form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DateTimeRangePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: DateTimeRangePicker.Options);
        /**
         * Constructs an instance of a DateTimeRangePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DateTimeRangePicker is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DateTimeRangePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: DateTimeRangePicker.Options);
        /**
         * Constructs an instance of a DateTimeRangePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DateTimeRangePicker is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DateTimeRangePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<DateUtil.DateTimeRange>, options?: DateTimeRangePicker.Options);
        _setEditScopeAccessors(fieldValueAccessors: EditScopeAccessors<DateUtil.DateTimeRange>): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\DayPicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DayPicker {
    interface Options extends MsPortalFx.ViewModels.Forms.Base.Editable.Options<number[]> {
    }
    class ViewModel extends MsPortalFx.ViewModels.Forms.Base.Editable.ViewModel<number[]> {
        /**
         * Constructs a standalone instance of a DyPicker form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DayPicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: DayPicker.Options);
        /**
         * Constructs an instance of a DayPicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DayPicker is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DayPicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: DayPicker.Options);
        /**
         * Constructs an instance of a DayPicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DayPicker is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DayPicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<number[]>, options?: DayPicker.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\DropDown.d.ts
declare module MsPortalFx.ViewModels.Forms.DropDown {
    interface Options<T> extends Base.Options.Options<T> {
    }
    class ViewModel<T> extends Base.Options.ViewModel<T> {
        /**
         * Constructs a standalone instance of a DropDown form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DropDownField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: DropDown.Options<T>);
        /**
         * Constructs an instance of a DropDown form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DropDownField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DropDownField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options: DropDown.Options<T>);
        /**
         * Constructs an instance of a DropDown form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DropDownField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DropDownField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<T>, options: DropDown.Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\DurationPicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DurationPicker {
    interface Options extends MsPortalFx.ViewModels.Forms.Base.Editable.Options<number> {
    }
    class ViewModel extends MsPortalFx.ViewModels.Forms.Base.Editable.ViewModel<number> {
        /**
         * Constructs a standalone instance of a DurationPicker form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DurationPicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: DurationPicker.Options);
        /**
         * Constructs an instance of a DurationPicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DurationPicker is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DurationPicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: DurationPicker.Options);
        /**
         * Constructs an instance of a DurationPicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DurationPicker is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DurationPicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<number>, options?: DurationPicker.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\FilterComboBox.d.ts
declare module MsPortalFx.ViewModels.Forms.FilterComboBox {
    interface FilterComboViewModel {
        /**
         * Filtered list of items.
         */
        filteredItems: KnockoutObservable<HierarchicalFormOption<string>[]>;
        /**
         * Filter text.
         */
        filterText: KnockoutObservable<string>;
        /**
         * Indicates if filtering is in progress now.
         */
        filterInProgress: KnockoutObservable<boolean>;
        /**
         * Items
         */
        items: KnockoutObservable<HierarchicalFormOption<string>[]>;
        /**
         * Options used for filtering text.
         */
        filterOptions: FilterOptions;
    }
    /**
     * Form option represents a row in hierarchical dropdown.
     */
    interface HierarchicalFormOption<T> extends MsPortalFx.ViewModels.Forms.IOption<T> {
        /**
         * Optional children for storing hierarchical data.
         */
        children?: HierarchicalFormOption<T>[];
        /**
         * Flag for filtering the dropdown option.
         */
        doNotFilter?: KnockoutObservableBase<boolean>;
    }
    interface Column {
        /**
         * String mapping to the item key.
         */
        itemKey: string;
        /**
         * Css class associated with the column.
         */
        cssClass?: string;
        /**
         * Width of the column in pixels or percentage.
         */
        width?: KnockoutObservable<string>;
    }
    interface FilterOptions {
        /**
         * Delimiter used for flattening a hierarchical dataset.
         */
        delimiter?: string;
        /**
         * Filter type for search.
         */
        datasetType: DatasetType;
        /**
         * Filter algorithm to use for search.
         */
        algorithmType?: AlgorithmType;
    }
    interface Options extends MsPortalFx.ViewModels.Forms.Base.EditableComboBox.Options<string> {
        /**
            * Icons to be shown next to text. Key should correspond to text in values.
            */
        iconLookup?: StringMap<KnockoutObservableBase<string>>;
        /**
            * Icon size in pixels which will correspond to both width and height (default "20px").
            */
        iconSize?: KnockoutObservable<string>;
        /**
         * Options used for filtering text.
         */
        filterOptions?: FilterOptions;
        /**
            * A list of values to be displayed in drop down.
            */
        options: KnockoutObservableArray<HierarchicalFormOption<string>>;
    }
    const enum DatasetType {
        /**
         * A flat list of data, with no hierarchy
         */
        List = 0,
        /**
         * Hierarchical data
         */
        Tree = 1,
    }
    const enum AlgorithmType {
        /**
        * Uses a string index algorithm that matches substrings anywhere in the text
        */
        StringContainsFilterText = 0,
        /**
        * Uses the prefix tree search algorithm to match words that start with the filter text.
        *
        * NOTE: This will not support returning substring matches embedded within words.
        * This is only intended for very special optimized scenarios.
        */
        WordStartsWithFilterText = 1,
    }
    interface SearchFilterContract {
        filterData(filterString: string): HierarchicalFormOption<string>[];
    }
    class HierarchicalFormOptionItem<T> extends Forms.Option<T> implements HierarchicalFormOption<T> {
        children: HierarchicalFormOption<T>[];
        constructor(text: string, value: T, children?: HierarchicalFormOption<T>[]);
        constructor(text: KnockoutObservableBase<string>, value: KnockoutObservableBase<T>, children?: HierarchicalFormOption<T>[]);
    }
    /**
     * Node data for prefix search tree.
     * Exported for unit tests
     */
    class Node {
        children: Node[];
        lineMatches: string[];
        private _value;
        constructor(value?: string);
        /**
         * Gets a child node matching the search char
         *
         * @param searchCharacter Character to search for
         * @return The node that matches the search character.
         */
        getChild(searchCharacter: string): Node;
        /**
         * Checks if node's value matches the search query
         *
         * @param searchQuery query to search for
         * @return true if the node matches the search character, false otherwise.
         */
        matchesValue(searchQuery: string): boolean;
    }
    /**
     * Search filter for searching a flat list of string items, to be used with FilterCombo.
     */
    class SearchFilter implements SearchFilterContract {
        _filterInProgress: boolean;
        _viewModel: FilterComboViewModel;
        _filterOptions: FilterOptions;
        private _disposables;
        /**
         * Creates an instance of SearchFilter.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param viewModel FilterCombo viewmodel to update data into.
         * @param filterOptions Options to filter values list, if data is hierarchical.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, viewModel: FilterComboViewModel, filterOptions: FilterOptions);
        /**
         * See interface
         */
        dispose(): void;
        /**
         * Filters data with a simple substring search, a temporary implementation
         * This search currently is case insensitive, but not as performant with toLowerCase
         * and ignores locale while comparing.
         *
         * @param filterString The filter string to search for.
         * @return The filtered items. If nothing matches, returns empty array.
         */
        filterData(filterString: string): HierarchicalFormOption<string>[];
        _setfilteredItems(values: HierarchicalFormOption<string>[]): void;
    }
    /**
     * Tree Search filter for searching a hierarchical list of string items, to be used with FilterCombo.
     * Tree is flattened using a delimiter that is passed in filter options. A Breadth-First-Search of
     * the hiearchical tree data is performed and each node is appended to path from root with delimiters
     * separating the node values.
     */
    class TreeSearchFilter extends SearchFilter {
        /**
         * Creates an instance of TreeSearchFilter.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param viewModel FilterCombo viewmodel to update data into.
         * @param filterOptions Options to filter values list, if data is hierarchical.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, viewModel: FilterComboViewModel, filterOptions: FilterOptions);
    }
    /**
     * Search filter for searching a flat list of string items, to be used with FilterCombo.
     */
    class SearchFilterPrefixTree implements SearchFilterContract {
        _filterInProgress: boolean;
        _viewModel: FilterComboViewModel;
        _filterOptions: FilterOptions;
        _prefixTree: PrefixTree;
        _directMatchDictionary: StringMap<HierarchicalFormOption<string>[]>;
        /**
         * Creates an instance of SearchFilter.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param viewModel FilterCombo viewmodel to update data into.
         * @param filterOptions Options to filter values list, if data is hierarchical.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, viewModel: FilterComboViewModel, filterOptions: FilterOptions);
        /**
         * Filters data with a prefix tree search, the search currently is case insensitive
         *
         * @param filterString The filter string to search for.
         * @return The filtered items. If nothing matches, returns empty array.
         */
        filterData(filterString: string): HierarchicalFormOption<string>[];
        _setFilteredItems(filteredItems: HierarchicalFormOption<string>[]): void;
        _addToSearchOnInitialize(item: HierarchicalFormOption<string>, searchString: string): void;
        private _setfilteredItems(values);
    }
    /**
     * Tree Search filter for searching a hierarchical list of string items, to be used with FilterCombo.
     * Tree is flattened using a delimiter that is passed in filter options. A Breadth-First-Search of
     * the hiearchical tree data is performed and each node is appended to path from root with delimiters
     * separating the node values.
     */
    class TreeSearchFilterPrefixTree extends SearchFilterPrefixTree {
        private _childPrefixTree;
        private _childMatchDictionary;
        /**
         * Creates an instance of TreeSearchFilter.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param viewModel FilterCombo viewmodel to update data into.
         * @param filterOptions Options to filter values list, if data is hierarchical.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, viewModel: FilterComboViewModel, filterOptions: FilterOptions);
        /**
         * Filters data with a prefix tree search, the search currently is case insensitive
         *
         * @param filterString The filter string to search for.
         * @return The filtered items. If nothing matches, returns empty array.
         */
        filterData(filterString: string): HierarchicalFormOption<string>[];
        _setFilteredItems(items: HierarchicalFormOption<string>[]): void;
        _addToSearchOnInitialize(item: HierarchicalFormOption<string>, searchString: string): void;
        private _processMatch(matches, isResultProcessed);
        private _processMatches(matches, extendedMatches);
        private _flattenTree(data);
        private _updateCurrentItem(currentItem, next, originalValue, newValue, matchType);
    }
    class FilterFactory {
        /**
         * Gets a search filter
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param viewModel FilterCombo viewmodel to update data into.
         * @param filterOptions Options to filter values list, if data is hierarchical.
         * @return The corresponding search filter.
         */
        getSearchFilter(lifetimeManager: MsPortalFx.Base.LifetimeManager, viewModel: FilterComboViewModel, filterOptions: FilterOptions): SearchFilterContract;
    }
    /**
     * Prefix Tree that can be used for prefix searching in a list of strings.
     */
    class PrefixTree {
        private _root;
        /**
         * Adds a word to the prefix tree
         *
         * @param word Word to add to the prefix tree.
         * @param line Line to return for prefix result.
         */
        addWord(word: string, line: string): void;
        /**
         * Finds a query in the prefix tree
         *
         * @param query String to search for.
         * @return results  query string results, empty array if not found.
         */
        getMatches(query: string): string[];
    }
    class ViewModel extends Base.EditableComboBox.ViewModel<string> {
        /**
         * A list of filtered values to be displayed in the drop down.
         */
        filteredItems: KnockoutObservableArray<HierarchicalFormOption<string>>;
        /**
         * Icons to be shown next to text. Key should correspond to text in values.
         */
        iconLookup: StringMap<KnockoutObservableBase<string>>;
        /**
         * Icon size in pixels which will correspond to both width and height (default "20px").
         */
        iconSize: KnockoutObservable<string>;
        /**
         * Options used for filtering text.
         */
        filterOptions: FilterOptions;
        /**
         * Filter text.
         */
        filterText: KnockoutObservable<string>;
        /**
         * Unused at the moment since the dropdown will shrink to take 0 height when no items are available.
         */
        noRowsMessage: KnockoutObservableBase<string>;
        /**
         * Indicates if filtering is in progress now.
         */
        filterInProgress: KnockoutObservable<boolean>;
        /**
         * A list of values to be displayed in drop down.
         */
        options: KnockoutObservableArray<HierarchicalFormOption<string>>;
        /**
         * Whether the view model is populated with items or not.
         */
        populated: KnockoutObservableBase<boolean>;
        private _values;
        /**
         * Constructs a standalone instance of a FilterComboBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the FilterComboField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: FilterComboBox.Options);
        /**
         * Constructs an instance of a FilterComboBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the FilterComboField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the FilterComboField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options: FilterComboBox.Options);
        /**
         * Constructs an instance of a FilterComboBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the FilterComboField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the FilterComboField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options: FilterComboBox.Options);
        /**
         * Gets a KnockoutObservable of list of items
         */
        items: KnockoutObservable<HierarchicalFormOption<string>[]>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\GroupDropDown.d.ts
declare module MsPortalFx.ViewModels.Forms.GroupDropDown {
    interface Item<T> {
        text: string | KnockoutObservableBase<string>;
        selectedItemOverride?: string | KnockoutObservableBase<string>;
        value: T;
        disabled?: boolean | KnockoutObservableBase<boolean>;
    }
    interface Group<T> {
        text: string | KnockoutObservableBase<string>;
        children?: Array<Item<T> | Group<T>> | KnockoutObservableBase<Array<Item<T> | Group<T>>>;
        disabled?: boolean | KnockoutObservableBase<boolean>;
    }
    interface Options<T> extends MsPortalFx.ViewModels.Forms.Base.Input.Options<T> {
        items?: KnockoutObservableBase<Array<Item<T> | Group<T>>>;
        filter?: boolean | KnockoutObservableBase<boolean>;
        /**
        * Sets the filter textbox's placeholder.
        * Default is blank.
        */
        filterPlaceholder?: string | KnockoutObservable<string>;
        /**
         * Callback which will override our simple substring filtering.
         * Return list of items you wish to filter.
         * Doesn't do anything unless filter is true.
         */
        customFilter?: (value: string) => MsPortalFx.Base.PromiseV<T[]>;
        multiselect?: boolean | KnockoutObservableBase<boolean>;
        selectAll?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback which will override our selectAll functionality.
         * Allows you to select any items you wish, we don't do any selecting when you provide this override.
         */
        selectAllOverride?: () => MsPortalFx.Base.PromiseV<any>;
    }
    class ViewModel<T> extends MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<T> {
        items: KnockoutObservableBase<Array<Item<T> | Group<T>>>;
        filter: boolean | KnockoutObservableBase<boolean>;
        /**
        * Sets the filter textbox's placeholder.
        * If you use singleSelectPlaceholder, you don't need to set this one.
        * Default is blank.
        */
        filterPlaceholder: string | KnockoutObservable<string>;
        /**
         * Callback which will override our simple substring filtering.
         */
        customFilter: (value: string) => MsPortalFx.Base.PromiseV<T[]>;
        multiselect: boolean | KnockoutObservableBase<boolean>;
        selectAll: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback which will override our selectAll functionality.
         */
        selectAllOverride: () => MsPortalFx.Base.PromiseV<any>;
        /**
         * Value is of type T or Array<T> depending on whether multiselect is set;
         */
        value: KnockoutObservableBase<T> & KnockoutObservableBase<Array<T>>;
        /**
         * Constructs a standalone instance of a CheckBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options<T>);
        /**
         * Constructs an instance of a CheckBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CheckBoxField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: MsPortalFx.ViewModels.Forms.Form.ViewModel<any>, observablePath: string, options?: Options<T>);
        /**
         * Constructs an instance of a CheckBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CheckBoxField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: MsPortalFx.ViewModels.Forms.Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\HtmlEditor.d.ts
declare module MsPortalFx.ViewModels.Forms.HtmlEditor {
    interface Options extends Base.Editable.Options<string> {
    }
    class ViewModel extends Base.Editable.ViewModel<string> {
        /**
         * Constructs a standalone instance of a TextBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: HtmlEditor.Options);
        /**
         * Constructs an instance of a TextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TextField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: HtmlEditor.Options);
        /**
         * Constructs an instance of a TextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TextField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: HtmlEditor.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\MultiLineTextBox.d.ts
declare module MsPortalFx.ViewModels.Forms.MultiLineTextBox {
    interface Options extends Base.Typable.Options<string> {
        /**
         * The number of rows to set the height of the textarea to.
         * This maps to the textarea rows attribute. The default is 7.
         */
        rows?: KnockoutObservable<number>;
    }
    class ViewModel extends Base.Typable.ViewModel<string> {
        /**
         * The number of rows to set the height of the textarea to.
         * This maps to the textarea rows attribute. The default is 7.
         */
        rows: KnockoutObservable<number>;
        /**
         * Constructs a standalone instance of a MultiLineTextBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the MultiLineTextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: MultiLineTextBox.Options);
        /**
         * Constructs an instance of a MultiLineTextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the MultiLineTextField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the MultiLineTextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: MultiLineTextBox.Options);
        /**
         * Constructs an instance of a MultiLineTextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the MultiLineTextField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the MultiLineTextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: MultiLineTextBox.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\MultiSelectDropDown.d.ts
declare module MsPortalFx.ViewModels.Forms.MultiSelectDropDown {
    interface Options<T> extends Base.Groups.Options<T> {
        /**
        * Sets if filtering should be initialized.
        * If false or not set, no filtering.
        * If true, adds the textbox and bindings required for filtering.
        */
        filter?: boolean | KnockoutObservableBase<boolean>;
        /**
        * Sets the filter textbox's placeholder.
        * Default is blank.
        */
        filterPlaceholder?: string | KnockoutObservable<string>;
        /**
         * Callback which will override our simple substring filtering.
         * Return list of items you wish to filter.
         * Doesn't do anything unless filter is true.
         */
        customFilter?: (value: string) => MsPortalFx.Base.PromiseV<string[]>;
        /**
         * Specify the format type and format option for customizing the option display value.
         */
        formatSetting?: MsPortalFx.ViewModels.FormOptionFormatSetting;
        /**
         * Show select all for multiselect mode.
         */
        showSelectAll?: KnockoutObservableBase<boolean>;
        /**
         * Show total amount of items in dropdown.
         */
        showTotal?: boolean;
        /**
         * Turns on or off multiselect.
         */
        multiselect?: KnockoutObservable<boolean>;
        /**
         * Maximum select rows counts.  When max is reached, the control will disable all the unselected item.
         */
        maxSelectAllowed?: KnockoutObservable<number>;
        /**
         * Display Text Format when it is under max allowed.
         * By default. the format string is "{0} selected"
         * The first argument({0}) is the selected rows count, for example, 3.
         * The second argument({1}) is the input value is going to submit, for example, "val1;val2;val3".
         * The third argument({2}) is the display value , for example, "display1;display2;display3".
         */
        multiItemsDisplayFormat?: KnockoutObservableBase<string>;
        /**
         * Display Text Format when max is reached.
         * By default. the format string is "max {0} selected"
         * The first argument({0}) is the selected rows count, for example, 3.
         * The second argument({1}) is the input value is going to submit, for example, "val1;val2;val3".
         * The third argument({2}) is the display value , for example, "display1;display2;display3".
         */
        multiItemsMaxDisplayFormat?: KnockoutObservableBase<string>;
    }
    class ViewModel<T> extends Base.Groups.ViewModel<T> {
        /**
         * Specify the format type and format option for customizing the option display value.
         */
        formatSetting: MsPortalFx.ViewModels.FormOptionFormatSetting;
        /**
         * Popup shown state
         */
        popupShown: KnockoutObservableBase<boolean>;
        /**
         * Show select all for multiselect mode.
         */
        showSelectAll: KnockoutObservableBase<boolean>;
        /**
         * Show total amount of items in dropdown.
         */
        showTotal: boolean;
        /**
         * Turns on or off multiselect.
         */
        multiselect: KnockoutObservable<boolean>;
        /**
         * Maximum select rows counts.  When max is reached, the control will disable all the unselected item.
         */
        maxSelectAllowed: KnockoutObservable<number>;
        /**
         * Display Text Format when it is under max allowed.
         * By default. the format string is "{0} selected"
         * The first argument({0}) is the selected rows count, for example, 3.
         * The second argument({1}) is the input value is going to submit, for example, "val1;val2;val3".
         * The third argument({2}) is the display value , for example, "display1;display2;display3".
         */
        multiItemsDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Display Text Format when max is reached.
         * By default. the format string is "max {0} selected"
         * The first argument({0}) is the selected rows count, for example, 3.
         * The second argument({1}) is the input value is going to submit, for example, "val1;val2;val3".
         * The third argument({2}) is the display value , for example, "display1;display2;display3".
         */
        multiItemsMaxDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Value Separator for combining the selected item into a <input> value. For example, "val1;val2;val5".
         * We use standard javascript split function.  Can be a string.
         * By default, we use String.fromCharCode(0x1d). 0x1d is the <GS>, group separator, in ascii code which is not visible in the text box.
         * If you need to see this in the display text, change it to different character, or string.
         */
        valueSeparator: string;
        /**
         * Display Separator for combining the selected item into a displayable string. For example, "display1;display2;display3".
         * We use standard javascript split function.  Can be a string.
         * By default, we use ";" -- since this need to be visible.
         */
        displaySeparator: string;
        /**
        * Indicate value/selection is initialized.
        * If false, it will initialize the value from Items.selected information.
        * If true,  it will honor value and make sure the Items.selected states match current value.
        */
        valueInitialized: boolean;
        /**
        * Sets if filtering is initialized.
        * If false, no filtering.
        * If true, adds the textbox and bindings required for filtering.
        */
        filter: boolean | KnockoutObservableBase<boolean>;
        /**
        * Sets the filter textbox's placeholder.
        * If you use singleSelectPlaceholder, you don't need to set this one.
        * Default is blank.
        */
        filterPlaceholder: string | KnockoutObservable<string>;
        /**
         * Callback which will override our simple substring filtering.
         */
        customFilter: (value: string) => MsPortalFx.Base.PromiseV<string[]>;
        /**
          * Constructs a standalone instance of a MultiSelectDropDown form field.
          *
          * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
          * @param options Optional The set of options to configure the MultiselectDropDownField control.
          */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: MultiSelectDropDown.Options<T>);
        /**
         * Constructs an instance of a MultiSelectDropDown form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the MultiselectDropDownField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the MultiselectDropDownField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: MultiSelectDropDown.Options<T>);
        /**
         * Constructs an instance of a MultiSelectDropDown form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the MultiselectDropDownField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the MultiselectDropDownField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<T>, options?: MultiSelectDropDown.Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\NumericTextBox.d.ts
declare module MsPortalFx.ViewModels.Forms.NumericTextBox {
    interface Options extends Base.Typable.Options<number> {
        /**
         * Minimum number allowed.
         */
        min?: KnockoutObservable<number>;
        /**
         * Maximum number allowed.
         */
        max?: KnockoutObservable<number>;
        /**
         *  Maximum decimal points allowed for the number. No more than 20.
         */
        decimalPoint?: KnockoutObservable<number>;
        /**
         * Text to display when entered text is not numeric.
         */
        invalidText?: string;
        /**
         * Placeholder text held by the control.
         */
        placeholder?: KnockoutObservable<string>;
        /**
         * Specifies whether an empty value should be allowed or if it should be replaced with a 0 value.
         */
        allowEmpty?: boolean;
    }
    class ViewModel extends Base.Typable.ViewModel<number> {
        /**
         * Minimum number allowed.
         */
        min: KnockoutObservable<number>;
        /**
         * Maximum number allowed.
         */
        max: KnockoutObservable<number>;
        /**
         *  Maximum decimal points allowed for the number. No more than 20.
         */
        decimalPoint: KnockoutObservable<number>;
        /**
         * Text to display when entered text is not numeric.
         */
        invalidText: string;
        /**
         * Placeholder text held by the control.
         * Currently this does not work on IE9 (which does not support placeholder attr on input).
         */
        placeholder: KnockoutObservable<string>;
        /**
         * Specifies whether an empty value is allowed or whether the control should replace it with a 0 value. Should only be set through Options.
         */
        allowEmpty: boolean;
        /**
         * Constructs a standalone instance of a NumericTextBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the NumericTextBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: NumericTextBox.Options);
        /**
         * Constructs an instance of a NumericTextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the NumericTextBoxField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the NumericTextBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: NumericTextBox.Options);
        /**
         * Constructs an instance of a NumericTextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the NumericTextBoxField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the NumericTextBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<number>, options?: NumericTextBox.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\OAuthButton.d.ts
declare module MsPortalFx.ViewModels.Forms.OAuthButton {
    import FxPromise = MsPortalFx.Base.Promise;
    /**
     * OAuthButton control options
     */
    interface Options extends Base.Input.Options<string> {
        /**
         * Request url used to pop up the OAuth window.
         */
        requestUrl: KnockoutObservable<string>;
        /**
         * Button text used to populate the text content of the OAuthButton
         */
        buttonText?: KnockoutObservable<string>;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth?: KnockoutObservable<number>;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight?: KnockoutObservable<number>;
        /**
         * The function executed before opening the popup.
         */
        beforeRequest?: () => FxPromise;
    }
    class ViewModel extends Base.Input.ViewModel<string> {
        /**
         * Request url used to pop up the OAuth window.
         */
        requestUrl: KnockoutObservable<string>;
        /**
         * Button text used to populate the text content of the OAuthButton
         */
        buttonText: KnockoutObservable<string>;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth: KnockoutObservable<number>;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight: KnockoutObservable<number>;
        /**
         * The function executed before opening the popup.
         */
        beforeRequest: () => FxPromise;
        /**
         * Constructs a standalone instance of a OAuthButton form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the OAuthButtonField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: OAuthButton.Options);
        /**
         * Constructs an instance of a OAuthButton form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OAuthButtonField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the OAuthButtonField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: OAuthButton.Options);
        /**
         * Constructs an instance of a OAuthButton form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OAuthButtonField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the OAuthButtonField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: OAuthButton.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\OptionsGroup.d.ts
declare module MsPortalFx.ViewModels.Forms.OptionsGroup {
    interface Options<T> extends Base.Options.Options<T> {
        /**
         * If true, sets the width of each option in the OptionGroup to the size of the content. Otherwise, sets each option to equal width
         * and the total size of the control to the size of the element. Defaults to true.
         */
        sizeToContent?: boolean;
        /**
         * If set, the option groups will appear as an inline set of radio buttons.  Defaults to false.
         */
        radioButtonStyle?: boolean;
        /**
         * If set while using radio button styling, the options in the group will each appear on their own line.  Defaults to false.
         * If not using radio button styling, this is not used.
         */
        singleItemPerLine?: boolean;
    }
    class ViewModel<T> extends Base.Options.ViewModel<T> {
        /**
         * If set the OptionGroup will size each option will size of the text in the option.
         * Otherwise the OptionGroup will expand the size of each option so that it takes up
         * the widget of the element. Defaults to true.
         */
        sizeToContent: boolean;
        /**
         * If set, the option groups will appear as an inline set of radio buttons.  Defaults to false.
         */
        radioButtonStyle: boolean;
        /**
         * If set while using radio button styling, the options in the group will each appear on their own line.  Defaults to false.
         * If not using radio button styling, this is not used.
         */
        singleItemPerLine: boolean;
        /**
         * Constructs a standalone instance of an OptionsGroup form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the OptionsGroupField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: OptionsGroup.Options<T>);
        /**
         * Constructs an instance of an OptionsGroup form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OptionsGroupField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the OptionsGroupField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: OptionsGroup.Options<T>);
        /**
         * Constructs an instance of an OptionsGroup form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OptionsGroupField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the OptionsGroupField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<T>, options?: OptionsGroup.Options<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\PasswordBox.d.ts
declare module MsPortalFx.ViewModels.Forms.PasswordBox {
    interface Options extends Base.Editable.Options<string> {
    }
    class ViewModel extends Base.Editable.ViewModel<string> {
        /**
         * Placeholder text shown when password is empty.
         */
        emptyValueText: KnockoutObservable<string>;
        /**
         * Constructs a standalone instance of a PasswordBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the PasswordField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: PasswordBox.Options);
        /**
         * Constructs an instance of a PasswordBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the PasswordField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the PasswordField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: PasswordBox.Options);
        /**
         * Constructs an instance of a PasswordBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the PasswordField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the PasswordField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: PasswordBox.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\RangeSlider.d.ts
declare module MsPortalFx.ViewModels.Forms.RangeSlider {
    interface Options extends Base.Slider.Options<string> {
    }
    class ViewModel extends Base.Slider.ViewModel<string> {
        /**
         * Value separator for combining the range into a single string value. For example, "2;6". Default is ";".
         */
        valueSeparator: string;
        /**
         * Start value of the range.
         */
        start: KnockoutObservableBase<number>;
        /**
         * End value of the range.
         */
        end: KnockoutObservableBase<number>;
        /**
         * Constructs a standalone instance of a RangeSlider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the RangeSlider control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: RangeSlider.Options);
        /**
         * Constructs an instance of a RangeSlider form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the RangeSlider is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the RangeSlider control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options: RangeSlider.Options);
        /**
         * Constructs an instance of a RangeSlider form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the RangeSlider is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the RangeSlider control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options: RangeSlider.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Section.d.ts
declare module MsPortalFx.ViewModels.Forms.Section {
    interface Options {
        /**
         * The sections & controls to nest within the section.
         */
        children?: KnockoutObservableArray<any>;
        /**
         * The name of the section.
         */
        name?: KnockoutObservableBase<string>;
        /**
         * The layout style of the section.
         */
        style?: KnockoutObservableBase<SectionStyle>;
        /**
         * The set width of the section.
         */
        width?: KnockoutObservableBase<number>;
        /**
         * The submit callback.
         */
        submit?: KnockoutObservableBase<SubmitEvent>;
        /**
         * The populate section callback.
         */
        populateSection?: KnockoutObservableBase<PopulateSection>;
        /**
         * A custom css class to apply to the section.
         */
        cssClass?: KnockoutObservableBase<string> | string;
        /**
         * The minimum height of the section in pixels.  Use this to reduce jumpiness in dynamic forms.
         */
        minHeight?: number;
        /**
         * Tab style.
         * ONLY USE when style is set to tabs.
         */
        tabStyle?: TabStyle;
    }
    enum SectionStyle {
        /**
         * A section that creates columns.
         */
        Column = 0,
        /**
         * The default section, used when you don't need columns.
         * NOTE: You don't need to declare a section style when using this.
         */
        Default = 1,
        /**
         * A default column, which is indented.
         */
        Dependent = 2,
        /**
         * A section that is meant to hold mutliple columns. Do not use except to hold columns.
         */
        Row = 3,
        /**
         * A section with layers made accessible via tabs.
         */
        Tabs = 4,
        /**
         * Same as Default.
         */
        Wrapper = 5,
        /**
         * Default with reduced padding between controls (used to create the appearance of a single composite control).
         */
        SingleControl = 6,
    }
    enum TabStyle {
        /**
         * Line based tabs.
         */
        Line = 0,
        /**
         * Traditional, block tabs.
         */
        Block = 1,
    }
    interface SubmitEvent {
        (): MsPortalFx.Base.PromiseV<SubmitEventResult>;
    }
    interface SubmitEventResult {
        success: boolean;
    }
    interface PopulateSection {
        (): MsPortalFx.Base.PromiseV<MsPortalFx.ViewModels.Forms.Section.ViewModel>;
    }
    class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel {
        /**
        * If under a tab, is the active section.
        */
        active: KnockoutObservable<boolean>;
        /**
         * The subsections to nest within the section.
         */
        children: KnockoutObservableArray<MsPortalFx.ViewModels.Controls.Base.ViewModel>;
        /**
         * Indicates if the sections or controls within the widget are currently dirty.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * The name of the section.
         */
        name: KnockoutObservableBase<string>;
        /**
         * The width of the section.
         */
        width: KnockoutObservableBase<number>;
        /**
         * Function which is called on form submit.
         */
        submit: KnockoutObservableBase<SubmitEvent>;
        /**
         * Function which is called to return form submit.
         */
        populateSection: KnockoutObservableBase<PopulateSection>;
        /**
         * The layout style of the section.
         */
        style: KnockoutObservableBase<SectionStyle>;
        /**
         * Indicates if the sections or controls within the widget are currently valid.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * Stub to conform with the FormElement viewmodel.
         */
        validate: KnockoutObservable<number>;
        /**
         * For tabs, this is a empty viewmodel until it is loaded.
         */
        tabSection: KnockoutObservable<MsPortalFx.ViewModels.Forms.Section.ViewModel>;
        /**
         * For tabs, indicates if the section has been loaded.
         */
        tabHasBeenLoaded: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the section.
         */
        cssClass: KnockoutObservableBase<string>;
        /**
         * The minimum height of the section in pixels. Use this to reduce jumpiness in dynamic forms.
         */
        minHeight: number;
        /**
         * Tab style. Default is Line style.
         */
        tabStyle: TabStyle;
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        /**
         * Constructs a standalone instance of a form Section.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the Section control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Section.Options);
        clearValidation(): MsPortalFx.Base.Promise;
        triggerValidation(): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Selector.d.ts
declare module MsPortalFx.ViewModels.Forms.Selector {
    interface OptionsBase<T> extends Base.Input.Options<T> {
        /**
         * The default value for the selector.
         */
        defaultValue?: KnockoutObservableBase<T>;
        /**
         * True if the value is displayed, else false.
         */
        showValue?: KnockoutObservableBase<boolean>;
        /**
         * The display text for the value in the selector.
         */
        displayText?: KnockoutObservableBase<string>;
        /**
         * The icon displayed next to the label and value.
         */
        icon?: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * True if the field is locked; else false.
         */
        locked?: KnockoutObservableBase<boolean>;
        /**
         * Text to display on the balloon shown next to the label.
         */
        infoBalloonText?: KnockoutObservableBase<string>;
        /**
         * Text to display on the balloon shown over the locked indicator.
         */
        lockedBalloonText?: KnockoutObservableBase<string>;
        /**
         * Link to display on the balloon shown next to the label.
         */
        infoBalloonLink?: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Balloon.Link>;
    }
    interface Options<T> extends OptionsBase<T> {
        /**
         * The initial state of the Selector.
         */
        initialState?: any;
        selectedValue?: MsPortalFx.ViewModels.DynamicBladeSelection;
    }
    abstract class ViewModelBase<T> extends Base.Editable.ViewModel<T> {
        /**
         * The default value for the selector.
         */
        defaultValue: KnockoutObservableBase<T>;
        /**
         * True if the value is displayed, else false.
         */
        showValue: KnockoutObservableBase<boolean>;
        /**
         * The display text for the value in the selector.
         */
        displayText: KnockoutObservableBase<string>;
        /**
         * The icon displayed next to the label and value.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * True if the field is locked; else false.
         */
        locked: KnockoutObservableBase<boolean>;
        /**
         * Text to display on the balloon shown next to the label.
         */
        infoBalloonText: KnockoutObservableBase<string>;
        /**
         * Text to display on the balloon shown over the locked indicator.
         */
        lockedBalloonText: KnockoutObservableBase<string>;
        /**
         * Link to display within the balloon underneath the text, the balloon is shown next to the label.
         */
        infoBalloonLink: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Balloon.Link>;
        /**
         * True if the current value is the default; else false.
         */
        isDefault: KnockoutObservableBase<boolean>;
        /**
         * Constructs a standalone instance of a Selector form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Selector.OptionsBase<T>);
        /**
         * Constructs an instance of a Selector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: Selector.OptionsBase<T>);
        /**
         * Constructs an instance of a Selector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<T>, options?: Selector.OptionsBase<T>);
    }
    class ViewModel<T> extends ViewModelBase<T> {
        /**
         * See interface.
         */
        selectable: Selectable<DynamicBladeSelection>;
        /**
         * Constructs a standalone instance of a Selector form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Selector.Options<T>);
        /**
         * Constructs an instance of a Selector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: Selector.Options<T>);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<T>, options?: MsPortalFx.ViewModels.Forms.Selector.Options<T>);
    }
    interface Options2<T> extends OptionsBase<T> {
        supplyBladeReference: () => FxImpl.Composition.Selectable.BladeReference<any>;
    }
    class ViewModel2<T> extends ViewModelBase<T> {
        /**
         * See interface.
         */
        selectable: FxImpl.Composition.Selectable.Selectable2<FxImpl.Composition.Selectable.BladeReference<any>>;
        /**
         * Constructs a standalone instance of a Selector form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Selector.Options2<T>);
        /**
         * Constructs an instance of a Selector form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SelectorField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the SelectorField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: Selector.Options2<T>);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<T>, options?: Selector.Options2<T>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Slider.d.ts
declare module MsPortalFx.ViewModels.Forms.Slider {
    interface Options extends Base.Slider.Options<number> {
    }
    class ViewModel extends Base.Slider.ViewModel<number> {
        /**
         * Constructs a standalone instance of a Slider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the SliderField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
        /**
         * Constructs an instance of a Slider form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SliderField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the SliderField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: Slider.Options);
        /**
         * Constructs an instance of a Slider form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SliderField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the SliderField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<number>, options?: Slider.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\Splitter.d.ts
declare module MsPortalFx.ViewModels.Controls.Splitter {
    enum Panes {
        Primary = 0,
        Secondary = 1,
        Both = 2,
    }
    interface Options {
        /**
         * Deprecated
         * The initial size of the top pane.
         */
        primaryPaneSize?: number;
        /**
         * Whether top pane should be shown or not.
         */
        showPanes?: KnockoutObservableBase<Panes>;
        /**
         * If the splitter is vertical.
         */
        vertical?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If the splitter's flow should be reversed
         */
        reversed?: boolean;
        /**
         * Minimum pane sizes
         */
        minPaneSizes?: {
            primaryPaneSize: number;
            secondaryPaneSize: number;
        };
    }
    class ViewModel extends MsPortalFx.ViewModels.Controls.Base.ViewModel {
        /**
         * The initial height of the top pane area.
         */
        primaryPaneSize: number;
        /**
         * Whether top pane should be shown or not.
         */
        showPanes: KnockoutObservableBase<Panes>;
        /**
         * If the splitter is vertical.
         */
        vertical: boolean | KnockoutObservableBase<boolean>;
        /**
         * If the splitter's flow should be reversed
         */
        reversed: boolean;
        /**
         * Minimum pane sizes
         */
        minPaneSizes: {
            primaryPaneSize: number;
            secondaryPaneSize: number;
        };
        /**
         * Constructs an instance of the form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Splitter.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\StaticSection.d.ts
declare module MsPortalFx.ViewModels.Forms.StaticSection {
    class ViewModel extends MsPortalFx.ViewModels.Controls.Base.ViewModel implements Base.Section {
        /**
         * Enum that defines the type of form element.
         */
        controlType: ControlType;
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutComputed<boolean>;
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled: KnockoutObservable<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading: KnockoutObservable<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutComputed<boolean>;
        /**
         * When changed this signals to the control validation should occur.
         */
        validate: KnockoutObservable<number>;
        /**
         * The list of form fields contained in the section.
         */
        fields: KnockoutObservableArray<FormField<any>>;
        _msPortalFxClearValidation: KnockoutObservable<() => MsPortalFx.Base.Promise>;
        private _subs;
        /**
         * Constructs an instance of a form section.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fields Optional. An array of fields that will go in the form section.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fields?: FormField<any>[]);
        dispose(): void;
        clearValidation(): MsPortalFx.Base.Promise;
        triggerValidation(): MsPortalFx.Base.Promise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\StringListBox.d.ts
declare module MsPortalFx.ViewModels.Vso.Forms.StringListBox {
    interface Options extends MsPortalFx.ViewModels.Forms.Base.Editable.Options<string[]> {
        /**
         * Set of values that the user can select from when adding new strings.
         * This could be used as a set of suggested or allowed values depending on what validation is configured.
         */
        values?: KnockoutObservableBase<string[]>;
        /**
         * The currently selected string within the control. By default no item is selected.
         */
        selected?: KnockoutObservableBase<string>;
        /**
         * Options for controlling the behavior when adding a new value to the list
         */
        newValueOptions?: NewValueOptionsOptions;
    }
    interface NewValueOptionsOptions {
        /**
         * The separator used to split strings when adding a new item
         */
        separator?: KnockoutObservableBase<string>;
        /**
         * View model for a custom control used when the String List switches into editing mode
         */
        viewModel?: MsPortalFx.ViewModels.Forms.FilterComboBox.Options;
    }
    interface NewValueOptionsContract {
        /**
         * The separator used to split strings when adding a new item
         */
        separator: KnockoutObservableBase<string>;
        /**
         * View model for a custom control used when the String List switches into editing mode
         */
        viewModel: MsPortalFx.ViewModels.Forms.FilterComboBox.ViewModel;
    }
    class StringListBoxNewValueOptions implements NewValueOptionsContract {
        /**
         * The separator used to split strings when adding a new item
         */
        separator: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        viewModel: MsPortalFx.ViewModels.Forms.FilterComboBox.ViewModel;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: NewValueOptionsOptions);
    }
    class ViewModel extends MsPortalFx.ViewModels.Forms.Base.Editable.ViewModel<string[]> {
        /**
         * See interface.
         */
        values: KnockoutObservableBase<string[]>;
        /**
         * See interface.
         */
        selected: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        newValueOptions: NewValueOptionsContract;
        /**
         * Constructs a standalone instance of a StringListBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the StringListField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: StringListBox.Options);
        /**
         * Constructs an instance of a StringListBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the StringListField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the StringListField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: MsPortalFx.ViewModels.Forms.Form.ViewModel<any>, observablePath: string, options?: StringListBox.Options);
        /**
         * Constructs an instance of a StringListBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the StringListField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the StringListField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: MsPortalFx.ViewModels.Forms.Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string[]>, options?: StringListBox.Options);
        _setEditScopeAccessors(fieldValueAccessors: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string[]>, form?: MsPortalFx.ViewModels.Forms.Form.ViewModel<string[]>): void;
        /**
         * Get a list of unique values from an array, ignoring case.
         */
        private _getUniqueValues(values);
        /**
         * Compare arrays of strings for equality (modulo string ordering). Returns true if arrays contains the same strings regardless of ordering.
         */
        private _compareValues(array1, array2);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\TextBox.d.ts
declare module MsPortalFx.ViewModels.Forms.TextBox {
    interface Options extends Base.Typable.Options<string> {
        /**
         * Makes the textbox read only.
         */
        readonly?: boolean | KnockoutObservable<boolean>;
        /**
         * The viewmodel of a list/grid control that can be controlled by this textbox.
         * The list will treat this textbox as a search text box by doing the following:
         *      enter keystrokes: Activate the first result
         *      down arrow keystrokes: Focus the first result
         *      focus and blur: highlight/remove highlight from the first result
         */
        actionHandler?: KnockoutObservableBase<FxImpl.ViewModels.Controls.Lists.Base.ActionHandler> | FxImpl.ViewModels.Controls.Lists.Base.ActionHandler;
        /**
         * Show validation error message below the control.
         */
        showValidationMessagesBelowControl?: boolean;
    }
    class ViewModel extends Base.Typable.ViewModel<string> implements FxImpl.ViewModels.Controls.Lists.Base.ActionSource {
        /**
         * The viewmodel of a list/grid control that can be controlled by this textbox.
         * The list will treat this textbox as a search text box by doing the following:
         *      enter keystrokes: Activate the first result
         *      down arrow keystrokes: Focus the first result
         *      focus and blur: highlight/remove highlight from the first result
         */
        actionHandler: KnockoutObservableBase<FxImpl.ViewModels.Controls.Lists.Base.ActionHandler> | FxImpl.ViewModels.Controls.Lists.Base.ActionHandler;
        /**
         * When not enabled, this control will not send events to the handler.
         */
        actionsEnabled: KnockoutObservable<boolean>;
        /**
         * Makes the textbox read only.
         */
        readonly: boolean | KnockoutObservable<boolean>;
        /**
         * Show validation error message below the control.
         */
        showValidationMessagesBelowControl: boolean;
        /**
         * Constructs a standalone instance of a TextBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: TextBox.Options);
        /**
         * Constructs an instance of a TextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TextField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: TextBox.Options);
        /**
         * Constructs an instance of a TextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TextField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<string>, options?: TextBox.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\TimePicker.d.ts
declare module MsPortalFx.ViewModels.Forms.TimePicker {
    interface Options extends Base.EditableComboBox.Options<Date> {
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange?: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
        * Whether the control should allow empty(null) value as valid.
        */
        allowEmpty?: boolean;
        /**
         * If true displays hours, minutes, and seconds. If false displays only hours and minutes.
         */
        showSeconds?: boolean;
    }
    class ViewModel extends Base.EditableComboBox.ViewModel<Date> {
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange: KnockoutObservable<MsPortalFx.DateUtil.DateTimeRange>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty: boolean;
        /**
         * If true displays hours, minutes, and seconds. If false displays only hours and minutes.
         */
        showSeconds: boolean;
        /**
         * Constructs a standalone instance of a TimePicker form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the TimePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: TimePicker.Options);
        /**
         * Constructs an instance of a TimePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TimePicker is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the TimePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: TimePicker.Options);
        /**
         * Constructs an instance of a TimePicker form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TimePicker is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the TimePicker control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<Date>, options?: TimePicker.Options);
        _setEditScopeAccessors(fieldValueAccessors: EditScopeAccessors<Date>): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\TriStateCheckBox.d.ts
declare module MsPortalFx.ViewModels.Forms.TriStateCheckBox {
    /**
     * CheckBoxValue value states.
     */
    enum Value {
        /**
         * TriStateCheckBox state representing unchecked state.
         */
        Unchecked = 0,
        /**
         * TriStateCheckBox state representing checked state.
         */
        Checked = 1,
        /**
         * TriStateCheckBox state representing indeterminate state.
         */
        Indeterminate = 2,
    }
    interface Options extends Base.Input.Options<Value> {
        /**
         * Display the label inline with the checkbox.
         */
        inlineLabel?: boolean;
        /**
         * Enable or disable user to select Indeterminate state.
         */
        canUserSetIndeterminate?: KnockoutObservable<boolean>;
    }
    class ViewModel extends Base.Input.ViewModel<Value> {
        /**
         * Display the label inline with the checkbox.
         */
        inlineLabel: boolean;
        /**
         * Enable or disable user to select Indeterminate state.
         */
        canUserSetIndeterminate: KnockoutObservable<boolean>;
        /**
         * Constructs a standalone instance of a TriStateCheckBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the TriStateCheckBox control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: TriStateCheckBox.Options);
        /**
         * Constructs an instance of a TriStateCheckBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TriStateCheckBox is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the TriStateCheckBox control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: TriStateCheckBox.Options);
        /**
         * Constructs an instance of a TriStateCheckBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TriStateCheckBox is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the TriStateCheckBox control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<Value>, options?: TriStateCheckBox.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\ViewModels.AsyncFileUpload.d.ts
declare module MsPortalFx.ViewModels.Forms.AsyncFileUpload {
    import FxFileUpload = MsPortalFx.ViewModels.FileUpload;
    import FxPromise = MsPortalFx.Base.Promise;
    /**
     * Options to initialize the file upload view model.
     */
    interface Options extends Base.Editable.Options<string> {
        /**
         * A comma-separated list of allowed file mime-types, excluding extensions.
         * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
         * The file filtering  behavior depends on native browser support.
         */
        accept?: string | KnockoutObservableBase<string>;
        /**
         * A comma-separated list of allowed file extensions.
         * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
         * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
         * Eg: "pfx,cer"
         */
        allowedFileExtensions?: string | KnockoutObservableBase<string>;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext?: KnockoutObservableBase<FxFileUpload.UploadContext>;
        /**
         * The user selected files via browse dialog is surfaced as SelectedFile in the selectedFiles array.
         * For scenarios where selected files should automatically be associated with an UploadTask, set this value to true.
         * If this option is set to false, the extension author is responsible for explicitly adding the selectedFile to uploadTasks by invoking
         * the addUploadTasks() method on view model to create an UploadTask representation and have it available in uploadTasks array.
         * By default, this option is set to true.
         */
        autoAddUploadTasks?: boolean;
    }
    /**
     * Async file upload ViewModel.
     */
    class ViewModel extends Base.Editable.ViewModel<string> {
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
         * The file filtering  behavior depends on native browser support.
         */
        accept: string | KnockoutObservableBase<string>;
        /**
         * A comma-separated list of allowed file extensions.
         * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
         * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
         * Eg: "pfx,cer"
         */
        allowedFileExtensions: string | KnockoutObservableBase<string>;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext: KnockoutObservableBase<FxFileUpload.UploadContext>;
        /**
         * Each time user clicks on the browse dialog, user can choose one or multiple files and each selected file is represented as SelectedFile on the extension iframe.
         * The selected files are surfaced in the selectedFiles array.
         * The array will be cleared if user chooses to click browse dialog to pick a different set of files.
         * Setting the value property null or calling resetUploadTasks() will clear the array.
         */
        selectedFiles: KnockoutReadOnlyObservableArray<FxFileUpload.SelectedFileContract>;
        /**
         * The user selected files via browse dialog is surfaced as SelectedFile in the selectedFiles array.
         * For scenarios where selected files should automatically be associated with an UploadTask, set this value to true.
         * If this option is set to false, the extension author is responsible for explicitly adding the selectedFile to uploadTasks by invoking
         * the addUploadTasks() method on view model to create an UploadTask representation and have it available in uploadTasks array.
         * By default, this option is set to true.
         */
        autoAddUploadTasks: boolean;
        /**
         * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress etc.
         * UploadTask is used to initiate the file upload, pause/resume uploads, cancel and dispose the file upload.
         */
        uploadTasks: KnockoutReadOnlyObservableArray<FxFileUpload.AsyncUploadTaskContract>;
        /**
         * Callback to handle upload management operations. The callback is populated by the upload widget which will then delegate the needed action to the global upload manager.
         */
        _msPortalFxUploadActionCallback: KnockoutObservableBase<FxFileUpload.UploadActionCallback>;
        /**
         * Constructs a standalone instance of a TextBox form field.
         *
         * @param lifetime A lifetime object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options);
        /**
         * Constructs an instance of a TextBox form field integrated with EditScope.
         *
         * @param lifetime A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TextField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the AsyncFileUpload control.
         */
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: Options);
        /**
         * Method to create an UploadTask associated with the selected file and populate that in the uploadTasks array.
         * File browse selections can be made any number of times. When autoAddUploadTaks is set to true, the selected files will be added automatically to the uploadTasks array.
         * If autoAddploadTasks is false, the selected file should be explicitly added to uploadTasks array by calling the addUploadTasks() method.
         * Extension authors will then be able to start the upload.
         *
         * @param selectedFiles User selected files to add to uploadTasks array to prepare for the file upload.
         */
        addUploadTasks(selectedFiles: FxFileUpload.SelectedFile[]): FxPromise;
        /**
         * Method to reset the uploadTasks array. This method will use the widget callback to intialize the uploadTasks array with empty array.
         * Calling this method will not dispose(abort) the uploads.
         * Uploads which have already started will continue upload in the background.
         * Uploads which have not been started will be cleaned up.
         * Invoking this method will clear the uploadTasks array, selectedFiles array and the value property.
         */
        resetUploadTasks(): FxPromise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\ViewModels.FileUpload.d.ts
declare module MsPortalFx.ViewModels.Forms.FileUpload {
    interface Options extends Base.Editable.Options<string> {
        /**
         * A comma-separated list of allowed file mime-types, excluding extensions.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept?: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext?: KnockoutObservableBase<FileUploadContext>;
        /**
         * Cancel all uploads that are in progress and clears the files list array.
         */
        cancelAllUploads?: KnockoutObservableBase<boolean>;
        /**
         * Show progress bars demonstrating the progress of the file upload.
         * Default is true.
         */
        showProgressBars?: KnockoutObservableBase<boolean>;
    }
    /**
     *  Specifies how the file content should be uploaded.
     */
    const enum FileUploadType {
        /**
         *  Full file content will be read. Use this option only for small file sizes less than 2 MB.
         */
        Full = 0,
        /**
         * File content will be read in chunks and provided to user in chunks.
         * Use this option to read large files and if user wants control over where to post the content.
         */
        Stream = 1,
        /**
         * File content will be uploaded to blob store.
         * Use this option for uploading large files in GBs.
         */
        BlobStore = 2,
    }
    /**
     * Specifies how the file content should be read and encoded in memory.
     * These options mimics the html5 file reader options to read the file content.
     */
    const enum ContentType {
        /**
         * By default, file content will be read and stored as binary data in an ArrayBuffer.
         */
        Default = 0,
        /**
         * The file content will be read as plain text.
         * By default the string is encoded in 'UTF-8' format. Use the optional encoding parameter to specify a different format.
         */
        Text = 1,
        /**
         * The file content will be available in an ArrayBuffer.
         */
        ArrayBuffer = 2,
        /**
         * The file content will be encoded in the data uri scheme. Use this option for images and if those need to be directly shown in img tag.
         */
        DataUri = 3,
    }
    const enum UploadStatus {
        /**
         * Invalid.
         */
        Invalid = 0,
        /**
         * Pending.
         */
        Pending = 1,
        /**
         * Uploading.
         */
        Uploading = 2,
        /**
         * Paused.
         */
        Paused = 3,
        /**
         * Complete.
         */
        Complete = 4,
        /**
         * Canceled.
         */
        Canceled = 5,
    }
    /**
     * The file upload context options around how/where to upload and size limits.
     */
    interface FileUploadContext {
        /**
         * Specify how/where the file should be uploaded.
         */
        type: FileUploadType;
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded.
         */
        chunkSize: number;
    }
    /**
     * Defines how the uploaded file content will be available for the user.
     */
    interface FileUploadContent {
        /**
         * File upload type. The content will be different for each file upload type.
         */
        type: FileUploadType;
        /**
         * Specifies how the content will be represented in memory.
         */
        contentType: ContentType;
    }
    interface FullFileUploadContent extends FileUploadContent {
        /**
         * The full file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
    }
    interface StreamFileUploadContent extends FileUploadContent {
        /**
         * The chunked file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
        /**
         * The startbyte of the chunk.
         */
        startByte: number;
        /**
         * The endbyte of the chunk.
         */
        endByte: number;
    }
    interface BlobStoreFileUploadContent extends FileUploadContent {
        /**
         * The SAS uri of the uploaded file will be available once the file upload completes successfully.
         */
        content: string;
    }
    interface FileUploadResult {
        /**
         * Whether the file associated with the upload task is valid or not.
         */
        valid: boolean;
        /**
         * The current status of the upload task.
         */
        status: UploadStatus;
        /**
         * The percent complete of the upload task.
         */
        progressPercent: number;
        /**
         * File upload content will be available in memory based on the specified upload type and content type.
         */
        data: FileUploadContent;
    }
    interface SelectedFile {
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Whether or not to continue uploading the file.
         */
        cancelUpload: KnockoutObservable<boolean>;
        /**
         * Whether or not to continue uploading the file.
         */
        resumeUpload: KnockoutObservable<boolean>;
        /**
         * The byte to start from when reading.
         */
        uploadStartByte: number;
        /**
         * The object representing the upload for this file.
         */
        uploadResult: KnockoutObservableBase<FileUploadResult>;
    }
    /**
     * Full file upload context.
     */
    class FullFileUploadContext implements FileUploadContext {
        /**
         * Full file will be read and the entire content will be available in memory.
         */
        type: FileUploadType;
        /**
         * File content will be stored by default in an array buffer.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding: string;
        /**
         * Specify the maximum file size that can be uploaded.
         * Recommended max file is less than 2 MB for this upload type.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded.
         * Default chunk size should be same as maxFileSize for fill file download.
         */
        chunkSize: number;
    }
    /**
     * Stream file upload context. File will be read in chunks and chunked content will be available in memory.
     */
    class StreamFileUploadContext extends FullFileUploadContext implements FileUploadContext {
        /**
         * Initialize default properties for stream file upload context.
         */
        constructor();
    }
    /**
     * BlobStore file upload context. File will be uploaded directly to blob store specified by the SAS uri.
     */
    class BlobStoreFileUploadContext<T> extends FullFileUploadContext implements FileUploadContext {
        /**
         * Sas uri command context that will be passed to the execute method of the sasUriCommand.
         */
        context: KnockoutObservableBase<T>;
        /**
         * Specify the command to fetch the SAS uri for the target blob store where file will be uploaded.
         * Execute method on the command should provide the SAS uri with correct permissions and calculate the expiration time from the time it was invoked.
         */
        sasUriCommand: KnockoutObservableBase<MsPortalFx.ViewModels.Commands.Command<T>>;
        /**
         * Optionally specify that the SAS uri should not be updated with selected file name and widget should not modify the SAS uri.
         * By default, a container SAS uri is expected and the upload control will insert the selected file name. If users need
         * better permission control at block level, they can provide block level sas uri and set this flag to true.
         */
        skipSasUriUpdateWithSelectedFile: KnockoutObservable<boolean>;
        /**
         * Initialize default properties for blob store file upload context.
         */
        constructor();
    }
    class ViewModel extends Base.Editable.ViewModel<string> {
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext: KnockoutObservableBase<FileUploadContext>;
        /**
         * The currently-selected files (as limited by maxFiles).
         */
        files: KnockoutObservableBase<SelectedFile[]>;
        /**
         * Cancel all uploads that are in progress and clears the files list array.
         */
        cancelAllUploads: KnockoutObservableBase<boolean>;
        /**
         * Show progress bars demonstrating the progress of the file upload.
         * Default is true.
         */
        showProgressBars: KnockoutObservableBase<boolean>;
        /**
         * Constructs a standalone instance of a TextBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: FileUpload.Options);
        /**
         * Constructs an instance of a TextBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the TextField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the TextField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: FileUpload.Options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Forms\ViewModels.TokenComboBox.d.ts
declare module MsPortalFx.ViewModels.Forms.TokenComboBox {
    enum UnrecognizedTokenBehavior {
        /**
         * A value indicating that unrecognized tokens should be allowed. Users can enter any token values.
         */
        Allow = 0,
        /**
         * A value indicating that unrecognized tokens should not be allowed. Users can only enter token values from the dropdown.
         * Any other token values will cause a validation error.
         */
        Disallow = 1,
        /**
         * A value indicating that unrecognized tokens should not be ignored. Only token values from the dropdown will be treated as
         * tokens. All other values will be treated as text.
         */
        Ignore = 2,
    }
    interface TokenizedValueItem {
        /**
         * The tokenized item value.
         */
        value: string;
        /**
         * A flag which indicates whether or not the tokenized item is a token.
         */
        isToken: boolean;
    }
    interface TokenStartAndEndCharacters {
        /**
         * The start character for a token.
         */
        tokenStart: string;
        /**
         * The end character for a token.
         */
        tokenEnd: string;
    }
    /**
     * Columns shown in the token combo box
     */
    interface Column extends MsPortalFx.ViewModels.Forms.FilterComboBox.Column {
    }
    interface Options<TItem> extends Base.Editable.Options<string> {
        /**
         * The start and end characters for tokens.
         */
        tokenStartAndEndCharacters: KnockoutObservable<TokenStartAndEndCharacters>;
        /**
         * The observable list of items. The items will appear in the dropdown menu and be insertable into the text box as tokens.
         */
        items: KnockoutObservableArray<TItem>;
        /**
         * The behavior for handling unrecognized token values (tokens that are not in the items array). Defaults to UnrecognizedTokenBehavior.Disallow.
         */
        unrecognizedTokenBehavior?: KnockoutObservable<UnrecognizedTokenBehavior>;
        /**
         * A flag indicating whether or not typing delete/backspace when the cursor is next to a token should delete the entire token. Defaults to false.
         */
        removeTokenOnDelete?: KnockoutObservable<boolean>;
        /**
         * Key used to get the display value.
         */
        valueKey?: KnockoutObservable<string>;
        /**
         * Column definitions.
         */
        columns?: KnockoutObservableArray<Column>;
        /**
         * Number of rows for the dropdown.
         */
        rowsCount?: KnockoutObservable<number>;
        /**
         * Specifies the default width of the single column for the hosted grid control.
         */
        defaultColumnWidth?: KnockoutObservable<string>;
        /**
         * No rows message when no rows are displayed.
         */
        noRowsMessage?: KnockoutObservable<string>;
    }
    class ViewModel<TItem> extends Base.Editable.ViewModel<string> {
        /**
         * The start and end characters for tokens.
         */
        tokenStartAndEndCharacters: KnockoutObservable<TokenStartAndEndCharacters>;
        /**
         * See interface.
         */
        items: KnockoutObservableArray<TItem>;
        /**
         * See interface.
         */
        unrecognizedTokenBehavior: KnockoutObservable<UnrecognizedTokenBehavior>;
        /**
         * See interface.
         */
        removeTokenOnDelete: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        valueKey: KnockoutObservable<string>;
        /**
         * See interface.
         */
        columns: KnockoutObservableArray<Column>;
        /**
         * See interface.
         */
        rowsCount: KnockoutObservable<number>;
        /**
         * See interface.
         */
        defaultColumnWidth: KnockoutObservable<string>;
        /**
         * See interface.
         */
        noRowsMessage: KnockoutObservable<string>;
        /**
        * Constructs a standalone instance of a TokenComboBox view model.
        *
        * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
        * @param options Optional The set of options to configure the TokenComboBox control.
        */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: TokenComboBox.Options<TItem>);
        /**
        * Constructs an instance of a TokenComboBox view model integrated with EditScope.
        *
        * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
        * @param form The form element within which the TokenComboBox is contained.
        * @param observablePath The path to the value on the EditScope to be bound to this field.
        * @param options Optional The set of options to configure the TokenComboBox control.
        */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: TokenComboBox.Options<TItem>);
        /**
        * Constructs an instance of a TokenComboBox view model integrated with EditScope.
        *
        * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
        * @param form The form element within which the TokenComboBox is contained.
        * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
        * @param options Optional The set of options to configure the TokenComboBox control.
        */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: EditScopeAccessors<string>, options?: TokenComboBox.Options<TItem>);
        private _setDefaults(options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Internal\MultiplexingSelectableSet.d.ts
declare module MsPortalFx.ViewModels.Internal {
    class MultiplexingSelectableSet<T, U> implements SelectableItems<T>, SetSelection<U>, MsPortalFx.Base.Disposable {
        private _disposables;
        private _selectableSets;
        private _selectableSetMap;
        private _subs;
        private _getSetName;
        private _syncing;
        /**
         * See interface.
         */
        selectableItems: KnockoutObservableArray<SelectableItem<T>>;
        /**
         * See interface.
         */
        selectedItems: KnockoutObservableArray<U>;
        /**
         * See interface.
         */
        activatedItems: KnockoutObservableArray<U>;
        /**
         * See interface
         */
        itemsWithChildEdits: KnockoutObservableArray<EditedItem<U>>;
        /**
         * Create an instance of the multiplexing selectable set
         *
         * @param getSetName A function that returns an identifier (name) from a selected item for its corresponding registered selectable set.
         * @param compareSelected A comparison function for selectable items.
         * @param initialState Initial state of the view model.
         */
        constructor(getSetName: (selectable: U) => string, initialState?: SetSelection<U>);
        registerSelectableSet(selectableSet: SelectableSet<T, U>, name: string): void;
        unregisterSelectableSet(selectableSet: SelectableSet<T, U>): void;
        unregisterSelectableSet(name: string): void;
        /**
         * See interface.
         */
        dispose(): void;
        private _initComputeds();
        private _initSubs();
        private _initState(initialState);
        /**
         * Setup handles to promote the selectable set's selected and activated collections to the outer set
         */
        private _attachSet(selectableSet, name);
        private _detachSet(selectableSet, removeFromParent?);
        private _removeItems(childArray, parentArray);
        private _syncItemsToChildSets(items, setChildValues, name?);
        /**
         * Sync changes in the children array up to the multiplexer's corresponding array. The reverse sync is handled elsewhere.
         *
         * @param childArray An array on one of the child selectable sets
         * @param parentArray The corresponding array in the parent to childArray.
         * @param ensureSingleValue Indicates if additions to child arrays should replace any existing values in the parent array (rather than appending).
         */
        private _createSyncToParentArray(childArray, parentArray, setName, ensureSingleValue?);
        private _guardedSync(guard, fn);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Internal\Selectable.d.ts
/**
 * Note: By new convention, this should be "FxImpl.ViewModels", but typescript generates the wrong
 *   .d.ts file and downstream projects fail to compile. It gets confused with the use of MsPortalFx.Base.PromiseV.
 */
declare module MsPortalFx.ViewModels.Internal {
    /**
     * Options to configure a delayed blade selection.
     */
    interface DelayedBladeSelectionOptions<TSelection> {
        /**
         * The expected size of the blade.
         */
        bladeWidth: MsPortalFx.Blades.BladeWidth;
        /**
         * Value that indicates whether the selection activation is to be prevented.
         */
        preventActivation?: boolean;
        /**
         * Promise that resolves when the selection once it is known.
         */
        selectedValuePromise: MsPortalFx.Base.PromiseV<TSelection>;
    }
    /**
     * Internal interface that represents selectable component.
     */
    class Selectable<TSelection> extends MsPortalFx.ViewModels.Selectable<TSelection> {
        /**
         * Informs the shell that a delayed blade selection is going to occur.
         */
        delayedBladeSelection: KnockoutObservable<DelayedBladeSelectionOptions<TSelection>>;
        constructor(options?: SelectableOptions<TSelection>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Internal\SelectableSet.d.ts
/**
 * Note: By new convention, this should be "FxImpl.ViewModels", but typescript generates the wrong
 *   .d.ts file and downstream projects fail to compile. It gets confused with the use of MsPortalFx.Base.PromiseV.
 */
declare module MsPortalFx.ViewModels.Internal.SelectableSet {
    interface CreateDelayedBladeSelection<TItem, TSelection> {
        (item: TItem): MsPortalFx.ViewModels.Internal.DelayedBladeSelectionOptions<TSelection>;
    }
    function setCreateDelayedBladeSelection<TItem, TSelection>(selectableSet: MsPortalFx.ViewModels.SelectableSet<TItem, TSelection>, createDelayedBladeSelection: CreateDelayedBladeSelection<TItem, TSelection>): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Internal\Selection2.d.ts
declare module MsPortalFx.ViewModels.Internal.Selection2 {
    import FxBase = MsPortalFx.Base;
    import Disposable = FxBase.Disposable;
    import DynamicSelection = MsPortalFx.ViewModels.DynamicSelection;
    import LifetimeManager = FxBase.LifetimeManager;
    /**
     * Selectable set selection mode.
     */
    const enum SelectionMode {
        /**
         * No selection.
         */
        None = 1,
        /**
         * Only a single item can be selected.
         */
        Single = 2,
        /**
         * Multiple items can be selected.
         */
        Multiple = 3,
    }
    /**
     * Selectable set activation mode.
     */
    const enum ActivationMode {
        /**
         * No activation.
         */
        None = 1,
        /**
         * Only a single item can be activated.
         */
        Single = 2,
    }
    /**
     * Identifies a group of commands.
     */
    interface CommandGroup {
        /**
         * The command group identifier.
         */
        id: string;
        /**
         * The command group owner.
         */
        owner?: string;
    }
    /**
     * Provides a dynamic selection for a data item.
     * This could be a DynamicBladeSelection, DynamicResourceSelection, DynamicAssetSelection or other dynamic selection.
     *
     * @param data The data item.
     * @return The dynamic selection object.
     */
    interface DynamicSelectionProvider<TId, TData, TDynamicSelection extends DynamicSelection> {
        (id: TId, data: TData): MsPortalFx.Base.PromiseV<TDynamicSelection>;
    }
    /**
     * Provides command groups for a data item.
     *
     * @param data The data item.
     * @return The command groups.
     */
    interface CommandGroupProvider<TData> {
        (data: TData): MsPortalFx.Base.PromiseV<CommandGroup[]>;
    }
    /**
     * Selectable set base options.
     */
    interface SelectableSetOptions<TData, TId> {
        /**
         * Data item dynamic selection provider.
         */
        dynamicSelectionProvider?: DynamicSelectionProvider<TId, TData, any>;
        /**
         * Data item command group provider.
         */
        commandGroupProvider?: CommandGroupProvider<TData>;
        /**
         * Set selection mode.
         * Single (Default), Multiple, or None.
         */
        selectionMode?: SelectionMode;
        /**
         * Set activation mode.
         * Single (Default), Multiple, or None.
         */
        activationMode?: ActivationMode;
        /**
         * Currently selected data item ids in the set.
         */
        selectedIds?: KnockoutReadOnlyObservableArray<TId>;
        /**
         * Indicates when all items in the set are selected.
         */
        selectedAll?: KnockoutReadOnlyObservable<boolean>;
        /**
         * Currently unselected data items when selectAll is applied.
         */
        unselectedIds?: KnockoutReadOnlyObservableArray<TId>;
        /**
         * Currently activated data item ids in the set.
         */
        activatedIds?: KnockoutReadOnlyObservableArray<TId>;
    }
    /**
     * Selectable set base contract.
     */
    interface SelectableSetContract<TData, TId> {
        /**
         * Data item dynamic selection provider.
         */
        dynamicSelectionProvider: DynamicSelectionProvider<TId, TData, any>;
        /**
         * Data item command group provider.
         */
        commandGroupProvider: CommandGroupProvider<TData>;
        /**
         * Set selection mode.
         * Single (Default), Multiple, or None.
         */
        selectionMode: SelectionMode;
        /**
         * Set activation mode.
         * Single (Default), or None.
         */
        activationMode: ActivationMode;
        /**
         * Currently selected data item ids in the set.
         */
        selectedIds: KnockoutReadOnlyObservableArray<TId>;
        /**
         * Indicates when all items in the set are selected.
         */
        selectedAll: KnockoutReadOnlyObservable<boolean>;
        /**
         * Currently unselected data items when selectAll is applied.
         */
        unselectedIds: KnockoutReadOnlyObservableArray<TId>;
        /**
         * Currently activated data item ids in the set.
         */
        activatedIds: KnockoutReadOnlyObservableArray<TId>;
    }
    /**
     * Compares two data item ids for equality.
     */
    function compareIds<TId>(id1: TId, id2: TId): boolean;
    /**
     * Selectable set view model.
     */
    class SelectableSet<TData, TId> implements SelectableSetContract<TData, TId>, Disposable {
        /**
         * Data item dynamic selection provider.
         */
        dynamicSelectionProvider: DynamicSelectionProvider<TId, TData, any>;
        /**
         * Data item command group provider.
         */
        commandGroupProvider: CommandGroupProvider<TData>;
        /**
         * Set selection mode.
         * Single (Default), Multiple, or None.
         */
        selectionMode: SelectionMode;
        /**
         * Set activation mode.
         * Single (Default), Multiple, or None.
         */
        activationMode: ActivationMode;
        /**
         * Currently selected data item ids in the set.
         */
        selectedIds: KnockoutReadOnlyObservableArray<TId>;
        /**
         * Indicates when all items in the set are selected.
         */
        selectedAll: KnockoutReadOnlyObservable<boolean>;
        /**
         * Currently unselected data item ids in the set when selectedAll is true.
         */
        unselectedIds: KnockoutReadOnlyObservableArray<TId>;
        /**
         * Currently activated data item ids in the set.
         */
        activatedIds: KnockoutReadOnlyObservableArray<TId>;
        private _lifetime;
        private _msPortalFxSelectableSet;
        /**
         * Constructs a selectable set viewmodel.
         *
         * @param lifetime The lifetime manager.
         * @maram options The options.
         */
        constructor(lifetime: LifetimeManager, options?: SelectableSetOptions<TData, TId>);
        /**
         * Disposes the viewmodel.
         */
        dispose(): void;
        /**
         * Gets the lifetime manager of the viewmodel.
         */
        lifetime: LifetimeManager;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollection\Internal\ProvisioningTelemetry.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection.Internal.ProvisioningTelemetry {
    import FxBase = MsPortalFx.Base;
    import TelemetryEvent = FxBase.Diagnostics.Telemetry.TelemetryEvent;
    module ActionModifier {
        const Failed: string;
        const Succeeded: string;
    }
    module ProvisioningStatus {
        const NoPromise: string;
        const Resolved: string;
        const UnknownFailure: string;
    }
    /**
     * Sets up the Shell-side counterpart to the Provisioner telemetry submitter.
     */
    function registerTelemetrySubmissionHandler(): void;
    /**
     * Traces provisioning started event.
     */
    function traceProvisioningStarted(event?: TelemetryEvent): TelemetryEvent;
    /**
     * Traces provisioning ended event.
     */
    function traceProvisioningEnded(event: TelemetryEvent): TelemetryEvent;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollection\Internals.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection.Internal {
    import FxBase = MsPortalFx.Base;
    /**
     * The model for the "collector" parameter collection binding.
     */
    class CollectorBindingInternals {
        /**
         * The inputs from the collector to the provider.
         */
        inputs: KnockoutObservable<ParameterCollectionInput>;
        /**
         * The errors passed down from the colletor to the provider.
         */
        errors: KnockoutObservable<ParameterCollectionError[]>;
    }
    /**
     * The model for the "provider" parameter collection binding.
     */
    class ProviderBindingInternals {
        /**
         * The outputs of the provider to the collector.
         */
        outputs: KnockoutObservable<ParameterCollectionOutput>;
        /**
         * A Guid that when changes, triggers the process of commiting the changes in the provider
         * and sending them to the collector.
         */
        commit: KnockoutObservable<string>;
    }
    /**
     * The contract for the parameter collection "collector" binding.
     */
    interface ParameterCollectorBinding {
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: CollectorBindingInternals;
    }
    /**
     * The contract for the parameter collection "provider" binding.
     */
    interface ParameterProviderBinding {
        /**
         * Private internal data. Do not use.
         */
        privateFpTcBI: ProviderBindingInternals;
    }
    interface IProvisioner {
        /**
         * The mapped outputs generated by processing the outputs using the mapOutputsForProvisioning function.
         */
        mappedOutputs: ParameterCollectionOutput;
        /**
         * Executes the provisioning command.
         *
         * @param data The parameter collection outputs from the create flow that will be used in the provisioning process.
         * @param options The options used for the provisioning process.
         * @return A Promise object signaling the completion of the provisioning process.
         */
        executeProvisioning(data: ParameterCollectionOutput, options: StringMap<any>): FxBase.Promise;
    }
    /**
     * The provisioner, an entity responsible for executing a provisioning command at the end of a
     * parameter collection process.
     */
    class Provisioner implements FxBase.Disposable {
        /**
         * The deployment response on starting provisioning.
         */
        deploymentResponse: any;
        private _provisioningEntity;
        private _data;
        private _options;
        private _executionDeferred;
        private _provisioningCommandSubscription;
        private _mappedOutputs;
        /**
         * Constructs the provisioner.
         *
         * @param provisioningEntity The provisioning entity.
         */
        constructor(provisioningEntity: ProvisioningEntity);
        /**
         * See interface.
         */
        mappedOutputs: ParameterCollectionOutput;
        /**
         * See interface.
         */
        executeProvisioning(data: ParameterCollectionOutput, options: StringMap<any>): FxBase.Promise;
        /**
         * See interface.
         */
        dispose(): void;
        private _initializeProvisioningEntity(galleryOptions);
        private _beginExecution(data, options);
        private _executeProvisioning(provisioningCommand);
        private _createEventBase();
        private _traceProvisioningStarted();
        private _traceProvisioningEnded(resolved);
    }
    /**
     * Provisioning command status.
     */
    enum ProvisioningCommandStatus {
        /**
         * Command has not being executed yet.
         */
        Idle = 0,
        /**
         * Command is in the process of executing.
         */
        InProgress = 1,
        /**
         * Command has been executed and succeeded.
         */
        Succeeded = 2,
        /**
         * Command has been executed and failed.
         */
        Failed = 3,
    }
    /**
     * A class that represents a provisioning command.
     */
    interface ProvisioningCommand {
        /**
         * Status of the command execution.
         */
        status: KnockoutObservable<ProvisioningCommandStatus>;
        /**
        * Executes the provisioning command.
        *
        * @param options The options needed to configure/execute the command.
        * @return A Promise object indicating whether the provisioning command has succeeded or not.
        */
        execute(options: StringMap<any>): FxBase.PromiseV<any>;
    }
    /**
     * The contract for a parameter collection entity that also does provisioning.
     */
    interface ProvisioningEntity {
        /**
         * Indicates whether the entity will perform a provisioning command or not.
         * Set this true to enable the provisioning logic.
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * True if provisioning should be done using a provisioning part; else false.
         */
        provisionOnStartboardPart?: KnockoutObservable<boolean>;
        /**
         * Private internal data. Do not use.
         */
        privatePcPrBI: ProvisioningEntityBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        cloudName: KnockoutObservable<string>;
        /**
         * Executes the provisioning command. Override this method for custom provisioning.
         *
         * @param data The parameter collection outputs from the create flow that will be used in
         *      the provisioning process.
         * @return A Promise object signaling the completion of the provisioning process.
         */
        executeProvisioning?(data: ParameterCollectionOutput): FxBase.Promise;
        /**
         * Maps the outputs of the parameter collection flow to what the provisioning command expects.
         * Override this method to implement custom mapping.
         *
         * @param originalOutputs The original outputs of the parameter collection flow.
         * @return The mapped outputs, to what the provisioning command expects.
         */
        mapOutputsForProvisioning?(originalOutputs: ParameterCollectionOutput): ParameterCollectionOutput;
    }
    /**
     * The contract for a parameter collection entity that also does provisioning.
     */
    class ProvisioningEntityBindingInternals {
        /**
         * Signals fetching the provisioning command from Shell.
         */
        triggerProvisioningCommand: KnockoutObservable<string>;
        /**
         * The name of the extension that contains the provisioning part.
         */
        provisioningPartExtensionName: KnockoutObservable<string>;
        /**
         * The name of the provisioning part in which to do provisioning.
         */
        provisioningPartName: KnockoutObservable<string>;
        /**
         * Signals the start of provisioning on a startboard part using the specified model.
         * If the startboard part is not already present, it is added.
         */
        triggerProvisioningInStartboardPart: KnockoutObservable<any>;
        /**
         * True if provisioning should be done using a provisioning part; else false.
         */
        masterIsProvisioningPart: KnockoutObservable<boolean>;
        /**
         * Force discards the journey when provisioning starts.
         */
        forceDiscardJourney: KnockoutObservable<boolean>;
        /**
         * The fetched provisioning command.
         */
        provisioningCommand: KnockoutObservable<ProvisioningCommand>;
        /**
         * Signal to the shell that an attempt was made to start provisioning.
         */
        provisioningAttempted: KnockoutObservable<any>;
        /**
         * Signal to the shell that provisioning has started. This means that the attempt to start provisioning was
         * successfully and acknowledged by the service.
         */
        provisioningStarted: KnockoutObservable<any>;
        /**
         * Signal to the provisioner that provisioning has completed.
         */
        provisioningCompleted: KnockoutObservable<any>;
    }
    /**
     * Gets cloud name from selfCloudName or detail blade inputs.
     *
     * @param inputs the inputs parameter from onInputsSet.
     * @returns the cloud name.
     */
    function getCloudNameFromInputs(inputs: any): string;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollection\ParameterCollectionData.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    /**
     * The model for the parameter collection inputs.
     */
    class ParameterCollectionInput {
        /**
         * The input parameters (key-value pairs).
         */
        inputParameters: StringMap<StringMap<string>>;
        /**
         * The input parameters metadata (key-value pairs). The key is the parameter name.
         */
        inputMetadata: StringMap<StringMap<ParameterMetadata>>;
        /**
         * The options needed to configure the behavior of the provider.
         */
        options: StringMap<any>;
    }
    /**
     * The model for the parameter collection outputs.
     */
    class ParameterCollectionOutput {
        /**
         * The output parameters (key-value pairs).
         */
        outputParameters: StringMap<StringMap<string>>;
    }
    /**
     * The model for a parameter collection metadata object. Useful for generated flows.
     */
    interface ParameterMetadata {
        /**
         * The display name for the parameter.
         */
        displayName: string;
        /**
         * The default value for the parameter.
         */
        defaultValue?: any;
        /**
         * The description for the parameter.
         */
        description?: string;
        /**
         * The text for the tool-tip.
         */
        toolTip?: string;
        /**
         * The UI hint used to find and render a suitable control that will capture the value for
         * the parameter (e.g. password, email, url, date, etc.). Used in generated UIs only, and
         * limited to types supported by controls that already exist in MsPortalFx.
         */
        uiHint?: string;
        /**
         * Constraints for rendering and validating the parameter.
         */
        constraints?: ParameterMetadataConstraints;
    }
    /**
     * The model for a parameter collection metadata constraints.
     */
    interface ParameterMetadataConstraints {
        /**
         * A flag indicating whether this parameter is required or not. Defaults to true.
         */
        required?: boolean;
        /**
         * A flag indicating whether this parameter is hidden or not. Defaults to false.
         */
        hidden?: boolean;
        /**
         * A list of possible values for the parameter (key-value pairs). Could be used for
         * validation and/or populating a list or a drop-down.
         */
        allowedValues?: {
            text: string;
            value: any;
        }[];
        /**
         * The range defining the parameter value.
         */
        range?: {
            lowerBind: number;
            upperBound: number;
        };
        /**
         * The length of the parameter value.
         */
        length?: {
            min: number;
            max: number;
        };
        /**
         * The characters the parameter value must contain.
         */
        containsCharacters?: string;
        /**
         * The characters the parameter value must not contain.
         */
        notContainsCharacters?: string;
        /**
         * Whether the parameter value has at least one digit or not.
         */
        hasDigit?: boolean;
        /**
         * Whether the parameter value has at least one letter or not.
         */
        hasLetter?: boolean;
        /**
         * Whether the parameter value has at least one upper-case letter or not.
         */
        hasUpperCaseLetter?: boolean;
        /**
         * Whether the parameter value has at least one lower-case letter or not.
         */
        hasLowerCaseLetter?: boolean;
        /**
         * Whether the parameter value has at least one special character or not.
         */
        hasPunctuation?: boolean;
        /**
         * Whether the parameter value is a number or not.
         */
        numeric?: boolean;
        /**
         * A custom list of constraints (key-value pairs). Useful for custom generated UI.
         */
        custom?: {
            key: string;
            value: string;
        }[];
    }
    /**
     * The model defining a parameter collection error object.
     */
    interface ParameterCollectionError {
        /**
         * The error message.
         */
        errorMessage: string;
        /**
         * The name of the associated parameter, if any.
         */
        parameterName?: string;
    }
    /**
     * A helper class with model transformation methods.
     */
    class Models {
        /**
         * Transforms an editable model object to a list of parameter-sets.
         *
         * @param model The editable model object.
         * @return The list if parameter-sets.
         */
        static modelToParameters<T>(model: T): StringMap<StringMap<string>>;
        /**
         * Transforms a list of parameter-sets to an editable model object.
         *
         * @param data The list if parameter-sets.
         * @return The editable model object.
         */
        static parametersToModel<T>(data: StringMap<StringMap<string>>): T;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollection\ParameterCollector.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    /**
     * The contract for the parameter collection "collector" role.
     * Enables the implementer to collect parameters from parameter provider(s).
     */
    interface ParameterCollector {
        /**
         * Gets the inputs that will be sent to a given provider when launched.
         *
         * @param providerId The id of the provider.
         * @return The inputs for the provider.
         */
        getProviderInputs(providerId: string): ParameterCollectionInput;
        /**
         * Reacts when a provider commits its output parameters.
         *
         * @param providerId The id of the committing provider.
         * @param outputs The outputs from the provider.
         * @return A JQuery promise (boolean) indicating whether to allow or deny the commit action.
         */
        onProviderCommit(providerId: string, outputs: ParameterCollectionOutput): MsPortalFx.Base.PromiseV<boolean>;
        /**
         * Errors to send to the provider.
         */
        parameterCollectionErrors: KnockoutObservable<ParameterCollectionError[]>;
    }
}
declare module MsPortalFx.ViewModels.ParameterCollection.Internal {
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * Class implementing collector-specific functionality.
     */
    class CollectorBase {
        private _provisioner;
        private _previousOutputs;
        private _previousCommit;
        private _previousDetailBladeOutput;
        /**
         * Creates the collector internal instance.
         *
         * @param provisioner The provisioner to use to execute provisioning.
         */
        constructor(provisioner: Internal.IProvisioner);
        /**
         * Executed when the provider binding internals have been received.
         *
         * @param providerBindingInternals The provider binding internals.
         * @param options The options for provisioning.
         * @param detailBladeOutput The actionbar output from the detail blade.
         * @param onProviderCommit The onProviderCommit callback to execute when provider commit conditions have been met.
         * @param onCommitSuccessAction The callback to execute if committed successfully.
         * @param onCommitFailedAction The callback to execute if commit failed.
         */
        onProviderBindingInternalsReceived(providerBindingInternals: ProviderBindingInternals, options: StringMap<any>, detailBladeOutput: FxViewModels.ActionBars.Base.ActionBarOutput, onProviderCommit: (selectorId: string, outputs: ParameterCollectionOutput) => MsPortalFx.Base.PromiseV<boolean>, onCommitSuccessAction: () => void, onCommitFailedAction: () => void): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollection\ParameterProvider.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    import FxBase = MsPortalFx.Base;
    /**
     * The contract for the parameter collection "provider" role.
     * Enables the implementer to communicate collected parameters back to a parameter collector.
     */
    interface ParameterProvider {
        /**
         * Overrides the input parameters that were obtained from the provider.
         *
         * @param inputParameters The input parameters (dictionary of sets of key-value pairs).
         * @return A Promise object that signals when processing the inputs is complete (async).
         */
        overrideInputParameters(inputParameters: StringMap<StringMap<string>>): FxBase.PromiseV<StringMap<StringMap<string>>>;
        /**
         * Triggered when the inputs from the collector are ready.
         *
         * @param inputs The inputs from the collector.
         * @return A Promise object that signals when processing the inputs is complete (async).
         */
        onInputsReceived(inputs: ParameterCollectionInput): FxBase.Promise;
        /**
         * Gets the outputs that will be commited to the collector. Called when the changes in the
         * provider are commited.
         *
         * @return The outputs from the provider.
         */
        getOutputsToCommit(): ParameterCollectionOutput;
        /**
         * Triggered if the collector raises errors after the commit.
         *
         * @param errors The errors raised by the collector.
         */
        onCommitError(errors: ParameterCollectionError[]): void;
    }
}
declare module MsPortalFx.ViewModels.ParameterCollection.Internal {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    import EditScopeViewContract = MsPortalFx.Data.EditScopeViewContract;
    interface OnCollectorBindingInternalsReceivedResult {
        /**
         * True if provisioning is enabled for current entity; else false.
         */
        enableProvisioning: boolean;
        /**
         * Promise that resolves when edit scope has been fetched and onInputsReceived callback has completed.
         */
        promise: FxPromise;
    }
    interface CommitProviderOptions {
        /**
         * True if provisioning is enabled for current entity; else false.
         */
        enableProvisioning: boolean;
        /**
         * Provisioner to use to commit the provider.
         */
        provisioner: IProvisioner;
        /**
         * Outputs to use for provisioning.
         */
        provisionerData: ParameterCollectionOutput;
        /**
         * Options to use for provisioning.
         */
        provisionerOptions: StringMap<any>;
        /**
         * Callback used to setup UI indication that provisioning is in progress.
         */
        progressAction?: (promise: FxPromise) => void;
        /**
         * Callback used to discard edits.
         */
        discardEdits?: () => void;
        /**
         * Binding internals for the provider.
         */
        privateFpTcBI: ProviderBindingInternals;
        /**
         * Binding internals for the provisioner.
         */
        privatePcPrBI?: ProvisioningEntityBindingInternals;
        /**
         * True if provision is to be done on start board; else false.
         */
        provisionOnStartboardPart?: boolean;
    }
    class ProviderBase {
        private _editScopeView;
        private _editScopeFetchPromise;
        private _onInputsReceivedPromise;
        private _previousCollectorInputs;
        /**
         * Creates the provider internal instance.
         *
         * @param editScopeView The edit scope view used by the provider.
         */
        constructor(editScopeView: EditScopeViewContract<Object, ParameterCollectionInput>);
        /**
         * Fetches the edit scope.
         *
         * @param editScopeId The ID of the edit scope to fetch.
         * @param collectorInputs The inputs obtained from the collector.
         * @return The promise that resolves once the edit scope has been fetched.
         */
        fetchEditScope(editScopeId: string, collectorInputs: ParameterCollectionInput): FxPromise;
        /**
         * Initializes the data model for a provider.
         *
         * @param inputs The inputs from the collector.
         * @param overrideInputParameters Callback that can be used to override the default values in the input parameters.
         * @return A promise that resolves when the 'existing data' for the edit scope has been initialized.
         */
        initializeDataModel(inputs: ParameterCollectionInput, overrideInputParameters: (inputParameters: StringMap<StringMap<string>>) => FxBase.PromiseV<StringMap<StringMap<string>>>): JQueryPromiseV<any>;
        /**
         * Executed when collector binding internals have been received.
         *
         * @param collectorInputs Inputs obtained from the collector.
         * @param editScopeId The ID of the edit scope for use by the provider.
         * @param onInputsReceived The onInputsReceived callback exposed by the provider.
         * @return The result containing the promise that resovles once operation completes and the enableProvisioning flag.
         */
        onCollectorBindingsReceived(collectorInputs: ParameterCollectionInput, editScopeId: string, onInputsReceived: (inputs: ParameterCollectionInput) => FxPromise): OnCollectorBindingInternalsReceivedResult;
        /**
         * Commits the provider.
         *
         * @param options The parameters used to commit the provider.
         */
        commitProvider(options: CommitProviderOptions): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollection\ViewModels.BaseCommand.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    import FxViewModels = MsPortalFx.ViewModels;
    import FxControls = FxViewModels.Controls;
    import FxParameterCollectionInternal = Internal;
    import Wizard = FxControls.Wizard;
    /**
     * The contract for the view model for a parameter collection command.
     */
    interface BaseCommandContract extends ParameterCollector, FxParameterCollectionInternal.ParameterCollectorBinding, FxParameterCollectionInternal.ProvisioningEntity {
        /**
         * The previously saved state of the wizard.
         */
        savedState: KnockoutObservable<Wizard.WizardState>;
        /**
         * The current state of the wizard to be saved.
         */
        currentState: KnockoutObservable<Wizard.WizardState>;
        /**
         * The input data for the current step.
         */
        stepInput: KnockoutObservable<Wizard.StepInput>;
    }
    /**
     * The base class for a parameter collection command (collector only).
     */
    class BaseCommandViewModel extends OpenBladeCommand implements BaseCommandContract {
        /**
         * See interface.
         */
        parameterCollectionErrors: KnockoutObservable<ParameterCollectionError[]>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: FxParameterCollectionInternal.CollectorBindingInternals;
        /**
         * See interface.
         */
        savedState: KnockoutObservable<Wizard.WizardState>;
        /**
         * See interface.
         */
        currentState: KnockoutObservable<Wizard.WizardState>;
        /**
         * See interface.
         */
        stepInput: KnockoutObservable<Wizard.StepInput>;
        /**
         * Private internal data. Do not use.
         */
        privatePcPrBI: FxParameterCollectionInternal.ProvisioningEntityBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        cloudName: KnockoutObservable<string>;
        /**
         * See interface.
         */
        enableProvisioning: KnockoutObservable<boolean>;
        private _collectorBase;
        private _container;
        /**
         * Constructs the view model.
         */
        constructor(container: FxViewModels.CommandContainerContract, initialState: any);
        onInputsSet(inputs: any): void;
        /**
         * Gets the inputs for a given provider.
         *
         * @param providerId The id of the provider.
         * @return The inputs for the provider.
         */
        getProviderInputs(providerId: string): ParameterCollectionInput;
        /**
         * Reacts when a provider commits its output parameters.
         *
         * @param providerId The id of the provider.
         * @param outputs The outputs from the provider.
         * @return A JQuery promise (boolean) dictating whether to allow or deny the commit action.
         */
        onProviderCommit(providerId: string, outputs: ParameterCollectionOutput): MsPortalFx.Base.PromiseV<boolean>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollection\ViewModels.BaseForm.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    import Fx = MsPortalFx;
    import FxBase = Fx.Base;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    import FxViewModels = Fx.ViewModels;
    import ActionBars = FxViewModels.ActionBars.Base;
    import Internal = FxViewModels.ParameterCollection.Internal;
    import Pricing = HubsExtension.Azure.Pricing;
    /**
     * The interface for a parameter collection form part (collector only, with no chevrons).
     */
    interface FormPartContract {
    }
    /**
     * The base class for a parameter collection form part (collector only, with no chevrons).
     */
    class BaseFormViewModel<T> extends FxViewModels.Forms.Form.ViewModel<T> implements FxBase.Disposable, Internal.ParameterCollectorBinding, Internal.ParameterProviderBinding, Internal.ProvisioningEntity, FormPartContract {
        /**
         * The edit scope id.
         */
        editScopeId: KnockoutObservable<string>;
        /**
         * Errors to send to the provider.
         */
        parameterCollectionErrors: KnockoutObservable<ParameterCollectionError[]>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: Internal.CollectorBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        privateFpTcBI: Internal.ProviderBindingInternals;
        /**
         * Indicates whether the entity will perform a provisioning command or not.
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        provisionOnStartboardPart: KnockoutObservable<boolean>;
        /**
         * Private internal data. Do not use.
         */
        privatePcPrBI: Internal.ProvisioningEntityBindingInternals;
        /**
         * An instance of MsPortalFx.ViewModels.Selectable to activate selectors.
         */
        selectable: Selectable<any>;
        /**
         * An instance of MsPortalFx.ViewModels.Selectable to activate the action bar's secondary link.
         */
        secondaryLinkSelectable: Selectable<DynamicBladeSelection>;
        /**
         * An instance of MsPortalFx.ViewModels.Selectable to activate hot spots.
         */
        hotSpot: SelectableSet<Selectable<any>, DynamicBladeSelection>;
        /**
         * The input to pass on to the action bar of the details blade.
         */
        stepInput: KnockoutObservable<ActionBars.ActionBarInput>;
        /**
         * The output received from the action bar of the details blade.
         */
        stepOutput: KnockoutObservable<ActionBars.ActionBarOutput>;
        /**
         * Indicates whether an action is in progress or not.
         * An action in progress will disable the action bar regardless of the validity of the form.
         */
        actionInProgress: KnockoutObservable<boolean>;
        /**
         * The summary and/or link to the EULA for the create step.
         */
        eula: KnockoutObservable<string>;
        /**
         * The display text for the link to the right of the create button.
         */
        secondaryLinkDisplayText: KnockoutObservable<string>;
        /**
         * Gallery create pricing information.
         */
        galleryPricingInfo: KnockoutObservable<Pricing.PricingInfo>;
        /**
         * See interface.
         */
        cloudName: KnockoutObservable<string>;
        /**
         * Provider base that for composed functionality. Used by tests.
         */
        _providerBase: Internal.ProviderBase;
        private _actionBarOutput;
        private _actionInProgressLock;
        private _baseCollectorInputs;
        private _baseFormContainer;
        private _baseFormSubscriptions;
        private _baseProviderCommit;
        private _baseProviderOutputs;
        private _deferredProviderDismiss;
        private _hotSpotItems;
        private _initialSelectedValue;
        private _previousOutput;
        private _previousSecondaryLinkCommitId;
        private _provisionerInstance;
        private _savedProviderOutputs;
        private _selectableMap;
        private _galleryItem;
        /**
         * EditScope cache.
         */
        _editScopeCache: MsPortalFx.Data.EditScopeCache<Object, ParameterCollectionInput>;
        /**
         * EditScope view.
         */
        _editScopeView: MsPortalFx.Data.EditScopeView<Object, ParameterCollectionInput>;
        /**
         * Constructs the view model.
         *
         * @param container The view model for part container into which the part is being placed.
         * @param initialState Initial state of the view model.
         * @param dataModelTypeName The metadata type name used in the creation of the edit
         *      scope. If you set this property, you need to define/set your metadata type first.
         *      You can define it using: MsPortalFx.Data.Metadata.setTypeMetadata().
         */
        constructor(container: FxViewModels.PartContainerContract, initialState?: any, dataModelTypeName?: string);
        /**
         * Get an editable copy of the editScope view model.
         *
         * @return The editable copy of the editScope view model.
         */
        dataModel: T;
        /**
         * Invoked when the Part's inputs change.
         */
        onInputsSet(inputs: any): FxPromise;
        /**
         * Registers a hot-spot with the form for opening the blade.
         *
         * @param hotSpotViewModel The selectable that is bound to the hot spot.
         */
        registerHotSpot(hotSpotViewModel: FxViewModels.Selectable<any> | FxViewModels.Controls.HotSpot.ViewModel): void;
        /**
         * Registers a selector with the form for opening the blade that provides values to it.
         *
         * @param id The ID for the form to uniquely identify the selector.
         * @param selectorField The selector form field to be registered.
         */
        registerSelector(id: string, selectorField: FxViewModels.Forms.Selector.ViewModel<any>): void;
        /**
         * See interface.
         */
        overrideInputParameters(inputParameters: StringMap<StringMap<string>>): FxPromiseV<StringMap<StringMap<string>>>;
        /**
         * Gets the inputs for a given provider.
         *
         * @param providerId The id of the provider.
         * @return The inputs for the provider.
         */
        getProviderInputs(providerId: string): ParameterCollectionInput;
        /**
         * Reacts when a provider commits its output parameters.
         *
         * @param providerId The id of the provider.
         * @param outputs The outputs from the provider.
         * @return A JQuery promise (boolean) dictating whether to allow or deny the commit action.
         */
        onProviderCommit(providerId: string, outputs: ParameterCollectionOutput): FxPromiseV<boolean>;
        /**
         * Triggered when the inputs from the collector are ready.
         *
         * @param inputs The inputs from the collector.
         * @return A Promise object that signals when processing the inputs is complete (async).
         */
        onInputsReceived(inputs: ParameterCollectionInput): FxPromise;
        /**
         * Gets the outputs that will be commited to the collector.
         *
         * @return The outputs from the provider.
         */
        getOutputsToCommit(): ParameterCollectionOutput;
        /**
         * Triggered if the collector raises errors after the commit.
         *
         * @param errors The errors raise by the collector.
         */
        onCommitError(errors: ParameterCollectionError[]): void;
        /**
         * See interface.
         */
        dispose(): void;
        private _unselectFields(exceptionSelector?);
        private _resetSelectionStateOfSelectors(value);
        private _onSelectorLoad(selectorId);
        private _onSelectorComplete(selectorId);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollection\ViewModels.BaseGalleryButtonPart.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxControls = FxViewModels.Controls;
    import Wizard = FxControls.Wizard;
    /**
     * The contract for the view model for a parameter collection button part.
     */
    interface BaseGalleryButtonPartContract {
        /**
         * The previously saved state of the wizard.
         */
        savedState: KnockoutObservable<Wizard.WizardState>;
        /**
         * The current state of the wizard to be saved.
         */
        currentState: KnockoutObservable<Wizard.WizardState>;
        /**
         * The input data for the current step.
         */
        stepInput: KnockoutObservable<Wizard.StepInput>;
        /**
         * Output of the current step propagated from it's details blade.
         */
        stepOutput: KnockoutObservable<Wizard.StepOutput>;
        /**
         * A value used to determine when to call executeCommand.
         */
        beginExecuteCommand: KnockoutObservable<boolean>;
    }
    /**
     * The base class for a parameter collection button part (provider only).
     *
     * IMPORTANT: An instance of this class can be used to kick off the create flow (following the
     * Samples Extension). However, once the gallery hub is available, it will invoke the create flows
     * directly with the correct parameters (from the Gallery service) and replace this button.
     */
    class BaseGalleryButtonPartViewModel extends FxViewModels.ButtonPart implements FxBase.Disposable, BaseGalleryButtonPartContract, ParameterCollector, Internal.ParameterCollectorBinding {
        /**
         * The edit scope id.
         */
        editScopeId: KnockoutObservable<string>;
        /**
         * Errors to send to the provider.
         */
        parameterCollectionErrors: KnockoutObservable<ParameterCollectionError[]>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: Internal.CollectorBindingInternals;
        /**
        * The previously saved state of the wizard.
        */
        savedState: KnockoutObservable<Wizard.WizardState>;
        /**
        * The current state of the wizard to be saved.
        */
        currentState: KnockoutObservable<Wizard.WizardState>;
        /**
         * The input data for the current step.
         */
        stepInput: KnockoutObservable<Wizard.StepInput>;
        /**
         * Output of the current step propagated from it's details blade.
         */
        stepOutput: KnockoutObservable<Wizard.StepOutput>;
        /**
        * A value indicating whether or not to start the command.
        */
        beginExecuteCommand: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        cloudName: KnockoutObservable<string>;
        _commit: KnockoutObservable<string>;
        private _baseButtonContainer;
        private _basePartSubscriptions;
        private _baseProviderCommit;
        private _initialLoadComplete;
        /**
         * Constructs the view model.
         */
        constructor(container: PartContainerContract, initialState: any, allowToggleProvisioningLocation?: boolean, isProvisioningPart?: boolean);
        /**
         * Invoked when the Part's inputs change.
         */
        onInputsSet(inputs: any): FxBase.Promise;
        /**
         * Gets the inputs for a given provider.
         *
         * @param providerId The id of the provider.
         * @return The inputs for the provider.
         */
        getProviderInputs(providerId: string): ParameterCollectionInput;
        /**
         * Reacts when a provider commits its output parameters.
         *
         * @param providerId The id of the provider.
         * @param outputs The outputs from the provider.
         * @return A JQuery promise (boolean) dictating whether to allow or deny the commit action.
         */
        onProviderCommit(providerId: string, outputs: ParameterCollectionOutput): FxBase.PromiseV<boolean>;
        /**
         * See interface.
         */
        dispose(): void;
        _processStepOutput(stepOutput: Wizard.StepOutput): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollection\ViewModels.BasePickerList.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxControls = FxViewModels.Controls;
    import FxLists = FxControls.Lists;
    import FxGrid = FxLists.Grid;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    import ActionBarsBase = FxViewModels.ActionBars.Base;
    import SelectorViewModel = FxViewModels.Forms.Selector.ViewModel;
    import DynamicBladeSelection = FxViewModels.DynamicBladeSelection;
    /**
     * Pickers list Interface.
     * The contract to support data for pickers and providing grid options as required by consumer.
     */
    interface PickerList<TItem> {
        /**
         * Gets the columns list for the Picker Grid.
         *
         * @return The Columns list for the picker grid.
         */
        getColumns(): KnockoutObservableArray<FxGrid.Column>;
        /**
         * Gets the index number for the grid item matching with the given id.
         *
         * @param id The id to match with the grid items
         * @return The index for the matching grid item with the given id.
         */
        getMatchingItemIndex(id: any): number;
        /**
         * The items match selection criteria for the Picker grid.
         *
         * @param item Item from the picker grid.
         * @param selection Selection from the grid createSelection interface.
         * @return The result that identifies whether item matches the selection.
         */
        itemMatchesSelection(item: TItem, selection: any): boolean;
        /**
         * A factory function that returns selection based on a grid item.
         *
         * @param item Item from the picker grid.
         * @return Returns the selection based on an grid item selected.
         */
        createSelection(item: TItem): any;
        /**
         * The header of the list.
         */
        listHeader: KnockoutObservable<string>;
        /**
         * The subheader of the list.
         */
        listSubHeader: KnockoutObservable<string>;
        /**
         * The summary and/or link to the EULA.
         */
        eula: KnockoutObservable<string>;
    }
    interface PickerListPartContract<TItem> extends PickerList<TItem> {
    }
    /**
     * Pickers list base view model implements Parameter Collector and Provider Bindings.
     */
    class BasePickerListViewModel<TItem, TDataModel> extends FxControls.Loadable.ViewModel implements FxBase.Disposable, Internal.ParameterCollectorBinding, Internal.ParameterProviderBinding {
        /**
         * The edit scope id for picker.
         */
        editScopeId: KnockoutObservable<string>;
        /**
         * The grid view model for picker items.
         */
        itemsGridViewModel: FxGrid.ViewModel<TItem, any>;
        /**
         * Triggers the select action.
         */
        triggerSelectAction: KnockoutObservable<string>;
        /**
         * See interface.
         */
        multiselectEnabled: KnockoutObservable<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * The flag to indicate whether create action visible or not.
         */
        showCreateAction: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        eula: KnockoutObservable<string>;
        /**
         * Errors to send to the provider. Do not use.
         */
        parameterCollectionErrors: KnockoutObservable<ParameterCollectionError[]>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: Internal.CollectorBindingInternals;
        /**
         * The parameter names for picker grid options.
         */
        filterPickerItemsParameterName: string;
        pickerItemsParameterName: string;
        /**
         * The List Header string to show on picker list part.
         */
        listHeader: KnockoutObservable<string>;
        /**
         * The List sub header string to show on picker list part.
         */
        listSubHeader: KnockoutObservable<string>;
        /**
         * The flag to indicate whether create Action providing the result from picker.
         */
        isCreateActionResult: KnockoutObservable<boolean>;
        /**
         * The create action outputs to return back to picker control invoker.
         */
        _createActionOutputs: ParameterCollectionOutput;
        /**
         * Private internal data. Do not use.
         */
        privateFpTcBI: Internal.ProviderBindingInternals;
        /**
         * The wizard step input provided as input to picker.
         */
        stepInput: KnockoutObservable<ActionBarsBase.ActionBarInput>;
        /**
         * The create action selector field.
         */
        createActionSelectorField: KnockoutObservable<SelectorViewModel<string>>;
        /**
         * The picker list activation blade opener to open the dynamic blade based on picker requirement.
         */
        pickerActivationBladeOpener: KnockoutObservable<DynamicBladeSelection>;
        /**
         * The create blade opener to open the dynamic blade based on inputs.
         */
        createActionBladeOpener: KnockoutObservable<DynamicBladeSelection>;
        /**
         * The item selected by default in the grid.
         */
        itemSelectedByDefault: KnockoutObservable<any>;
        /**
         * The filterItems provided by the picker invoker as options.
         */
        filterItems: KnockoutObservable<any>;
        private _filteredItems;
        /**
         * EditScope cache.
         */
        _editScopeCache: MsPortalFx.Data.EditScopeCache<Object, ParameterCollectionInput>;
        /**
         * EditScope view.
         */
        _editScopeView: MsPortalFx.Data.EditScopeView<Object, ParameterCollectionInput>;
        _providerBase: Internal.ProviderBase;
        /**
         * The inputs provided to picker stored here to provide these to selection action.
         */
        private _pickerInputCollections;
        /**
         * The flag to indicate whether the create action provider commited output or not.
         */
        private _createActionProviderCommited;
        private _actionBarOutput;
        /**
         * The selector field properties for create action.
         */
        private _createSelectorField;
        private _selectorOriginalValue;
        private _selectorEditableValue;
        private _createSelectorBladeName;
        private _createSelectorBladeExtension;
        private _throttleUnselectSelectorFieldHandle;
        /**
         * The part container local variable.
         */
        private _partContainer;
        /**
         * The set of filters to filter items on.
         */
        filters: KnockoutObservableArray<FxViewModels.PickerFilter.IPickerItemsFilter<TItem>>;
        /**
         * Constructs a new picker list view model.
         *
         * @param container The container into which the part is being placed.
         * @param initialState Initial state for the part.
         * @param items The Obervable array of picker items of type TItem to populate.
         * @param multiselect Optional. True if the picker supports multiple selection. Defaults to false.
         */
        constructor(container: PartContainerContract, initialState: any, items: KnockoutObservableArray<TItem>, multiselect?: boolean, dataNavigator?: MsPortalFx.Data.DataNavigatorBase<any>);
        /**
         * Initializes Create Selector on Picker Blade with given blade action inputs.
         *
         * @param initialValue The initial value Selector uses.
         * @param createActionTitle The title for Selector control.
         * @param createActionBladeName The blade name to launch on Selector selection.
         * @param createActionBladeExtension The optional field for extension name to launch the create action blade from that extension.
         * @param validations The optional field for validations to apply on this selector field.
         */
        initializeCreateSelector(initialValue: string, createActionTitle: string, createActionBladeName: string, createActionBladeExtension?: string, validations?: FxViewModels.FormValidation[]): void;
        /**
         * Invoked when the Part's inputs change.
         *
         * @param inputs Inputs is collection of input and output parameters to blade.
         * @return Promise for onInputsSet to notify completion.
         */
        onInputsSet(inputs: any): FxPromise;
        /**
         * See interface.
         */
        overrideInputParameters(inputParameters: StringMap<StringMap<string>>): FxPromiseV<StringMap<StringMap<string>>>;
        /**
         * Gets the parameter given from the list of parameters given.
         *
         * @param parameterName The parameterName to get from collection.
         * @param parameters The collection of parameters.
         * @return The parameter value from collection.
         */
        getParameter<T>(parameterName: string, parameterSetName: string, parameters: StringMap<StringMap<T>>): T;
        /**
         * See interface.
         */
        dispose(): void;
        /**
         * Get the data model bound to the provider. This is where all parameter collection data
         * are persisted.
         *
         * @return The data model.
         */
        dataModel: TDataModel;
        /**
         * See interface.
         */
        getMatchingItemIndex(id: any): number;
        /**
         * See interface.
         */
        getColumns(): KnockoutObservableArray<FxGrid.Column>;
        /**
         * See interface.
         */
        itemMatchesSelection(item: TItem, selection: any): boolean;
        /**
         * See interface.
         */
        createSelection(item: TItem): any;
        /**
         * See interface.
         */
        getProviderInputs(providerId: string): ParameterCollectionInput;
        /**
         * See interface.
         */
        onProviderCommit(providerId: string, outputs: ParameterCollectionOutput): FxPromiseV<boolean>;
        /**
         * See interface.
         */
        onInputsReceived(inputs: ParameterCollectionInput): FxPromise;
        /**
         * See interface.
         */
        getOutputsToCommit(): ParameterCollectionOutput;
        /**
         * See interface.
         */
        onCommitError(errors: ParameterCollectionError[]): void;
        private _onSelectedItemsChanged(selectedItems);
        private _runFilters(items);
        private _closeBlade(selectedItems);
        private _clearThrottleUnselectSelectorFieldHandle();
        /**
         * Gets Grid Extension Options.
         *
         * @return Grid Extension options with select type and other grid extension options
         */
        private _getGridExtensionOptions();
        /**
         * Selects the grid item based on given index.
         *
         * @param index Row index to select in the grid.
         */
        private _selectGridItem(index);
        /**
         * Disables the specified grid item ..
         *
         * @param item Item to disable in the grid.
         * @param reason Reason for disabling the row in the grid.
         */
        private _disableGridItem(item, reason);
        /**
         * Initialize create action selector with defaults.
         */
        private _initializeCreateActionSelector();
        /**
         * Launch create action blade with the inputs required.
         */
        private _launchCreateActionBlade();
        /**
         * Filter Grid Items.
         */
        private _filterGridItems(filterValues);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollection\ViewModels.BaseWizard.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxWizard = FxViewModels.Controls.Wizard;
    import ActionBarBase = FxViewModels.ActionBars.Base;
    interface WizardPartContract extends FxWizard.Contract {
    }
    /**
     * The base class for a parameter collection wizard part (collector and provider).
     */
    class BaseWizardViewModel<T> extends FxWizard.ViewModel implements FxBase.Disposable, Internal.ParameterCollectorBinding, Internal.ParameterProviderBinding, Internal.ProvisioningEntity, WizardPartContract {
        /**
         * The edit scope id.
         */
        editScopeId: KnockoutObservable<string>;
        /**
         * Errors to send to the provider.
         */
        parameterCollectionErrors: KnockoutObservable<ParameterCollectionError[]>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: Internal.CollectorBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        privateFpTcBI: Internal.ProviderBindingInternals;
        /**
         * Indicates whether the entity will perform a provisioning command or not.
         * Set this true to enable the provisioning logic.
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        provisionOnStartboardPart: KnockoutObservable<boolean>;
        /**
         * Private internal data. Do not use.
         */
        privatePcPrBI: Internal.ProvisioningEntityBindingInternals;
        /**
         * True if the form has been validated and is valid; else false.
         */
        valid: KnockoutComputed<boolean>;
        /**
         * The summary and/or link to the EULA for the create step.
         */
        eula: KnockoutObservable<string>;
        /**
         * See interface.
         */
        cloudName: KnockoutObservable<string>;
        /**
         * EditScope cache.
         */
        private _editScopeCache;
        /**
         * EditScope view.
         */
        private _editScopeView;
        private _actionBarOutput;
        private _baseCollectorInputs;
        private _baseProviderCommit;
        private _baseProviderOutputs;
        private _baseWizardContainer;
        private _baseWizardSubs;
        private _deferredProviderDismiss;
        private _providerBase;
        private _provisionerInstance;
        private _savedProviderOutputs;
        /**
         * Constructs the view model.
         *
         * @param container The view model for part container into which the part is being placed.
         * @param initialState Initial state of the view model.
         * @param dataModelTypeName The metadata type name used in the creation of the edit
         *      scope. If you set this property, you need to define/set your metadata type first.
         *      You can define it using: FxData.Metadata.setTypeMetadata().
         */
        constructor(container: FxViewModels.PartContainerContract, initialState: any, dataModelTypeName?: string);
        /**
         * Get the data model bound to the provider. This is where all parameter collection data
         * are persisted.
         *
         * @return The data model.
         */
        dataModel: T;
        /**
         * Invoked when the Part's inputs change.
         */
        onInputsSet(inputs: any): FxPromise;
        /**
         * See interface.
         */
        overrideInputParameters(inputParameters: StringMap<StringMap<string>>): FxPromiseV<StringMap<StringMap<string>>>;
        /**
         * Gets the inputs for a given provider.
         *
         * @param providerId The id of the provider.
         * @return The inputs for the provider.
         */
        getProviderInputs(providerId: string): ParameterCollectionInput;
        /**
         * Reacts when a provider commits its output parameters.
         *
         * @param providerId The id of the provider.
         * @param outputs The outputs from the provider.
         * @return A JQuery promise (boolean) dictating whether to allow or deny the commit action.
         */
        onProviderCommit(providerId: string, outputs: ParameterCollectionOutput): FxPromiseV<boolean>;
        /**
         * Triggered when the inputs from the collector are ready.
         *
         * @param inputs The inputs from the collector.
         * @return A Promise object that signals when processing the inputs is complete (async).
         */
        onInputsReceived(inputs: ParameterCollectionInput): FxPromise;
        /**
         * Gets the outputs that will be commited to the collector.
         *
         * @return The outputs from the provider.
         */
        getOutputsToCommit(): ParameterCollectionOutput;
        /**
         * Triggered if the collector raises errors after the commit.
         *
         * @param errors The errors raise by the collector.
         */
        onCommitError(errors: ParameterCollectionError[]): void;
        /**
         * See interface.
         */
        dispose(): void;
        /**
         * Adds a wizard step.
         *
         * @param stepId The ID that uniquely identifies the step.
         * @param title The title for the wizard step.
         * @param formBlade The blade containing the form for the wizard step.
         * @param description The description for the wizard step.
         * @param isOptional A value indicating whether or not the step is optional.
         * @param status The initial status of the step.
         * @param extension The extension that hosts the blade containing the form for the wizard step.
         */
        addWizardStep(stepId: string, title: string, formBlade: string, description?: string, isOptional?: boolean, status?: ActionBarBase.Status, extension?: string): void;
        /**
         * Inserts a wizard step at the specified position.
         *
         * @param position The 0 based position at which to insert the step.
         * @param stepId The ID that uniquely identifies the step.
         * @param title The title for the wizard step.
         * @param formBlade The blade containing the form for the wizard step.
         * @param description The description for the wizard step.
         * @param isOptional A value indicating whether or not the step is optional.
         * @param status The initial status of the step.
         * @param extension The extension that hosts the blade containing the form for the wizard step.
         */
        insertWizardStep(position: number, stepId: string, title: string, formBlade: string, description?: string, isOptional?: boolean, status?: ActionBarBase.Status, extension?: string): void;
        /**
         * Removes the specified wizard step.
         *
         * @param step The step to be removed.
         */
        removeWizardStep(step: FxWizard.WizardStep): void;
        /**
         * Removes the wizard step at the specified position.
         *
         * @param position The 0 based position at which to remove the step.
         * @return The step that was removed.
         */
        removeWizardStepAt(position: number): FxWizard.WizardStep;
        private _onStepLoad(step);
        private _onStepComplete(step);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\Internal\Internals.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV2.Internal {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    import FxData = MsPortalFx.Data;
    /**
     * The edit scope implementation for parameter collection roles.
     */
    interface EditScope<T> {
        /**
         * The inputs sent by the parameter collector.
         */
        collectorInputs: ParameterCollectionInput;
        /**
         * Gets the edit scope.
         *
         * @return The edit scope.
         */
        editScope: KnockoutObservable<FxData.EditScope<any>>;
        /**
         * Get an editable copy of the editScope view model. This view model has the same structure
         * as the parameter collection inputs received (and the optional overrides).
         *
         * @return The editable copy of the editScope view model.
         */
        dataModel: T;
        /**
         * Processes the inputs received by the view model referencing this object. This method
         * should be called inside the 'onInputsSet' method.
         *
         * @param inputs The inputs to the part.
         * @return A promise signaling the completion of processing the inputs.
         */
        processInputs(inputs: any): FxPromise;
        /**
         * Initializes the edit scope.
         */
        initializeEditScope(): void;
        /**
         * Fetches the edit scope.
         *
         * @return The promise that resolves once the edit scope has been fetched.
         */
        fetchEditScope(): FxPromise;
        /**
         * Initializes the data model.
         *
         * @param inputs The inputs from the collector.
         * @param overrideInputParameters Callback that can be used to override the default values in the input parameters.
         * @return A promise that resolves when the 'existing data' for the edit scope has been initialized.
         */
        initializeDataModel(inputs: ParameterCollectionInput, overrideInputParameters: (inputParameters: InputParameters, inputMetadata: InputMetadata, parameterCollectionOptions: ParameterCollectionOptions) => FxPromiseV<ParameterCollectionInput>): FxPromiseV<any>;
        /**
         * Discard the edits made to the edit scope.
         */
        discardEditScopeEdits(): void;
    }
    /**
     * The edit scope factory.
     */
    class EditScopeFactory {
        /**
         * Creates an instance of the edit scope implementation.
         *
         * @param providerRole The provider role implementation object.
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param initializeMethod An optional initialization method that runs once the edit scope has been created.
         * @param editScopeView An optional editScopeView object.
         * @return An instance of the edit scope  implementation.
         */
        static createEditScope<T>(providerRole: Roles.ParameterProvider, lifetimeManager: FxBase.LifetimeManager, initializeMethod?: () => FxPromise, editScopeView?: FxData.EditScopeView<Object, ParameterCollectionInput>): EditScope<T>;
    }
    /**
     * The contract for the parameter collection "collector" binding.
     */
    interface ParameterCollectorPdlBinding {
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: CollectorBindingInternals;
    }
    /**
     * The contract for the parameter collection "provider" binding.
     */
    interface ParameterProviderPdlBinding {
        /**
         * Private internal data. Do not use.
         */
        privateFpTcBI: ProviderBindingInternals;
    }
    /**
     * The model for the "collector" parameter collection binding.
     */
    class CollectorBindingInternals {
        /**
         * The inputs from the collector to the provider.
         */
        inputs: KnockoutObservable<ParameterCollectionInput>;
        /**
         * The errors passed down from the colletor to the provider.
         */
        errors: KnockoutObservable<ParameterCollectionError[]>;
    }
    /**
     * The model for the "provider" parameter collection binding.
     */
    class ProviderBindingInternals {
        /**
         * The outputs of the provider to the collector.
         */
        outputs: KnockoutObservable<ParameterCollectionOutput>;
        /**
         * A Guid that when changes, triggers the process of commiting the changes in the provider
         * and sending them to the collector.
         */
        commit: KnockoutObservable<string>;
    }
    /**
     * The model for the "provisioner" binding.
     */
    class ProvisionerBindingInternals {
        /**
         * Signals fetching the provisioning command from Shell.
         */
        triggerProvisioningCommand: KnockoutObservable<string>;
        /**
         * The name of the extension that contains the provisioning part.
         */
        provisioningPartExtensionName: KnockoutObservable<string>;
        /**
         * The name of the provisioning part in which to do provisioning.
         */
        provisioningPartName: KnockoutObservable<string>;
        /**
         * Signals the start of provisioning on a startboard part using the specified model.
         * If the startboard part is not already present, it is added.
         */
        triggerProvisioningInStartboardPart: KnockoutObservable<any>;
        /**
         * True if provisioning should be done using a provisioning part; else false.
         */
        masterIsProvisioningPart: KnockoutObservable<boolean>;
        /**
         * Force discards the journey when provisioning starts.
         */
        forceDiscardJourney: KnockoutObservable<boolean>;
        /**
         * The fetched provisioning command.
         */
        provisioningCommand: KnockoutObservable<ProvisioningCommand>;
        /**
         * Signal to the shell that an attempt was made to start provisioning.
         */
        provisioningAttempted: KnockoutObservable<any>;
        /**
         * Signal to the shell that provisioning has started. This means that the attempt to start provisioning was
         * successfully and acknowledged by the service.
         */
        provisioningStarted: KnockoutObservable<any>;
        /**
         * Signal to the provisioner that provisioning has completed.
         */
        provisioningCompleted: KnockoutObservable<any>;
    }
    /**
     * The parameter collector.
     */
    interface ParameterCollector<T> {
        /**
         * The outputs returned by the the last launched provider.
         */
        providerOutputs: ParameterCollectionOutput;
        /**
         * Processes the inputs received by the view model referencing this object. This method
         * should be called inside the 'onInputsSet' method.
         *
         * @param inputs The inputs to the part.
         * @return A promise signaling the completion of processing the inputs.
         */
        processInputs(inputs: any): FxPromise;
        /**
         * Adds a provider to the list of tracked providers.
         *
         * @param providerId The id of the parameter provider.
         * @param collectorCallbacks The collector inline implementation that handles this provider.
         */
        addProvider(providerId: string, collectorCallbacks: Roles.CollectorCallbacks): void;
        /**
         * Removes a provider from the list of tracked providers.
         *
         * @param providerId The id of the parameter provider.
         */
        removeProvider(providerId: string): void;
        /**
         * Creates the inputs for a given parameter provider and sends them to that provider.
         *
         * @param providerId The id of the parameter provider.
         * @retrun void.
         */
        sendInputsToProvider(providerId: string): void;
        /**
         * Commits the outputs returned back by the parameter provider. This includes both validating
         * and saving the returned outputs.
         *
         * @param providerId The id of the parameter provider.
         * @return A thenable signaling the completion of the output commit process.
         */
        commitProviderOutputs(providerId: string): FxPromise;
    }
    /**
     * Options used to initialize a parameter collector.
     */
    interface ParameterCollectorOptions {
        /**
         * Flag indicating whether the commit action is executed once the commit signal is available
         * (eg. command), opposed to waiting for the UI element view model to trigger that action
         * explicitly (eg. form).
         */
        commitWhenSignaled: boolean;
        /**
         * The commit action to be executed when the provider commits.
         */
        commitAction: () => void;
    }
    /**
     * The parameter collector factory.
     */
    class ParameterCollectorFactory {
        /**
         * The confim-commit suffix.
         */
        static confirmCommitSuffix: string;
        /**
         * The try-commit suffix.
         */
        static tryCommitSuffix: string;
        /**
         * Creates an instance of the parameter collector implementation.
         *
         * @param collectorRole The collector role implementation object.
         * @param editScope The edit scope implementation object.
         * @param privateFcTpBI The parameter collector binding internals.
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer
         *      being used by the caller.
         * @param commitWhenSignaled Whether to commit automatically when signaled (opposed to wait
         *      for the part to control the commit action). The commit action will be called with a
         *      provider id of null (i.e. assuming only one provider).
         * @return An instance of the parameter collec implementation.
         */
        static createParameterCollector<T>(collectorRole: Roles.ParameterCollector, editScope: EditScope<T>, privateFcTpBI: Internal.CollectorBindingInternals, lifetimeManager: FxBase.LifetimeManager, options?: ParameterCollectorOptions): ParameterCollector<T>;
    }
    /**
     * The parameter provider.
     */
    interface ParameterProvider<T> {
        /**
         * Processes the inputs received by the view model referencing this object. This method
         * should be called inside the 'onInputsSet' method.
         *
         * @param inputs The inputs to the part.
         * @return A promise signaling the completion of processing the inputs.
         */
        processInputs(inputs: any): FxPromise;
        /**
         * Get the outputs that the provider will commit back to the collector.
         *
         * @return A promise resolved with the parameter collection outputs.
         */
        getOutputsToCommit(): FxPromiseV<ParameterCollectionOutput>;
        /**
         * Commit the outputs and send them back to the collector.
         *
         * @param options The options used in the commit process.
         */
        commitOutputs(options: ProviderCommitOptions): void;
    }
    /**
     * The parameter provider factory.
     */
    class ParameterProviderFactory {
        /**
         * Creates an instance of the parameter provider implementation.
         *
         * @param providerRole The provider role implementation object.
         * @param editScope The edit scope implementation object.
         * @return An instance of the parameter provider implementation.
         */
        static createParameterProvider<T>(providerRole: Roles.ParameterProvider, editScope: EditScope<T>): ParameterProvider<T>;
    }
    /**
     * The commit options the provider uses in the commit process.
     */
    interface ProviderCommitOptions {
        /**
         * Provisioner to use to commit the provider.
         */
        provisioner: Provisioner;
        /**
         * Outputs to use for provisioning.
         */
        provisionerData: ParameterCollectionOutput;
        /**
         * Callback used to setup UI indication that provisioning is in progress.
         */
        progressAction?: (promise: FxPromise) => void;
        /**
         * Callback used to discard edits.
         */
        discardEdits?: () => void;
        /**
         * Binding internals for the provider.
         */
        privateFpTcBI: ProviderBindingInternals;
        /**
         * Binding internals for the provisioner.
         */
        privatePcPrBI?: ProvisionerBindingInternals;
    }
    /**
     * The provisioner contract.
     */
    interface Provisioner {
        /**
         * Indicates whether the entity will perform a provisioning command or not.
         * Set this true to enable the provisioning logic.
         */
        enableProvisioning: KnockoutObservableBase<boolean>;
        /**
         * Indicating whether provisioning will take place on a startboard part or on the current UI
         * element part (form, wizard, etc.).
         */
        provisionOnStartboardPart: KnockoutObservableBase<boolean>;
        /**
         * The mapped outputs generated by processing the outputs using the 'mapOutputsForProvisioning'
         * function.
         */
        mappedOutputs: ParameterCollectionOutput;
        /**
         * Processes the inputs received by the view model referencing this object. This method
         * should be called inside the 'onInputsSet' method.
         *
         * @param inputs The inputs to the part.
         * @return A promise signaling the completion of processing the inputs.
         */
        processInputs(inputs: any): FxPromise;
        /**
         * Executes the provisioning command.
         *
         * @param data The parameter collection outputs from the create flow that will be used in the
         *      provisioning process.
         * @param options The options used for the provisioning process.
         * @return A promise object signaling the completion of the provisioning process.
         */
        executeProvisioning(data: ParameterCollectionOutput, options: StringMap<any>): FxPromise;
    }
    /**
     * The provisioner factory.
     */
    class ProvisionerFactory {
        /**
         * Creates an instance of the parameter provider implementation.
         *
         * @param provisionerRole The provisioner role implementation object.
         * @param privatePcPrBI The provisioning binding internals.
         * @return An instance of the provisioner implementation.
         */
        static createProvisioner(provisionerRole: Roles.Provisioner, privatePcPrBI: ProvisionerBindingInternals): Provisioner;
    }
    /**
     * Provisioning command status.
     */
    enum ProvisioningCommandStatus {
        /**
         * Command has not being executed yet.
         */
        Idle = 0,
        /**
         * Command is in the process of executing.
         */
        InProgress = 1,
        /**
         * Command has been executed and succeeded.
         */
        Succeeded = 2,
        /**
         * Command has been executed and failed.
         */
        Failed = 3,
    }
    /**
     * A class that represents a provisioning command.
     */
    interface ProvisioningCommand {
        /**
         * Status of the command execution.
         */
        status: KnockoutObservable<ProvisioningCommandStatus>;
        /**
         * Executes the provisioning command.
         *
         * @param options The options needed to configure/execute the command.
         * @return A Thenable object indicating whether the provisioning command has succeeded or not.
         */
        execute(options: StringMap<any>): MsPortalFx.Base.PromiseV<any>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\ParameterCollectionData.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV2 {
    /**
     * The input parameters: The input parameters passed from the collector to the provider.
     *
     * Defined as a dictionary of parameter sets (key is a string, parameter set name - value is an
     * object, the parameter set). A parameter set is a dictionary of parameters (key is a string,
     * parameter name - value is a string, parameter value).
     */
    interface InputParameters extends ParameterSetCollection {
    }
    /**
     * The input parameters metadata: The metadata for the input parameters passed from the collector
     * to the provider.
     *
     * Defined as a dictionary of parameter metadata sets (key is a string, parameter metadata set
     * name - value is an object, the parameter metadata set). A parameter metadata set is a
     * dictionary of parameter metadata (key is a string, parameter name - value is a ParameterMetadata
     * object, parameter metadata).
     */
    interface InputMetadata extends StringMap<StringMap<ParameterMetadata>> {
    }
    /**
     * The parameter collection options: A set of options that the collector uses to configure the
     * behavior of the provider.
     *
     * Defined as a dictionary of option sets (key is a string, option set name - value is an object,
     * a bag of options).
     */
    interface ParameterCollectionOptions extends StringMap<StringMap<any>> {
    }
    /**
     * The output parameters: The output parameters sent back from the provider to the collector.
     *
     * Defined as a dictionary of parameter sets (key is a string, parameter set name - value is an
     * object, the parameter set). A parameter set is a dictionary of parameters (key is a string,
     * parameter name - value is a string, parameter value).
     */
    interface OutputParameters extends ParameterSetCollection {
    }
    /**
     * The model for the parameter collection inputs.
     */
    class ParameterCollectionInput {
        /**
         * The input parameters.
         */
        inputParameters: InputParameters;
        /**
         * The input parameters metadata.
         */
        inputMetadata: InputMetadata;
        /**
         * The options needed to configure the behavior of the provider.
         */
        options: ParameterCollectionOptions;
    }
    /**
     * The model for the parameter collection outputs.
     */
    class ParameterCollectionOutput {
        /**
         * The output parameters.
         */
        outputParameters: OutputParameters;
    }
    /**
     * The model for a parameter collection metadata object. Useful for conditional UI and generated
     * parameter collection flows.
     */
    interface ParameterMetadata {
        /**
         * The display name for the parameter.
         */
        displayName: string;
        /**
         * The default value for the parameter.
         */
        defaultValue?: any;
        /**
         * The description for the parameter.
         */
        description?: string;
        /**
         * The text for the tool-tip.
         */
        toolTip?: string;
        /**
         * The UI hint used to find and render a suitable control that will capture the value for
         * the parameter (e.g. password, email, url, date, etc.). Used in generated UIs only, and
         * limited to types supported by controls that already exist in MsPortalFx.
         */
        uiHint?: string;
        /**
         * Constraints for rendering and validating the parameter.
         */
        constraints?: ParameterMetadataConstraints;
    }
    /**
     * The model for a parameter collection metadata constraints.
     */
    interface ParameterMetadataConstraints {
        /**
         * A flag indicating whether this parameter is required or not. Defaults to true.
         */
        required?: boolean;
        /**
         * A flag indicating whether this parameter is hidden or not. Defaults to false.
         */
        hidden?: boolean;
        /**
         * A list of possible values for the parameter (key-value pairs). Could be used for
         * validation and/or populating a list or a drop-down.
         */
        allowedValues?: {
            text: string;
            value: any;
        }[];
        /**
         * The range defining the parameter value.
         */
        range?: {
            lowerBind: number;
            upperBound: number;
        };
        /**
         * The length of the parameter value.
         */
        length?: {
            min: number;
            max: number;
        };
        /**
         * The characters the parameter value must contain.
         */
        containsCharacters?: string;
        /**
         * The characters the parameter value must not contain.
         */
        notContainsCharacters?: string;
        /**
         * Whether the parameter value has at least one digit or not.
         */
        hasDigit?: boolean;
        /**
         * Whether the parameter value has at least one letter or not.
         */
        hasLetter?: boolean;
        /**
         * Whether the parameter value has at least one upper-case letter or not.
         */
        hasUpperCaseLetter?: boolean;
        /**
         * Whether the parameter value has at least one lower-case letter or not.
         */
        hasLowerCaseLetter?: boolean;
        /**
         * Whether the parameter value has at least one special character or not.
         */
        hasPunctuation?: boolean;
        /**
         * Whether the parameter value is a number or not.
         */
        numeric?: boolean;
        /**
         * A custom list of constraints (key-value pairs). Useful for custom generated UI.
         */
        custom?: {
            key: string;
            value: string;
        }[];
    }
    /**
     * The model defining a parameter collection error object.
     */
    interface ParameterCollectionError {
        /**
         * The error message.
         */
        errorMessage: string;
        /**
         * The name of the associated parameter, if any.
         */
        parameterName?: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\Roles\ParameterCollector.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV2.Roles {
    import FxBase = MsPortalFx.Base;
    import FxPromise = FxBase.Promise;
    import FxPromiseV = FxBase.PromiseV;
    /**
     * The contract for the parameter collection "collector" role.
     * Enables the implementer to collect parameters from parameter provider(s).
     */
    interface ParameterCollector {
        /**
         * Create the inputs that will be sent to a given provider when launched.
         *
         * @param providerId The id of the provider.
         * @return The input parameters for the provider.
         */
        createInputParameters(providerId: string): ParameterCollectionInput;
        /**
         * (Optional) Validates the output parameters received from the provider. Do not reject the
         * promise. In case of failure, resolve with the errors. In case of success, resolve with an
         * empty array, or simply return null.
         *
         * @param providerId The id of the provider sending back the output parameters.
         * @param outputParameters The output parameters received from the provider.
         * @return Null (sync) or a promise (aysnc) resolved with an array of validation errors, if any.
         */
        validateOutputParameters?(providerId: string, outputParameters: OutputParameters): FxPromiseV<ParameterCollectionError[]>;
        /**
         * Saves the output parameters received from the provider.
         *
         * @param providerId The id of the provider sending back the output parameters.
         * @param outputParameters The output parameters received from the provider.
         * @return Null (sync) or a promise (aysnc) resolved when the saving process is done.
         */
        saveOutputParameters(providerId: string, outputParameters: OutputParameters): FxPromise;
    }
    /**
     * The contract for the parameter collection "collector" callbacks for a provider.
     */
    interface CollectorCallbacks {
        /**
         * Create the inputs that will be sent to the provider when launched.
         *
         * @return The input parameters for the provider.
         */
        createInputParameters(): ParameterCollectionInput;
        /**
         * (Optional) Validates the output parameters received from the provider. Do not reject the
         * promise. In case of failure, resolve with the errors. In case of success, resolve with an
         * empty array, or simply return null.
         *
         * @param providerOutputs The outputs received from the provider.
         * @return Null (sync) or a promise (aysnc) resolved with an array of validation errors, if any.
         */
        validateOutputParameters?(providerOutputs: OutputParameters): FxPromiseV<ParameterCollectionError[]>;
        /**
         * (Optional) Saves the output parameters received from the provider.
         *
         * @param providerOutputs The outputs received from the provider.
         * @return Null (sync) or a promise (aysnc) resolved when the saving process is done.
         */
        saveOutputParameters(providerOutputs: OutputParameters): FxPromise;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\Roles\ParameterProvider.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV2.Roles {
    import FxBase = MsPortalFx.Base;
    import FxPromiseV = FxBase.PromiseV;
    /**
     * The contract for the parameter collection "provider" role.
     * Enables the implementer to communicate collected parameters back to a parameter collector.
     */
    interface ParameterProvider {
        /**
         * (Optional) The metadata type name used in the creation of the edit scope. If you set this
         * property, you need to define/set your metadata type first. An error will be thrown if the
         * metadata type is not defined. You can define it using: MsPortalFx.Data.Metadata.setTypeMetadata().
         */
        dataModelTypeName?: string;
        /**
         * (Optional) Overrides the parameter collection inputs received from the collector. Use this
         * to override or initialize any value before the editScope is created. Otherwise, the editScope
         * will be seeded with the input parameters as they are.
         *
         * @param inputParameters The input parameters received from the collector.
         * @param inputMetadata The input parameters metadata received from the collector.
         * @param options The parameter collection options received from the collector.
         * @return A promise resolved with the overriden parameter collection inputs.
         */
        overrideInputParameters?(inputParameters: InputParameters, inputMetadata: InputMetadata, options: ParameterCollectionOptions): FxPromiseV<ParameterCollectionInput>;
        /**
         * (Optional) Overrides the output parameters sent to the collector at the end of the parameter
         * collection process. Otherwise, the dataModel (the data in the editScope) will be sent to
         * the collector as they are.
         *
         * @param outputParameters The output parameters to be sent to the collector (extracted from the dataModel).
         * @return A promise resolved with the overriden output parameters.
         */
        overrideOutputParameters?(outputParameters: OutputParameters): FxPromiseV<OutputParameters>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\Roles\Provisioner.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV2.Roles {
    import FxBase = MsPortalFx.Base;
    import FxPromiseV = FxBase.PromiseV;
    /**
     * The contract for the parameter collection "provisioner" role.
     * Enables the implementer to execute a provisioning action.
     */
    interface Provisioner {
        /**
         * (Optional) Maps the outputs of the parameter collection flow to what the default provisioning
         * action expects (i.e. gallery create). Override this method to implement custom mapping of
         * output parameters if the outputs of the parameter collection flow are different from what the
         * gallery deployment expects.
         *
         * NOTE: You cannot implement both the "executeCustomProvisioning" and "mapOutputsForProvisioning"
         * methods. Implement one or the other, but not both.
         *
         * @param outputParameters The outputs of the parameter collection flow.
         * @param options The options used for the provisioning process.
         * @return The mapped outputs, to what the default provisioning expects.
         */
        mapOutputsForProvisioning?(outputParameters: OutputParameters, options: ParameterCollectionOptions): FxPromiseV<OutputParameters>;
        /**
         * (Optional) Executes a custom provisioning action. Override this method for custom provisioning.
         *
         * NOTE: You cannot implement both the "mapOutputsForProvisioning" and "executeCustomProvisioning"
         * methods. Implement one or the other, but not both.
         *
         * @param outputParameters The outputs of the parameter collection flow.
         * @param options The options used for the provisioning process.
         * @return A promise object that is resolved with any value (operation results) if the provisioning
         *      succeeds, or rejected if it fails.
         */
        executeCustomProvisioning?(outputParameters: OutputParameters, options: ParameterCollectionOptions): FxPromiseV<any>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\Utilities.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV2 {
    /**
     * A dictionary of parameter sets (key is a string, parameter set name - value is an
     * object, the parameter set). A parameter set is a dictionary of parameters (key is a string,
     * parameter name - value is a string, parameter value).
     */
    interface ParameterSetCollection extends StringMap<StringMap<string>> {
    }
    /**
     * Utilities for parameter collection implementations.
     */
    module Utilities {
        /**
         * Transforms an editable model object to a parameter-set collection.
         *
         * @param model The editable model object.
         * @return The list if parameter-sets.
         */
        function modelToParameters<T>(model: T): ParameterSetCollection;
        /**
         * Transforms a parameter-set collection to an editable model object.
         *
         * @param data The list if parameter-sets.
         * @return The editable model object.
         */
        function parametersToModel<T>(data: ParameterSetCollection): T;
        /**
         * Reads the outputs returned by the provider from the ParameterCollectionOptions bag.
         * Use this inside a provider role implementation. This is useful if the provider is launched
         * one more time after it has committed, and you want to restore the values from your previous commit.
         *
         * @param options The parameter collection options passed on from the collector.
         * @return The parameter collection outputs that the provider returned the last time, or null
         *      if there aren't any (i.e. provider hasn't committed before).
         */
        function getPreviousOutputsFromOptions(options: ParameterCollectionOptions): ParameterCollectionOutput;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\ViewModels.Command.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV2 {
    import FxViewModels = MsPortalFx.ViewModels;
    import ActionBars = FxViewModels.ActionBars;
    /**
     * The interface for a parameter collection command.
     */
    interface CommandContract {
        /**
         * The input data for the current step.
         */
        stepInput: KnockoutObservable<ActionBars.CreateActionBar.ActionBarInput>;
    }
    /**
     * The parameter collection roles that could be defined for a parameter collection command.
     */
    interface CommandRoles {
        /**
         * The parameter collector role. This role is required.
         */
        parameterCollector: Roles.ParameterCollector;
        /**
         * (Optional) The provisioner role.
         */
        provisioner?: Roles.Provisioner;
    }
    /**
     * The base class for a parameter collection command.
     */
    class Command<T> extends OpenBladeCommand implements CommandContract {
        /**
         * See interface.
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        stepInput: KnockoutObservable<ActionBars.CreateActionBar.ActionBarInput>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: Internal.CollectorBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        privatePcPrBI: Internal.ProvisionerBindingInternals;
        private _collectorImpl;
        private _provisionerImpl;
        private _rolesSet;
        private _baseCommandContainer;
        private _baseCommandInitialState;
        /**
         * Constructs the view model.
         *
         * @param container The view model for part container into which the part is being placed.
         * @param initialState Initial state of the view model.
         */
        constructor(container: FxViewModels.CommandContainerContract, initialState: any);
        /**
         * Invoked when the Part's inputs change.
         */
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        /**
         * Sets the parameter collection roles on the view model.
         *
         * @param roles The parameter collection roles.
         */
        initializeParameterCollectionRoles(roles?: CommandRoles): void;
        private _extractCommandRoles(roles, lifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\ViewModels.Form.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV2 {
    import Fx = MsPortalFx;
    import FxViewModels = Fx.ViewModels;
    import ActionBars = FxViewModels.ActionBars.Base;
    import Pricing = HubsExtension.Azure.Pricing;
    /**
     * The interface for a parameter collection form part.
     */
    interface FormPartContract {
    }
    /**
     * The parameter collection roles that could be defined for a parameter collection form part.
     */
    interface FormRoles {
        /**
         * (Optional) The parameter collector role.
         */
        parameterCollector?: Roles.ParameterCollector;
        /**
         * (Optional) The parameter provider role.
         */
        parameterProvider?: Roles.ParameterProvider;
        /**
         * (Optional) The provisioner role.
         */
        provisioner?: Roles.Provisioner;
    }
    /**
     * The base class for a parameter collection form part.
     */
    class Form<T> extends Forms.Form.ViewModel<T> implements FormPartContract, Internal.ParameterCollectorPdlBinding, Internal.ParameterProviderPdlBinding, Base.Disposable {
        /**
         * The edit scope id.
         */
        editScopeId: KnockoutObservable<string>;
        /**
         * Indicates whether an action is in progress or not.
         * An action in progress will disable the action bar regardless of the validity of the form.
         */
        actionInProgress: KnockoutObservable<boolean>;
        /**
         * Indicates whether the entity will perform a provisioning command or not.
         * Set this true to enable the provisioning logic.
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * The summary and/or link to the EULA for the create step.
         */
        eula: KnockoutObservable<string>;
        /**
         * The display text for the link to the right of the create button.
         */
        secondaryLinkDisplayText: KnockoutObservable<string>;
        /**
         * Gallery create pricing information.
         */
        galleryPricingInfo: KnockoutObservable<Pricing.PricingInfo>;
        /**
         * An instance of Selectable to activate hot spots.
         */
        hotSpot: SelectableSet<Selectable<any>, DynamicBladeSelection>;
        /**
         * An instance of Selectable to activate selectors.
         */
        selectable: Selectable<any>;
        /**
         * An instance of Selectable to activate the action bar's secondary link.
         */
        secondaryLinkSelectable: Selectable<DynamicBladeSelection>;
        /**
         * The input to pass on to the action bar of the details blade.
         */
        stepInput: KnockoutObservable<ActionBars.ActionBarInput>;
        /**
         * The output received from the action bar of the details blade.
         */
        stepOutput: KnockoutObservable<ActionBars.ActionBarOutput>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: Internal.CollectorBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        privateFpTcBI: Internal.ProviderBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        privatePcPrBI: Internal.ProvisionerBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        protected cloudName: KnockoutObservable<string>;
        _editScopeImpl: Internal.EditScope<T>;
        private _collectorImpl;
        private _providerImpl;
        private _provisionerImpl;
        private _parameterCollectionRolesSet;
        private _actionBarOutput;
        private _actionInProgressLock;
        private _baseFormContainer;
        private _baseFormInitialState;
        private _hotSpotItems;
        private _initialSelectedValue;
        private _previousOutput;
        private _previousSecondaryLinkCommitId;
        private _selectableMap;
        private _isValid;
        private _galleryItem;
        /**
         * Constructs the view model.
         *
         * @param container The view model for part container into which the part is being placed.
         * @param initialState Initial state of the view model.
         */
        constructor(container: PartContainerContract, initialState?: any);
        /**
         * Sets the parameter collection roles on the view model.
         *
         * @param roles The parameter collection roles.
         */
        initializeParameterCollectionRoles(roles?: FormRoles): void;
        /**
         * Get an editable copy of the data model. This view model has the same structure
         * as the parameter collection inputs received (and the optional overrides).
         *
         * @return The editable copy of the data model.
         */
        dataModel: T;
        /**
         * The parameter collection input metadata received as part of the inputs to the part.
         *
         * @return The parameter collection input metadata. Null if not available.
         */
        inputMetadata: InputMetadata;
        /**
         * The parameter collection options received as part of the inputs to the part.
         *
         * @return The parameter collection options. Null if not available.
         */
        parameterCollectionOptions: ParameterCollectionOptions;
        /**
         * (Optional) This is called in when the inputs are available or have changed.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param initialState Initial state of the view model.
         */
        onFormInputsSet(lifetimeManager: Base.LifetimeManager, initialState?: any): Base.Promise;
        /**
         * Invoked when the Part's inputs change.
         */
        onInputsSet(inputs: any): Base.Promise;
        /**
         * See interface.
         */
        dispose(): void;
        /**
         * Registers a hot-spot with the form for opening the blade.
         *
         * @param hotSpotViewModel The selectable that is bound to the hot spot.
         */
        registerHotSpot(hotSpotViewModel: Selectable<any> | Controls.HotSpot.ViewModel): void;
        /**
         * Registers a selector with the form for opening the blade that provides values to it.
         *
         * @param id The ID for the form to uniquely identify the selector.
         * @param selectorField The selector form field to be registered.
         * @param collectorCallbacks The collector inline implementation that handles this selector.
         */
        registerSelector(id: string, selectorField: Forms.Selector.ViewModel<any>, collectorCallbacks?: Roles.CollectorCallbacks): void;
        /**
         * Registers a selectable with the form for opening the blade that provides values to it.
         *
         * @param id The ID for the form to uniquely identify the selector.
         * @param selectable The selectable to be registered.
         * @param collectorCallbacks The collector inline implementation that handles this upsell control.
         */
        registerInfoBox(id: string, infoBoxViewModel: Controls.InfoBox.ViewModel, collectorCallbacks?: Roles.CollectorCallbacks): void;
        private _registerSelectable(id, selectable);
        private _extractFormRoles(roles, lifetimeManager);
        private _unselectFields(exceptionSelector?);
        private _resetSelectionStateOfSelectors(value);
        private _onSelectorLoad(selectorId);
        private _onSelectorComplete(selectorId);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\ViewModels.Picker.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV2 {
    import FxViewModels = MsPortalFx.ViewModels;
    import FxControls = FxViewModels.Controls;
    import Grid = FxControls.Lists.Grid;
    /**
     * The interface for a parameter collection picker part.
     */
    interface PickerPartContract<TItem> extends FxControls.Loadable.Contract {
        /**
         * A factory function that returns selection based on a grid item.
         *
         * @param item Item from the picker grid.
         * @return Returns the selection based on an grid item selected.
         */
        createSelection(item: TItem): any;
        /**
         * The summary and/or link to the EULA.
         */
        eula: KnockoutObservable<string>;
        /**
         * Gets the columns list for the picker grid.
         *
         * @return The Columns list for the picker grid.
         */
        getColumns(): KnockoutObservableArray<Grid.Column>;
        /**
         * Gets the index number for the grid item matching with the given id.
         *
         * @param id The id to match with the grid items
         * @return The index for the matching grid item with the given id.
         */
        getMatchingItemIndex(id: any): number;
        /**
         * The items match selection criteria for the picker grid.
         *
         * @param item Item from the picker grid.
         * @param selection Selection from the grid createSelection interface.
         * @return The result that identifies whether item matches the selection.
         */
        itemMatchesSelection(item: TItem, selection: any): boolean;
        /**
         * The header of the list.
         */
        listHeader: KnockoutObservable<string>;
        /**
         * The subheader of the list.
         */
        listSubHeader: KnockoutObservable<string>;
        /**
         * Indicates if this picker supports multiselect.
         */
        multiselectEnabled: KnockoutObservable<boolean>;
    }
    /**
     * The parameter collection roles that could be defined for a parameter collection picker part.
     */
    interface PickerRoles {
        /**
         * (Optional) The parameter collector role.
         */
        parameterCollector?: Roles.ParameterCollector;
        /**
         * (Optional) The parameter provider role.
         */
        parameterProvider?: Roles.ParameterProvider;
    }
    /**
     * The base class for a parameter collection pciker part.
     */
    class Picker<TItem, TDataModel> extends FxControls.Loadable.ViewModel implements PickerPartContract<TItem>, Internal.ParameterCollectorPdlBinding, Internal.ParameterProviderPdlBinding, MsPortalFx.Base.Disposable {
        /**
         * The parameter names for picker grid options.
         */
        static filterPickerItemsParameterName: string;
        static pickerItemsParameterName: string;
        /**
         * The edit scope id.
         */
        editScopeId: KnockoutObservable<string>;
        /**
         * The create action outputs to return back to picker control invoker.
         */
        _createActionOutputs: ParameterCollectionOutput;
        /**
         * The summary and/or link to the EULA for the create step.
         */
        eula: KnockoutObservable<string>;
        /**
         * The list header string to show on picker list part.
         */
        listHeader: KnockoutObservable<string>;
        /**
         * The list sub header string to show on picker list part.
         */
        listSubHeader: KnockoutObservable<string>;
        /**
         * See interface.
         */
        multiselectEnabled: KnockoutObservable<boolean>;
        /**
         * The grid view model for picker items.
         */
        itemsGridViewModel: Grid.ViewModel<TItem, any>;
        /**
         * The flag to indicate whether create action visible or not.
         */
        showCreateAction: KnockoutObservable<boolean>;
        /**
         * Triggers the select action.
         */
        triggerSelectAction: KnockoutObservable<string>;
        /**
         * True if the form has been validated and is valid; else false.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * The flag to indicate whether create Action providing the result from picker.
         */
        isCreateActionResult: KnockoutObservable<boolean>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: Internal.CollectorBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        privateFpTcBI: Internal.ProviderBindingInternals;
        /**
         * The wizard step input provided as input to picker.
         */
        stepInput: KnockoutObservable<FxViewModels.ActionBars.Base.ActionBarInput>;
        /**
         * The create action selector field.
         */
        createActionSelectorField: KnockoutObservable<FxViewModels.Forms.Selector.ViewModel<string>>;
        /**
         * The picker list activation blade opener to open the dynamic blade based on picker requirement.
         */
        pickerActivationBladeOpener: KnockoutObservableBase<FxViewModels.DynamicBladeSelection>;
        /**
         * The create blade opener to open the dynamic blade based on inputs.
         */
        createActionBladeOpener: KnockoutObservableBase<FxViewModels.DynamicBladeSelection>;
        /**
         * The item selected by default in the grid.
         */
        itemSelectedByDefault: KnockoutObservable<any>;
        /**
         * The filterItems provided by the picker invoker as options.
         */
        filterItems: KnockoutObservable<any>;
        /**
         * The set of filters to filter items on.
         */
        filters: KnockoutObservableArray<FxViewModels.PickerFilter.IPickerItemsFilter<TItem>>;
        private _filteredItems;
        private _createSelectorField;
        private _selectorOriginalValue;
        private _selectorEditableValue;
        private _createSelectorBladeName;
        private _createSelectorBladeExtension;
        private _throttleUnselectSelectorFieldHandle;
        _editScopeImpl: Internal.EditScope<TDataModel>;
        private _collectorImpl;
        private _providerImpl;
        private _parameterCollectionRolesSet;
        private _basePickerContainer;
        private _basePickerInitialState;
        private _actionBarOutput;
        /**
         * Constructs the view model.
         *
         * @param container The view model for part container into which the part is being placed.
         * @param initialState Initial state of the view model.
         * @param items The Obervable array of picker items of type TItem to populate.
         * @param multiselect Optional. True if the picker supports multiple selection. Defaults to false.
         */
        constructor(container: PartContainerContract, initialState: any, items: KnockoutObservableArray<TItem>, multiselect?: boolean);
        /**
         * Initializes Create Selector on Picker Blade with given blade action inputs.
         *
         * @param initialValue The initial value Selector uses.
         * @param createActionTitle The title for Selector control.
         * @param createActionBladeName The blade name to launch on Selector selection.
         * @param createActionBladeExtension The optional field for extension name to launch the create action blade from that extension.
         * @param collectorCallbacks The collector inline implementation that handles this wizard step.
         * @param validations The optional field for validations to apply on this selector field.
         */
        initializeCreateSelector(initialValue: string, createActionTitle: string, createActionBladeName: string, createActionBladeExtension?: string, collectorCallbacks?: Roles.CollectorCallbacks, validations?: FxViewModels.FormValidation[]): void;
        /**
         * (Optional) This is called in when the inputs are available or have changed.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param initialState Initial state of the view model.
         */
        onPickerInputsSet(lifetimeManager: MsPortalFx.Base.LifetimeManager, initialState?: any): MsPortalFx.Base.Promise;
        /**
         * Invoked when the Part's inputs change.
         *
         * @param inputs Inputs is collection of input and output parameters to blade.
         * @return Promise for onInputsSet to notify completion.
         */
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        /**
         * Sets the parameter collection roles on the view model.
         *
         * @param roles The parameter collection roles.
         */
        initializeParameterCollectionRoles(roles?: PickerRoles): void;
        /**
         * Get an editable copy of the data model. This view model has the same structure
         * as the parameter collection inputs received (and the optional overrides).
         *
         * @return The editable copy of the data model.
         */
        dataModel: TDataModel;
        /**
         * The parameter collection input metadata received as part of the inputs to the part.
         *
         * @return The parameter collection input metadata. Null if not available.
         */
        inputMetadata: InputMetadata;
        /**
         * The parameter collection options received as part of the inputs to the part.
         *
         * @return The parameter collection options. Null if not available.
         */
        parameterCollectionOptions: ParameterCollectionOptions;
        /**
         * Gets the parameter given from the list of parameters given.
         *
         * @param parameterName The parameterName to get from collection.
         * @param parameters The collection of parameters.
         * @return The parameter value from collection.
         */
        getParameter<TDataModel>(parameterName: string, parameterSetName: string, parameters: StringMap<StringMap<TDataModel>>): TDataModel;
        /**
         * See interface.
         */
        dispose(): void;
        /**
         * See interface.
         */
        getMatchingItemIndex(id: any): number;
        /**
         * See interface.
         */
        getColumns(): KnockoutObservableArray<Grid.Column>;
        /**
         * See interface.
         */
        itemMatchesSelection(item: TItem, selection: any): boolean;
        /**
         * See interface.
         */
        createSelection(item: TItem): any;
        private _extractPickerRoles(roles, lifetimeManager);
        private _onSelectedItemsChanged(selectedItems);
        private _runFilters(items);
        private _closeBlade(selectedItems);
        private _clearThrottleUnselectSelectorFieldHandle();
        /**
         * Gets Grid Extension Options.
         *
         * @return Grid Extension options with select type and other grid extension options
         */
        private _getGridExtensionOptions();
        /**
         * Selects the grid item based on given index.
         *
         * @param index Row index to select in the grid.
         */
        private _selectGridItem(index);
        /**
         * Disables the specified grid item ..
         *
         * @param item Item to disable in the grid.
         * @param reason Reason for disabling the row in the grid.
         */
        private _disableGridItem(item, reason);
        /**
         * Initialize create action selector with defaults.
         */
        private _initializeCreateActionSelector();
        /**
         * Launch create action blade with the inputs required.
         */
        private _launchCreateActionBlade();
        /**
         * Fileter Grid Items.
         */
        private _filterGridItems(filterValues);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\ViewModels.PickerFilter.d.ts
declare module MsPortalFx.ViewModels.PickerFilter {
    import FxBase = MsPortalFx.Base;
    /**
     * An inteface for a filtered item.
     */
    interface FilteredItem<TItem> {
        /**
         * The disabled item.
         */
        item: TItem;
        /**
         * The reason the item is disabled.
         */
        disabledReason: string;
    }
    /**
     * An inteface for filtering a set of items.
     */
    interface IPickerItemsFilter<TItem> {
        /**
         * This function takes an input set of items and returns a subset of items from this set
         *
         * @param container The container into which the part is being placed.
         * @param initialState Initial state for the part.
         * @param items The Obervable array of picker items of type TItem to populate.
         * @param multiselect Optional. True if the picker supports multiple selection. Defaults to false.
         */
        getDisabledItems(items: TItem[]): FxBase.PromiseV<FilteredItem<TItem>[]>;
    }
    /**
     * Filter that supports ARM RBAC filtering.
     */
    class ArmRbacFilter<TItem> implements IPickerItemsFilter<TItem> {
        private _requiredPermission;
        private _mapItemToResourceId;
        /**
         * See interface.
         */
        getDisabledItems(items: TItem[]): FxBase.PromiseV<FilteredItem<TItem>[]>;
        /**
         * Constructs a new filter class that filters using ARM permissions.
         * This base class provides automatic filtering of
         *
         * @param container The container into which the part is being placed.
         * @param initialState Initial state for the part.
         * @param items The Obervable array of picker items of type TItem to populate.
         * @param multiselect Optional. True if the picker supports multiple selection. Defaults to false.
         */
        constructor(mapItemToResourceId: (item: TItem) => string, requiredPermission: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV2\ViewModels.Wizard.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV2 {
    /**
     * The parameter collection roles that could be defined for a parameter collection wizard part.
     */
    interface WizardRoles {
        /**
         * (Optional) The parameter collector role.
         */
        parameterCollector?: Roles.ParameterCollector;
        /**
         * (Optional) The parameter provider role.
         */
        parameterProvider?: Roles.ParameterProvider;
        /**
         * (Optional) The provisioner role.
         */
        provisioner?: Roles.Provisioner;
    }
    /**
     * The base class for a parameter collection wizard part.
     */
    class Wizard<T> extends Controls.Wizard.ViewModel implements Internal.ParameterCollectorPdlBinding, Internal.ParameterProviderPdlBinding, Base.Disposable {
        /**
         * The edit scope id.
         */
        editScopeId: KnockoutObservable<string>;
        /**
         * Indicates whether the entity will perform a provisioning command or not.
         * Set this true to enable the provisioning logic.
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * The summary and/or link to the EULA for the create step.
         */
        eula: KnockoutObservable<string>;
        /**
         * Indicating whether provisioning will take place on a startboard part or on the current UI
         * element part (form, wizard, etc.).
         */
        provisionOnStartboardPart: KnockoutObservable<boolean>;
        /**
         * True if the form has been validated and is valid; else false.
         */
        valid: KnockoutComputed<boolean>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: Internal.CollectorBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        privateFpTcBI: Internal.ProviderBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        privatePcPrBI: Internal.ProvisionerBindingInternals;
        /**
         * Private internal data. Do not use.
         */
        protected cloudName: KnockoutObservable<string>;
        _editScopeImpl: Internal.EditScope<T>;
        private _collectorImpl;
        private _providerImpl;
        private _provisionerImpl;
        private _parameterCollectionRolesSet;
        private _actionBarOutput;
        private _baseWizardContainer;
        private _baseWizardInitialState;
        /**
         * Constructs the view model.
         *
         * @param container The view model for part container into which the part is being placed.
         * @param initialState Initial state of the view model.
         */
        constructor(container: PartContainerContract, initialState: any);
        /**
         * (Optional) This is called in when the inputs are available or have changed.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param initialState Initial state of the view model.
         */
        onWizardInputsSet(lifetimeManager: Base.LifetimeManager, initialState?: any): Base.Promise;
        /**
         * Invoked when the Part's inputs change.
         */
        onInputsSet(inputs: any): Base.Promise;
        /**
         * Sets the parameter collection roles on the view model.
         *
         * @param roles The parameter collection roles.
         */
        initializeParameterCollectionRoles(roles?: WizardRoles): void;
        /**
         * Get an editable copy of the data model. This view model has the same structure
         * as the parameter collection inputs received (and the optional overrides).
         *
         * @return The editable copy of the data model. Null if not available.
         */
        dataModel: T;
        /**
         * The parameter collection input metadata received as part of the inputs to the part.
         *
         * @return The parameter collection input metadata. Null if not available.
         */
        inputMetadata: InputMetadata;
        /**
         * The parameter collection options received as part of the inputs to the part.
         *
         * @return The parameter collection options. Null if not available.
         */
        parameterCollectionOptions: ParameterCollectionOptions;
        /**
         * Adds a wizard step.
         *
         * @param stepId The ID that uniquely identifies the step.
         * @param title The title for the wizard step.
         * @param formBlade The blade containing the form for the wizard step.
         * @param collectorCallbacks The collector inline implementation that handles this wizard step.
         * @param description The description for the wizard step.
         * @param isOptional A value indicating whether or not the step is optional.
         * @param status The initial status of the step.
         * @param extension The extension that hosts the blade containing the form for the wizard step.
         */
        addWizardStep(stepId: string, title: string, formBlade: string, description?: string, collectorCallbacks?: Roles.CollectorCallbacks, isOptional?: boolean, status?: ActionBars.Base.Status, extension?: string): void;
        /**
         * Inserts a wizard step at the specified position.
         *
         * @param position The 0 based position at which to insert the step.
         * @param stepId The ID that uniquely identifies the step.
         * @param title The title for the wizard step.
         * @param formBlade The blade containing the form for the wizard step.
         * @param collectorCallbacks The collector inline implementation that handles this wizard step.
         * @param description The description for the wizard step.
         * @param isOptional A value indicating whether or not the step is optional.
         * @param status The initial status of the step.
         * @param extension The extension that hosts the blade containing the form for the wizard step.
         */
        insertWizardStep(position: number, stepId: string, title: string, formBlade: string, description?: string, collectorCallbacks?: Roles.CollectorCallbacks, isOptional?: boolean, status?: ActionBars.Base.Status, extension?: string): void;
        /**
         * Removes the specified wizard step.
         *
         * @param step The step to be removed.
         */
        removeWizardStep(step: Controls.Wizard.WizardStep): void;
        /**
         * Removes the wizard step at the specified position.
         *
         * @param position The 0 based position at which to remove the step.
         * @return The step that was removed.
         */
        removeWizardStepAt(position: number): Controls.Wizard.WizardStep;
        private _extractWizardRoles(roles, lifetimeManager);
        private _onStepLoad(step);
        private _onStepComplete(step);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ParameterCollection.Common.d.ts
declare module MsPortalFx.ViewModels.Internal {
    /**
     * A message passed from collector to provider when the provider is opened.
     */
    interface ParameterProviderOpenMessage {
        /**
         * Initial data for the provider.
         */
        initialData: any;
        /**
         * Additional configuration for the provider.
         */
        providerConfig: any;
    }
    /**
     * A message passed from provider to collector when a result is available.
     */
    interface ParameterProviderResultMessage {
        /**
         * The result supplied by the parameter provider.
         */
        resultData: any;
    }
    /**
     * A subscriber to the results committed by the provider back to the collector.
     */
    interface ProviderResultSubscriber<TResult> {
        /**
         * A callback on the subscriber to receive the results.
         */
        receiveResult: (result: TResult) => void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ParameterCollector.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Options for constructing a parameter collector.
     */
    interface ParameterCollectorOptions<TResult> {
        /**
         * The selectable associated with the same <BladeAction> as this
         * parameter collector. The parameter collector will supply initial
         * data to the child blade when this becomes selected.
         *
         * If not specified, this defaults to container.selectable (so it
         * works with selectable parts without configuration).
         *
         * This option is mutually exclusive with 'selectableSet'.
         */
        selectable?: SelectableContract<any>;
        /**
         * The selectable set associated with the same <BladeAction> as this
         * parameter collector. The parameter collector will supply initial
         * data to the child blade when this becomes selected.
         *
         * This option is mutually exclusive with 'selectable'.
         */
        selectableSet?: SelectableSet<any, any>;
        /**
         * A callback that supplies initial data for the parameter provider
         * in the child blade each time it opens.
         *
         * Note that the object received by the parameter provider will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed (and sometimes stored) in a serialized form.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @return Initial data for the child blade.
         */
        supplyInitialData?(activatedItem: any): TResult;
        /**
         * A callback that supplies additional configuration options for the
         * provider each time it opens. You can use this to pass non-editable
         * data, for example configuring how a form will be displayed.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @return Arbitrary configuration options for the child blade.
         */
        supplyProviderConfig?(activatedItem: any): any;
        /**
         * A callback to be invoked when the child blade supplies a result
         * and closes.
         *
         * @param result The result given by the child blade.
         * @param activatedItem The object whose selection launched this parameter collection process. The result refers to that object.
         */
        receiveResult?(result: TResult, activatedItem: any): void;
        /**
         * Provides an easy way to integrate a parameter collector with an EditScope.
         *
         * The collector will supply initial data to the provider from this edit scope
         * property, and will automatically insert the provider's output into this edit
         * scope property. The net result is that your parameter collector will act as
         * an editor for the specified edit scope property.
         *
         * If you specify this option, do not also specify either supplyInitialData or
         * receiveResult.
         */
        formFieldValueAccessor?: Forms.EditScopeAccessors<TResult>;
        /**
         * For internal use only
         */
        fxInternalFI?: boolean;
    }
    /**
     * A parameter collector opens a child blade, supplies initial data to it, and may later
     * receive back completed data.
     */
    class ParameterCollector<TResult> {
        private bladeCaller;
        /**
         * Constructs an instance of ParameterCollector.
         *
         * @param inputsCallbackRegistrar The container to register with for callbacks
         * @param options Options for the instance.
         *
         */
        constructor(inputsCallbackRegistrar: InputsCallbacksRegistrar, options: ParameterCollectorOptions<TResult>);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ParameterProvider.d.ts
declare module MsPortalFx.ViewModels {
    import FxData = MsPortalFx.Data;
    import ActionBarOutput = MsPortalFx.ViewModels.ActionBars.Base.ActionBarOutput;
    /**
     * The default parameter provider commit arguments with the action bar output.
     */
    interface ParameterProviderActionBarCommitArgs {
        /**
         * The action bar output.
         */
        actionBarOutput: ActionBarOutput;
    }
    /**
     * Options for constructing a parameter provider.
     */
    interface ParameterProviderOptions<TResult, TEditScope> {
        /**
         * A callback that supplies the initial data for the provider's edit scope.
         * This callback is mandatory, and must account for the possibility of the
         * collector supplying incomplete information (or none at all) by returning
         * the complete initial state for the edit scope.
         *
         * @param dataFromCollector The incoming initial data from the parameter collector, or null if the collector did not supply any.
         * @return The desired initial edit scope data.
         */
        mapIncomingDataForEditScope?(dataFromCollector: TResult): TEditScope;
        /**
         * An asynchronous callback that supplies the initial data for the provider's edit scope.
         * This callback is mandatory, and must account for the possibility of the
         * collector supplying incomplete information (or none at all) by returning
         * the complete initial state for the edit scope.
         *
         * @param dataFromCollector The incoming initial data from the parameter collector, or null if the collector did not supply any.
         * @return The desired initial edit scope data.
         */
        mapIncomingDataForEditScopeAsync?(dataFromCollector: TResult): Base.PromiseV<TEditScope>;
        /**
         * The metadata type corresponding to the TResult generic parameter. This is
         * used to configure the edit scope.
         */
        editScopeMetadataType?: string;
        /**
         * A mapping function that converts outgoing data from the provider's edit scope
         * into the format you wish to return to the collector.
         *
         * Note that the object received by the parameter collector will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed in a serialized form.
         *
         * @param editScopeData The data currently held by the parameter provider.
         * @param commitArgs The optional commit arguments.
         * @return The data that should be returned to the calling parameter collector.
         */
        mapOutgoingDataForCollector(editScopeData: TEditScope, commitArgs?: any): TResult;
        /**
         * A callback invoked when the user dismisses the provider. If you need to begin a
         * provisioning operation that adds a startboard part and collapses the current
         * journey, you can do so in this callback. You should not commence any other
         * server-side operation from this callback, because the blade will have closed
         * before it completes, so the user would not be able to see the result.
         *
         * @param editScopeData The data stored in the provider's edit scope.
         */
        commitResult?(editScopeData: TEditScope): void;
    }
    /**
     * A parameter provider receives parameters from its parent blade, then later, when the user clicks
     * on an action bar, supplies a result object to the parent blade and closes.
     */
    class ParameterProvider<TResult, TEditScope> {
        private bladeCallable;
        private defaultActionBarInput;
        private _options;
        private _configFromCollector;
        private _hasSentResult;
        private _editScopeId;
        private _editScopeCache;
        private _editScopeView;
        private _getResultSubscribers;
        /**
         * Constructs an instance of ParameterProvider.
         *
         * @param container The container associated with the part or other composition item hosting this parameter provider.
         * @params options Options for the instance.
         */
        constructor(container: ContainerContract, options: ParameterProviderOptions<TResult, TEditScope>);
        /**
         * The edit scope holding the data being edited in this provider blade.
         */
        editScope: KnockoutObservable<FxData.EditScope<TEditScope>>;
        /**
         * The arbitrary configuration object supplied by the collector, if any.
         */
        configFromCollector: KnockoutObservable<any>;
        private getResultsBeforeCommit(subscriber);
        private getResults();
        private _prepareEditScopeWithInitialData(container);
        private _setUpActionBarWatcher(container);
        private _discardEditScopeAndSendResult(commitArgs?);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.PickerBase.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV3.Pickers {
    import FxViewModels = MsPortalFx.ViewModels;
    import Grid = FxViewModels.Controls.Lists.Grid;
    /**
     * Picker base module
     */
    module PickerBase {
        /**
         * Options for the create new blade launched from the picker.
         *
         * Create new will be an entry at the top of the picker and will launch a blade.
         * This blade has to implement a Parameter Provider V3 and return data in the same type as the picker.
         */
        interface CreateNewOptions<TDataModel> {
            /**
             * The title to show for the create new entry.
             */
            title: string;
            /**
             * The blade to launch when the create new entry is selected.
             * This blade has to implement Parameter Provider V3 to receive inputs and send outputs.
             */
            dynamicBladeSelection: FxViewModels.DynamicBladeSelection;
            /**
             * Optional method to supply intial data to the provider in the create new blade.
             * If this method is implemented, the create new blade will get passed these inputs from the picker.
             */
            supplyInitialData?(): TDataModel;
            /**
             * Optional method to supply config to the provider in the create new blade.
             * By default, the create new blade will get the same inputs that the picker received but this can be
             * overridden by implementing this method.
             */
            supplyProviderConfig?(): any;
            /**
             * Optional method that receives results from the create new provider.
             * Once the create new blade closes, the results received are passed to this method if it is implemented.
             */
            receiveResults?(result: TDataModel): void;
        }
        /**
         * Options for the picker.
         */
        interface Options<TItem, TDataModel> {
            /**
             * The data navigator that returns the list of picker items. It has to be a sequential data navigator for now.
             * This is mutually exclusive with the observable list of items provided.
             */
            dataNavigator?: MsPortalFx.Data.DataNavigatorBase<TItem>;
            /**
             * The list of items shown in the picker.
             * This is mutually exclusive with the data navigator.
             */
            items?: KnockoutObservableArray<TItem>;
            /**
             * Callback to map incoming data to data model.
             *
             * @param data Incoming data that gets written to the edit scope.
             */
            mapIncomingDataToDataModel(data: any): TDataModel;
            /**
             * Callback to load picker items. This is called after the parameter collector is ready.
             *
             * @pickerInputs List of inputs that the picker defines
             * @dataModel The data model. If this is set and the picker is multiselect, the items in the data model must be returned in the first page.
             */
            loadPickerItems(pickerOptions: any, dataModel?: TDataModel): void;
            /**
             * Callback to map items to the data model. This is called with a list of selected items.
             *
             * @param items List of selected picker items
             */
            mapItemsToDataModel(items: TItem[]): TDataModel;
            /**
             * Callback to check if a picker item is in or equal the data model.
             *
             * @item The picker item in the grid
             * @dataModel The data model.
             */
            isItemInDataModel(pickerItem: TItem, dataModel: TDataModel): boolean;
            /**
             * The text to show for the create new entry.
             */
            createNewOptions?: CreateNewOptions<TDataModel>;
            /**
             * If set to true, allows multiple items to be selected in the picker. Defaults to false.
             * Note that when multi-select is set, the loadPickerItems should return all the pre-selected items in the first page.
             */
            allowMultiSelect?: boolean;
        }
        /**
         * Picker item interface
         */
        interface Item {
            /**
             * The title of the item displayed.
             */
            title: KnockoutObservable<string>;
            /**
             * The sub title of the item.
             */
            subtitle?: KnockoutObservable<string>;
            /**
             * Text next to sub title on the second row.
             */
            detail?: KnockoutObservable<string>;
            /**
             * The icon to display for this picker item.
             */
            icon?: KnockoutObservable<MsPortalFx.Base.Image>;
            /**
             * Flag indicating if the item is disabled.
             */
            disabled?: KnockoutObservable<boolean>;
            /**
             * The info balloon shown next to the item.
             */
            infoBalloon?: FxViewModels.Controls.DockedBalloon.ViewModel;
            /**
             * The item associated with this picker item.
             */
            item: any;
        }
        /**
         * Inputs to picker. Picker implementations can extend this interface to add additional options.
         * But it is expected to contain the options supported by the base picker.
         */
        interface Config {
        }
    }
    /**
     * The base picker class.
     */
    class PickerBase<TItem, TDataModel> extends FxViewModels.Controls.Loadable.ViewModel {
        /**
         * The parameter provider defined in this this part.
         */
        parameterProvider: FxViewModels.ParameterProvider<any, {
            pickedItems: KnockoutObservable<TDataModel>;
        }>;
        /**
         * The parameter collector that gets data for new items.
         */
        addNewItemCollector: FxViewModels.ParameterCollector<TDataModel>;
        /**
         * Flag indicating if the picker allows create new.
         */
        showCreateAction: KnockoutObservable<boolean>;
        /**
         * Add new grid that launches a new blade
         */
        addNewGrid: Grid.ViewModel<any, any>;
        /**
         * The grid that lists the picker items.
         */
        pickerGrid: Grid.ViewModel<TItem, any>;
        /**
         * Option that shows or disables a select button.
         * This is controlled by the multiSelectEnabled flag from the collector and should not be changed by the deriving picker.
         */
        showSelectButton: KnockoutObservable<boolean>;
        /**
         * Used to automatically trigger the select button when single select is enabled.
         */
        triggerSelectAction: KnockoutObservable<string>;
        /**
         * Boolean indicating if an info box should be shown.
         */
        showInfoBox: KnockoutObservable<boolean>;
        /**
         * The info box view model.
         */
        infoBoxViewModel: FxViewModels.Controls.InfoBox.BaseViewModel;
        private _preSelectedItems;
        private _pickerOptions;
        private _basicTemplate;
        /**
         * Creates a new instance of the
         */
        constructor(container: PartContainerContract, initialState: any, options: PickerBase.Options<TItem, TDataModel>);
        /**
         * If the picker implementation supports create new and wants to programatically open the create new blade
         * based on certain inputs/config, it can call this method.
         */
        openCreateNewBlade(): void;
        /**
         * If the picker implementation supports create new and wants to programatically disable the create new option
         * based on certain inputs/config, it can call this method.
         */
        disableCreateNewOption(): void;
        private _saveToEditScope(dataModel);
        /**
         * Create the picker grid.
         */
        private _buildPickerGrid(lifetimeManager, options);
        /**
         * Create an add new grid.
         */
        private _buildAddNewGrid(lifetimeManager, createNewOptions);
        /**
         * Gets the data model from the edit scope.
         */
        private dataModel;
        /**
         * Selects the grid item based on given index.
         *
         * @param item Picker item to select in the grid.
         */
        private _selectGridItem(item);
        /**
         * Selects the grid item based on given index.
         *
         * @param item Picker item to disable in the grid.
         */
        private _disableGridItem(item);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.Provisioner.d.ts
declare module FxImpl.ViewModels.ParameterCollectionV3 {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import Rpc = FxBase.Rpc.Internal;
    import ParameterCollection = FxViewModels.ParameterCollectionV3;
    interface ProvisioningInitiationId {
        provisionerId: string;
        provisioningRefKey: string;
        cloudName: string;
    }
    interface ProvisioningRequest {
        provisioningConfig: ParameterCollection.Provisioner.Config;
        provisioningRefKey: string;
        provisioningPromise: FxBase.PromiseVN<any, any>;
        startboardInfo: ParameterCollection.StartboardInfo;
    }
    interface ProvisioningOperation {
        provisioningPromise: FxBase.PromiseVN<any, any>;
        data: any;
    }
    interface ProvisioningPartInitialData {
        provisioningConfig: ParameterCollection.Provisioner.Config;
        provisioningRefKey: string;
        startboardPart: ParameterCollection.ExtensionElement;
    }
    var initiateProvisioningRequestEndPoint: Rpc.ProxiedObjectTypeDefinition<ProvisioningInitiationId, ProvisioningInitiationId>;
    var getProvisioningRequestEndPoint: Rpc.ProxiedObjectTypeDefinition<ProvisioningInitiationId, ProvisioningRequest>;
    var getProvisioningOperationEndPoint: Rpc.ProxiedObjectTypeDefinition<string, ProvisioningOperation>;
    function getProvisioningOperation(provisioningRefKey: string, rpcClient?: Rpc.Client): FxBase.PromiseV<ProvisioningOperation>;
}
declare module MsPortalFx.ViewModels.ParameterCollectionV3 {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import Telemetry = FxBase.Diagnostics.Telemetry;
    /**
     * A provisioner allows for executing a provisioning operation, and adds a startboard part if
     * needed. Provisioning is triggered automatically if the provisioner is hooked up with a parameter
     * provider and an action bar, or manually by calling the 'startProvisioning' method.
     */
    class Provisioner<TData> implements FxBase.Disposable {
        /**
         * The provisioner configuration that the collector passes to the provider part.
         */
        provisioningConfig: KnockoutObservable<Provisioner.Config>;
        /**
         * A promise representing the provisioning operation. The observable is updated with the result
         * of the 'supplyProvisioningPromise' callback.
         */
        provisioningPromise: KnockoutObservable<FxBase.PromiseVN<any, any>>;
        /**
         * A flag indicating whether provisioning is happening on the startboard or not.
         */
        provisionOnStartboard: KnockoutObservable<boolean>;
        /**
         * The tracking id of the deployment.
         */
        protected _telemetryId: string;
        /**
         * A flag indicating whether provisioning is custom or not custom (going through ARM).
         */
        protected _isCustomProvisioning: boolean;
        /**
         * The launching context.
         */
        protected _launchingContext: MsPortalFx.Azure.ResourceManager.LaunchingContext;
        private static rpcClient;
        private static provisioningRequestsLookup;
        private static provisionersList;
        private static _rpcRegistered;
        protected _actionBar: FxViewModels.ActionBars.CreateActionBar.Contract;
        protected _actionBarSupportsForceInProgressStatus: boolean;
        protected _actionBarSupportsIsProvisioningBlade: boolean;
        protected _actionBarSupportsProvisionOnStartboardPart: boolean;
        protected _actionBarSupportsSecondaryLinkDisplayText: boolean;
        protected _actionBarSupportsSecondaryLinkValidation: boolean;
        protected _actionBarSupportsShowActionBar: boolean;
        protected _cloudName: string;
        private _options;
        private _provisionerId;
        /**
         * Constructs a new instance of a parameter collection provisioner.
         *
         * @param container The container into which the part containing the provisioner is being placed.
         * @param options The provisioner options.
         */
        constructor(container: FxViewModels.ContainerContract, options: Provisioner.Options<TData>);
        /**
         * See interface.
         */
        dispose(): void;
        /**
         * Manually start provisioning. This is usually used with collector view models. This must
         * not be used if the provisioner is configured with a provider and an action bar (automatically)
         * triggered). This method uses the 'supplyStartboardInfo' to define a startboard part if you
         * want provisioning to happen on the startboard, or return null or undefined if you want it
         * to run in the background.
         *
         * @param data The provisioning data that will be passed to the provisioning operation.
         * @return A promise that represents the provisioning operation.
         */
        startProvisioning(data: TData): FxBase.PromiseVN<any, any>;
        private receiveResult(result);
        private _beginProvisioning(data);
        private _initiateProvisioningRequest(data, startboardInfo);
        private static _registerRpcCallbacks();
        private getProvisioningRequest(provisioningRefKey);
        protected _createEventBase(): Telemetry.TelemetryEvent;
        protected _traceProvisioningStarted(eventData?: Telemetry.TelemetryEvent): Telemetry.TelemetryEvent;
        protected _traceProvisioningEnded(result: any, resolved: boolean, eventData?: Telemetry.TelemetryEvent): Telemetry.TelemetryEvent;
    }
    module Provisioner {
        /**
         * Options for constructing a provisioner.
         */
        interface Options<TData> {
            /**
             * A callback that supplies the promise that represents the provisioning operation.
             *
             * Note that the promise returned cannot be persisted. So in the case when the user closes
             * the browser, navigates away, or loses connection. It's advisable to make the operation as
             * short as possible, make it return some sort of an operation id, and then use that operation
             * id to continuously check on the status of the operation (i.e. poll for updates).
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically, the data is the same data returned to the collector (by the
             *      'mapOutgoingDataForCollector' method). If the provisioner is triggered automatically,
             *      the data is whatever is passed to the 'startProvisioning' method.
             * @return A promise representing the provisioning operation, that is resolved with data passed
             *      to the provisioning part, if one exists.
             */
            supplyProvisioningPromise: (data: TData) => FxBase.PromiseVN<any, any>;
            /**
             * A callback that supplies the provisioner with the startboard info.
             *
             * If provisioning is automatically triggered, and if the user wants provisioning to happen
             * on the startboard, the startboard info returned by used for that purpose. If invalid
             * startboard info is returned, the provisioner will throw an exception and provisioning will
             * fail. Null or undefined are not acceptable.
             *
             * If provisioning is manually triggered, returning null or undefined indicates that you don't
             * want provisioning to happen on the startboard. If you return invalid startboard info, the
             * provisioner will throw an exception. If you return valid startboard info, a provisioning
             * part will be added to the startboard for provisioning to take place.
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically (it's hooked up with a provider and an action bar), the data
             *      is the same data returned to the collector (by the 'mapOutgoingDataForCollector'
             *      method). If the provisioner is triggered automatically, the data is whatever was
             *      passed to the 'startProvisioning' method.
             * @return A startboard info object indicating which provisioning part to use and which
             *      startboard the provisioning part will mutate into.
             */
            supplyStartboardInfo: (data: TData) => StartboardInfo;
            /**
             * The action bar view model. This is the action bar on your provider blade. Defining this
             * property means you also need to define a parameter provider.
             */
            actionBar?: FxViewModels.ActionBars.Base.Contract;
            /**
             * The parameter provider. This is the parameter provider on your provider view model.
             * Defining this property means you also need to define an action bar.
             */
            parameterProvider?: FxViewModels.ParameterProvider<TData, any>;
        }
        /**
         * The provisioner configuration that a collector can pass to the provider part.
         */
        interface Config {
            /**
             * A flag that indicates whether provisioning is enabled or not.
             * Valid only in the automatic triggering scenario.
             */
            provisioningEnabled: boolean;
            /**
             * (Optional) The startboard info used in the provisioning process.
             */
            startboardProvisioningInfo?: StartboardInfo;
            /**
             * (Optional) Prevents the provisioner from discarding the journey. Only works if
             * provisioning does not happen on the startboard (because choosing to add a part on the
             * startboard means the journey must be discarded). Defaults to false.
             *
             */
            dontDiscardJourney?: boolean;
        }
    }
    /**
     * An extension element definition (e.g. part or blade) .
     */
    interface ExtensionElement {
        /**
         * The extension element extension.
         */
        extension: string;
        /**
         * The extension element name.
         */
        name: string;
    }
    /**
     * Startboard info. Used by the provisioner to know which provisioning part to add to the
     * startboard, and which part it will mutate into.
     */
    class StartboardInfo {
        /**
         * The provisioning part definition.
         */
        provisioningPart: ExtensionElement;
        /**
         * The startboard part definition (the one the provisioning part will mutate into).
         */
        startboardPart: ExtensionElement;
        /**
         * The name of the id property on the startboard part.
         */
        startboardPartKeyId: string;
        /**
         * Validates a startboard info object.
         * Validates against null, undefined, and incomplete data.
         *
         * @param startboardInfo The startboard info.
         * @return A boolean indicating whether the startboard info object is valid or not.
         */
        static isValid(startboardInfo: StartboardInfo): boolean;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ProvisioningPart.d.ts
declare module FxImpl.ViewModels.ParameterCollectionV3 {
    var pollingInterval: number;
    var pollingRetries: number;
}
declare module MsPortalFx.ViewModels.ParameterCollectionV3 {
    import Internal = FxImpl.ViewModels.ParameterCollectionV3;
    /**
     * A parameter collection provisioning part.
     */
    class ProvisioningPart extends ButtonPart {
        /**
         * The description displayed on the provisioning part.
         */
        description: KnockoutObservable<string>;
        /**
         * Error message displayed when there is an error during provisioning.
         */
        errorMessage: KnockoutObservable<string>;
        /**
         * The URI for the icon displayed on the provisioning part.
         */
        icon: KnockoutObservable<Base.Image>;
        /**
         * The initial inputs the provisioning part receives when added to the startboard. This is
         * persisted to the part's view state, and used to resume polling for deployment updates in
         * case of refresh.
         */
        initialData: KnockoutObservable<Internal.ProvisioningPartInitialData>;
        /**
         * The updated data, the last data sent by the provisioning promise in the progress or then
         * callbacks. This is useful if we need to notify the part with some data, but we're not sure
         * whether it's set up or not. This helps the provisioning part catch up on the last update
         * while it wasn't ready with the callbacks.
         */
        updatedData: KnockoutObservable<any>;
        /**
         * A promise representing the provisioning operation. The part mutates into the target startboard
         * part when this promise is resolved.
         */
        provisioningPromise: KnockoutObservable<Base.PromiseVN<any, any>>;
        /**
         * A flag indicating whether or not provisioning has started.
         */
        provisioningStarted: KnockoutObservable<boolean>;
        /**
         * True if the status of the deployment cannot be obtained; else false.
         */
        statusUnknown: KnockoutObservable<boolean>;
        /**
         * Callback invoked when the provisioning promise is acquired. Unless the subclass implements
         * it, the default behavior is mutating the part into the target startboard part on success,
         * and errors are thrown (unless 'onProvisioningPromiseError' is also implemented).
         */
        onProvisioningPromiseAcquired: (promise: Base.PromiseVN<any, any>) => void;
        /**
         * Callback invoked when an error occurs due to the provisioning promise being rejected.
         * Unless the subclass implements it, the default behavior is updating the part's title to
         * the error message and throwing the error.
         */
        onProvisioningPromiseError: (error: any) => void;
        /**
         * The title displayed on the provisioning part.
         */
        title: KnockoutObservable<string>;
        _shouldBlockUiWhenProvisioning: boolean;
        private _delayPromise;
        private _partContainer;
        private _provisioningConfig;
        /**
         * Initializes a new instance of the parameter collection provisioning part view model class.
         *
         * @param container The container into which the part is being placed.
         * @param initialState Initial state for the part.
         */
        constructor(container: PartContainerContract, initialState: any);
        /**
         * Gets the provisioner configuration passed originally from the collector, to the provisioner,
         * to this provisioning part.
         */
        /**
         * Sets the provisioner configuration passed originally from the collector, to the provisioner,
         * to this provisioning part.
         */
        provisioningConfig: Provisioner.Config;
        /**
         * See interface.
         */
        onInputsSet(inputs: any): Base.Promise;
        /**
         * Finds the startboard part and mutates into it.
         *
         * @param partInputs The inputs to the startboard part.
         */
        mutateIntoStartboardPart(partInputs: any): void;
        private _fetchProvisioningPromise();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.AssetPart.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * The interface that defines the view model that represents an asset part. Extends resizable.
     */
    interface AssetPartContract extends Resizable {
        /**
         * The friendly-name of the type.
         */
        assetType: KnockoutObservableBase<string>;
        /**
         * The name of the part.
         */
        assetName: KnockoutObservableBase<string>;
        /**
         * The asset's image.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The id of the part.
         */
        assetId: KnockoutObservableBase<any>;
        /**
         * The state of the part.
         */
        status?: KnockoutObservableBase<string>;
        /**
         * The colored line beside the part.
         */
        state?: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
    }
    /**
     * A view model class that respresents an asset part.
     */
    class AssetPart implements AssetPartContract {
        /**
         * The friendly-name of the type.
         */
        assetType: KnockoutObservableBase<string>;
        /**
         * The name of the part.
         */
        assetName: KnockoutObservableBase<string>;
        /**
         * The asset's image.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The id of the part.
         */
        assetId: KnockoutObservableBase<any>;
        /**
         * The state of the part.
         */
        status: KnockoutObservableBase<string>;
        /**
         * The colored line beside the part.
         */
        state: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.ButtonPart.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * The interface that defines the view model that respresents a button part. Extends resizable.
     */
    interface ButtonPartContract extends Resizable {
        /**
         * The title of the part.
         */
        title: KnockoutObservableBase<string>;
        /**
         * A shorter title of the part (for size: mini).
         */
        shortTitle: KnockoutObservableBase<string>;
        /**
         * A description for the part.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon for the the part.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
    }
    /**
     * A view model class that respresents a button part.
     */
    class ButtonPart implements ButtonPartContract {
        /**
         * The title of the part.
         */
        title: KnockoutObservableBase<string>;
        /**
         * A shorter title of the part (for size: mini).
         */
        shortTitle: KnockoutObservableBase<string>;
        /**
         * A description for the part.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon for the the part.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.ChartPart.d.ts
declare module MsPortalFx.ViewModels {
    import PartSize = MsPortalFx.Parts.PartSize;
    /**
     * A view model class that respresents a chart part.
     */
    class ChartPart<TX, TY> extends MsPortalFx.ViewModels.Controls.Visualization.Chart.ViewModel<TX, TY> implements Resizable {
        /**
         * The size of the part (makes it adaptive).
         */
        size: KnockoutObservable<PartSize>;
        /**
         * The selectable for the edit button.
         */
        editButtonSelectable: MsPortalFx.ViewModels.Selectable<any>;
        /**
         * The text for the edit button.
         */
        editButtonText: KnockoutObservable<string>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.CollectionPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Collection {
    import Fx = MsPortalFx;
    import BaseFx = Fx.Base;
    import PartSize = Fx.Parts.PartSize;
    import FxViewModels = Fx.ViewModels;
    import FxControls = FxViewModels.Controls;
    import FxLists = FxControls.Lists;
    import FxGrid = FxLists.Grid;
    /**
     * The modes of the grid in collection part.
     */
    enum GridMode {
        /**
         * Shows no grid. 0 is falsy.
         */
        None = 0,
        /**
         * Shows raw data grid.
         */
        Data = 1,
        /**
         * Shows the aggregated rollup data grid.
         */
        Rollup = 2,
    }
    /**
     * The contract for the grid on the collection part.
     */
    interface GridContract {
        /**
         * Column definitions.
         */
        columns: KnockoutObservableArray<FxGrid.Column>;
        /**
         * Items displayed in the table based on the column definitions when selection is disabled.
         * It is set in the constructor. Do not directly replace it.
         */
        items?: KnockoutObservableArray<any>;
    }
    /**
     * The options for the collection part view model
     */
    interface CollectionOptions {
        /**
         * The raw data.
         */
        data: GridContract;
        /**
         * The rollup data.
         */
        rollupData?: GridContract;
        /**
         * Shows the header of the grid.
         */
        showHeader?: boolean;
        /**
         * Options for the SelectableRow grid extension.  If null, rows will not be selectable.
         */
        selectableRowExtensionOptions?: FxGrid.SelectableRowExtensionOptions<any, any>;
        /**
         * The label to show when the grid has no rows.
         */
        noRowsMessage?: KnockoutObservableBase<string>;
    }
    /**
     * A view model class that respresents a collection part.
     */
    class ViewModel implements Resizable {
        /**
         * See interface.
         */
        size: KnockoutObservable<PartSize>;
        /**
         * See interface.
         */
        alwaysShowRollupCount: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        rollupCount: KnockoutObservable<number>;
        /**
         * See interface.
         */
        selectableData: FxViewModels.SelectableSet<any, any>;
        /**
         * See interface.
         */
        rollupCountIconUri: KnockoutObservable<string>;
        /**
         * See interface.
         */
        rollupCountIcon: KnockoutObservableBase<BaseFx.Image>;
        /**
         * See interface.
         */
        rollupCountLabel: KnockoutObservable<string>;
        /**
         * The mode of the grid.
         */
        gridMode: KnockoutObservable<GridMode>;
        _options: CollectionOptions;
        _container: FxViewModels.PartContainerContract;
        private grid;
        private hasMoreData;
        private noRollupCount;
        /**
         * The constructor of the collection part view model.
         */
        constructor(container: FxViewModels.PartContainerContract, options: CollectionOptions);
        private _reactToDataChange(lifetime, data, predicate);
        private _reactToSizeChange();
        private _updateGrid(data);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.CollectionSummary.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model interface that respresents summary information for a collection of resource instances.
     */
    interface CollectionSummaryContract extends Resizable {
        /**
         * The count of instances of the resource.
         */
        resourceCount: KnockoutObservableBase<number>;
        /**
         * If the resourceCount is a lower limit
         */
        countIsMinimum?: KnockoutObservableBase<boolean>;
        /**
         * The description text or resource data.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon to an image representing the resource type.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The label associated with the resource count.
         */
        label?: KnockoutObservableBase<string>;
    }
    /**
     * A view model class that represents summary information for a collection of resource instances.
     */
    class CollectionSummary implements CollectionSummaryContract {
        /**
         * The count of instances of the resource.
         */
        resourceCount: KnockoutObservableBase<number>;
        /**
         * If the resourceCount is a lower limit
         */
        countIsMinimum: KnockoutObservableBase<boolean>;
        /**
         * The description text or resource data.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon to an image representing the resource type.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The label associated with the resource count.
         */
        label: KnockoutObservableBase<string>;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.CreatePart.d.ts
declare module MsPortalFx.ViewModels {
    interface CreatePartContract extends ButtonPartContract {
        /**
         * The name of the create definition.
         */
        createName: KnockoutObservable<string>;
    }
    class CreatePart extends ButtonPart implements CreatePartContract {
        /**
         * See interface.
         */
        createName: KnockoutObservable<string>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.DiffEditorPart.d.ts
declare module MsPortalFx.ViewModels.Parts.DiffEditor {
    /**
     * The view model that implements the DiffEditor part interface.
     */
    class ViewModel extends MsPortalFx.ViewModels.Controls.Documents.DiffEditor.ViewModel {
        /**
         * The size of the part.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
        /**
         * Constructs a DiffEditor part view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.DonutPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Donut {
    /**
     * Item represents a row.
     */
    interface ItemData {
    }
    /**
     * GroupInfo is the ViewModel for a particular <optGroup>
     */
    interface GroupInfo extends MsPortalFx.ViewModels.Controls.Visualization.Donut.GroupInfo {
    }
    /**
     * ItemSetting is the fields setting to inform the ViewModel to construct the donut items.
     */
    interface ItemSetting extends MsPortalFx.ViewModels.Controls.Visualization.Donut.ItemSetting {
        /**
         * Data key used to identify the color.  This is optional, if not provided, it will use default color wheel.
         */
        colorKey?: string;
        /**
         * Data key used to identify the row.  Data has to be string, we use it on the object map to identify item's element.
         */
        rowIdKey?: string;
        /**
         * Data key used to label the row for display purpose.  Data has to be string and its used to show center caption.
         */
        labelKey?: string;
        /**
         * RowId of currently hovered slice in donut.
         */
        hoveredIndex?: KnockoutObservable<string>;
    }
    /**
     * The ViewModel class that implementes the Donut interface.
     */
    class ViewModel implements Resizable {
        /**
         * See Contract interface.
         */
        groupInfos: KnockoutObservableArray<GroupInfo>;
        /**
         * See Contract interface.
         */
        itemsDataArray: KnockoutObservableArray<ItemData>;
        /**
         * See Contract interface.
         */
        itemSetting: KnockoutObservableBase<ItemSetting>;
        /**
         * See Contract interface.
         */
        valueInitialized: boolean;
        /**
         * Indicates whether the widget should regenerate the Items from itemsDataArray & itemSetting.
         * This property is deprecated. Please invoke render() method to re-render the donut.
         */
        resetItems: Obsolete;
        /**
         * total value. The total value of all instances.
         */
        total: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * Display Text in the center.
         * By default the format string is "{0}".
         * {0}: current value.
         * {1}: maximum value.
         */
        totalFormat: KnockoutObservableBase<string>;
        /**
         * Display Unit in the center. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * By default the format string is "".
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center will not be auto scaled and the raw total value and specified unit string will be displayed.
         */
        unitFormat: KnockoutObservableBase<string | UnitConversion.Unit>;
        /**
         * Display info in the center. (Caption)
         * This is used when there is no selected nor hover on the donut.
         */
        infoFormat: KnockoutObservableBase<string>;
        /**
         * Specify the globalized number precision format options for the center and hovered value.
         * By default we will have 1 floating point precision due to space contraints in the center of the Donut.
         */
        numberFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions>;
        /**
         * Display Unit for Hovered/Selected. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * If it is "%" or undefined, by default it shows percentange.
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value and caption value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center and hovered values will not be auto scaled and the raw item value and specified unit string will be displayed.
         */
        hoveredUnit: KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * Display info in the center during the hover. (Caption)
         * This is used when hover on the text.
         * {0}: current label ("" if not available).
         * {1}: current value (or percentage).
         * {2}: current unit (or %).
         */
        hoverInfoFormat: KnockoutObservableBase<string>;
        /**
         * Display info in the center when there is a selected and no hover. (Caption)
         * {0}: current selected total.
         * {1}: current total().
         * {2}: current unitFormat().
         */
        selectedInfoFormat: KnockoutObservableBase<string>;
        /**
         * Disable selected change on click.
         */
        disableSelectOnClick: KnockoutObservableBase<boolean>;
        /**
         * Show or hide the legend. For some part size, the size will dictate whether legend should present or not.
         */
        showLegend: KnockoutObservableBase<boolean>;
        /**
         * Metrics used by the control
         */
        metrics: MsPortalFx.ViewModels.Controls.Visualization.Metrics.ViewModel;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
        _msPortalFxRerenderTrigger: KnockoutObservableBase<number>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
        render(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.EditorPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Editor {
    /**
     * The view model that implements the Editor part interface.
     */
    class ViewModel extends MsPortalFx.ViewModels.Controls.Documents.Editor.ViewModel {
        /**
         * The size of the part.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
        /**
         * Constructs an Editor part view model.
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.InfoListPart.d.ts
declare module MsPortalFx.ViewModels.Parts.InfoList {
    /**
     * The interface that defines the view model that respresents an InfoList. Extends resizable.
     */
    interface Contract {
        /**
         * The sections.
         */
        sections: KnockoutObservableArray<Section>;
    }
    interface Section {
        /**
         * The icon. Leave null if numbering is preferred.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * The section header text.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The multi-line description text.
         */
        description: KnockoutObservableBase<string>;
        /**
         * The Link entries.
         */
        links?: Link[];
        /**
         * A section-wide click effect.
         */
        selection?: Link;
    }
    class Link {
        /**
         * Display Text.
         */
        text: KnockoutObservableBase<string>;
        /**
         * The hyperlink target.
         */
        uri: KnockoutObservableBase<string>;
        /**
         * Describes the blade that should be opened when this link is selected.
         */
        bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>;
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param uri The target to open in a new browser tab.
         */
        constructor(text: string, uri: string);
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param uri The target to open in a new browser tab.
         */
        constructor(text: KnockoutObservableBase<string>, uri: KnockoutObservableBase<string>);
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param bladeSelection The blade to open.
         */
        constructor(text: string, bladeSelection: MsPortalFx.ViewModels.DynamicBladeSelection);
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param bladeSelection The blade to open.
         */
        constructor(text: KnockoutObservableBase<string>, bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>);
    }
    /**
     * A view model class that respresents an InfoList Part.
     */
    class ViewModel implements Contract, Base.Disposable {
        /**
         * See Contract.
         */
        sections: KnockoutObservableArray<Section>;
        private selection;
        private bladeLinks;
        constructor(initialState?: any);
        /**
         * See interface.
         */
        dispose(): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param sectionTargetUri The URI visited or blade opened on click. Text is ignored.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: string, description: string, sectionTargetUri: string, icon?: MsPortalFx.Base.Image): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param sectionTarget The URI visited or blade opened on click. Text is ignored.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: string, description: string, sectionTargetSelectable: MsPortalFx.ViewModels.DynamicBladeSelection, icon?: MsPortalFx.Base.Image): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param links The links provided after the description.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: string, description: string, links: Link[], icon?: MsPortalFx.Base.Image): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param links The links provided after the description.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: KnockoutObservableBase<string>, description: KnockoutObservableBase<string>, links: any, icon?: MsPortalFx.Base.Image): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.ItemSummary.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model that respresents summary information for an item.
     */
    interface ItemSummary {
        /**
         * The name of the item.
         */
        name: KnockoutObservable<string>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.PropertiesPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Properties {
    import InternalProperties = FxImpl.ViewModels.Parts.Properties;
    /**
     * Part contract.
     */
    interface Contract {
        /**
         * The collection of properties.
         */
        properties: KnockoutObservableArray<Property>;
    }
    /**
     * Part view model.
     */
    class ViewModel implements MsPortalFx.ViewModels.Parts.Properties.Contract, MsPortalFx.Base.Disposable {
        private _openBladeProperties;
        private _openBladeAsyncProperties;
        private _moveResourceProperties;
        selection: MsPortalFx.ViewModels.SelectableSet<OpenBladeProperty, MsPortalFx.ViewModels.DynamicSelection>;
        asyncSelection: MsPortalFx.ViewModels.SelectableSet<InternalProperties.OpenBladeAsyncProperty, MsPortalFx.ViewModels.DynamicSelection>;
        moveResourceSelection: MsPortalFx.ViewModels.SelectableSet<Property, MsPortalFx.ViewModels.DynamicSelection>;
        /**
         * See interface.
         */
        properties: KnockoutObservableArray<Property>;
        constructor(initialState?: any);
        /**
         * Add a property to the collection.
         * @deprecated This API has been deprecated. Use setProperties instead.
         */
        addProperty: Obsolete;
        _addProperty(property: Property): void;
        /**
         * Sets the properties.
         */
        setProperties(properties: Property[]): void;
        /**
         * Removes all properties.
         */
        removeAllProperties(): void;
        /**
         * See interface.
         */
        dispose(): void;
    }
    /**
     * Property types.
     */
    enum PropertyType {
        /**
         * Property with only text.
         */
        Text = 0,
        /**
         * Property with a link.
         */
        Link = 1,
        /**
         * Property with a copy field.
         */
        CopyField = 2,
        /**
         * Property with a callback.
         */
        Callback = 3,
        /**
         * Property to open a blade.
         */
        OpenBlade = 4,
        /**
         * Property to have a list of links.
         */
        MultiLinks = 5,
        /**
         * Property to have an of Svg.
         */
        Image = 6,
        /**
         * Property to have a list of open blade properties.
         */
        MultiOpenBlades = 7,
        /**
         * Property to open an asynchronously determined blade.
         */
        OpenBladeAsync = 8,
    }
    /**
     * Supported edit types.
     */
    enum EditType {
        /**
         * Unknown edit type.
         */
        Unknown = 0,
        /**
         * Allows to edit Resource Group or Subscription properties of a resource.
         */
        MoveResource = 1,
    }
    /**
     * Options that can be set for all properties
     */
    interface CommonOptions {
        /**
         * Label of the property.
         */
        label: string;
        /**
         * If the property is visible.
         */
        visible?: KnockoutObservableBase<boolean> | boolean;
        /**
         * If the property value should be wrapped.
         */
        wrappable?: KnockoutObservableBase<boolean> | boolean;
        /**
         * Value reflecting whether the property is loading its value.
         */
        isLoading?: KnockoutObservableBase<boolean>;
        /**
         * Info balloon to be shown next to the property.
         */
        infoBalloon?: MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel;
    }
    /**
     * Options for properties that can launch a blade
     */
    interface OpenBladeOptionalOptions {
        /**
         * Info of the blade to open
         */
        blade?: OpenBlade;
    }
    /**
     * Options for properties that are editable.
     */
    interface EditBladeOptionalOptions {
        /**
         * Info of the blade to open which allows editing property.
         */
        editBlade?: OpenBlade;
    }
    /**
     * Options for an OpenBladeProperty
     */
    interface OpenBladeOptions extends CommonOptions, EditBladeOptionalOptions, OpenBlade {
    }
    /**
     * The interface of a blade link.
     */
    interface OpenBlade {
        /**
         * The uri of the link.
         */
        bladeSelection: MsPortalFx.ViewModels.DynamicSelectionImpl | KnockoutObservableBase<MsPortalFx.ViewModels.DynamicSelectionImpl>;
        /**
         * The display text of the link.
         */
        displayValue?: string | KnockoutObservableBase<string>;
        /**
         * Supported edit type if it's an edit blade.
         */
        editType?: EditType;
        /**
         * The edit link if it's an edit blade.
         */
        showLink?: boolean;
    }
    /**
     * Options for a TextProperty
     */
    interface TextOptions extends OpenBladeOptionalOptions, CommonOptions {
        /**
         * Value of the property.
         */
        value: KnockoutObservableBase<string> | string;
        /**
         * Optional icon to display before the text
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
    }
    /**
     * Options for a LinkProperty
     */
    interface LinkOptions extends CommonOptions {
        /**
         * Value of the property.
         */
        value: KnockoutObservableBase<string> | string;
        /**
         * Link display value of the property.
         */
        displayValue?: KnockoutObservableBase<string> | string;
    }
    /**
     * Options for a CopyFieldProperty
     */
    interface CopyFieldOptions extends OpenBladeOptionalOptions, EditBladeOptionalOptions, CommonOptions {
        /**
         * Value of the property.
         */
        value: KnockoutObservableBase<string> | string;
    }
    /**
     * Options for an ImageProperty
     */
    interface ImageOptions extends OpenBladeOptionalOptions, CommonOptions {
        /**
         * The icon for callback and image
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
    }
    /**
     * Options for a MultiOpenBladeProperty
     */
    interface MultiOpenBladeOptions extends CommonOptions {
        /**
         * A collection of link for multiopenblade
         */
        bladeLinks: KnockoutObservableArray<OpenBlade>;
    }
    /**
     * Options for a MultiLinksProperty
     */
    interface MultiLinksOptions extends CommonOptions {
        /**
         * The observable array of links for multilinks
         */
        links: KnockoutObservableArray<Link>;
    }
    /**
     * Options for a CallbackProperty
     */
    interface CallbackOptions extends CommonOptions {
        /**
         * Displayed text for the link to execute the callback.
         */
        displayValue: KnockoutObservableBase<string> | string;
        /**
         * The callback for callback
         */
        callback: () => void;
        /**
         * The icon for callback and image
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
    }
    interface MoveResourceOptions extends CopyFieldOptions {
        /**
         * Resource Id
         */
        resourceId: string;
        /**
         * Resource move type
         */
        moveType: MsPortalFx.Azure.ResourceManager.MoveType;
    }
    /**
     * Property base class.
     */
    class Property implements MsPortalFx.Base.Disposable {
        /**
         * Gets the label of the property.
         */
        label: string;
        /**
         * Gets the display value of the property.
         */
        displayValue: KnockoutObservableBase<string>;
        /**
         * Gets the value of the property.
         * Note : this should be a KnockoutObservableBase<string>, but external code uses this
         * as a CopyField ViewModel because this property was an "any" and either a string,
         * or a CopyField ViewModel.  Can't separate them as this API is public and in use.
         */
        value: any;
        /**
         * Gets the value that is copied
         */
        copyableValue: KnockoutObservableBase<string>;
        /**
         * Gets or sets if the property is visible. It is true by default.
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * Gets or sets if the property value should be wrapped. It is false by default.
         */
        wrappable: KnockoutObservableBase<boolean>;
        /**
         * Gets or sets a link to open another blade.
         */
        bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicSelection>;
        /**
         * Get a value reflecting whether the property is loading its value.
         */
        isLoading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Info balloon to be shown next to the property.
         */
        infoBalloon: MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel;
        /**
         * Get the type of this property.
         */
        type: PropertyType;
        /**
         * A link to open a blade to edit the property.
         */
        editBlade: OpenBlade;
        /**
         * text for edit blade link.
         */
        editBladeText: string;
        _supportsIsLoading: boolean;
        private _loaded;
        private hasValidBladeSelection;
        private _bladeSelectionSub;
        constructor(options: InternalProperties.AllOptions);
        /**
         * Get the property type.
         */
        getType(): PropertyType;
        /**
         * See interface.
         */
        dispose(): void;
    }
    /**
     * Text property class.
     */
    class TextProperty extends Property {
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        constructor(label: string, value: string);
        constructor(label: string, value: KnockoutObservableBase<string>);
        constructor(options: TextOptions);
        /**
         * See base.
         */
        getType(): PropertyType;
    }
    /**
     * Link property class.
     */
    class LinkProperty extends Property {
        constructor(label: string, uri: string, displayUri?: string);
        constructor(label: string, uri: KnockoutObservableBase<string>, displayUri?: KnockoutObservableBase<string>);
        constructor(options: LinkOptions);
        /**
         * See base.
         */
        getType(): PropertyType;
    }
    /**
     * Copy field property.
     */
    class CopyFieldProperty extends Property {
        private _valueResponder;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, label: string, value: string);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, label: string, value: KnockoutObservableBase<string>);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: CopyFieldOptions);
        /**
         * See base.
         */
        getType(): PropertyType;
        /**
         * See base.
         */
        dispose(): void;
    }
    /**
     * Callback property class.
     */
    class CallbackProperty extends Property {
        callback: () => void;
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        private callbackWrapper;
        constructor(label: string, displayValue: string, callback: () => void, icon?: MsPortalFx.Base.Image);
        constructor(label: string, displayValue: KnockoutObservableBase<string>, callback: () => void, icon?: KnockoutObservableBase<MsPortalFx.Base.Image>);
        constructor(options: CallbackOptions);
        /**
         * See base.
         */
        getType(): PropertyType;
    }
    /**
     * The property to open a specified blade.
     */
    class OpenBladeProperty extends Property {
        constructor(label: string, displayValue: string, bladeSelection: MsPortalFx.ViewModels.DynamicSelectionImpl);
        constructor(label: string, displayValue: KnockoutObservableBase<string>, bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicSelectionImpl>);
        constructor(options: OpenBladeOptions);
        /**
         * See base.
         */
        getType(): PropertyType;
    }
    /**
     * The property to have a list of open blade properties
     */
    class MultiOpenBladeProperty extends Property {
        /**
         * The observable array of blade links.
         */
        bladeLinks: KnockoutObservableArray<OpenBladeProperty>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, label: string, bladeLinks: KnockoutObservableArray<OpenBlade>);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: MultiOpenBladeOptions);
        /**
         * See base.
         */
        getType(): PropertyType;
    }
    /**
     * The interface of a html link.
     */
    interface Link {
        /**
         * The display text of the link.
         */
        text: string;
        /**
         * The uri of the link.
         */
        uri: string;
    }
    /**
     * The property to have a list of html links
     */
    class MultiLinksProperty extends Property {
        /**
         * The observable array of links.
         */
        links: KnockoutObservableArray<Link>;
        constructor(label: string, links: KnockoutObservableArray<Link>);
        constructor(options: MultiLinksOptions);
        /**
         * See base.
         */
        getType(): PropertyType;
    }
    /**
     * The property to have a image
     */
    class ImageProperty extends Property {
        /**
         * The observable image.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        constructor(label: string, icon: KnockoutObservableBase<MsPortalFx.Base.Image>);
        constructor(options: ImageOptions);
        /**
         * See base.
         */
        getType(): PropertyType;
    }
}
declare module FxImpl.ViewModels.Parts.Properties {
    import Properties = MsPortalFx.ViewModels.Parts.Properties;
    /**
     * All options that can be set for a property
     */
    interface AllOptions {
        /**
         * Label of the property.
         */
        label?: string;
        /**
         * Value of the property.
         */
        value?: MsPortalFx.ViewModels.Controls.Forms.CopyableLabel.ViewModel | string | KnockoutObservableBase<string>;
        /**
         * Value that is copied.
         */
        copyableValue?: KnockoutObservableBase<string> | string;
        /**
         * If the property is visible.
         */
        visible?: KnockoutObservableBase<boolean> | boolean;
        /**
         * If the property value should be wrapped.
         */
        wrappable?: KnockoutObservableBase<boolean> | boolean;
        /**
         * Blade link display value of the property.
         */
        displayValue?: KnockoutObservableBase<string> | string;
        /**
         * A link to open another blade.
         */
        blade?: Properties.OpenBlade | OpenBladeAsync;
        /**
         * A link to open a blade to edit the property.
         */
        editBlade?: Properties.OpenBlade;
        /**
         * The icon for the property
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
        /**
         * A collection of link for multiopenblade
         */
        bladeLinks?: KnockoutObservableArray<Properties.OpenBlade>;
        /**
         * The observable array of links for multilinks
         */
        links?: KnockoutObservableArray<Properties.Link>;
        /**
         * The callback for callback
         */
        callback?: () => void;
        /**
         * Value reflecting whether the property is loading its value.
         */
        isLoading?: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Info balloon to be shown next to the property.
         */
        infoBalloon?: MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel;
    }
    /**
     * Options for an OpenBladeAsyncProperty
     */
    interface OpenBladeAsyncOptions extends Properties.CommonOptions, Properties.EditBladeOptionalOptions, OpenBladeAsync {
    }
    /**
     * The interface of a blade link.
     */
    interface OpenBladeAsync {
        /**
         * The display text of the link.
         */
        displayValue: string | KnockoutObservableBase<string>;
        /**
         * The uri of the link.
         */
        resolveBlade: () => MsPortalFx.Base.PromiseV<MsPortalFx.ViewModels.DynamicSelection>;
    }
    /**
     * The property to open a blade that is determined asynchronously.
     */
    class OpenBladeAsyncProperty extends Properties.Property {
        resolveBlade: () => MsPortalFx.Base.PromiseV<MsPortalFx.ViewModels.DynamicSelection>;
        constructor(options: OpenBladeAsyncOptions);
        /**
         * See base.
         */
        getType(): Properties.PropertyType;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.ProvisioningPart.d.ts
declare module MsPortalFx.ViewModels.ProvisioningPart {
    interface ContentContract extends PartContent {
        /**
         * The title displayed on the provisioning part.
         */
        title: KnockoutObservable<string>;
        /**
         * The description displayed on the provisioning part.
         */
        description: KnockoutObservable<string>;
        /**
         * The URI for the icon displayed on the provisioning part.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
    }
    class ContentViewModel extends MsPortalFx.ViewModels.ParameterCollection.BaseGalleryButtonPartViewModel implements ContentContract, MsPortalFx.Base.Disposable {
        private _partContainer;
        /**
         * Creates the view model that drives the content within the unprovisioned part.
         *
         * @param container The view model for the part container.
         * @param initialState The saved state defining the current progress of the wizard.
         * @param allowToggleProvisioningLocation True, if user can choose whether provisioning happens on blade or startboard part; else false.
         */
        constructor(container: MsPortalFx.ViewModels.PartContainerContract, initialState?: any, allowToggleProvisioningLocation?: boolean);
        /**
         * See interface.
         */
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        /**
         * See interface.
         */
        title: KnockoutObservable<string>;
        /**
         * See interface.
         */
        description: KnockoutObservable<string>;
        /**
         * See interface.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * Obsolete. This property will be removed post //Build.
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * Error message displayed when there is an error during provisioning.
         */
        errorMessage: KnockoutObservable<string>;
        /**
         * Obsolete. This property will be removed post //Build.
         */
        privatePcPrBI: MsPortalFx.ViewModels.ParameterCollection.Internal.ProvisioningEntityBindingInternals;
        mutate(containerModel: any): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.QuickStartPart.d.ts
declare module MsPortalFx.ViewModels {
    interface QuickStartPartContract extends ButtonPartContract {
        /**
         * The color to use for the background of the quickstart button.
         */
        backgroundColor: MsPortalFx.Parts.PartColor;
    }
    class QuickStartPart extends ButtonPart implements QuickStartPartContract {
        /**
         * See interface.
         */
        backgroundColor: MsPortalFx.Parts.PartColor;
        /**
         * Initialize the part.
         */
        constructor();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.QuotaGaugePart.d.ts
declare module MsPortalFx.ViewModels.Parts.QuotaGauge {
    /**
     * The color of the bar in the metric.
     */
    enum MetricColorBarKind {
        /**
         * No bar color. This is the default.
         */
        None = 0,
        /**
         * Color used for the current value in the gauge.
         */
        CurrentValue = 1,
        /**
         * Color used for the background of the arc of the gauge (max - current).
         */
        GaugeBackground = 2,
        /**
         * Color used for the total value in the gauge.
         */
        TotalValue = 3,
    }
    /**
     * The interface that defines the information for each metric.
     */
    interface MetricContract {
        /**
         * Value of the metric.
         */
        value: KnockoutObservableBase<string>;
        /**
         * Unit of the metric.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * Caption of the metric.
         */
        caption: KnockoutObservableBase<string>;
        /**
         * Color bar for the metric.
         */
        metricColorBarKind?: KnockoutObservable<MetricColorBarKind>;
    }
    /**
     * The interface for the QuotaGauge control.
     */
    interface Contract extends Resizable {
        /**
         * Current instance value of the gauge.
         */
        instance: KnockoutObservable<number>;
        /**
         * Current instance quota value.
         */
        instanceQuota: KnockoutObservable<number>;
        /**
         * Total value of the grouped instances.
         */
        total: KnockoutObservable<number>;
        /**
         * Total quota value of the grouped instances.
         */
        totalQuota: KnockoutObservable<number>;
        /**
         * Unit of measurement.
         */
        unit: KnockoutObservable<string>;
        /**
         * Hide the Total bar.
         */
        hideTotal: KnockoutObservableBase<boolean>;
        /**
         * Hide quota verification.
         */
        hideQuota: KnockoutObservableBase<boolean>;
        /**
         * Hide the current tick mark.
         */
        hideTick: KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * Total Arc of the gauge. (units in degree). Gauge total arc must be less than 360.
         */
        totalArc: KnockoutObservableBase<number>;
        /**
         * captionDisplayFormat value.
         *  {0} is intance
         *  {1} is instanceQuota,
         *  {2} is total
         *  {3} is totalQuota
         *  {4} is maximum
         *  You can also override with custom text.
         */
        captionDisplayFormat: KnockoutObservableBase<string>;
        /**
         * valueDisplayFormat value.
         *  {0} is intance
         *  {1} is instanceQuota,
         *  {2} is total
         *  {3} is totalQuota
         *  {4} is maximum
         */
        valueDisplayFormat: KnockoutObservableBase<string>;
        /**
         * List of metrics.
         */
        metrics: KnockoutObservableArray<MetricContract>;
    }
    /**
     * The ViewModel class that implementes the QuotaGauge interface.
     */
    class ViewModel implements Contract {
        /**
         * Current instance value of the gauge.
         */
        instance: KnockoutObservable<number>;
        /**
         * Total value of the grouped instances.
         */
        total: KnockoutObservable<number>;
        /**
         * Current instance quota value .
         */
        instanceQuota: KnockoutObservable<number>;
        /**
         * Total quota value of the grouped instances.
         */
        totalQuota: KnockoutObservable<number>;
        /**
         * See interface.
         */
        unit: KnockoutObservable<string>;
        /**
         * See interface.
         */
        hideTotal: KnockoutObservableBase<boolean>;
        /**
         * See interface.
         */
        hideQuota: KnockoutObservableBase<boolean>;
        /**
         * See interface.
         */
        hideTick: KnockoutObservableBase<boolean>;
        /**
         * See interface.
         */
        maximum: KnockoutObservableBase<number>;
        /**
         *  See interface.
         */
        startOffset: KnockoutObservableBase<number>;
        /**
         * See interface.
         */
        totalArc: KnockoutObservableBase<number>;
        /**
         * See interface.
         */
        captionDisplayFormat: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        valueDisplayFormat: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        metrics: KnockoutObservableArray<MetricContract>;
        /**
         * See interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.ResourceSummaryPart.d.ts
declare module MsPortalFx.ViewModels.Parts.ResourceSummary {
    import FxViewModels = MsPortalFx.ViewModels;
    import Property = FxViewModels.Parts.Properties.Property;
    import PropertiesPart = FxViewModels.Parts.Properties;
    import FxImplViewModels = FxImpl.ViewModels;
    import Base = MsPortalFx.Base;
    import ResourceManager = MsPortalFx.Azure.ResourceManager;
    import MoveType = ResourceManager.MoveType;
    var includedResourceTypes: StringMap<MoveType>;
    /**
     * Resource summary part contract.
     */
    interface Contract {
    }
    /**
     * The function contract to get dynamic blade selection.
     */
    interface GetDynamicBladeSelection {
        (inputs: any): ViewModels.DynamicBladeSelection;
    }
    /**
     * Resource summary part options.
     */
    interface Options {
        /**
         * The function to get selection for settings blade.
         */
        getSettingsSelection?: GetDynamicBladeSelection;
        getQuickStartSelection?: GetDynamicBladeSelection;
        /**
         * The function to get selection for keys blade.
         */
        getKeysSelection?: GetDynamicBladeSelection;
        /**
         * Sets if the resource summary is collapsed by default.
         */
        collapsed?: boolean;
        /**
         * Sets if the resource group property should be added.
         */
        noResourceGroup?: boolean;
        /**
         * Sets if the tags shortcut should be added.
         */
        noTags?: boolean;
        /**
         * Sets if the rbac shortcut should be added.
         */
        noRbac?: boolean;
        /**
         * Sets if the change resource group/subscription is supported.
         */
        supportsResourceMove?: MoveType;
    }
    /**
     * Resource summary part view model.
     */
    class ViewModel extends PropertiesPart.ViewModel implements Contract {
        /**
         * Gets or sets if the tags shortcut should be visible.
         */
        tagsVisible: KnockoutObservableBase<boolean>;
        /**
         * Gets or sets the title of resource summary.
         */
        title: KnockoutObservableBase<string>;
        /**
         * Gets or sets the label of the all settings button.
         */
        settingsLabel: KnockoutObservableBase<string>;
        protected collapsed: KnockoutObservableBase<boolean>;
        resourceGroupSelectable: ViewModels.Selectable<ViewModels.DynamicAssetSelection>;
        quickStartSelectable: ViewModels.Selectable<ViewModels.DynamicBladeSelection>;
        settingsSelectable: ViewModels.Selectable<ViewModels.DynamicBladeSelection>;
        accessSelectable: ViewModels.Selectable<FxImplViewModels.DynamicBladeSelection>;
        tagsSelectable: ViewModels.Selectable<ViewModels.DynamicBladeSelection>;
        keysSelectable: ViewModels.Selectable<ViewModels.DynamicBladeSelection>;
        private hasKeys;
        private hasQuickStart;
        private hasSettings;
        private noResourceGroup;
        private noTags;
        private noRbac;
        private _editRg;
        private _allowedPropertyTypes;
        private _partContainer;
        protected _options: Options;
        protected _loadingPromise: Base.Promise;
        private _loadingLM;
        private _inputs;
        protected _currentResourceId: KnockoutObservable<string>;
        protected _ensureRGProperty: () => Property;
        protected _cloudName: string;
        constructor(initialState: any, options: Options, container: ViewModels.PartContainerContract);
        /**
         * See base.
         */
        onInputsSet(inputs: any, settings: any): Base.Promise;
        /**
         * It invokes whenever the resource summary is expanded.
         *
         * @param lifetimeManager The lifetime manager helps manage the life cycle of data loading.
         * @param inputs The inputs sent to resource summary.
         * @return A promise that will be used to decide the completion of an operation.
         */
        protected onExpanded(lifetimeManager: Base.LifetimeManager, inputs: any): Base.Promise;
        /**
         * See base.
         *  @deprecated This API has been deprecated. Use setProperties instead.
         */
        _addProperty(property: Property): void;
        /**
         * See base.
         */
        setProperties(properties: Property[]): void;
        protected _setProperties(properties: Property[]): void;
        protected _startRebind(resourceId: string): void;
        protected _isValidProperty(property: Property): boolean;
        protected _markBuiltInProperty(property: Property, kind: BuiltInPropertyKind): void;
        private _createSelectable<T>(initialState, propName);
        private _updateDataLoading(container, collapsed);
        private _resetLoadingState(container);
        private _createResourceGroupProperty(lifetime);
    }
    /**
     * Reflects the different built-in properties that are typically displayed in the left-hand column of the
     * ResourceSummary Part.
     */
    enum BuiltInPropertyKind {
        ResourceGroup = 0,
        Status = 1,
        Location = 2,
        SubscriptionName = 3,
        SubscriptionId = 4,
    }
    /**
     * For advanced cases, describes the layout of properties in the left- and right-hand columns of the ResourceSummary
     * Part.
     */
    interface Layout {
        left: (Property | BuiltInPropertyKind)[];
        right: (Property | BuiltInPropertyKind)[];
    }
    /**
     * Options for the ResourceSummary Part view model.
     */
    interface Options2 extends Options {
        /**
         * Observables that represent the 'status' of the resource and an indication of whether the 'status' is
         * currently loading (which controls a loading indicator for the 'status' property).  Supply null/undefined
         * here to explicitly not include this property.
         */
        status: {
            /**
             * Indicates the status value for the resource.
             */
            value: KnockoutObservableBase<string>;
            /**
             * Reflects whether the status value for the resource is currently being loaded.
             * This controls a loading indicator for the 'status' property.
             */
            isLoading: KnockoutObservableBase<boolean>;
        };
        /**
         * An optional observable the extension can supply/populate in order to customize the 'location' property
         * to be different than the default for this built-in property.
         */
        location?: KnockoutObservableBase<string>;
        /**
         * An array of properties that should be displayed for all instances of this resource type.
         */
        staticProperties: Property[];
        /**
         * For advanced cases, an optional object that describes the layout of properties into the left- and right-hand
         * columns of the ResourceSummary Part.
         */
        layout?: Layout;
    }
    /**
     * The view model for the ResourceSummary Part.
     */
    class ViewModel2 extends ViewModel {
        private _dynamicProperties;
        private _dependencies;
        private _editSub;
        constructor(initialState: any, options: Options2, container: ViewModels.PartContainerContract);
        /**
         * Called by the extension before the Part's 'onInputsSet' promise resolves, this appends dynamic,
         * data-specific properties to the view.
         *
         * @param properties The properties to be apppended.
         */
        setDynamicProperties(properties: Property[]): void;
        /**
         * Not supported by this view model class.  The set of displayed properties is managed implicitly by this class.
         * The displayed properties can be controlled by the extension by supplying 'options' to the constructor and
         * by calling 'setDynamicProperties' during data-loading/rebinding of this Part.
         */
        setProperties(properties: Property[]): void;
        private _setBuiltInProperty(builtInProperties, kind, property);
        private _createBuiltInProperties(lifetime, options);
        private _layoutProperties(builtInProperties, staticProperties, dynamicProperties, layout);
        protected _startRebind(resourceId: string): void;
    }
}
declare module FxImpl.ViewModels.Parts.ResourceSummary {
    import Base = MsPortalFx.Base;
    import ViewModels = MsPortalFx.ViewModels;
    import ResourceSummaryPart = MsPortalFx.ViewModels.Parts.ResourceSummary;
    interface Dependencies {
        /**
         * Gets the resource location for a given resource ID.
         * @param resourceId The resource ID.
         * @return A promise that resolves with the resource location string.
         */
        getLocation?: (resourceId: string) => Base.PromiseV<string>;
        /**
         * Gets the name of a subscription, given a subscription ID.
         * @param subscriptionID The subscription ID.
         * @return A promise that resolves with the subscription name string.
         */
        getSubscriptionName?: (subscriptionId: string) => Base.PromiseV<string>;
        /**
         * Gets a descriptor of the Blade to be opened for the given subscription ID.
         * @param subscriptionID The subscription ID.
         * @return A promise that resolves with the descriptor of the Blade to be opened.
         */
        getSubscriptionBlade?: (subscriptionId: string) => Base.PromiseV<ViewModels.DynamicBladeSelection>;
    }
    /**
     * For testing purposes, mocks the dependencies of this ResourceSummary Part view model.
     * @param viewModel The ResourceSummary Part view model.
     * @param dependencies The dependencies.
     */
    function setDependencies(viewModel: ResourceSummaryPart.ViewModel2, dependencies: Dependencies): void;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.SettingList.d.ts
declare module MsPortalFx.ViewModels.Parts.SettingList {
    import Fx = MsPortalFx;
    import BaseFx = Fx.Base;
    import FxViewModels = FxImpl.ViewModels;
    import ViewModels = Fx.ViewModels;
    import Selectable = ViewModels.Selectable;
    import GridFx = ViewModels.Controls.Lists.Grid;
    import PartContainerContract = ViewModels.PartContainerContract;
    function ShouldRemoveSupportSettings(value: boolean): void;
    /**
     * The contract of the setting selection.
     */
    interface SettingSelection extends FxViewModels.DynamicBladeSelection {
        /**
         * The identifier of the setting.
         */
        key: string;
        /**
         * Gets if the setting using parameter collector.
         */
        isParameterCollector: boolean;
    }
    /**
     * The options of the settings.
     */
    interface SettingOptions<TParameterCollectorResult> {
        /**
         * The parameter collector callbacks.
         */
        parameterCollector?: ParameterCollectorSettingOptions<TParameterCollectorResult>;
    }
    /**
     * The options of the parameter collector for the settings.
     */
    interface ParameterCollectorSettingOptions<TResult> {
        /**
         * A callback that supplies initial data for the parameter provider
         * in the child blade each time it opens.
         *
         * Note that the object received by the parameter provider will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed (and sometimes stored) in a serialized form.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @return Initial data for the child blade.
         */
        supplyInitialData(): TResult;
        /**
         * A callback to be invoked when the child blade supplies a result
         * and closes.
         *
         * @param result The result given by the child blade.
         * @param activatedItem The object whose selection launched this parameter collection process. The result refers to that object.
         */
        receiveResult(result: TResult): void;
        /**
         * A callback that supplies additional configuration options for the
         * provider each time it opens. You can use this to pass non-editable
         * data, for example configuring how a form will be displayed.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @return Arbitrary configuration options for the child blade.
         */
        supplyProviderConfig?(): any;
    }
    /**
     * The class of the setting list item.
     */
    class Setting {
        /**
         * Gets or sets the display text for the setting.
         */
        displayText: KnockoutObservable<string>;
        /**
         * Gets or sets the icon for the setting.
         */
        icon: KnockoutObservable<BaseFx.Image>;
        /**
         * Gets or sets the keywords for the setting.
         */
        keywords: KnockoutObservableArray<string>;
        /**
         * Gets or sets the group name for the setting.
         */
        group: KnockoutObservable<string>;
        private aggregatedKeywords;
        private _key;
        private _blade;
        protected _bladeInputs: KnockoutObservableBase<any>;
        protected _extension: KnockoutObservableBase<string>;
        private _options;
        /**
         * Gets the key of the setting.
         */
        key: string;
        /**
         * Gets the setting options.
         */
        getOptions(): SettingOptions<any>;
        constructor(key: string, detailBlade: string | KnockoutObservableBase<string>, detailBladeInputs: KnockoutObservableBase<any>, extension?: string | KnockoutObservableBase<string>, options?: SettingOptions<any>);
        /**
         * Gets the setting selection.
         */
        toSelection(): SettingSelection;
    }
    /**
     * The options of the setting list part.
     */
    interface Options {
        /**
         * Indicates whether the export template menu item should be enabled. Enabled by defualt for subscription resources and resource groups.
         */
        enableExportTemplate?: boolean;
        /**
         * Enables the settings for roles and users.
         */
        enableRbac?: boolean;
        /**
         * Enables the settings for help request support.
         */
        enableSupportHelpRequest?: boolean;
        /**
         * Enables the settings for troubleshoot support.
         */
        enableSupportTroubleshoot?: boolean;
        /**
         * Enables the settings for troubleshoot support.
         */
        enableSupportTroubleshootV2?: boolean;
        /**
         * Enables the settings for resource health support.
         */
        enableSupportResourceHealth?: boolean;
        /**
         * Enables the settings for the event logs.
         */
        enableSupportEventLogs?: boolean;
        /**
         * Enables the setting for tags.
         */
        enableTags?: boolean;
        /**
         * Enables grouping of the settings.
         */
        groupable?: boolean;
        /**
         * Enables the setting for management certs.
         */
        enableManagementCerts?: boolean;
        /**
         * Enables the setting for access details.
         */
        enableAccessDetails?: boolean;
        /**
         * Enables the setting for resource provider details.
         */
        enableResourceProviders?: boolean;
    }
    abstract class BaseViewModel {
        resourceId: KnockoutObservableBase<string>;
        settingList: GridFx.ViewModel<Setting, SettingSelection>;
        searchBoxPlaceholder: KnockoutObservableBase<string>;
        private _cloudAwareSettings;
        private _searchText;
        private _cloudName;
        constructor(container: PartContainerContract, initialState: any, settings: Setting[] | KnockoutObservableArray<Setting>, options?: Options);
        /**
         * Internal only, do not use.
         */
        protected _setCloudName(cloudName: string): void;
        protected isPCv3(): boolean;
        private _updateSettings(container, settings, options, resource);
        private _processSettings(container);
        private _removeSetting(setting);
        private _trace(settingSelection);
    }
    /**
     * The view model of the setting list part.
     */
    class ViewModel extends BaseViewModel {
        /**
         * This is only here to cause compile time breaks between V1 and V2, for migrating from V1 to V2 see
         * https://auxdocs.azurewebsites.net/en-us/documentation/articles/portalfx-blades-bladekinds-settinglist-migration
         */
        private _1;
        constructor(container: PartContainerContract, initialState: any, settings: Setting[] | KnockoutObservableArray<Setting>, options?: Options);
    }
    /**
     * The setting list part view model v2 enables the parameter collector V3 for the settings.
     * It is fully back-compatible with setting list part view model v1.
     */
    class ViewModelV2 extends BaseViewModel {
        selectable: Selectable<SettingSelection>;
        pcSelectable: Selectable<SettingSelection>;
        parameterCollector: ViewModels.ParameterCollector<any>;
        protected isPCv3(): boolean;
        constructor(container: PartContainerContract, initialState: any, settings: Setting[] | KnockoutObservableArray<Setting>, options?: Options);
        private _initParameterCollector(container);
        private _getCurrentSetting(selectable);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.SetupPart.d.ts
declare module MsPortalFx.ViewModels.SetupPart {
    /**
     * Interface for the content of a create part.
     */
    interface ContentContract extends ProvisioningPart.ContentContract {
        /**
         * A parameter collection entity that does provisioning.
         */
        provisioningEntity: MsPortalFx.ViewModels.ParameterCollection.Internal.ProvisioningEntity;
    }
    /**
     * Base class for the content view model of a create part.
     */
    class Content extends ProvisioningPart.ContentViewModel implements ContentContract, MsPortalFx.Base.Disposable {
        private _setupPartContainer;
        private _previousCommit;
        private _outputs;
        /**
         * See interface.
         */
        provisioningEntity: MsPortalFx.ViewModels.ParameterCollection.Internal.ProvisioningEntity;
        /**
         * Creates the view model for the setup part.
         *
         * @param container The view model for the part container.
         * @param initialState The initial state of the part.
         */
        constructor(container: MsPortalFx.ViewModels.PartContainerContract, initialState?: any);
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        /**
         * Allows subclasses to provide a promise that indicates whether to load the content for the setup part
         * or mutate into another part.
         *
         * @return Null to proceed straight to the content for this part or a promise. If a promise is returned
         * the setup part will wait in a loading state until it is resolved with one of the following values:
         *   * null - The setup part will proceed to load it's content.
         *   * string - The string is the name of a part in this extension's part catalog. The setup part will mutate into that part.
         *   * object - The object must have 'partName' and 'extensionName' properties. The setup part will find the part in the specified extension's part
         * catalog and mutate into that part.
         */
        mutateOnLoad(): MsPortalFx.Base.PromiseV<any>;
        /**
         * Mutates setup part into another part.
         *
         * @param newPart The name of the part in the part catalog.
         * @param exetensionForPart Name of the extension containing the part. Optional.
         */
        mutate(newPart: string, extensionForPart?: string): void;
        onProviderCommit(providerId: string, outputs: MsPortalFx.ViewModels.ParameterCollection.ParameterCollectionOutput): MsPortalFx.Base.PromiseV<boolean>;
        private _loadContent();
        private _executeProvisioningIfApplicable(newCommit);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.SimpleChartPart.d.ts
declare module MsPortalFx.ViewModels {
    interface SimpleChartPartOptions<TX, TY> extends MsPortalFx.ViewModels.Controls.Visualization.SimpleChart.SimpleChartOptions<TX, TY> {
        /**
         * The size of the part (makes it adaptive).
         */
        size?: KnockoutObservable<MsPortalFx.Parts.PartSize>;
        /**
         * The selectable for the edit button.
         */
        editButtonSelectable?: MsPortalFx.ViewModels.Selectable<any>;
        /**
         * The text for the edit button.
         */
        editButtonText?: string | KnockoutObservableBase<string>;
    }
    /**
     * A view model class that respresents a chart part.
     */
    class SimpleChartPart<TX, TY> extends MsPortalFx.ViewModels.Controls.Visualization.SimpleChart.ViewModel<TX, TY> implements Resizable {
        /**
         * The size of the part (makes it adaptive).
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
        /**
         * The selectable for the edit button.
         */
        editButtonSelectable: MsPortalFx.ViewModels.Selectable<any>;
        /**
         * The text for the edit button.
         */
        editButtonText: string | KnockoutObservableBase<string>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: SimpleChartPartOptions<TX, TY>);
        private _initSimpleChartPartOptions(options);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Parts\ViewModels.SingleValueGaugePart.d.ts
declare module MsPortalFx.ViewModels.Parts.SingleValueGauge {
    /**
     * The color of the bar in the metric.
     */
    enum MetricColorBarKind {
        /**
         * No bar color. This is the default.
         */
        None = 0,
        /**
         * Color used for the current value in the gauge.
         */
        CurrentValue = 1,
        /**
         * Color used for the background of the arc of the gauge (max - current).
         */
        GaugeBackground = 2,
    }
    /**
     * The interface that defines the information for each metric.
     */
    interface MetricContract {
        /**
         * Value of the metric.
         */
        value: KnockoutObservableBase<string>;
        /**
         * Unit of the metric.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * Caption of the metric.
         */
        caption: KnockoutObservableBase<string>;
        /**
         * Color bar for the metric.
         */
        metricColorBarKind?: KnockoutObservable<MetricColorBarKind>;
    }
    /**
     * The interface for the SingleValueGauge control.
     */
    interface Contract extends Resizable {
        /**
         * Maximum value of the gauge.
         */
        maximum: KnockoutObservable<number>;
        /**
         * Current value for the gauge.
         */
        current: KnockoutObservable<number>;
        /**
         * Unit of measurement.
         */
        unit: KnockoutObservable<string>;
        /**
         * List of metrics.
         */
        metrics: KnockoutObservableArray<MetricContract>;
    }
    /**
     * The ViewModel class that implementes the SingleValueGauge interface.
     */
    class ViewModel implements Contract {
        /**
         * See interface.
         */
        maximum: KnockoutObservable<number>;
        /**
         * See interface.
         */
        current: KnockoutObservable<number>;
        /**
         * See interface.
         */
        unit: KnockoutObservable<string>;
        /**
         * See interface.
         */
        metrics: KnockoutObservableArray<MetricContract>;
        /**
         * See interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Selection.d.ts
declare module FxImpl.ViewModels {
    /**
     * Internal interface that the shell uses to manage a selectable instance
     */
    interface SelectableState {
        /**
         * Method invoked by the shell to obtain exclusive access to the selectedValue
         */
        lock(): void;
        /**
         * Method invoked by the shell to internally change the selectedValue
         *
         * @param value New Value to assign selected value too.
         */
        setInternalSelectedValue(value: any): void;
        /**
         * Gets if the selectable is locked
         */
        isLocked(): boolean;
    }
    /**
     * A navigation cursor command interface to move to the next or previous item.
     * Currently this is an internal interface used by SelectableSet to enable BladePair parent navigation.
     */
    interface SelectableCursor {
        /**
         * Selects the previous selectable item.
         */
        previous: MsPortalFx.ViewModels.Commands.Command<void>;
        /**
         * Selects the next selectable item.
         */
        next: MsPortalFx.ViewModels.Commands.Command<void>;
    }
}
declare module MsPortalFx.ViewModels {
    /**
     * A view model that represents a list of items, each of which can be selected.
     */
    interface SelectableItems<T> {
        /**
         * A list of items, each of which can be selected.
         */
        selectableItems: KnockoutObservableArray<SelectableItem<T>>;
    }
    /**
     * A view model representing an item that can be selected.
     */
    interface SelectableItem<T> {
        /**
         * Reflects whether the item is currently in a selected state.
         */
        isSelected: KnockoutObservable<boolean>;
        /**
         * Reflects whether the item is currently in an activated state.
         * Activation is a further level of selection that may invoke
         * additional behavior, such as opening the 'details' view in
         * a master-details scenario.
         */
        isActivated: KnockoutObservable<boolean>;
        /**
         * Reflects whether the item currently has journey children that are in an edited state.
         */
        hasChildEdits: KnockoutObservableBase<boolean>;
        /**
         * The model data.
         */
        data: T;
    }
    /**
     * A view model that represents an edited, selected item.
     */
    interface EditedItem<U> {
        /**
         * A representation of the edited item.
         */
        item: U;
        /**
         * The EditScope identifier for the edited item.
         */
        editScopeId: string;
    }
    /**
     * A view model that represents a sparse list of currently selected and/or activated items.
     */
    interface SetSelection<U> {
        /**
         * A representation of the items currently selected.
         */
        selectedItems: KnockoutObservableArray<U>;
        /**
         * A representation of the items currently activated.
         */
        activatedItems: KnockoutObservableArray<U>;
        /**
         * A representation of the items that currently have journey children that are in edited state.
         */
        itemsWithChildEdits: KnockoutObservableArray<EditedItem<U>>;
    }
    /**
     * Interface that allows extension authors to provide named parameters to SelectableSet's constructor
     */
    interface SelectableSetOptions<T, U> {
        /**
         * A list of items.
         */
        items: KnockoutObservableArray<T>;
        /**
         * A function that determines if an item matches a selection.
         */
        itemMatchesSelection?: (item: T, selection: U) => boolean;
        /**
         * A factory function that creates a selection object based on an item.
         */
        createSelection?: (item: T) => U;
        /**
         * Initial state of the view model.
         */
        initialState?: SetSelection<U>;
        /**
         * Function that supplies commands for a given data item.
         */
        supplyCommands?: (dataItem: T) => MsPortalFx.ViewModels.Toolbars.ToolbarItemContract[];
        /**
         * When set SelectableSet will not deactivate an item when it's deselected.
         */
        keepDeselectedItemsActivated?: boolean;
        /**
         * When set SelectableSet will not deselect an item when it is deactivated.
         */
        leaveSelectionOnDeactivation?: boolean;
    }
    /**
     * A view model implementation that captures both a list of selectable items as well as a separate, sparse list of
     * representations of only the currently selected items and only the currently activated items.
     */
    class SelectableSet<T, U> implements SelectableItems<T>, SetSelection<U>, MsPortalFx.Base.Disposable {
        /**
         * See interface.
         */
        selectableItems: KnockoutObservableArray<SelectableItem<T>>;
        /**
         * See interface.
         */
        selectedItems: KnockoutObservableArray<U>;
        /**
         * See interface.
         */
        activatedItems: KnockoutObservableArray<U>;
        /**
         * See interface
         */
        itemsWithChildEdits: KnockoutObservableArray<EditedItem<U>>;
        /**
         * Allows right-click context menu commands to produce a selection, given an item.
         */
        createSelection: (item: T) => U;
        /**
         * Enables the data to be pinned in a context menu
         */
        itemsArePinnable: KnockoutObservable<boolean>;
        /**
         * The comparison function that determines how items and their corresponding selection value are related.
         */
        itemMatchesSelection: (item: T, selection: U) => boolean;
        /**
         * See interface.
         */
        getDefaultSelection: () => MsPortalFx.Base.PromiseV<U>;
        /**
         * Utility method used to located the data item given the provided selected item
         *
         * @param selectedItem item to search for
         * @param properties list if properties to compare using deepEquals.  If omitted then itemMatchesSelection is used.
         */
        _msPortalFxFindDataItem: (selectedItem: U, properties?: string[]) => T;
        _msPortalFxHasCreateSelection: boolean;
        _msPortalFxCursor: KnockoutObservableBase<FxImpl.ViewModels.SelectableCursor>;
        /**
         * This is the means by which this SelectableSet communicates a delayed Blade-opening to the Shell.  The Shell
         * proceeds to manage the opening of the delayed Blade and the eventual update to 'activatedItems'.
         */
        _msPortalFxDelayedBladeSelection: KnockoutObservable<MsPortalFx.ViewModels.Internal.DelayedBladeSelectionOptions<U>>;
        /**
         * Allows right-click context menu commands to produce a selection, given an item.
         */
        _msPortalFxCreateSelectionAsync: (item: T) => MsPortalFx.Base.PromiseV<U>;
        /**
         * Optional method to supply toolbar items to be displayed in the context menu
         */
        _msPortalFxSupplyCommands: (dataItem: T) => MsPortalFx.ViewModels.Toolbars.ToolbarItemContract[];
        /**
         * This member only exists to pin the current toolbar items so the PO layer doesn't release the proxies.
         */
        _msPortalFxCurrentCommands: KnockoutObservable<Toolbars.ToolbarItemContract[]>;
        /**
         * For now, only FX code can plug in an async 'createDelayedBladeSelection' callback that will be preferred over
         * the synchronous 'createSelection'.
         * NOTE: This private member is set by MsPortalFx.ViewModels.Internal.SelectableSet.setCreateDelayedBladeSelection.
         */
        private _createDelayedBladeSelection;
        private _lifetime;
        private _isDisposed;
        /**
         * Constructs an instance of this view model.
         * @param options A SelectableSetOptions options object with named properties to configure the SelectableSet.
         */
        constructor(options: SelectableSetOptions<T, U>);
        /**
         * Constructs an instance of this view model.
         * @param items A list of items.
         * @param itemMatchesSelection A function that determines if an item matches a selection.
         * @param createSelection A factory function that creates a selection object based on an item.
         * @param initialState Initial state of the view model.
         * @param supplyCommands Function that supplies commands for a given data item.
         * @param keepDeselectedItemsActivated When set SelectableSet will not deactivate an item when it's deselected.
         * @param leaveSelectionOnDeactivation When set SelectableSet will not deselect an item when it is deactivated.
         */
        constructor(items: KnockoutObservableArray<T>, itemMatchesSelection?: (item: T, selection: U) => boolean, createSelection?: (item: T) => U, initialState?: SetSelection<U>, supplyCommands?: (dataItem: T) => MsPortalFx.ViewModels.Toolbars.ToolbarItemContract[], keepDeselectedItemsActivated?: boolean, leaveSelectionOnDeactivation?: boolean);
        /**
         * Makes all items activated if and only if they are selected.
         */
        activateAllSelectedItems(): void;
        /**
         * See interface.
         */
        dispose(): void;
        private _setCreateDelayedBladeSelection(createDelayedBladeSelection);
    }
    /**
     * Options that can be supplied when instantiating Selectable<T>.
     */
    interface SelectableOptions<T> {
        /**
         * Determines whether the click target can be unselected by clicking.  Defaults to 'true'.
         */
        allowUnselect?: boolean;
        /**
         * The initial value of this view model's 'value' property when in its selected state.  Can be supplied
         * dynamically using part binding.
         */
        selectedValue?: T;
        /**
         * Determines whether the click target is initially in its selected state.  Defaults to 'false'.
         */
        isSelected?: boolean;
        /**
         * Determines whether the click target is initially in its command selected state.  Defaults to 'false'.
         */
        isCommandSelected?: boolean;
        /**
         * Determines whether the click target is initially in its activated state.  Defaults to 'false'.
         */
        isActivated?: boolean;
    }
    /**
     * Common interface that selectabe 1 and selectable 2 implementations share
     */
    interface SelectableContract<T> {
        isSelected: KnockoutObservableBase<boolean>;
        onClick: () => void;
        isCommandSelected?: KnockoutObservable<boolean>;
        isClickable(): boolean;
        value: KnockoutObservableBase<T>;
    }
    /**
     * A view model that represents a click target that is selectable.
     */
    class Selectable<T> implements MsPortalFx.Base.Disposable, SelectableContract<T> {
        /**
         * A property that will be set to the value of 'selectedValue' whenever the click target is
         * selected.  The property can be set to 'undefined' via part binding to unselect.
         */
        value: KnockoutObservableBase<T>;
        /**
         * The value to which 'value' will be set when the click target is selected.  The property can be set to
         * via part binding to dynamically change 'value' when the click target is selected.
         */
        selectedValue: KnockoutObservableBase<T>;
        /**
         * Reflects whether the click target can currently be clicked to unselect.
         */
        isClickable: KnockoutObservableBase<boolean>;
        /**
         * Reflects whether the click target is currently in a selected state.
         */
        isSelected: KnockoutObservable<boolean>;
        /**
         * Reflects whether the click target is currently in a command selected state.
         */
        isCommandSelected: KnockoutObservable<boolean>;
        /**
         * Reflects whether the click target is currently in an activated state.
         */
        isActivated: KnockoutObservable<boolean>;
        /**
         * Reflects whether the click target has journey children that are in an edited state.
         */
        hasChildEdits: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        getDefaultSelection: () => MsPortalFx.Base.PromiseV<T>;
        private _lifetime;
        /**
         * Construct an instance of the view model.
         * @param options Options to configure the instance.
         */
        constructor(options?: SelectableOptions<T>);
        /**
         * See interface.
         */
        dispose(): void;
        setIsSelected(initialState?: any, selectedByDefault?: boolean): void;
        /**
         * Called from a left-click event handler when the click target is clicked.
         */
        onClick(): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Services\Browse.d.ts
declare module MsPortalFx.ViewModels.Services.Browse {
    import FxServices = MsPortalFx.Services;
    /**
     * The browse criteria provides the information for browse as a data contract.
     */
    interface Criteria {
        /**
         * The asset type to browse.
         */
        assetType: string;
        /**
         * The asset owner of the asset type to browse (extension name).
         */
        assetOwner: string;
        /**
         * The optional cookie value for the browse service (opaque pass-through value).
         */
        cookie?: any;
        /**
         * The cloud name of the asset type to browse.
         */
        cloudName: string;
    }
    /**
     * The browse operation contract for a running browse.
     */
    interface Contract {
        /**
         * This will be set to true to signal the browse manager that the browse is initialized.
         */
        initialized: KnockoutObservable<boolean>;
        /**
         * The result set which will contain the results of the browse as they come in.
         */
        results: KnockoutObservableArray<any>;
        /**
         * This will be set to true to signal the browse operation that it should be canceled.
         */
        canceled: KnockoutObservable<boolean>;
    }
    /**
     * Represents the browse service base class.
     */
    class Service<T> implements Contract {
        /**
         * See interface.
         */
        initialized: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        results: KnockoutObservableArray<any>;
        /**
         * See interface.
         */
        canceled: KnockoutObservable<boolean>;
        private _dataSub;
        private _canceledSub;
        /**
         * Disposes any resources owned by this object.
         */
        dispose(): void;
        /**
         * Invoked when the inputs change.
         *
         * @param inputs The inputs object with all the input parameters.
         * @return A promise if there is async loading, else null.
         */
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
        /**
         * Connects the data source for the browse to the results.
         *
         * @param items The observable array representing the data source.
         * @param mapper The callback function to map the items in the data source to their asset details.
         */
        connectDataSource(items: KnockoutObservableArray<T>, mapper: (value: T) => FxServices.AssetDetails): void;
        private _releaseDataSub();
    }
    /**
     * The deserialized browse provides a wrapper for the criteria and use current browse flag.
     */
    interface DeserializedBrowse {
        /**
         * The browse criteria for the saved browse.
         */
        browseCriteria: Criteria;
        /**
         * The new browse flag for the saved browse.
         */
        newBrowse: boolean;
        /**
         * The browse key to use for the saved browse.  If this is null, no browse associated.
         */
        useBrowseKey: string;
    }
    /**
     * The browse serializer class is used to serialize a use current browse flag to a string.
     */
    class BrowseSerializer {
        /**
         * Serializes the use browse key to a string.
         *
         * @param browseCriteria The browse criteria for the saved browse.
         * @param newBrowse The optional new browse flag for the saved browse (default is false).
         * @param useBrowseKey The optional browse key to use for the saved browse (default is null).
         * @return The browse serialized as a string value.
         */
        static serialize(browseCriteria: Criteria, newBrowse?: boolean, useBrowseKey?: string): string;
        /**
         * Deserializes a saved browse to the use current browse flag.
         *
         * @param savedBrowse The browse that was serialized into a string.
         * @return An object that will contain the asset owner and type, the new browse flag and use browse key.
         */
        static deserialize(savedBrowse: string): DeserializedBrowse;
    }
    /**
     * The browse results view model provides the view model for the results of an initiated browse.
     */
    class ResultsViewModel {
        /**
         * The initialized flag signifies that the initial browse results are initialized.
         */
        initialized: KnockoutObservable<boolean>;
        /**
         * The results array contains all the results of the browse.
         */
        results: KnockoutObservableArray<any>;
        private _browseCriteria;
        /**
         * Creates an instance of the browse results view model.
         *
         * @param criteria The browse criteria for the browse.
         * @param results The initial collection for the results.
         */
        constructor(criteria: Criteria, results: any[]);
        /**
         * Gets the browse criteria of the browse.
         */
        browseCriteria: Criteria;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Services\Diagnostics.d.ts
declare module MsPortalFx.ViewModels.Services.Diagnostics {
    interface HubsDiagnosticsProvider {
        /**
         * Gets the cached permissions for the current logged in user.
         *
         * @return The promise for the permissions results.
         */
        getPermissions(): MsPortalFx.Base.PromiseV<any>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Services\DynamicBlade.d.ts
declare module MsPortalFx.ViewModels.Services.DynamicBlade {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * The dynamic blade usage values.
     */
    enum Usage {
        /**
         * The blade usage for a dynamic asset selection.
         */
        DynamicAssetSelection = 0,
    }
    /**
     * The dynamic blade contract for an asset.
     */
    interface Contract {
        /**
         * The extension name for the blade.
         */
        extensionName: KnockoutObservable<string>;
        /**
         * The blade name for the blade.
         */
        bladeName: KnockoutObservable<string>;
    }
    /**
     * Represents the dynamic blade service base class.
     */
    class Service implements Contract {
        /**
         * See interface.
         */
        extensionName: KnockoutObservable<string>;
        /**
         * See interface.
         */
        bladeName: KnockoutObservable<string>;
        /**
         * Initialize a new instance of the dynamic blade service.
         */
        constructor();
    }
    /**
     * Prepares a dynamic selection from a dynamic blade service, an asset ID and the extension and asset type names.
     *
     * @param dynamicBladeService The dynamic blade service to check for a blade override.
     * @param assetId The asset ID to use for the selection.
     * @param extensionName The name of the extension that owns the asset type.
     * @param assetTypeName The name of the asset type.
     * @return A promise to supply the dynamic selection.
     */
    function prepareDynamicSelection(dynamicBladeService: Service, assetId: any, extensionName: string, assetTypeName: string): FxBase.PromiseV<FxViewModels.DynamicSelection>;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Services\GridColumns.d.ts
declare module MsPortalFx.ViewModels.Services.GridColumns {
    import GridColumn = MsPortalFx.ViewModels.Controls.Lists.Grid.Column;
    /**
     * The global grid columns base columns.
     */
    class BaseColumns {
        /**
         * Gets the base columns for assets which do not provide columns or for multiple-asset type grids.
         */
        static base: GridColumn[];
    }
    /**
     * The grid columns usage values.
     */
    enum Usage {
        /**
         * The grid columns usage for browse.
         */
        Default = 0,
    }
    /**
     * A grid columns definition for an asset.
     */
    interface Contract {
        /**
         * Flag to include the asset icon in the first column.
         */
        includeAssetIcon: KnockoutObservableBase<boolean>;
        /**
         * The columns for the grid for the asset.
         */
        columns: KnockoutObservableBase<GridColumn[]>;
    }
    /**
     * Represents the grid columns service base class.
     */
    class Service implements Contract {
        /**
         * See interface.
         */
        includeAssetIcon: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        columns: KnockoutObservable<GridColumn[]>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Services\PropertyProvider.d.ts
declare module MsPortalFx.ViewModels.Services.PropertyProvider {
    /**
     * A property definition returned via the property provider.
     */
    interface PropertyDefinition {
        /**
         * The name of the property.
         */
        property: string;
        /**
         * The value of the property.
         */
        value: any;
    }
    /**
     * The property provider contract for providing properties.
     */
    interface Contract {
        /**
         * The result set which will contain the properties provided.
         */
        properties: KnockoutObservableArray<PropertyDefinition>;
    }
    /**
     * Represents the property provider service base class.
     */
    class Service implements Contract {
        /**
         * See interface.
         */
        properties: KnockoutObservableArray<PropertyDefinition>;
        /**
         * Initialize a new instance of the security service.
         */
        constructor();
        /**
         * Sets a property to the result property set.
         */
        setProperty(property: string, value: any): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Services\ResourceTypes.d.ts
declare module MsPortalFx.ViewModels.Services.ResourceTypes {
    import FxBase = MsPortalFx.Base;
    import FxPromiseV = FxBase.PromiseV;
    import CsmTopologyStatus = MsPortalFx.ViewModels.Controls.Visualization.CsmTopology.ResourceStatus;
    /**
     * The tagname prefix for a related association tag.
     */
    const relatedTagPrefix: string;
    /**
     * The tagname prefix for a link association tag.
     */
    const linkTagPrefix: string;
    /**
     * A resource type mapping for resource types.
     */
    interface MappingContract {
        /**
         * Maps a resource ID string to an asset ID value.
         *
         * @param resourceId The resource ID to map to an asset ID.
         * @return The promise for the asset ID.
         */
        mapResourceIdToAssetId(resourceId: string): FxPromiseV<any>;
        /**
         * Maps an asset ID value to a resource ID string.
         *
         * @param assetId The asset ID to map to a resource ID.
         * @return The promise for the resource ID.
         */
        mapAssetIdToResourceId(assetId: any): FxPromiseV<string>;
        /**
         * Signals that resources of the specified type have changed and cache for these resources should be updated.
         *
         * @return The promise that resolves when the operation has completed.
         */
        signalResourcesChanged?(): FxBase.Promise;
    }
    /**
     * The resource type mapping rejection reason enumeration provides named constants for rejection reason.
     */
    enum MappingRejectionReason {
        /**
         * Generic failure.
         */
        Failure = 0,
        /**
         * Data is not currently available.
         */
        DataNotAvailable = 1,
        /**
         * Access is denied.
         */
        AccessDenied = 2,
    }
    /**
     * The resource type mapping rejection interface provides the contract for rejections on the resource type mapping
     * view model.
     */
    interface MappingRejection {
        /**
         * The reason for the rejection.
         */
        reason: MappingRejectionReason;
        /**
         * The message for the rejection, this should be a localized string as it can appear in the UI.
         */
        message: string;
    }
    /**
     * The resource type contract for returning resource type information.
     */
    interface Contract {
        /**
         * The friendly-name of the resource.
         */
        name: KnockoutObservableBase<string>;
        /**
         * Optional description of the resource.
         */
        description?: KnockoutObservableBase<string>;
        /**
         * Optional description uri link.
         */
        descriptionUri?: KnockoutObservableBase<string>;
        /**
         * Current resource status.
         */
        status: KnockoutObservableBase<CsmTopologyStatus>;
        /**
         * Additional information about the current status.
         */
        statusMessage: KnockoutObservableBase<string>;
    }
    /**
     * The resource type service base class for returning resource type information.
     */
    class Service {
        /**
         * See interface.
         */
        name: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        description: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        descriptionUri: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        status: KnockoutObservableBase<CsmTopologyStatus>;
        /**
         * See interface.
         */
        statusMessage: KnockoutObservableBase<string>;
        /**
         * Initialize a new instance of the resource info service.
         */
        constructor();
    }
    /**
     * The subscription descriptor represents a subscription ID in part form.
     */
    class SubscriptionDescriptor {
        /**
         * The subscription ID for the resource group.
         */
        subscription: string;
    }
    /**
     * The resource group descriptor represents a resource group ID in part form.
     */
    class ResourceGroupDescriptor extends SubscriptionDescriptor {
        /**
         * The resource group name for the resource group.
         */
        resourceGroup: string;
    }
    /**
     * The resource descriptor represents a resource ID in part form.
     */
    class ResourceDescriptor extends ResourceGroupDescriptor {
        /**
         * The provider name for the resource.
         */
        provider: string;
        /**
         * The type for the resource (this is the most nested type).
         */
        type: string;
        /**
         * The resource name for the resource.
         */
        resource: string;
        /**
         * The collection of types for the resource (from left-to-right from the URI).
         * This will have more than one item for nested resources, one for each level of nesting.
         */
        types: string[];
        /**
         * The collection of resource names for the resource (from left-to-right from the URI).
         * This will have more than one item for nested resources, one for each level of nesting.
         */
        resources: string[];
        /**
         * The resource map maps a partial type to a resource name.
         * For the resource ID: /subscriptions/sub123/resourcegroups/rg123/providers/prov123/type1/resource1/type2/resource2/type3/resource3
         * the map includes:
         * "prov123/type1" => resource1
         * "prov123/type1/type2" => resource2
         * "prov123/type1/type2/type3" => resource3
         */
        resourceMap: StringMap<string>;
    }
    /**
     * The deployment descriptor represents a deployment ID in part form.
     */
    class DeploymentDescriptor extends ResourceGroupDescriptor {
        /**
         * The deployment name.
         */
        deploymentName: string;
    }
    /**
     * The tag descriptor represents a tag ID in part form.
     */
    class TagDescriptor extends SubscriptionDescriptor {
        /**
         * The tag name.
         */
        tagName: string;
        /**
         * The tag name.
         */
        tagValue: string;
    }
    /**
     * Parses a subscription ID into a subscription descriptor.
     *
     * @param id The subscription ID to parse.
     * @return The subscription descriptor object.
     */
    function parseSubscriptionDescriptor(id: string): SubscriptionDescriptor;
    /**
     * Parses a resource group ID into a resource group descriptor.
     *
     * @param id The resource group ID to parse.
     * @return The resource group descriptor object.
     */
    function parseResourceGroupDescriptor(id: string): ResourceGroupDescriptor;
    /**
     * Parses a resource ID into a resource descriptor.
     *
     * @param id The resource ID to parse.
     * @return The resource descriptor object.
     */
    function parseResourceDescriptor(id: string): ResourceDescriptor;
    /**
     * Parses a resource manager ID into a resource descriptor.
     *
     * @param id The resource manager ID to parse.
     * @return The resource descriptor object.
     */
    function parseResourceManagerDescriptor(id: string): ResourceDescriptor;
    /**
     * Parses a deployment ID into a deployment descriptor.
     *
     * Supports deployment ids of the forms:
     * /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.Resources/deployments/{deploymentName}
     * /subscriptions/{subId}/resourceGroups/{rgName}/deployments/{deploymentName}
     *
     * @param id The deployment ID to parse.
     * @return The deployment descriptor object.
     */
    function parseDeploymentDescriptor(id: string): DeploymentDescriptor;
    /**
     * Parses a tag ID into a tag descriptor.
     *
     * @param id The tag ID to parse.
     * @return The tag descriptor object.
     */
    function parseTagDescriptor(id: string): TagDescriptor;
    /**
     * Builds a deployment id from a subscription id, resource group name, and deployment name.
     *
     * @param subscriptionId The subscription id for the deployment.
     * @param resourceGroupName The resource group name for the deployment.
     * @param deploymentName The deployment name for the deployment.
     * @return The deployment id.
     */
    function buildDeploymentId(subscriptionId: string, resourceGroupName: string, deploymentName: string): string;
    /**
     * Builds a subscription ID from a subscription descriptor.
     *
     * @param subscriptionDescriptor The subscription descriptor.
     * @return The subscription ID.
     */
    function buildSubscriptionIdFromDescriptor(subscriptionDescriptor: SubscriptionDescriptor): string;
    /**
     * Builds a subscription ID from a resource group descriptor.
     *
     * @param resourceGroupDescriptor The resource group descriptor.
     * @return The subscription ID.
     */
    function buildSubscriptionIdFromResourceGroupDescriptor(resourceGroupDescriptor: ResourceGroupDescriptor): string;
    /**
     * Builds a subscription ID from a resource descriptor.
     *
     * @param resourceDescriptor The resource descriptor.
     * @return The subscription ID.
     */
    function buildSubscriptionIdFromResourceDescriptor(resourceDescriptor: ResourceDescriptor): string;
    /**
     * Builds a subscription ID from a resource group ID.
     *
     * @param resourceGroupId The resource group ID.
     * @return The subscription ID.
     */
    function buildSubscriptionIdFromResourceGroupId(resourceGroupId: string): string;
    /**
     * Builds a subscription ID from a resource ID.
     *
     * @param resourceId The resource ID.
     * @return The subscription ID.
     */
    function buildSubscriptionIdFromResourceId(resourceId: string): string;
    /**
     * Builds a subscription ID from it's subscription.
     *
     * @param subscription The subscription for the subscription.
     * @return The subscription ID.
     */
    function buildSubscriptionIdFromSubscriptionName(subscription: string): string;
    /**
     * Builds a resource group ID from a resource group descriptor.
     *
     * @param resourceGroupDescriptor The resource group descriptor.
     * @return The resource group ID.
     */
    function buildResourceGroupIdFromDescriptor(resourceGroupDescriptor: ResourceGroupDescriptor): string;
    /**
     * Builds a resource group ID from a resource descriptor.
     *
     * @param resourceDescriptor The resource descriptor.
     * @return The resource group ID.
     */
    function buildResourceGroupIdFromResourceDescriptor(resourceDescriptor: ResourceDescriptor): string;
    /**
     * Builds a resource group ID from a resource ID.
     *
     * @param resourceId The resource ID.
     * @return The resource group ID.
     */
    function buildResourceGroupIdFromResourceId(resourceId: string): string;
    /**
     * Builds a resource group ID from it's subscription and resource group name.
     *
     * @param subscription The subscription for the resource group.
     * @param resourceGroup The resource group for the resource group.
     * @return The resource group ID.
     */
    function buildResourceGroupIdFromSubscriptionAndResourceGroupName(subscription: string, resourceGroup: string): string;
    /**
     * Builds a subscription entity ID from the subscription ID.
     *
     * @param id The subscription ID.
     * @return The subscription entity ID.
     */
    let buildSubscriptionFromId: typeof buildSubscriptionIdFromSubscriptionName;
    /**
     * Builds a resource type from a resource ID.
     *
     * @param resourceId The resource ID.
     * @return The resource type.
     */
    function buildResourceTypeFromResourceId(resourceId: string): string;
    /**
     * Builds a resource type from a resource manager ID.
     *
     * @param resourceId The resource ID.
     * @return The resource type.
     */
    function buildResourceTypeFromResourceManagerId(resourceId: string): string;
    /**
     * Builds a resource type from a resource descriptor.
     *
     * @param resourceDescriptor The resource descriptor.
     * @return The resource type.
     */
    function buildResourceTypeFromResourceDescriptor(resourceDescriptor: ResourceDescriptor): string;
    /**
     * Builds a resource ID from a resource descriptor.
     *
     * @param resourceDescriptor The resource descriptor.
     * @return The resource ID.
     */
    function buildResourceIdFromDescriptor(resourceDescriptor: ResourceDescriptor): string;
    /**
     * Builds the topmost parent resource ID from a resource descriptor with nested types.
     * If the resource is not nested, this will return the resource id.
     *
     * @param resourceDescriptor The resource descriptor.
     * @return The topmost parent resource ID.
     */
    function buildTopmostParentResourceIdFromDescriptor(resourceDescriptor: ResourceDescriptor): string;
    /**
     * Builds a parent resource ID from a resource descriptor with nested types.
     * If the resource is not nested, this will throw an error.
     *
     * @param resourceDescriptor The resource descriptor.
     * @return The parent resource ID.
     */
    function buildParentResourceIdFromDescriptor(resourceDescriptor: ResourceDescriptor): string;
    /**
     * Determines if the given possible parent resource ID is a parent of the given possible child resource ID.
     *
     * @param parentResourceId The possible parent resource ID.
     * @param childResourceId The given possible child resource ID.
     * @return Boolean true if the parent resource ID was a parent of the child resource ID, else false.
     */
    function isParentResource(parentResourceId: string, childResourceId: string): boolean;
    /**
     * Builds a related tag name for the resource manager for the given resource ID.
     *
     * @param resourceId The fully qualified resource ID in the format '/subscriptions/{subID}/resourcegroups/{rgID}/providers/{provID}/{type1}/{name1}[/{typeN}/{nameN}].
     * @return The tag name string for the related association tag.
     */
    function buildRelatedTagName(resourceId: string): string;
    /**
     * Builds a link tag name for the resource manager for the given resource ID.
     *
     * @param resourceId The fully qualified resource ID in the format '/subscriptions/{subID}/resourcegroups/{rgID}/providers/{provID}/{type1}/{name1}[/{typeN}/{nameN}].
     * @return The tag name string for the link association tag.
     */
    function buildLinkTagName(resourceId: string): string;
    /**
     * Builds an association tag name for the resource manager for the given resource ID with the given prefix.
     *
     * @param tagPrefix The tag prefix for the association tag (should be 'Related' or 'Link').
     * @param resourceDescriptor The resource descriptor for the resource.
     * @return The tag name string for the link association tag.
     */
    function buildTagName(tagPrefix: string, resourceDescriptor: ResourceDescriptor): string;
    /**
     * Builds a lower-case copy of the given subscription ID using the resource manager rules of case sensitivity.
     * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
     * for indexing and comparisons.
     *
     * @param subscriptionId The subscription ID to create the lower-case copy from.
     * @return The lower-case copy of the subscription ID.
     */
    function buildLowerCaseSubscriptionId(subscriptionId: string): string;
    /**
     * Compares two subscription ID's for equality using the resource manager rules of case sensitivity.
     *
     * @param subscriptionId1 The first subscription ID to compare.
     * @param subscriptionId2 The second subscription ID to compare.
     * @return Boolean true if the subscription ID's are a match, else boolean false.
     */
    function compareSubscriptionId(subscriptionId1: string, subscriptionId2: string): boolean;
    /**
     * Builds a lower-case copy of the given resource group ID using the resource manager rules of case sensitivity.
     * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
     * for indexing and comparisons.
     *
     * @param resourceGroupId The resource group ID to create the lower-case copy from.
     * @return The lower-case copy of the resource group ID.
     */
    function buildLowerCaseResourceGroupId(resourceGroupId: string): string;
    /**
     * Compares two resource group ID's for equality using the resource manager rules of case sensitivity.
     *
     * @param resourceGroupId1 The first resource group ID to compare.
     * @param resourceGorupId2 The second resource group ID to compare.
     * @return Boolean true if the resource group ID's are a match, else boolean false.
     */
    function compareResourceGroupId(resourceGroupId1: string, resourceGroupId2: string): boolean;
    /**
     * Builds a lower-case copy of the given resource ID using the resource manager rules of case sensitivity.
     * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
     * for indexing and comparisons.
     *
     * @param resourceId The resource ID to create the lower-case copy from.
     * @return The lower-case copy of the resource ID.
     */
    function buildLowerCaseResourceId(resourceId: string): string;
    /**
     * Compares two resource ID's for equality using the resource manager rules of case sensitivity.
     *
     * @param resourceId1 The first resource ID to compare.
     * @param resourceId2 The second resource ID to compare.
     * @return Boolean true if the resource ID's are a match, else boolean false.
     */
    function compareResourceId(resourceId1: string, resourceId2: string): boolean;
    /**
     * Compares two resource manager ID's for equality using the resource manager rules of case sensitivity.
     *
     * @param id1 The first resource manager ID to compare.
     * @param id2 The second resource manager ID to compare.
     * @return Boolean true if the resource manager ID's are a match, else boolean false.
     */
    function compareResourceManagerId(id1: string, id2: string): boolean;
    /**
     * Builds a resource manager key from a resource manager ID.
     * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
     * for indexing and comparisons.
     *
     * @param id The resource manager ID.
     * @return The resource manager key for the ID if the ID was a valid resource manager ID, otherwise null.
     */
    function tryBuildResourceManagerKey(id: string): string;
    /**
     * Determines if the subscription contains the resource group.
     *
     * @param subscriptionId The subscription ID.
     * @param resourceGroupId The resource group ID.
     * @return Boolean true if the subscription contains the resource group, else boolean false.
     */
    function subscriptionContainsResourceGroup(subscriptionId: string, resourceGroupId: string): boolean;
    /**
     * Determines if the subscription contains the resource.
     *
     * @param subscriptionId The subscription ID.
     * @param resourceId The resource ID.
     * @return Boolean true if the subscription contains the resource, else boolean false.
     */
    function subscriptionContainsResource(subscriptionId: string, resourceId: string): boolean;
    /**
     * Determines if the resource group contains the resource.
     *
     * @param resourceGroupId The resource group ID.
     * @param resourceId The resource ID.
     * @return Boolean true if the resource group contains the resource, else boolean false.
     */
    function resourceGroupContainsResource(resourceGroupId: string, resourceId: string): boolean;
    /**
     * The resource part extender view model is an extender view model for the resource map and list parts.
     */
    interface ResourcePartExtenderViewModel {
        /**
         * The refresh key is used to signal the part that the cache for it's resource group or resource should be
         * invalidated. When the host changes this value, it signals the part to update.
         */
        refreshPacket: KnockoutObservableBase<ResourcePartRefreshPacketContract>;
    }
    /**
     * The resource part refresh packet is the base refresh packet contract.
     */
    interface ResourcePartRefreshPacketContract {
    }
    /**
     * The resource group refresh packet is the contract for refreshing a resource group part.
     * This is used for the resource group list part and the resource group map part.
     */
    interface ResourceGroupRefreshPacket extends ResourcePartRefreshPacketContract {
        /**
         * The ID of the resource group to refresh.
         */
        resourceGroupId: string;
    }
    /**
     * The resource refresh packet is the contract for refreshing a resource part.
     * This is used for the resource list part.
     */
    interface ResourceRefreshPacket extends ResourcePartRefreshPacketContract {
        /**
         * The ID of the resource.
         */
        resourceId: any;
    }
    /**
     * The asset refresh packet is the contract for refreshing a resource part.
     * This is used for the resource map part.
     */
    interface AssetRefreshPacket extends ResourcePartRefreshPacketContract {
        /**
         * The extension name of the extension that owns the asset.
         */
        assetOwner: string;
        /**
         * The asset type of the asset.
         */
        assetType: string;
        /**
         * The ID of the asset.
         */
        assetId: any;
    }
    /**
     * The resource part extender provides a base class implementation of the resource part extender view model.
     */
    class ResourcePartExtender implements ResourcePartExtenderViewModel {
        /**
         * See interface.
         */
        refreshPacket: KnockoutObservableBase<ResourcePartRefreshPacketContract>;
        /**
         * Initialize a new instance of the resource part extender class.
         */
        constructor();
        /**
         * Signals a resource group refresh for resource group list part and resource group map part.
         *
         * @param resourceGroupId The ID of the resource group.
         */
        signalResourceGroupRefresh(resourceGroupId: string): void;
        /**
         * Signals a resource refresh for resource list part.
         *
         * @param resourceId The ID of the resource.
         */
        signalResourceRefresh(resourceId: string): void;
        /**
         * Signals an asset refresh for resource map part.
         *
         * @param assetOwner The extension name of the extension that owns the asset.
         * @param assetType The asset type of the asset.
         * @param assetId The ID of the asset.
         */
        signalAssetRefresh(assetOwner: string, assetType: string, assetId: any): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Services\ResourceTypes.Utilities.d.ts
declare module MsPortalFx.ViewModels.Services.ResourceTypes {
    const regExpTenantResource: RegExp;
    const regExpSubscriptionId: RegExp;
    const regExpResourceGroupId: RegExp;
    const regExpResourceId: RegExp;
    const regExpResourceIdRelaxed: RegExp;
    const regExpDeploymentId: RegExp;
    const regExpDeploymentResourceId: RegExp;
    const regExpTagId: RegExp;
    /**
     * Determines if a given resource is a tenant level resource.
     *
     * @param resource The resource to check.
     * @return Boolean true if the resource is a tenant level resource, otherwise false.
     */
    function isTenantResource(resource: string): boolean;
    /**
     * Determines if a given ID is a subscription ID.
     * Eg: /subscriptions/sub123
     *
     * @param id The ID to check.
     * @return Boolean true if the ID is a resource group ID, otherwise false.
     */
    function isSubscriptionId(id: string): boolean;
    /**
     * Determines if a given ID is a resource group ID.
     * Eg: /subscriptions/sub123/resourcegroups/rg123
     *
     * @param id The ID to check.
     * @return Boolean true if the ID is a resource group ID, otherwise false.
     */
    function isResourceGroupId(id: string): boolean;
    /**
     * Determines if a given ID is a resource ID.
     * Eg: /subscriptions/sub123/resourcegroups/rg123/providers/pro123/type123/res123
     *     /subscriptions/sub123/resourcegroups/rg123/providers/pro123/type123/res123[/type456/res456[/type789/res789[...]]]
     *
     * @param id The ID to check.
     * @return Boolean true if the ID is a resource ID, otherwise false.
     */
    function isResourceId(id: string): boolean;
    /**
     * Determines if a given ID is a deployment ID.
     * Supports ids of the form:
     * /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.Resources/deployments/{deploymentName}
     * /subscriptions/{subId}/resourceGroups/{rgName}/deployments/{deploymentName}
     *
     * @param id The ID to check.
     * @return Boolean true if the ID is a deployment ID, otherwise false.
     */
    function isDeploymentId(id: string): boolean;
    /**
     * Determines if a given ID is a tag ID.
     *
     * @param id The ID to check.
     * @return Boolean true if the ID is a tag ID, otherwise false.
     */
    function isTagId(id: string): boolean;
    /**
     * Determines if a given ID is a resource manager ID. This includes resource IDs, resource group IDs,
     * subscription IDs, deployment IDs and tag IDs.
     *
     * @param id The ID to check.
     * @param supportsSecurity Optional boolean to indicate to only check for resource manager IDs which
     *                         support security (RBAC), default is false.
     * @return Boolean true if the ID is a resource manager ID, otherwise false.
     */
    function isResourceManagerId(id: string, supportsSecurity?: boolean): boolean;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\Services\Security.d.ts
declare module MsPortalFx.ViewModels.Services.Security {
    /**
     * The security provider contract for a running security check.
     */
    interface Contract {
        /**
         * The result set which will contain the actions available to the asset.
         */
        actions: KnockoutObservableArray<string>;
    }
    /**
     * Represents the security service base class.
     */
    class Service implements Contract {
        /**
         * See interface.
         */
        actions: KnockoutObservableArray<string>;
        /**
         * Initialize a new instance of the security service.
         */
        constructor();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.AppBlade.d.ts
declare module MsPortalFx.ViewModels.AppBlade {
    import ViewModels = MsPortalFx.ViewModels;
    import FxContainerContract = ViewModels.ContainerContract;
    /**
     * The options of the app blade.
     */
    interface Options {
        source: string;
    }
    type MessageHandler = (data: any) => void;
    /**
     * The message envelope.
     */
    class Message {
        /**
         * The message signature.
         */
        signature: string;
        /**
         * The message kind.
         */
        kind: string;
        /**
         * The message data.
         */
        data: any;
        constructor(kind: string, data?: any);
    }
    /**
     * The view model of the app blade.
     */
    class ViewModel extends ViewModels.Blade {
        private iFrame;
        private _handlers;
        private _queue;
        constructor(container: FxContainerContract, options: Options);
        postMessage(message: Message): void;
        on(kind: string, callback: MessageHandler): void;
        off(kind: string, callback: MessageHandler): void;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.Blade.d.ts
declare module MsPortalFx.ViewModels {
    import FxViewModels = MsPortalFx.ViewModels;
    import FxBase = MsPortalFx.Base;
    /**
     * The status bar of the blade.
     */
    interface BladeStatusBar {
        /**
         * The text to display in the blade's status bar.
         */
        text: string;
        /**
         * The state of the blade.
         */
        state: FxViewModels.ContentState;
        /**
         * The blade selection that blade's status bar can activate.
         */
        selection?: FxViewModels.DynamicSelectionImpl;
        /**
         * The callback executed whenever the status bar is activated.
         */
        onActivated?: () => void;
    }
    /**
     * A view model for a Blade.
     */
    interface BladeContract {
        /**
         * The displayed title of the blade.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The displayed subtitle of the blade.
         */
        subtitle?: KnockoutObservableBase<string>;
        /**
         * The displayed description of the blade.
         */
        description?: KnockoutObservableBase<string>;
        /**
         * The help uri of the blade.
         */
        helpUri?: KnockoutObservableBase<string>;
        /**
         * The SVG of the icon to display for the given blade.
         */
        icon: KnockoutObservableBase<FxBase.Image>;
        /**
         * The URI of the image in the title of the blade.
         */
        titleImageUri?: KnockoutObservableBase<string>;
        /**
         * The status bar of the blade.
         * Once initialized, it will take precedence over contentState and contentStateDisplayText.
         */
        statusBar?: KnockoutObservableBase<BladeStatusBar>;
        /**
         * The content state of the blade.
         */
        contentState?: KnockoutObservableBase<FxViewModels.ContentState>;
        /**
         * The text to display in the blade's status bar.
         */
        contentStateDisplayText?: KnockoutObservableBase<string>;
    }
    /**
     * Defines an entity that contains a title and subtitle.
     */
    interface ItemWithTitleAndSubtitle {
        /**
         * The displayed title of the blade.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The displayed subtitle of the blade.
         */
        subtitle: KnockoutObservableBase<string>;
    }
    /**
     * Defines attributes used to configure a blade hosted within a menu blade.
     */
    interface HostedInMenuBlade {
        /**
         * Defines attributes to use when the blade is displayed as the content of a menu blade.
         */
        menuContent: ItemWithTitleAndSubtitle;
    }
    /**
     * A view model class that respresents a Blade.
     */
    class Blade implements BladeContract, ItemWithTitleAndSubtitle {
        /**
         * The displayed title of the blade.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The displayed subtitle of the blade.
         */
        subtitle: KnockoutObservableBase<string>;
        /**
         * The displayed description of the blade.
         */
        description: KnockoutObservableBase<string>;
        /**
         * The help uri of the blade.
         */
        helpUri: KnockoutObservable<string>;
        /**
         * The SVG of the image in the title of the blade.
         */
        icon: KnockoutObservableBase<FxBase.Image>;
        /**
         * The URI of the image in the title of the blade.
         */
        titleImageUri: KnockoutObservableBase<string>;
        /**
         * The status bar of the blade. The default value is null.
         * Once initialized, it will take precedence over contentState and contentStateDisplayText.
         */
        statusBar: KnockoutObservableBase<BladeStatusBar>;
        /**
         * The content state of the blade.
         */
        contentState: KnockoutObservableBase<FxViewModels.ContentState>;
        /**
         * The text to display in the blade's status bar.
         */
        contentStateDisplayText: KnockoutObservableBase<string>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.BladeCaller.d.ts
declare module MsPortalFx.ViewModels.Internal {
    /**
     * Describes options for constructing a BladeCaller.
     */
    interface BladeCallerOptions<TParams, TResult, TSelectable> {
        /**
         * A selectable that, when selected, causes the child blade to be invoked.
         *
         * This option is mutually exclusive with 'invokeOnSelectableSet'.
         */
        invokeOnSelectable?: MsPortalFx.ViewModels.SelectableContract<TSelectable>;
        /**
         * A selectable set that, when selected, causes the child blade to be invoked.
         *
         * This option is mutually exclusive with 'invokeOnSelectable'.
         */
        invokeOnSelectableSet?: MsPortalFx.ViewModels.SelectableSet<TSelectable, any>;
        /**
         * A callback that supplies parameters for a child blade that is being opened.
         *
         * @param activatedItem The object that has been activated, causing this blade call to begin.
         * @return The parameters to supply.
         */
        supplyParams(activatedItem: TSelectable): TParams;
        /**
         * A callback that receives result values from the called child blade.
         *
         * @param result The result value sent from the child blade.
         * @param activatedItem The object that was activated when the blade call began. The result refers to that object.
         */
        receiveResult(result: TResult, activatedItem: TSelectable): void;
        /**
         * If true the blade is always invoked regardless of the selectable state.
         * This is for internal shell use.
         */
        forceInvocation?: boolean;
    }
    /**
     * Describes options for constructing a BladeCallable.
     */
    interface BladeCallableOptions<TParams, TResult> {
        /**
         * A callback that receives parameter values from the parent blade.
         *
         * @param params The parameter values received from the parent blade.
         */
        receiveParams(params: TParams): void;
    }
    /**
     * Determines if the given Part/Blade/Command input is one injected by the FX BladeCaller component.
     *
     * @param inputName The name of the input.
     * @return A boolean reflecting whether this input is an injected BladeCaller input.
     */
    function isBladeCallerInput(propertyName: string): boolean;
    /**
     * A viewmodel that can call a child blade, i.e., supply parameters to it and
     * receive result values.
     */
    class BladeCaller<TParams, TResult, TSelectable> {
        private _options;
        private _invokeOnSelectable;
        private _invokeOnSelectableSet;
        private _currentBladeCallId;
        private _activatedItemForCurrentBladeCall;
        private _hasInitialized;
        private internal_bladeCallId;
        private internal_bladeCallerParams;
        /**
         * Constructs an instance of BladeCaller.
         *
         * @param container The container instance associated with the part or other composition element hosting this BladeCaller.
         * @param options Options for the instance.
         */
        constructor(container: MsPortalFx.ViewModels.InputsCallbacksRegistrar, options: BladeCallerOptions<TParams, TResult, TSelectable>);
        private _initialize(lifetime, forceInvocation);
        private _beginNewBladeCall(sendNewBladeCallerParams);
        private _isCurrentlyActivated();
        private _getCurrentlyActivatedValue();
        private _subscribeToActivationStateChange(lifetime, callback);
        private _clearActivation();
    }
    /**
     * A viewmodel that can be called by a parent part or other composition item. It
     * can receive parameters from the parent, and send back results to it.
     */
    class BladeCallable<TParams, TResult> {
        private _options;
        private _bladeCallId;
        private _lastReceivedParamsStringHash;
        private internal_bladeCallerResult;
        /**
         * Constructs an instance of BladeCallable.
         *
         * @param container The container instance associated with the part or other composition element hosting this BladeCallable.
         * @param options Options for the instance.
         */
        constructor(container: MsPortalFx.ViewModels.ContainerContract, options: BladeCallableOptions<TParams, TResult>);
        /**
         * Sends a result value back to the associated BladeCaller.
         *
         * @param result The result to send.
         */
        sendResult(result: TResult): void;
        /**
         * Returns a string value that can be compared with other returned values to
         * determine whether two 'params' values are deeply equal.
         *
         * @param params Any object/null/undefined.
         * @return A string that, if equal to another string returned from this function, implies deep equality of the supplied objects.
         */
        private _makeStringHashFromParams(params);
    }
    /**
     * Represents binding inputs that a blade callback expects to receive from its caller.
     */
    interface BladeCallableInputs<TParams> {
        /**
         * The unique ID representing the blade call. This is used to ensure that, later,
         * the child blade's output is directed to the correct BladeCaller, and that the
         * BladeCaller doesn't accept more than one result per call.
         */
        internal_bladeCallId: number;
        /**
         * Parameters sent from the BladeCaller to its child blade.
         */
        internal_bladeCallerParams: TParams;
    }
    /**
     * A message sent from a child blade to its parent BladeCaller.
     */
    interface BladeCallableResultMessage<TResult> {
        /**
         * The unique ID representing the blade call. This is used to ensure that, later,
         * the child blade's output is directed to the correct BladeCaller, and that the
         * BladeCaller doesn't accept more than one result per call.
         */
        bladeCallId: number;
        /**
         * The result value sent from the child blade to its parent BladeCaller.
         */
        result: TResult;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.Command.d.ts
declare module MsPortalFx.ViewModels {
    import FxBase = MsPortalFx.Base;
    import FxNet = FxBase.Net2;
    import FxImage = FxBase.Image;
    /**
     * Command execution status.
     */
    enum CommandStatus {
        /**
         * Command is not executing or displaying a message.
         */
        None = 0,
        /**
         * Command is in the process of executing. Command may display dialogs
         * in the blade while in an executing state.
         */
        Executing = 1,
    }
    enum FileDownloadType {
        /**
         * Download file is a text file
         */
        Text = 1,
        /**
         * Download file is a binary file
         */
        Binary = 2,
    }
    interface UriCallbackConfirmationDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        uriCallbackProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        uriCallbackProgressText?: string;
        /**
         * MessageBox title string to indicate if file should be downloaded or canceled.
         */
        downloadTitle?: string;
        /**
         * MessageBox description string to indicate if file should be downloaded or canceled.
         */
        downloadText?: string;
        /**
         * MessageBox default button text.
         */
        defaultButtonText: string;
        /**
         * MessageBox cancel button text.
         */
        cancelButtonText: string;
    }
    interface DownloadProgressDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        downloadProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        downloadProgressText?: string;
    }
    /**
     * Error notification messages for uri callback errors.
     * When uri callback error fails, reject the promise and provide the needed error messages and it will be shown in the hubs notification.
     */
    interface UriCallbackErrorMessage {
        /**
         * Optionally specify the title text for error notification message.
         */
        title?: string;
        /**
         * Optionally specify the description text for error notification message.
         */
        description?: string;
    }
    /**
     * View model
     */
    interface CommandBaseContract {
        /**
         * Whether the command is enabled.
         */
        enabled: KnockoutObservableBase<boolean>;
        /**
         * Icon object for the command.
         */
        icon?: KnockoutObservableBase<FxBase.Image>;
        /**
         * Text for the command.
         */
        text?: KnockoutObservableBase<string>;
    }
    /**
     * A view model for the command container.
     */
    interface CommandContainerContract extends MsPortalFx.ViewModels.ContainerContract {
        /**
         * View model reflecting the selection state of the Command. The value is null if the command is not selectable.
         */
        selectable?: Selectable<any>;
    }
    /**
     * A view model that respresents an executable command.
     */
    interface CommandContract extends CommandBaseContract {
        /**
         * Status of the command execution.
         */
        status: KnockoutObservableBase<CommandStatus>;
        /**
         * Function called when command is executed.
         * @param formValid Contains the validation status of form elements contained within the command's blade or part.
         */
        execute(formValid?: boolean): void;
        /**
         * Dialog box shown to user. Will be cleared if the message box is dismissed without
         * a button being clicked. If a message box button is clicked messageBoxClick() function
         * will be called.
         */
        dialog?: KnockoutObservableBase<Dialogs.Dialog>;
        /**
         * Function called when a message box button is clicked.
         *
         * @param result Contains the result of the user interaction with the dialog.
         */
        dialogClick?(result: Dialogs.DialogResult): void;
    }
    /**
     * Interface for a command that launches a URI.
     */
    interface UriCommandContract extends CommandBaseContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget?: KnockoutObservableBase<string>;
    }
    /**
     * Interface for a command that launches a URI.
     */
    interface UriCallbackCommandContract extends CommandBaseContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional callback to dynamically generate navigate uri when the command is clicked.
         * If this callback is provided, navigateUri will not be used.
         */
        navigateUriCallback?: KnockoutObservableBase<() => FxBase.PromiseV<string>>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget?: KnockoutObservableBase<string>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions?: UriCallbackConfirmationDialogOptions;
    }
    /**
     * Interface for a command that opens a dropdown menu of items.
     */
    interface ListCommandContract extends CommandBaseContract {
        /**
         * Items that will be displayed when the ListCommand is open.
         */
        listItems: KnockoutObservableArray<string>;
        /**
         * Text of the selected item. We use the text as the key.
         */
        selectedItem: KnockoutObservable<string>;
    }
    /**
     * Interface for a command that defines its type and behavior dynamically.
     */
    interface DynamicCommandContract extends CommandBaseContract {
        /**
         * The view model of the nested command.
         */
        viewModel: KnockoutObservableBase<CommandBaseContract>;
    }
    /**
     * Interface for a command that launches a file download specified by the URI.
     */
    interface FileDownloadCommandContract extends CommandBaseContract {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * A callback to set the targetUri of the file download dynamically if the target URI is not known when
         * the command is clicked. This can be used if the target URI needs to be generated only when the user initiates a
         * click on the file download command. If this is set, then the targetUri property is not used.
         */
        targetUriCallback?: KnockoutObservableBase<() => FxBase.PromiseV<string>>;
        /**
         * Optionally specify GET or POST type for the http request. Default is GET.
         */
        httpMethod?: KnockoutObservableBase<string>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType?: KnockoutObservableBase<string>;
        /**
         * Specify set of http headers to be included in the request.
         */
        headers?: KnockoutObservableBase<StringMap<any>>;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType?: KnockoutObservableBase<FileDownloadType>;
        /**
         * File download status with standard http response codes will be updated based on the file download ajax call response.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         */
        downloadStatus: KnockoutObservableBase<FileDownloadStatus>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions?: UriCallbackConfirmationDialogOptions;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions?: DownloadProgressDialogOptions;
    }
    /**
     * Interface for a command that opens a blade.
     */
    interface OpenBladeCommandContract extends CommandBaseContract {
    }
    /**
     * Abstract base class for Commands and UriCommands.
     */
    class CommandBase implements CommandBaseContract {
        /**
         * Whether the command is enabled.
         */
        enabled: KnockoutObservableBase<boolean>;
        /**
         * Icon object for the command.
         */
        icon: KnockoutObservableBase<FxImage>;
        /**
         * Text for the command.
         */
        text: KnockoutObservableBase<string>;
    }
    /**
     * Base class for executable commands.
     */
    class Command extends CommandBase implements CommandContract {
        /**
         * Status of the command execution.
         */
        status: KnockoutObservableBase<MsPortalFx.ViewModels.CommandStatus>;
        /**
         * Function called when command is executed.
         * @param formValid Contains the validation status of form elements contained within the command's blade or part.
         */
        execute(formValid?: boolean): void;
        /**
         * Dialog box shown to user. Will be cleared if the message box is dismissed without
         * a button being clicked. If a message box button is clicked messageBoxClick() function
         * will be called.
         */
        dialog: KnockoutObservableBase<Dialogs.Dialog>;
        /**
         * Function called when a message box button is clicked.
         *
         * @param result Contains the result of the user interaction with the dialog.
         */
        dialogClick(result: Dialogs.DialogResult): void;
    }
    /**
     * Base class for commands which launch URIs.
     */
    class UriCommand extends CommandBase implements UriCommandContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget: KnockoutObservableBase<string>;
    }
    /**
     * Base class for commands which launch URIs.
     */
    class UriCallbackCommand extends CommandBase implements UriCallbackCommandContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional callback to dynamically generate navigate uri when the command is clicked.
         * If this callback is provided, navigateUri will not be used.
         */
        navigateUriCallback: KnockoutObservableBase<() => FxBase.PromiseV<string>>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget: KnockoutObservableBase<string>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog: KnockoutObservableBase<boolean>;
    }
    /**
     * Base class for a command that opens a dropdown menu of items.
     */
    class ListCommand extends CommandBase implements ListCommandContract {
        /**
         * See interface.
         */
        listItems: KnockoutObservableArray<string>;
        /**
         * See interface.
         */
        selectedItem: KnockoutObservable<string>;
    }
    /**
     * Base class for a command that defines its type and behavior dynamically.
     */
    class DynamicCommand extends CommandBase implements DynamicCommandContract {
        /**
         * See interface.
         */
        viewModel: KnockoutObservableBase<CommandBaseContract>;
    }
    /**
     * File download status with http response codes.
     */
    class FileDownloadStatus {
        /**
         * Indicates the file download status category.
         * Status string will have the AJAX response status ("success", "notmodified", "error", "timeout", "abort", or "parsererror").
         */
        status: string;
        /**
         * Indicates the file download status code which are standard http response code.
         */
        statusCode: number;
        /**
         * Indicates the error message returned by the AJAX call.
         */
        errorMessage: string;
        constructor(status: string, statusCode: number, errorMessage?: string);
    }
    /**
     * Options for command that launches a file download specified by the URI.
     */
    interface FileDownloadCommandOptions {
        authorizationOptions?: FxNet.AuthorizationOptions;
    }
    /**
     * Command class for launching a file download specified by the URI.
     */
    class FileDownloadCommand extends CommandBase implements FileDownloadCommandContract {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * Optionally specify a callback to set the targetUri of the file download dynamically if the target URI is not known when
         * the command is clicked. This can be used if the target URI needs to be generated only when the user initiates a
         * click on the file download command. If this is defined, then the targetUri property is not used.
         */
        targetUriCallback: KnockoutObservableBase<() => FxBase.PromiseV<string>>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod: KnockoutObservableBase<string>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent: KnockoutObservable<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType: KnockoutObservable<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName: KnockoutObservableBase<string>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType: KnockoutObservableBase<FileDownloadType>;
        /**
         * File download status with standard http response codes will be updated based on the file download ajax call response.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         */
        downloadStatus: KnockoutObservableBase<FileDownloadStatus>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions: UriCallbackConfirmationDialogOptions;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions: DownloadProgressDialogOptions;
        /**
         * FileDownload command constructor.
         *
         * @param container Boolean flag or authorization options to indicate if authorization token needs to be feteched and updated in authorizationToken.
         */
        constructor(addDefaultAuthorizationToken?: FileDownloadCommandOptions | boolean);
    }
    /**
     * Base class for commands that launches detail blades.
     */
    class OpenBladeCommand extends CommandBase implements OpenBladeCommandContract {
        /**
         * Initializes a new instance of a command that can launch new blades.
         *
         * @param container The view model for the UI representation of the command.
         */
        constructor(container: CommandContainerContract);
        /**
         * Creates a Selectable view model optionally initialized with a selectable value.
         *
         * @param selectedValue Optional, initial value for the 'selectedValue' property of the Selectable.
         * @return A Selectable view model instance.
         */
        static createSelectableViewModel(selectedValue?: any): Selectable<any>;
    }
    module Commands.Dynamic {
        import FxViewModels = MsPortalFx.ViewModels;
        /**
         * Interface for a command that opens a blade and is instantiated by a dynamic command.
         */
        interface OpenBladeCommandContract extends FxViewModels.OpenBladeCommandContract {
            /**
             * Defines a blade name.
             */
            bladeName: string;
            /**
             * Defines blade inputs.
             */
            bladeInputs: Object;
        }
        /**
         * Base class for commands that launches detail blades and is instantiated dynamically.
         */
        class OpenBladeCommand extends FxViewModels.OpenBladeCommand implements OpenBladeCommandContract {
            /**
             * See interface.
             */
            bladeName: string;
            /**
             * See interface.
             */
            bladeInputs: Object;
            /**
             * Initializes a new instance of a command that can launch new blades.
             *
             * @param container The view model for the UI representation of the command.
             */
            constructor(container: CommandContainerContract);
        }
        /**
         * Command class for launching a file download specified by the URI that is instantiated dynamically.
         */
        class FileDownloadCommand extends FxViewModels.FileDownloadCommand {
            constructor();
        }
        /**
         * Base class for executable dynamic commands.
         */
        class ExecutableCommand extends FxViewModels.Command {
            constructor();
        }
        /**
         * Base class for commands which launch URIs dynamically.
         */
        class UriCallbackCommand extends FxViewModels.UriCallbackCommand {
            constructor();
        }
        /**
         * Base class for commands which launch URIs dynamically.
         */
        class UriCommand extends FxViewModels.UriCommand {
            constructor();
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.Container.d.ts
declare module MsPortalFx.ViewModels {
    import FxControlsNotice = MsPortalFx.ViewModels.Controls.Notice;
    import FxBase = MsPortalFx.Base;
    import FxCompositionSelectable = FxImpl.Composition.Selectable;
    /**
     * A callback that will be invoked when new inputs are available for the composition item.
     */
    interface OnInputsSetCallback {
        (inputs: any, settings?: any): MsPortalFx.Base.Promise;
    }
    /**
     * A registry of callbacks that will be invoked when new inputs are available for the composition item.
     */
    interface OnInputsSetCallbacks extends MsPortalFx.Base.Disposable {
        /**
         * Adds a callback to be invoked whenever new inputs are available.
         *
         * @param callback The callback to be invoked whenever new inputs are available.
         * @param invokeIfPreviousInputsPassed  If true and the callback is added after onInputsSet was invoked, then the callback is invoked immediately
         */
        add(callback: OnInputsSetCallback, invokeIfPreviousInputsPassed?: boolean): void;
        /**
         * Removes a callback from the registry, so it will no longer be invoked when new inputs are available.
         *
         * @param callback The callback to be removed.
         */
        remove(callback: OnInputsSetCallback): void;
        /**
         * Invokes any registered onInputsSet callbacks, returning a promise representing the
         * asynchronous completion of all the callbacks.
         *
         * @param inputs Inputs to supply to the callbacks.
         * @param settings Settings values to supply to the callbacks.
         * @return If any callbacks are registered and return a promise, returns a promise that represents their aggregate completion. Otherwise, returns null.
         */
        triggerCallbacks(inputs: any, settings: any): MsPortalFx.Base.Promise;
    }
    /**
     * The options for the notice blade.
     */
    interface NoticeOptions {
        /**
         * The header of the notice.
         */
        noticeHeader?: string;
        /**
         * The title of the notice.
         */
        noticeTitle?: string;
        /**
         * The description of the notice.
         */
        noticeDescription?: string;
        /**
         * The call to action text of the notice.
         */
        noticeCallToActionText?: string;
        /**
         * The call to action uri of the notice.
         */
        noticeCallToActionUri?: string;
        /**
         * The image type of the notice.
         */
        noticeImageType?: FxControlsNotice.ImageType;
    }
    interface InputsCallbacksRegistrar extends FxBase.DisposableLifetimeManager {
        /**
         * A registry of callbacks that will be invoked when new inputs are available for the composition item.
         */
        onInputsSetCallbacks: OnInputsSetCallbacks;
    }
    /**
     * Methods that can be used for managing a locked blade
     */
    interface LockedBladeManagement {
        /**
         * Closes this blade
         *
         * @param data Optional value to return back to the parent blade
         * @return a promise that resolves to true if the this blade is successfully closed.
         */
        closeCurrentBlade(data?: any): Q.Promise<boolean>;
    }
    interface OpenBladeOptions {
        asSubJourney?: boolean;
    }
    interface BladeManagement {
        /**
         * Opens a child Blade.
         *
         * @param bladeReference A BladeReference describing the Blade to be opened.
         */
        openBlade(bladeReference: FxCompositionSelectable.BladeReference<any>, options?: OpenBladeOptions): Q.Promise<boolean>;
        /**
         * Opens a child Blade asynchronously.  While the Blade to be shown is being determined (via 'bladeReferencePromise') a loading
         * indicator will be displayed on the new child Blade.
         *
         * @param bladeReferencePromise A Promise that will be resolved with a BladeReference describing the Blade to be opened.
         */
        openBladeAsync(bladeReferencePromise: Q.Promise<FxCompositionSelectable.BladeReference<any>>, options?: OpenBladeOptions): Q.Promise<boolean>;
        /**
         * Opens a child Blade in the Context Pane.
         *
         * @param bladeReference A BladeReference describing the Blade to be opened.
         * @param options Options used to open the child Blade.
         */
        openContextPane(bladeReference: FxCompositionSelectable.BladeReference<any>): Q.Promise<boolean>;
        /**
         * Opens a child Blade asynchronously in the Context Pane.  While the Blade to be shown is being determined (via
         * 'bladeReferencePromise') a loading indicator will be displayed in the Context Pane.
         *
         * @param bladeReferencePromise A Promise that will be resolved with a BladeReference describing the Blade to be opened.
         * @param options Options used to open the child Blade.
         */
        openContextPaneAsync(bladeReferencePromise: Q.Promise<FxCompositionSelectable.BladeReference<any>>): Q.Promise<boolean>;
    }
    /**
     * All view models have a associated container view model.   The container view model
     * exists to drive the chrome.   This is the base interface that all container view models
     * share.
     */
    interface ContainerContract extends InputsCallbacksRegistrar, MsPortalFx.Data.ErrorNotificationTarget {
        /**
         * The message provided to the container when not found.
         */
        notFoundMessage: KnockoutObservable<string>;
        /**
         * The message provided to the container when unauthorized.
         */
        unauthorizedMessage: KnockoutObservable<string>;
        /**
         * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
         *
         * @param message An optional custom error message.
         */
        notFound(message?: string): void;
        /**
         * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
         *
         * @param message A custom error message in place of the default.
         */
        unauthorized(message?: string): void;
        /**
         * A registry of callbacks that will be invoked when new inputs are available for the composition item.
         */
        onInputsSetCallbacks: OnInputsSetCallbacks;
        /**
         * Renders noitce as content.
         */
        enableNotice(notice: NoticeOptions): void;
    }
    /**
     * A view model for the content displayed in a portal entity (such as Blade, Part, ActionBar, Command).
     */
    interface InputsContract {
        /**
         * Invoked by the Shell when the entity's inputs change to a new,
         * complete set of values. The view model should handle this by
         * loading whatever data corresponds to the input properties.
         *
         * @param inputs The entity's current set of input property values as a name/value collection.
         * @return A promise representing a data access operation that has been initiated, or null.
         */
        onInputsSet(inputs: any): MsPortalFx.Base.Promise;
    }
    /**
     * View models which function as a selectable source implement this interface
     */
    interface SelectableSource {
        selectable: MsPortalFx.ViewModels.Selectable<any>;
    }
    module Internal {
        /**
         * ClickContext and the BladeManagement API are the same at this time
         * This may change in the future.
         */
        type ClickContext = BladeManagement;
        /**
         * See interface.
         */
        function createOnInputsSetCallbacks(): OnInputsSetCallbacks;
        /**
         * Generic container implementation.
         */
        class ContainerViewModel implements MsPortalFx.ViewModels.ContainerContract {
            private _lifetime;
            private _id;
            private _msPortalFxNotice;
            /**
             * Debug only helper fuction to check all ContainerVeiewModels been disposed correctly.
             */
            static VerifyAllContainerViewModelDisposed(): void;
            /**
             * See interface.
             */
            onInputsSetCallbacks: OnInputsSetCallbacks;
            /**
             * See interface.
             */
            notFoundMessage: KnockoutObservable<string>;
            /**
             * See interface.
             */
            unauthorizedMessage: KnockoutObservable<string>;
            /**
             * See interface.
             */
            registerForDispose: FxBase.RegisterForDisposeFunction;
            /**
             * See interface.
             */
            isDisposed(): boolean;
            /**
             * See interface.
             */
            createChildLifetime(): FxBase.DisposableLifetimeManager;
            /**
             * See interface.
             */
            dispose(): void;
            /**
             * See interface.
             */
            unauthorized(message?: string): void;
            /**
             * See interface.
             */
            notFound(message?: string): void;
            /**
             * See interface.
             */
            enableNotice(notice: NoticeOptions): void;
            constructor();
        }
        /**
         * Various flags used to configure the SDK features exposed to the view model
         */
        const enum ViewModelFlags {
            /**
             * The view model is inside a context pane
             */
            InContextPane = 1,
            /**
             * The view model is inside a locked blade
             */
            InLockedBlade = 2,
        }
        /**
         * Options that are used to configure the selectable container.
         */
        interface SelectableContainerOptions {
            /**
             * initial state from journey rehydration.
             */
            initialState?: any;
            /**
             * An instance of MsPortalFx.ViewModels.Selectable which controls whether this Part can be selected.
             */
            selectable?: MsPortalFx.ViewModels.Selectable<any>;
            /**
             * Various view model flags used to configure the SDK options
             */
            flags?: ViewModelFlags;
        }
        /**
         * creates a click context for the openBlade APIs.   The click context is used for ensure lightpath works correctly.
         * For example if the openBlade API is invoked inside a onRowClick callback then click context will will contain sufficent
         * state to ensure the appropriate row is highlighted when the blade is opened.
         *
         * @lifetime The lifetime of the click context.   The click context has a subscription to listen for blade opening to be completed.
         * @reason The reason click context was created.
         * @openBladeShellInterface The interface that click context requests opening a blade and listens for the open blade request to be completed.
         * @containerInContextPane True if this view model exists inside a context pane.
         * @options Addtional options provided from the caller used to influence how the blade is opened.
         * @selectedItem For list controls such as the grid.   This optional parameter is a reference to the selected item.
         * @controlMetadata for list controls such as the grid.   This optional parameter contains additional state associated with the open blade request.
         */
        function createClickContext(lifetime: MsPortalFx.Base.LifetimeManager, reason: OnClickReason, openBladeShellInterface: FxImpl.OpenBladeShellInterface<any>, containerInContextPane: boolean, selectedItem?: any, controlMetadata?: any): ClickContext;
        function setClickContext(selectableContainer: SelectableContainerViewModel, clickContext: ClickContext): void;
        class SelectableContainerViewModel extends ContainerViewModel implements FxImpl.Composition.Selectable.SelectableViewModel, CommandContainerContract, BladeManagement {
            /**
             * see CommandContainerContract interface
             * This member is not initialized or exposed when this class is used for blade view models and other generic cases
             */
            selectable: MsPortalFx.ViewModels.Selectable<any>;
            /**
             * see MsPortalFx.Blades.SelectableViewModel interface
             * For open blade commands
             */
            configureSelectable: <TBladeReference extends FxImpl.Composition.Selectable.BladeReference<any>>(options: FxImpl.Composition.Selectable.Selectable2Options<FxImpl.Composition.Selectable.BladeReference<any>>) => FxImpl.Composition.Selectable.Selectable2<TBladeReference>;
            /**
             * If true then this container is inside a blade context pane
             */
            flags: Internal.ViewModelFlags;
            constructor(options: SelectableContainerOptions);
            /**
             * Opens a child Blade.
             *
             * @param bladeReference A BladeReference describing the Blade to be opened.
             * @param options Addtional options for how the blade should be opened
             * @return a promise that is fullfilled when the blade is opened.
             */
            openBlade<TParameters, TOutputs>(bladeReference: FxCompositionSelectable.PdlBladeReference<TParameters, TOutputs>, options?: OpenBladeOptions): Q.Promise<boolean>;
            /**
             * Opens a child Blade asynchronously.  While the Blade to be shown is being determined (via 'bladeReferencePromise') a loading
             * indicator will be displayed on the new child Blade.
             *
             * @param bladeReferencePromise A promise that will be resolved with a BladeReference describing the Blade to be opened.
             * @param options Additonal options for how the blade should be opened
             * @return A promise that is fullfilled when the blade is opened.
             */
            openBladeAsync<TParameters, TOutputs>(bladeReferencePromise: Q.Promise<FxCompositionSelectable.PdlBladeReference<TParameters, TOutputs>>, options?: OpenBladeOptions): Q.Promise<boolean>;
            /**
             * Opens a child Blade in the Context Pane.
             *
             * @param bladeReference A BladeReference describing the Blade to be opened.
             */
            openContextPane(bladeReference: FxCompositionSelectable.BladeReference<any>): Q.Promise<boolean>;
            /**
             * Opens a child Blade asynchronously in the Context Pane.  While the Blade to be shown is being determined (via
             * 'bladeReferencePromise') a loading indicator will be displayed in the Context Pane.
             *
             * @param bladeReferencePromise A Promise that will be resolved with a BladeReference describing the Blade to be opened.
             */
            openContextPaneAsync(bladeReferencePromise: Q.Promise<FxCompositionSelectable.BladeReference<any>>): Q.Promise<boolean>;
        }
        interface PreviewContract {
            /**
             * True if the composition is marked as being in preview.
             */
            preview: KnockoutObservableBase<boolean>;
        }
        /**
         * Marks the given container as having content that is in preview.
         *
        * @param The container to mark as preview.
        * @param isPreview Optional boolean true to mark the contain as in preview (default), false to clear the preview mark.
        */
        function markAsPreview(container: MsPortalFx.ViewModels.ContainerContract, isPreview?: boolean): void;
        const enum CloseBladeTarget {
            ThisBlade = 0,
            ChildBlade = 1,
            ContextBlade = 2,
        }
        /**
         * This is the shell close blade API typing that is invoked by extensions to close a blade.
         * This API is wrapped with some SDK sugar for general consumption by extensions view models.
         */
        type ShellCloseBladeFunction = (target: CloseBladeTarget, data?: any) => boolean;
        /**
         * private contract shared between the shell and the part container
         */
        interface ShellPartContainerContract {
            /**
             * A flag to request auto-sizing at the composition level.
             */
            autoSize: KnockoutObservable<boolean>;
            /**
             * A flag to request resizing at the composition level.
             */
            resize: KnockoutObservable<{
                width: number;
                height: number;
            }>;
            /**
             * Shared selectable instance for opening blades
             */
            selectables: KnockoutObservable<StringMap<FxImpl.Composition.Selectable.Selectable2<any>>>;
            /**
             * Callback for closing blades.   This member is populated by the shell after the part is created.
             *
             * This member cannot be populated by the part view model constructor because there is pooled view models which
             * at the time of creation have no context (no specific part instance they are attached too).
             */
            closeBlade: KnockoutObservable<ShellCloseBladeFunction>;
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.ContentState.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Specifies which content state decoration should be applied to a Part.
     */
    enum ContentState {
        /**
         * The Part / Blade does not display any content state decoration.
         */
        None = 0,
        /**
         * The Part / Blade displays a "success" content state decoration.
         */
        Success = 1,
        /**
         * The Part / Blade displays a "warning" content state decoration.
         */
        Warning = 2,
        /**
         * The Part / Blade displays an "error" content state decoration.
         */
        Error = 3,
        /**
         * The Part / Blade displays a "dirty" content state decoration.
         */
        Dirty = 4,
        /**
         * The Part / Blade displays an "info" content state decoration.
         */
        Info = 5,
        /**
         * The Part / Blade displays an "upsell" content state decoration.
         */
        Upsell = 6,
        /**
         * The Part / Blade displays an "complete" content state decoration.
         */
        Complete = 7,
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.DeleteAssetConfirmation.d.ts
declare module MsPortalFx.ViewModels.DeleteAssetConfirmation {
    import Fx = MsPortalFx;
    import FxUI = Fx.UI;
    import NotificationManager = FxUI.NotificationManager;
    import FxViewModels = Fx.ViewModels;
    import FxControls = FxViewModels.Controls;
    /**
     * The contract of the binding inputs data to the view model.
     */
    interface InputData {
        /**
         * The id of the asset.
         */
        assetId: any;
        /**
         * The name of the asset.
         */
        assetName: string;
        /**
         * The display name of the asset type.
         */
        assetTypeDisplayName?: string;
        /**
         * The affected items of the asset.
         */
        items?: string[];
    }
    /**
     * The options of the delete asset confirmation part view model.
     */
    interface PartViewModelOptions<TItem, TSelection> extends FxControls.DeleteAssetConfirmation.Options<TItem, TSelection> {
    }
    /**
     * The view model of the delete asset confirmation blade.
     */
    class BladeViewModel extends FxViewModels.Blade {
        /**
         * Gets the data input to the blade view model.
         */
        data: KnockoutObservable<InputData>;
        /**
         * Invoked when the inputs are set.
         * Subclass should call this method and chain the returned Promise.
         */
        onInputsSet(inputs: any): Fx.Base.Promise;
        /**
         * Gets the title for the blade.
         * Subclass can override this method to proivde the custom title for the blade.
         *
         * @param data The asset input data.
         * @return the blade title.
         */
        _onGetTitle(data: InputData): string;
    }
    /**
     * The command view model to open the delete asset confirmation blade.
     */
    class CommandViewModel extends FxViewModels.OpenBladeCommand {
        /**
         * Gets the data input to the command.
         */
        data: KnockoutObservable<InputData>;
        /**
         * Gets or sets the result of the deletion result.
         */
        result: KnockoutObservable<FxViewModels.CommandResult>;
        /**
         * Gets the container of the command.
         */
        _container: FxViewModels.CommandContainerContract;
        /**
         * Gets the type of the asset.
         */
        _assetType: string;
        private _data;
        private _selectedItems;
        private _previousUserActionId;
        /**
         * Creates the command instance.
         *
         * @param container The command container.
         * @param assetType The type of the asset.
         */
        constructor(container: FxViewModels.CommandContainerContract, assetType: string);
        /**
         * Invoked when the inputs are set.
         * Subclass should call this method and chain the returned Promise.
         */
        onInputsSet(inputs: any): Fx.Base.Promise;
        /**
         * Deletes the asset.
         * Subclass is required to implement this method to actually delete the identified asset.
         * Based on the result of the deletion, subclass need to set the result property accordingly.
         *
         * @param data The data of the asset to be deleted.
         * @param selectedItems The items selected to be deleted.
         */
        _onDelete(data: InputData, selectedItems: any[]): void;
        /**
         * Sends the error notification when deletion fails.
         * Subclass is required to implement this method to notify the shell the failure of the deletion of the asset.
         *
         * @param data The data of the asset to be deleted.
         * @param selectedItems The items selected to be deleted.
         * @return the error notification.
         */
        _onSendErrorNotification(data: InputData, selectedItems: any[]): NotificationManager.Notification;
        /**
         * Validates if the command should be enabled.
         * Subclass can provide additional logic to decide if the command should be enabled based the data.
         *
         * @param data The data of the asset.
         * @return true if the command should be enabled, false otherwise.
         */
        _onValidateCommand(data: InputData): boolean;
        private _onDeletionResultChange(result);
        private _sendErrorNotification(data, selectedItems);
    }
    /**
     * The viewModel of delete asset confirmation part.
     */
    class PartViewModel<TItem, TSelection> extends FxControls.DeleteAssetConfirmation.ViewModel<TItem, TSelection> implements FxViewModels.InputsContract {
        /**
         * Gets the input data.
         */
        data: KnockoutObservable<InputData>;
        private _data;
        constructor(container: FxViewModels.PartContainerContract, options: PartViewModelOptions<TItem, TSelection>);
        /**
         * See base.
         */
        onInputsSet(inputs: any): Fx.Base.Promise;
        /**
         * Populates the grid when the asset is changed.
         * Subclass is required to implement this method to populate the grid.
         *
         * @param data The asset input data.
         */
        _onPopulateGrid(data: InputData): void;
        private _isSameAsset(data);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.DeleteCommand.d.ts
declare module MsPortalFx.ViewModels {
    import Fx = MsPortalFx;
    import NotificationManager = Fx.UI.NotificationManager;
    import FxViewModels = Fx.ViewModels;
    import Dialogs = FxViewModels.Dialogs;
    import DialogResult = Dialogs.DialogResult;
    /**
     * The result of the command execution.
     */
    enum CommandResult {
        /**
         * The command is not executed.
         */
        None = 0,
        /**
         * The execution of the command has succeeded.
         */
        Success = 1,
        /**
         * The execution of the command has failed.
         */
        Failure = 2,
    }
    /**
     * The options of the message box.
     */
    interface DeleteCommandMessageBoxOptions {
        /**
         * The title of the message box.
         */
        title: string;
        /**
         * The message of the message box.
         */
        message: string;
    }
    /**
     * The command to delete an asset.
     */
    class DeleteAssetCommand extends FxViewModels.Command {
        private _assetType;
        private _confirmationDialog;
        private _errorDialog;
        private _data;
        /**
         * The asset data bound to the command.
         */
        data: KnockoutObservable<any>;
        /**
         * The result of the deletion.
         */
        result: KnockoutObservable<CommandResult>;
        /**
         * Instantiates the command.
         */
        constructor(container: FxViewModels.ContainerContract, assetType: string);
        /**
         * See base.
         */
        onInputsSet(inputs: any): Fx.Base.Promise;
        /**
         * See base.
         */
        execute(formValid?: boolean): void;
        /**
         * See base.
         */
        dialogClick(result: DialogResult): void;
        /**
         * Deletes the asset.
         * Subclass is required to implement this method to actually delete the identified asset.
         * Based on the result of the deletion, subclass should set the result property accordingly.
         *
         * @param data The data of the asset to be deleted.
         */
        _onDelete(data: any): void;
        /**
         * Gets the id of the asset.
         * Subclass is required to implement this method to let the shell know the asset deleted.
         * For example, if data is a complex object that contains the asset id, subclass should return the asset id from this method.
         *
         * @param data The data of the asset to be deleted.
         * @return the id of the asset.
         */
        _onGetAssetId(data: any): any;
        /**
         * Sends the error notification when deletion fails.
         * Subclass is required to implement this method to notify the shell the failure of the deletion of the asset.
         * If subclass really does not want to send error notification, it can return null/undefined from this method to cancel it.
         *
         * @param data The data of the asset to be deleted.
         * @return the error notification.
         */
        _onSendErrorNotification(data: any): NotificationManager.Notification;
        /**
         * Configures the confirmation message box to display.
         * Subclass can override the method to customize the confirmation message box.
         *
         * @param data The data of the asset to be deleted.
         * @return the options of the confirmation message box.
         */
        _onShowConfirmation(data: any): DeleteCommandMessageBoxOptions;
        /**
         * Configures the error message box to display.
         * Subclass can override the method to customize the error message box.
         *
         * @param data The data of the asset to be deleted.
         * @return the options of the error message box.
         */
        _onShowError(data: any): DeleteCommandMessageBoxOptions;
        /**
         * Validates if the command should be enabled.
         * Subclass can provide additional logic to decide if the command should be enabled based the data.
         *
         * @param data The data of the asset.
         * @return true if the command should be enabled, false otherwise.
         */
        _onValidateCommand(data: any): boolean;
        private _shouldDelete(result);
        private _onDeletionResultChange(result);
        private _createConfirmationDialog(data);
        private _createErrorDialog(data);
        private _sendErrorNotification(data);
        private _resetCommand();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.Dialogs.d.ts
declare module MsPortalFx.ViewModels.Dialogs {
    /**
     * The combinations of buttons that can be displayed on a message box.
     */
    enum MessageBoxButtons {
        /**
         * The message box contains Abort, Retry and Ignore buttons.
         */
        AbortRetryIgnore = 0,
        /**
         * The message box contains an OK button.
         */
        OK = 1,
        /**
         * The message box contains OK and Cancel buttons.
         */
        OKCancel = 2,
        /**
         * The message box contains Retry and Cancel buttons.
         */
        RetryCancel = 3,
        /**
         * The message box contains Yes and No buttons.
         */
        YesNo = 4,
        /**
         * The message box contains Yes, No and Cancel buttons.
         */
        YesNoCancel = 5,
    }
    /**
     * The options required by a message box.
     */
    class MessageBox extends Dialog {
        /**
         * See interface.
         */
        text: string;
        /**
         * See interface.
         */
        buttons: MessageBoxButtons;
        /**
         * Gets or sets if a confirmation is required before users can press default button.
         */
        confirmationRequired: boolean;
        /**
         * The text of the confirmation message.
         */
        confirmationMessage: string;
        /**
         * Creates a new instance of a MessageBox.
         *
         * @param title Title shown at the top of the message box.
         * @param text Text of the message box.
         * @param buttons The button set to be displayed on the message box.
         */
        constructor(title: string, text: string, buttons: MessageBoxButtons);
    }
    /**
     * The options required by a progress box.
     */
    class ProgressBox extends Dialog {
        /**
         * See interface.
         */
        text: KnockoutObservable<string>;
        /**
         * See interface.
         */
        completionPercentage: KnockoutObservable<number>;
        /**
         * Creates a new instance of a ProgressBox.
         *
         * @param title Title shown at the top of the progress dailog.
         * @param text Text of the progress dailog.
         * @param buttons Optional number that specifies the completion progress of the command. Values range from 0-100 or -1 for indefinite progress.
         * Defaults to indefinite progress if not specified.
         */
        constructor(title: string, text: string, completionPercentage?: number);
    }
    /**
     * The options required by the form dialog.
     */
    class FormDialog extends Dialog {
        /**
         * See interface.
         */
        description: KnockoutObservable<string>;
        /**
         * See interface.
         */
        row1column1: MsPortalFx.ViewModels.Field<any>;
        /**
         * See interface.
         */
        row1column2: MsPortalFx.ViewModels.Field<any>;
        /**
         * See interface.
         */
        row2column1: MsPortalFx.ViewModels.Field<any>;
        /**
         * See interface.
         */
        row2column2: MsPortalFx.ViewModels.Field<any>;
        /**
         * Creates the options for a form dialog.
         *
         * @param title The title for the dialog.
         */
        constructor(title: string);
    }
    /**
     * The options required by the list popup.
     */
    class ListPopup extends Dialog {
        /**
         * See interface.
         */
        listItems: KnockoutObservableBase<string[]>;
        /**
         * See interface.
         */
        selectedItem: KnockoutObservable<string>;
        /**
         * Creates the options for a list dialog.
         */
        constructor();
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.ExtensibleViewModel.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model whose behavior can be customized or expanded with logic supplied by another extension.
     * The additional logic is supplied by the other extension as an inner view model configured into this view model.
     */
    interface ExtensibleViewModel<T> {
        /**
         * The view model supplied by another extension.
         */
        extenderViewModel: KnockoutObservable<T>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.InputDefinitions.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * The fully qualified type name of the resource id.
     */
    var ResourceIdTypeName: string;
    /**
     * The type of the resource id.
     * It is equivalent to string.
     */
    type ResourceId = string;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.Part.d.ts
declare module MsPortalFx.ViewModels {
    import FxBase = MsPortalFx.Base;
    import FxComposition = MsPortalFx.Composition;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxImplComposition = FxImpl.Composition;
    import FxImplExtension = FxImpl.Extension;
    import FxCompositionConfiguration = FxComposition.Configuration;
    import FxViewModelsInternal = FxViewModels.Internal;
    import Selection2 = FxViewModelsInternal.Selection2;
    import ImplViewModels = FxImpl.ViewModels;
    import CompositionViewModelContract = ImplViewModels.CompositionViewModelContract;
    import CompositionViewModelBase = ImplViewModels.CompositionViewModelBase;
    import FrameworkPartViewModelContract = ImplViewModels.FrameworkPartViewModelContract;
    import FxClickContext = FxImplComposition.Selectable;
    /**
     * The PartContainer information that can be saved from an earlier rendering of this part.
     * Used when rehydration of the part fails and we want to show some information to the user.
     */
    interface PartContainerSerializableStateOptions {
        /**
         * The title text displayed for this part. Typically this specifies what kind of information
         * appears inside the part, e.g., "Deployment history", or if that is not applicable then the
         * type of the asset that the part relates to, e.g., "Website".
         */
        partTitle?: string;
        /**
         * The asset name text displayed for this part, e.g., "Freezing Fog".
         */
        assetName?: string;
    }
    /**
     * Properties for setting the current blade as a parent blade in a blade pair when using registerSelectable
     */
    interface BladePairOptions {
        /**
         * Determines if opening a child blade should push the current blade out of view
         */
        showParent: boolean;
        /**
         * Determines if the blades are paired in windowed mode
         */
        fullScreen: boolean;
    }
    /**
     * Options used when constructing a PartContainer view model.
     */
    interface PartContainerOptions extends PartContainerSerializableStateOptions, MsPortalFx.ViewModels.Internal.SelectableContainerOptions {
        /**
         * An instance of MsPortalFx.ViewModels.ClickableLink which controls whether this Part opens a link when clicked.
         */
        clickableLink?: ClickableLink;
        /**
         * The Part's location.
         */
        location?: PartLocation;
    }
    /**
     * Interface for an unprovisioned part that uses an edit scope to collect form data.
     */
    interface ProvisioningPartContentContract {
        /**
         * Edit scope id to be used by the unprovisioned part and it's children.
         */
        editScopeId: KnockoutObservable<string>;
    }
    const enum OnClickReason {
        Click = 1,
        FxClick = 2,
        RowClick = 3,
    }
    /**
     * Interface for a part.
     */
    interface PartContract<T> extends CompositionViewModelContract<PartContainer, T, FrameworkPartViewModelContract> {
        /**
         * Updates a part when it becomes unauthorized.
         */
        updatePartForUnauthorized(): void;
        /**
         * Invokes extension onClick and onRowClick callbacks with click context
         */
        invokeClickHandler<TSelectedItem>(reason: OnClickReason, thisPtr: any, onClick: FxClickContext.OnClickHandler | FxClickContext.OnListClickHandler<TSelectedItem>, referenceSetter: FxImpl.OpenBladeShellInterface<any>, selectedItem?: TSelectedItem, controlMetadata?: any): void;
    }
    interface MutateInfo {
        /**
         * Part to mutate into. Can be omitted for provisioning parts in which case
         * the new part locator will be looked up from extension definition.
         */
        partName?: string;
        /**
         * Extension that defines the specified part in its parts catalog.
         */
        extensionName?: string;
        /**
         * Input bindings for the new part. Parts in blades must not specify a new
         * container model. Their context will be the blade.
         */
        containerModel?: any;
        /**
         * Whether to prevent activation of the new part.
         */
        preventActivation?: boolean;
    }
    /**
     * Options for the for the registerSelectable API
     */
    interface RegisterSelectableOptions {
        /**
         * parameter collector is optional.
         * provide a parameter collector associated with the selectable here if the blade
         * is a a parameter provider.
         */
        parameterCollector?: ParameterCollector<any>;
        /**
         *  Provide blade pair options if the blade is the parent of a blade pair.
         */
        bladePairOptions?: BladePairOptions;
        /**
         * If set to true AND the blade is a contextblade, will open in a contextpane.
         */
        openInContextPane?: boolean;
        /**
         * if the blade will be opened in the context pane, true open as context, false open as detail blade
         */
        persistentContextPane?: boolean;
    }
    /**
     * Interface for a part container.
     */
    interface PartContainerContract extends MsPortalFx.ViewModels.ContainerContract, FxImpl.Composition.Selectable.SelectableViewModel, BladeManagement {
        /**
         * The title text displayed for this part. Typically this specifies what kind of information
         * appears inside the part, e.g., "Deployment history", or if that is not applicable then the
         * type of the asset that the part relates to, e.g., "Website".
         */
        partTitle: KnockoutObservableBase<string>;
        /**
         * The label read by assistive devices on this part. If not set, will default to the part title set.
         * Override if you desire the label to be more specific than the default title of the part.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * The asset name text displayed for this part, e.g., "Freezing Fog".
         */
        assetName: KnockoutObservableBase<string>;
        /**
         * If isSelectable is true then the part is selectable.  This value always is true by default.
         * If this setting is false then the state of selectable is ignored and the part is not selectable.
         */
        isSelectable: KnockoutObservableBase<boolean>;
        /**
         * View model reflecting the selection state of the Part. The value is null if the part is not selectable.
         */
        selectable: Selectable<any>;
        /**
         * View model reflecting whether the Part will open a link when clicked. The value is null if the part is not a link.
         */
        clickableLink: ClickableLink;
        /**
         * Tracks the list of asynchronous operations being performed by the Part.
         */
        operations: PartOperationList;
        /**
         * Specifies which content state decoration is applied to the Part.
         */
        contentState: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
        /**
         * Reflects the load state of the Part.
         */
        partState: KnockoutObservableBase<MsPortalFx.Parts.PartState>;
        /**
         * The error message displayed by the Part when it has failed.
         */
        failureMessage: KnockoutObservable<string>;
        /**
         * The message displayed by the Part when it has no data to display.
         */
        noDataMessage: KnockoutObservable<string>;
        /**
         * Member used to mutate the part.
         */
        mutate: KnockoutObservable<MutateInfo>;
        /**
         * The height of the part in pixels without padding.
         * Note: The height value will be not useful for part size FullWidthFitHeight, HeroWideFitHeight and FitToContainer.
         */
        height: KnockoutObservableBase<number>;
        /**
         * The width of the part in pixels without padding.
         */
        width: KnockoutObservableBase<number>;
        /**
         * Detailed size information for the Part.
         */
        size: KnockoutObservableBase<PartSizeInfo>;
        /**
         * Shows an error message in place of the Part.
         *
         * @param message A message that will be displayed to the user when the part fails.
         */
        fail(message: string): void;
        /**
         * Indicates the location of this Part (on a Dashboard, on a Blade, etc.).
         */
        location: PartLocation;
        /**
         * Removes any 'failed' error message and brings the part back to 'ready' state.
         * If the part was not already in a 'failed' state, this method does nothing.
         */
        recover(): void;
        /**
         * If allowed by ResizeMode, will adjust the size of the container to the size of the content, clamped to the grid constraints.
         *
         * The content must be enclosed in a single container div in the content area of the part.
         * If more than one div is found in the content area, the autoSize will be ignored, and a warning logged in Dev Mode.
         */
        autoSize(): void;
        /**
         * If allowed by ResizeMode, will adjust the size of the part to the size specified, clamped to the grid constraints.
         *
         * @param width The desired width, in grid steps, valid in range from 1 to 25.
         * @param height The desired height, in grid steps, valid in range from 1 to 25.
         */
        resizeTo(width: number, height: number): void;
        /**
         * Causes the part's content to be revealed immediately, regardless of any onInputsSet promise that
         * might not yet have completed. This removes the opaque 'loading' spinner and makes the part interactive,
         * so you must also disable or hide any UI elements that the user should not be able to see or interact with
         * until data is fully loaded.
         */
        revealContent(): void;
        /**
         * Registers a selectable to open blades using dynamic blade selection.
         *
         * @param lifetime Reflects the lifetime of the selectable.  When the lifetime is disposed, the selectable will be implicitly unregistered.
         * @param identity Required, this is used as the key for persisting the selection state
         * @param selectable Required, the selectable that will be used to open blades.   This must be a Selectable or SelectableSet type only.
         * @param options Optional, additional options to configure
         */
        registerSelectable(lifetime: FxBase.LifetimeManager, identity: string, selectable: Selectable<any> | SelectableSet<any, any> | Selection2.SelectableSetContract<any, any>, options?: RegisterSelectableOptions): void;
        /**
         * Activates this Part's 'Configuration', which is an API that enables the Part to manage parameter and settings overrides/inheritance via
         * configuration UI (typically via a Context Blade).  See the MsPortalFx.Composition.Configuration.Contract interface for details.
         *
         * @param options Options used to initialize the Configuration API for this Part
         * @return The Configuration API for this Part
         */
        activateConfiguration<TParameters, TSettings>(options?: FxCompositionConfiguration.Part.Options<TParameters, TSettings>): FxCompositionConfiguration.Part.Contract<TParameters, TSettings>;
        /**
         * Closes the child blade that is currently open
         *
         * @return a promise that resolves to true if the child blade is successfully closed.
         */
        closeChildBlade(): Q.Promise<boolean>;
        /**
         * Closes the context blade that was opened by this part
         *
         * @returns a promise that resolves to true if the context blade is sucessfully closed.
         */
        closeContextBlade(): Q.Promise<boolean>;
        /**
         * Optional property that provides functionality for parts that are on locked blades.
         */
        onLockedBlade?: LockedBladeManagement;
    }
    /**
     * Detailed Part size information.
     */
    interface PartSizeInfo {
        /**
         * One of the defined Part sizes, including 'Custom' if the Part is configured to support arbitrary sizing.
         */
        partSize: MsPortalFx.Parts.PartSize;
        /**
         * The width/height of the Part in terms of pixels.
         */
        dimensions: {
            width: number;
            height: number;
        };
    }
    /**
     * The location of a Part.
     */
    enum PartLocation {
        /**
         * For testing purposes only.  The Part is neither on a Dashboard nor on a Blade.
         */
        _Internal_None = 0,
        /**
         * The Part is on a Dashboard.
         */
        Dashboard = 1,
        /**
         * The Part is on a Blade.
         */
        Blade = 2,
    }
    /**
     * A view model for a Part.
     */
    class Part extends CompositionViewModelBase<PartContainer, any, FrameworkPartViewModelContract> implements PartContract<any> {
        /**
         * A promise that will automatically be "superseded" (removed from the
         * operations list) the next time onInputsSet is called.
         */
        private _currentOnInputsSetPromise;
        /**
         * If true, we know that all subsequent onInputsSet promises should not block the UI, because if
         * all necessary data was known at construction (i.e., the part called 'revealContent' from inside
         * its constructor) then it can't depend on any asynchronously-loaded data.
         */
        private _hadRevealedContentAtConstruction;
        /**
         * Message context of the RPC call that triggers onInputsSet. Contains data used for telemetry.
         */
        private _onInputsSetContext;
        /**
         * Constructs a Part view model instance.
         *
         * @param internal Internal view model used for extension/shell sharing of internal state
         * @param containerViewModel View model for the container of the Part.
         * @param contentViewModel View model for the content of the Part.
         * @param initialViewModelState View model state which was restored from a previous journey
         */
        constructor(internal: FrameworkPartViewModelContract, containerViewModel: PartContainer, contentViewModel?: any, initialViewModelState?: any, createHubsInternalCloudNameProperty?: boolean);
        /**
         * Creates a Selectable view model that is initialized with the Part's saved state.
         *
         * @param initialState Optional, saved selection state for the Part.
         * @param selectedValue Optional, initial value for the 'selectedValue' property of the Selectable.
         * @return A Selectable view model instance.
         */
        static createSelectableViewModel(initialState?: any, selectedValue?: any): FxViewModels.Selectable<any>;
        static createClickableLinkViewModel(observableUri: KnockoutObservable<string>, observableTarget?: KnockoutObservable<string>): FxViewModels.ClickableLink;
        /**
         * Supplies updated input binding values to the part.
         *
         * @param inputs The inputs to the part.
         * @param partSettings Object with settings loaded for these set of inputs.
         * @param traceOptions Options to enable tracing during operation.
         * @param viewModelName An identifier for the composition item that can be used in diagnostic traces.
         * @param inputsMetadata Metadata describing the current configuration state of the Part's inputs (used by its Configuration API).
         * @return The promise for the onInputsSet.
         */
        updatePartInputValues(inputs: any, partSettings?: any, traceOptions?: ImplViewModels.CompositionViewModelTraceOptions, viewModelName?: string, inputsMetadata?: FxImplExtension.InputsMetadata): FxBase.Promise;
        private _updatePartStateAfterOnInputsSetPromise(promise);
        /**
         * Updates a part when it becomes unauthorized.
         */
        updatePartForUnauthorized(): void;
        /**
         * Invokes onClick and onRowClick calls on the extension view model in the context of the extension IFrame
         */
        invokeClickHandler<TSelectedItem>(reason: OnClickReason, thisPtr: any, onClick: FxClickContext.OnClickHandler | FxClickContext.OnListClickHandler<TSelectedItem>, openBladeShellContract: FxImpl.OpenBladeShellInterface<any>, selectedItem?: TSelectedItem, controlMetadata?: any): void;
        private _onRevealContent();
    }
    /**
     * A view model for the Part itself, that is, the container around the Part's content.
     */
    class PartContainer extends FxViewModelsInternal.SelectableContainerViewModel implements PartContainerContract {
        /**
         * See interface.
         */
        partTitle: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        assetName: KnockoutObservableBase<string>;
        /**
         * See interface.
         */
        isSelectable: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        clickableLink: ClickableLink;
        /**
         * See interface.
         */
        operations: PartOperationList;
        /**
         * See interface.
         */
        contentState: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
        /**
         * See interface.
         */
        partState: KnockoutObservableBase<MsPortalFx.Parts.PartState>;
        /**
         * See interface.
         */
        failureMessage: KnockoutObservable<string>;
        /**
         * See interface.
         */
        noDataMessage: KnockoutObservable<string>;
        /**
         * See interface.
         */
        height: KnockoutObservable<number>;
        /**
         * See interface.
         */
        width: KnockoutObservable<number>;
        /**
         * See interface.
         */
        size: KnockoutObservable<FxViewModels.PartSizeInfo>;
        /**
         * See interface.
         */
        mutate: KnockoutObservable<MutateInfo>;
        /**
         * See interface.
         */
        location: PartLocation;
        /**
         * Optional property that provides functionality for parts that are on locked blades.
         */
        onLockedBlade: LockedBladeManagement;
        private _partState;
        /**
         * selectables that are dynamically registered
         */
        private _registeredSelectables;
        /**
         * Options for dynamically registered selectables
         */
        private _registeredSelectableOptions;
        /**
         * Initial state from a rehydrated journey.   We used this to restore selectable set state.
         */
        private _registeredSelectablesInitialState;
        /**
         * A private viewmodel used for interactions between the part, its container, and the Shell.
         */
        private _internalViewModel;
        /**
         * This Part's Configuration API, optionally activated via 'container.activateConfiguration()'.
         */
        private _config;
        /**
         * Constructs a PartContainer view model instance.
         *
         * @param internal Required internal framework view model.   The container API manipulates this internal view model.
         * @param options Options used to construct this view model. Optional.
         */
        constructor(internal: FrameworkPartViewModelContract, options?: PartContainerOptions);
        /**
         * See interface.
         */
        autoSize(): void;
        /**
         * See interface.
         */
        resizeTo(width: number, height: number): void;
        /**
         * Shows an error message in place of the Part.
         */
        fail(message: string): void;
        /**
         * See interface.
         */
        recover(): void;
        /**
         * See interface.
         */
        revealContent(): void;
        enableNotice(notice: NoticeOptions): void;
        /**
         * See interface
         */
        registerSelectable(lifetime: FxBase.LifetimeManager, identity: string, selectable: Selectable<any> | SelectableSet<any, any> | Selection2.SelectableSetContract<any, any>, options?: RegisterSelectableOptions): void;
        /**
         * See interface.
         */
        activateConfiguration<TParameters, TSettings>(options?: FxCompositionConfiguration.Part.Options<TParameters, TSettings>): FxCompositionConfiguration.Part.Contract<TParameters, TSettings>;
        closeCurrentBlade(data?: any): Q.Promise<boolean>;
        closeChildBlade(): Q.Promise<boolean>;
        closeContextBlade(): Q.Promise<boolean>;
        /**
         * Updates this Part's Configuration when 'updatePartInputValues' is called.
         *
         * @param inputs The inputs to the part.
         * @param settings The settings for the part.
         * @param inputsMetadata Metadata describing the current configuration state of the Part's inputs (used by its Configuration API).
         */
        private _updateConfiguration(inputs, settings, inputsMetadata);
        /**
         * As the extension commits Configuration changes (typically as the user interacts with a Context Blade), this method will be
         * called to act on these changes.  For instance, the user might update a Part setting or they may elect to override (or remove an
         * override) of a Part parameter (input).
         *
         * @param values The updated Configuration values.
         */
        private _handleConfigurationChange(values);
    }
    module Parts.Frame {
        /**
         * The contract for the view model of a frame part.
         */
        interface Contract {
        }
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.PartContent.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model for the content displayed in a Part.
     */
    interface PartContent {
        /**
         * Optional. Invoked by the Shell when the Part's inputs change to a new,
         * complete set of values. The view model should handle this by
         * loading whatever data corresponds to the input properties.
         *
         * @param inputs The Part's current set of input property values as a name/value collection.
         * @param partSettings Object with settings loaded for these set of inputs.
         * @return A promise representing a data access operation that has been initiated, or null.
         */
        onInputsSet?(inputs: any, partSettings?: any): MsPortalFx.Base.Promise;
    }
    /**
     * A view model that is resizable.
     */
    interface Resizable {
        /**
         * Represents the size for a part.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.PartOperationList.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Represents the set of operations (e.g., loading data) that a Part is currently executing.
     */
    class PartOperationList implements Base.Disposable {
        /**
         * Specifies whether or not there is at least one operation in progress.
         */
        inProgress: KnockoutComputed<boolean>;
        /**
         * Provides a viewmodel that can be bound to a pcProgressBar control.
         */
        progressBarViewModel: MsPortalFx.ViewModels.Controls.Visualization.ProgressBar.ViewModel;
        /**
         * Specifies whether or not at least one of the active operations is intended to block the UI.
         */
        blockingUi: KnockoutComputed<boolean>;
        /**
         * The type of blocking shield that will appear if UI is blocked.
         */
        shieldType: KnockoutComputed<ShieldType>;
        private _activeOperations;
        /**
         * Constructs an instance of PartOperationList.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
        /**
         * See interface.
         **/
        dispose(): void;
        /**
         * Adds an operation to the list.
         *
         * @param promise A promise representing the operation to be added.
         * @param options Additional options describing how the operation should be visualized.
         */
        add(promise: MsPortalFx.Base.Promise, options?: PartOperationOptions): void;
        /**
         * Removes an operation from the list.
         *
         * @param promise The promise matching the operation to remove.
         */
        remove(promise: MsPortalFx.Base.Promise): void;
        /**
         * Updates the options associated with an operation list entry.
         *
         * @param promise The promise matching the operation to update.
         * @param options New options for the operation.
         */
        update(promise: MsPortalFx.Base.Promise, options: PartOperationOptions): void;
        /**
         * Describes the options associated with an operation list entry.
         *
         * @param promise The promise matching the operation to update.
         * @return Options associated with the operations.
         */
        getOptionsForOperation(promise: MsPortalFx.Base.Promise): PartOperationOptions;
    }
    enum ShieldType {
        /**
         * The shield is opaque.
         */
        Opaque = 0,
        /**
         * The shield is translucent.
         */
        Translucent = 1,
    }
    interface PartOperationOptions {
        /**
         * The type of blocking shield that will appear if UI is blocked.
         */
        shieldType?: ShieldType;
    }
    /**
     * A set of options describing how an operation should be visualized.
     */
    class PartOperationOptions {
        /**
         * If true, indicates that the Part UI should be blocked (non-interactive) until the operation finishes.
         */
        blockUi: boolean;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.RightClick.d.ts
declare module MsPortalFx.ViewModels {
    interface ContextualCommands {
        /**
         * Commands for the item.
         */
        commandGroup: string;
        /**
         * Optional string that specifies the extension that owns the commands. If omitted it is
         * assumed to be the extension that defined the containing part.
         */
        commandGroupOwner?: string;
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\ViewModels\ViewModels.Toolbar.d.ts
declare module MsPortalFx.ViewModels.Toolbars {
    import FxViewModels = MsPortalFx.ViewModels;
    import FileDownload = FxViewModels.FileDownload;
    import FileDownloadContext = FileDownload.Context;
    /**
     * The type of the toolbar item.
     */
    enum ToolbarItemType {
        /**
         * Not a valid type.
         */
        None = 0,
        /**
         * An items that visually groups other toolbar items.
         */
        Group = 1,
        /**
         * A toolbar button that opens a link.
         */
        OpenLinkButton = 2,
        /**
         * A toolbar button that opens a blade.
         */
        OpenBladeButton = 3,
        /**
         * A toolbar button that is associated to a command.
         */
        CommandButton = 4,
        /**
         * A toolbar button that opens a dialog before executing a command.
         */
        DialogButton = 5,
        /**
         * A toolbar button and can be toggled (between ON and OFF states).
         */
        ToggleButton = 6,
        /**
         * A toolbar button which initiates a file download
         */
        FileDownloadButton = 7,
        /**
         * A toolbar button which initiates a file upload
         */
        FileUploadButton = 8,
        /**
         * A toolbar button which acts like OAuth button
         */
        OAuthButton = 9,
        /**
         * A toolbar button that opens a blade using selectable 2
         */
        OpenBladeButton2 = 10,
        /**
         * A toolbar button that allows moving resources across resource groups/subscriptions
         */
        MoveResourceButton = 11,
    }
    /**
     * Defines an item in the toolbar.
     */
    interface ToolbarItemContract {
        /**
         * The type of the toolbar item.
         */
        type: ToolbarItemType;
        /**
         * A value indicating whether or not the toolbar item is disabled.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * The message provided to the container when unauthorized.
         */
        unauthorizedMessage: KnockoutObservable<string>;
        /**
         * Signals the container is in unauthorized mode and provides an optional custom error message.
         *
         * @param message A custom error message in place of the default.
         */
        unauthorized(message?: string): void;
    }
    /**
     * See interface.
     */
    class ToolbarItem implements ToolbarItemContract {
        /**
         * See interface.
         */
        type: ToolbarItemType;
        /**
         * See interface.
         */
        disabled: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        unauthorizedMessage: KnockoutObservable<string>;
        /**
         * Creates a toolbar item.
         *
         * @param type The type of the toolbar item.
         */
        constructor(type: ToolbarItemType);
        /**
         * See interface.
         */
        unauthorized(message?: string): void;
    }
    interface ToolbarContract extends FxViewModels.Controls.Loadable.Contract {
        /**
         * Sets the list of items to show in the toolbar.
         */
        setItems(items: ToolbarItemContract[]): void;
        /**
         * A value indicating whether or not to show item labels.
         */
        showLabels: KnockoutObservable<boolean>;
    }
    class Toolbar extends Controls.Loadable.ViewModel implements ToolbarContract {
        /**
         * See interface.
         */
        showLabels: KnockoutObservable<boolean>;
        /**
         * The list of items to show in the toolbar.
         * Does not start with '_' so that it gets proxied over to the shell.
         */
        private items;
        /**
         * See interface.
         */
        setItems(items: ToolbarItemContract[]): void;
        /**
         * Creates a toolbar.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
    /**
     * Defines a button in the toolbar.
     */
    interface ToolbarButtonContract extends ToolbarItemContract {
        /**
         * The command label.
         */
        label: KnockoutObservableBase<string>;
        /**
         * The icon for the command.
         */
        icon: KnockoutObservableBase<Base.Image>;
    }
    /**
     * See interface.
     */
    class ToolbarButton extends ToolbarItem implements ToolbarButtonContract {
        /**
         * See interface.
         */
        label: KnockoutObservable<string>;
        /**
         * See interface.
         */
        icon: KnockoutObservable<Base.Image>;
        /**
         * Creates a toolbar button.
         *
         * @param type The type of the button.
         */
        constructor(type: ToolbarItemType);
    }
    /**
     * Defines a group in the toolbar.
     */
    interface ToolbarGroupContract extends ToolbarItemContract {
        /**
         * The items in the group.
         */
        items: ToolbarItemContract[];
    }
    /**
     * See interface.
     */
    class ToolbarGroup extends ToolbarItem implements ToolbarGroupContract {
        /**
         * See interface.
         */
        items: ToolbarItemContract[];
        /**
         * Creates a toolbar group.
         *
         * @param items The items in the group.
         */
        constructor(items: ToolbarItemContract[]);
    }
    /**
     * Defines a button that can execute the associated command.
     */
    interface ExecutableButtonBaseContract<T> extends ToolbarButtonContract {
        /**
         * The command associated to the toolbar item.
         */
        command: Commands.Command<T>;
    }
    /**
     * See interface.
     */
    class ExecutableButtonBase<T> extends ToolbarButton implements ExecutableButtonBaseContract<T> {
        /**
         * See interface.
         */
        command: Commands.Command<T>;
        /**
         * Creates an executable button.
         *
         * @param type The type of the button.
         */
        constructor(type: ToolbarItemType);
    }
    /**
     * Defines a button that can execute the associated command.
     */
    interface CommandButtonContract<T> extends ExecutableButtonBaseContract<T> {
        /**
         * The context to pass on to the command.
         */
        commandContext: KnockoutObservable<T>;
    }
    /**
     * See interface.
     */
    class CommandButton<T> extends ExecutableButtonBase<T> implements CommandButtonContract<T> {
        /**
         * See interface.
         */
        commandContext: KnockoutObservable<T>;
        /**
         * Creates an executable button.
         */
        constructor();
    }
    interface ToggleButtonContext<T> {
        /**
         * A value indicating whether or not the toggle button is in the checked state.
         */
        checked: boolean;
        /**
         * The context defined by the consumer of the toggle button.
         */
        context: T;
    }
    /**
     * This type of button provides an ON-OFF functionality that allows the user to toggle between
     * the ON and OFF states on every click.
     */
    interface ToggleButtonContract<T> extends ExecutableButtonBase<ToggleButtonContext<T>> {
        /**
         * The option group that the toggle button belongs to.
         */
        optionGroupName: string;
        /**
         * A value indicating whether or not the toggle button is in the checked state.
         */
        checked: KnockoutObservable<boolean>;
        /**
         * The context to pass on to the command.
         */
        commandContext: KnockoutObservable<T>;
    }
    /**
     * See interface.
     */
    class ToggleButton<T> extends ExecutableButtonBase<ToggleButtonContext<T>> implements ToggleButtonContract<T> {
        /**
         * See interface.
         */
        optionGroupName: string;
        /**
         * See interface.
         */
        checked: KnockoutObservable<boolean>;
        /**
         * See interface.
         */
        commandContext: KnockoutObservable<T>;
        /**
         * Creates a toggle button.
         *
         * @param optionGroupName The option group that the toggle button belongs to.
         */
        constructor(optionGroupName?: string);
    }
    /**
     * Defines a button that shows a dialog before executing a command using the dialog result as context.
     */
    interface DialogButtonContract extends ExecutableButtonBaseContract<Dialogs.DialogResult> {
        /**
         * Options required for showing the dialog.
         */
        dialogOptions: Dialogs.DialogContract;
    }
    /**
     * See interface.
     */
    class DialogButton extends ExecutableButtonBase<Dialogs.DialogResult> implements DialogButtonContract {
        /**
         * See interface.
         */
        dialogOptions: Dialogs.DialogContract;
        /**
         * Creates a dialog button.
         */
        constructor(type?: ToolbarItemType);
    }
    /**
     * Defines a toolbar command button that can upload a file from local disk.
     */
    interface FileUploadButtonContract extends ToolbarButtonContract, FxViewModels.FileUpload.UploadContract {
    }
    /**
     * See interface.
     */
    class FileUploadButton extends ToolbarButton implements FileUploadButtonContract {
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext: KnockoutObservableBase<FxViewModels.FileUpload.UploadContext>;
        /**
         * Cancel all uploads that are in progress and clears the files list array.
         */
        cancelAllUploads: KnockoutObservableBase<boolean>;
        /**
         * When file input is clicked, if set to true,  the upload command/widget will cancel all uploads that are in progress and clears the uploadTasks array.
         * If set to false, the new file will be added to the uploadTasks and extension author should dispose it off when upload completes.
         * Default is set to true and each time a new file is selected, existing uploadTasks will be canceled and removed from uploadTasks observable array.
         */
        cancelAllUploadsOnFileSelection: KnockoutObservableBase<boolean>;
        /**
         * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress and content.
         * FileUploadTask is used to initiate the file upload, resume steaming uploads, cancel and dispose the file upload.
         */
        uploadTasks: KnockoutObservableArray<FxViewModels.FileUpload.UploadTaskContract>;
        /**
         * Creates the file upload toolbar button.
         */
        constructor();
    }
    /**
     * Defines a toolbar command button that can download a file.
     */
    interface FileDownloadButtonContract extends ToolbarButtonContract {
        /**
         * The file download context of the button
         */
        context: KnockoutObservableBase<FileDownloadContext>;
    }
    /**
     * See interface.
     */
    class FileDownloadButton extends ToolbarButton implements FileDownloadButtonContract {
        /**
         * The file download context of the button
         */
        context: KnockoutObservableBase<FileDownloadContext>;
        /**
         * Creates the file download toolbar button.
         */
        constructor(options: FileDownload.Options);
    }
    /**
     * See interface.
     */
    class OAuthButton extends ToolbarButton implements ToolbarButtonContract {
        /**
         * Request url used to pop up the OAuth window.
         */
        requestUrl: KnockoutObservable<string>;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth: KnockoutObservable<number>;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight: KnockoutObservable<number>;
        /**
         * Token
         */
        value: KnockoutObservable<string>;
        /**
         * Creates the file upload toolbar button.
         */
        constructor();
    }
    /**
     * Defines a button that can open a blade.
     */
    interface OpenBladeButtonContract<T> extends ToolbarButtonContract {
        /**
         * The selectable for the command.
         */
        selectable: FxViewModels.Selectable<T>;
    }
    /**
     * See interface.
     */
    class OpenBladeButton<T> extends ToolbarButton implements OpenBladeButtonContract<T> {
        /**
         * See interface.
         */
        selectable: FxViewModels.Selectable<T>;
        /**
         * Creates the selectable toolbar button.
         */
        constructor(options?: SelectableOptions<T>);
    }
    /**
     * Defines a button that can open a blade.
     */
    interface OpenBladeButtonContract2<T extends FxImpl.Composition.Selectable.BladeReference<any>> extends ToolbarButtonContract {
        /**
         * command identifier, required to support journey persistance/restoration
         */
        id: string;
        /**
         * The selectable for the command.
         */
        selectable: FxImpl.Composition.Selectable.Selectable2<T>;
    }
    /**
     * See interface.
     */
    class OpenBladeButton2<T extends FxImpl.Composition.Selectable.BladeReference<any>> extends ToolbarButton implements OpenBladeButtonContract2<T> {
        /**
         * command identifier, required to support journey persistance/restoration
         */
        id: string;
        /**
         * See interface.
         */
        selectable: FxImpl.Composition.Selectable.Selectable2<T>;
        /**
         * Creates the selectable toolbar button.
         */
        constructor(options?: FxImpl.Composition.Selectable.Selectable2Options<T>);
    }
    /**
     * Defines a button that can open a blade.
     */
    interface OpenLinkButtonContract extends ToolbarButtonContract {
        /**
         * An instance of MsPortalFx.ViewModels.ClickableLink which controls whether this Part
         * opens a link when clicked.
         */
        clickableLink: FxViewModels.ClickableLink;
    }
    /**
     * See interface.
     */
    class OpenLinkButton extends ToolbarButton implements OpenLinkButtonContract {
        /**
         * See interface.
         */
        clickableLink: ClickableLink;
        /**
         * Creates the selectable toolbar button.
         *
         * @param uri The URI that will be opened when target is clicked.
         * @param target The target window to open the URI in.
         */
        constructor(uri: string, target?: string);
    }
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Widgets\Widgets.AzureGrid.d.ts
declare module MsPortalFx.Widgets.AzureGrid {
    var CellWidth: number;
    var CellHeight: number;
    var CellSpacingWidth: number;
    var CellSpacingHeight: number;
    var GridSpacingWidth: number;
    var GridSpacingHeight: number;
}

// FILE: E:\bt\787750\repo\src\SDK\Framework\TypeScript\MsPortalFx\Widgets\Widgets.PartGallery.d.ts
declare module MsPortalFx.Widgets.PartGallery {
    /**
     * Describes how thumbnail is resized to fill its allocated space.
     */
    const enum ThumbnailStretch {
        /**
         * The thumbnail is centered in its allocated space.
         */
        None = 0,
        /**
         * The thumbnail is completely filled in its allocated space.
         */
        Fill = 1,
    }
}
